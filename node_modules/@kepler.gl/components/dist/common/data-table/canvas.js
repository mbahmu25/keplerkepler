"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));
var _styledComponents = _interopRequireDefault(require("styled-components"));
var _templateObject; // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/*
    ScrollSync works by getting a callback about the dom elements scroll amount
    and then using that to pass into how much to scroll all child components,
    it works great!

    Except... Because scrolling is managed by a separate thread, and JavaScript
    is only periodically notified of the updated position, there's some latency
    issues with this.

    We can hack around this by using a niche property of canvas that removes the
    delay in scroll event firing! Easiest way to reproduce: enable "Trace React updates"
    in React DevTools (it works by overlaying a viewport-wide canvas over the document).
  */
var _default = exports["default"] = _styledComponents["default"].canvas(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  height: 100%;\n  left: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  width: 100%;\n"])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfc3R5bGVkQ29tcG9uZW50cyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3RlbXBsYXRlT2JqZWN0IiwiX2RlZmF1bHQiLCJleHBvcnRzIiwic3R5bGVkIiwiY2FudmFzIiwiX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbDIiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tbW9uL2RhdGEtdGFibGUvY2FudmFzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcblxuLypcbiAgICBTY3JvbGxTeW5jIHdvcmtzIGJ5IGdldHRpbmcgYSBjYWxsYmFjayBhYm91dCB0aGUgZG9tIGVsZW1lbnRzIHNjcm9sbCBhbW91bnRcbiAgICBhbmQgdGhlbiB1c2luZyB0aGF0IHRvIHBhc3MgaW50byBob3cgbXVjaCB0byBzY3JvbGwgYWxsIGNoaWxkIGNvbXBvbmVudHMsXG4gICAgaXQgd29ya3MgZ3JlYXQhXG5cbiAgICBFeGNlcHQuLi4gQmVjYXVzZSBzY3JvbGxpbmcgaXMgbWFuYWdlZCBieSBhIHNlcGFyYXRlIHRocmVhZCwgYW5kIEphdmFTY3JpcHRcbiAgICBpcyBvbmx5IHBlcmlvZGljYWxseSBub3RpZmllZCBvZiB0aGUgdXBkYXRlZCBwb3NpdGlvbiwgdGhlcmUncyBzb21lIGxhdGVuY3lcbiAgICBpc3N1ZXMgd2l0aCB0aGlzLlxuXG4gICAgV2UgY2FuIGhhY2sgYXJvdW5kIHRoaXMgYnkgdXNpbmcgYSBuaWNoZSBwcm9wZXJ0eSBvZiBjYW52YXMgdGhhdCByZW1vdmVzIHRoZVxuICAgIGRlbGF5IGluIHNjcm9sbCBldmVudCBmaXJpbmchIEVhc2llc3Qgd2F5IHRvIHJlcHJvZHVjZTogZW5hYmxlIFwiVHJhY2UgUmVhY3QgdXBkYXRlc1wiXG4gICAgaW4gUmVhY3QgRGV2VG9vbHMgKGl0IHdvcmtzIGJ5IG92ZXJsYXlpbmcgYSB2aWV3cG9ydC13aWRlIGNhbnZhcyBvdmVyIHRoZSBkb2N1bWVudCkuXG4gICovXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQuY2FudmFzYFxuICBoZWlnaHQ6IDEwMCU7XG4gIGxlZnQ6IDA7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG5gO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUdBLElBQUFBLGlCQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFBdUMsSUFBQUMsZUFBQSxFQUh2QztBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQSxJQUFBQyxRQUFBLEdBQUFDLE9BQUEsY0FhZUMsNEJBQU0sQ0FBQ0MsTUFBTSxDQUFBSixlQUFBLEtBQUFBLGVBQUEsT0FBQUssdUJBQUEiLCJpZ25vcmVMaXN0IjpbXX0=