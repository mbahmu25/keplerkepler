"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.getTickFormat = getTickFormat;
exports.getXAxis = getXAxis;
exports.updateAxis = updateAxis;
var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));
var _react = _interopRequireWildcard(require("react"));
var _momentTimezone = _interopRequireDefault(require("moment-timezone"));
var _d3Scale = require("d3-scale");
var _d3Selection = require("d3-selection");
var _d3Axis = require("d3-axis");
var _styledComponents = _interopRequireDefault(require("styled-components"));
var _utils = require("@kepler.gl/utils");
var _templateObject; // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
var MIN_TICK_WIDTH_LARGE = 80;
var MIN_TICK_WIDTH_SMALL = 50;
var HEIGHT = 30;
var TimeSliderContainer = _styledComponents["default"].svg(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  overflow: visible;\n  margin-top: 6px;\n\n  .axis text {\n    font-size: ", ";\n    fill: ", ";\n  }\n\n  .axis line {\n    stroke: ", ";\n    shape-rendering: crispEdges;\n    stroke-width: 1;\n  }\n\n  .axis path {\n    fill: none;\n    stroke: ", ";\n    shape-rendering: crispEdges;\n    stroke-width: 2;\n  }\n\n  .axis .domain {\n    display: none;\n  }\n\n  .value {\n    fill: ", ";\n    font-size: ", ";\n\n    &.start {\n      text-anchor: start;\n    }\n\n    &.end {\n      text-anchor: end;\n    }\n  }\n"])), function (props) {
  return props.theme.axisFontSize;
}, function (props) {
  return props.theme.axisFontColor;
}, function (props) {
  return props.theme.axisFontColor;
}, function (props) {
  return props.theme.sliderBarBgd;
}, function (props) {
  return props.theme.axisFontColor;
}, function (props) {
  return props.theme.axisFontSize;
});
var TICK_FORMATS = {
  millisecond: '.SSS',
  second: ':ss',
  minute: 'HH:mm',
  hour: 'HH A',
  day: 'ddd DD',
  week: 'MMM DD',
  month: 'MMM',
  year: 'YYYY'
};

// timezone sensitive tick formatter based on moment
// adapted based on d3 time scale tick format https://github.com/d3/d3-scale/blob/master/src/time.js#L59
function getTickFormat(timezone) {
  // date is js date object
  var toMoment = timezone ? function (date) {
    return (0, _momentTimezone["default"])(date).tz(timezone);
  } : _momentTimezone["default"];
  var formatter = (0, _utils.datetimeFormatter)(timezone);
  return function (date) {
    return (toMoment(date).startOf('second') < date ? formatter(TICK_FORMATS.millisecond) : toMoment(date).startOf('minute') < date ? formatter(TICK_FORMATS.second) : toMoment(date).startOf('hour') < date ? formatter(TICK_FORMATS.minute) : toMoment(date).startOf('day') < date ? formatter(TICK_FORMATS.hour) : toMoment(date).startOf('month') < date ? toMoment(date).startOf('isoWeek') < date ? formatter(TICK_FORMATS.day) : formatter(TICK_FORMATS.week) : toMoment(date).startOf('year') < date ? formatter(TICK_FORMATS.month) : formatter(TICK_FORMATS.year))(date);
  };
}

// create a helper function so we can test it
function getXAxis(domain, width, isEnlarged, timezone) {
  if (!Array.isArray(domain) || !domain.every(Number.isFinite)) {
    return null;
  }
  var scale = (0, _d3Scale.scaleUtc)().domain(domain).range([0, width]);
  if (!scale) {
    return null;
  }
  var ticks = Math.floor(width / (isEnlarged ? MIN_TICK_WIDTH_LARGE : MIN_TICK_WIDTH_SMALL));
  var tickFormat = timezone ? getTickFormat(timezone) : null;
  var xAxis = (0, _d3Axis.axisBottom)(scale).ticks(ticks).tickSize(4).tickPadding(4);
  if (tickFormat) {
    xAxis.tickFormat(tickFormat);
  }
  return xAxis;
}
function updateAxis(xAxisRef, xAxis) {
  if (!xAxis) {
    return;
  }
  (0, _d3Selection.select)(xAxisRef.current).call(xAxis);
}
function TimeSliderMarkerFactory() {
  var TimeSliderMarker = function TimeSliderMarker(_ref) {
    var width = _ref.width,
      domain = _ref.domain,
      _ref$isEnlarged = _ref.isEnlarged,
      isEnlarged = _ref$isEnlarged === void 0 ? true : _ref$isEnlarged,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? HEIGHT : _ref$height,
      timezone = _ref.timezone;
    var xAxisRef = (0, _react.useRef)(null);
    var xAxis = (0, _react.useMemo)(function () {
      return getXAxis(domain, width, isEnlarged, timezone);
    }, [domain, width, isEnlarged, timezone]);
    (0, _react.useEffect)(function () {
      updateAxis(xAxisRef, xAxis);
    }, [xAxisRef, xAxis]);
    return /*#__PURE__*/_react["default"].createElement(TimeSliderContainer, {
      className: "time-slider-marker",
      width: width,
      height: height
    }, /*#__PURE__*/_react["default"].createElement("g", {
      className: "x axis",
      ref: xAxisRef,
      transform: "translate(0, 0)"
    }));
  };
  return /*#__PURE__*/_react["default"].memo(TimeSliderMarker);
}
var _default = exports["default"] = TimeSliderMarkerFactory;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfbW9tZW50VGltZXpvbmUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2QzU2NhbGUiLCJfZDNTZWxlY3Rpb24iLCJfZDNBeGlzIiwiX3N0eWxlZENvbXBvbmVudHMiLCJfdXRpbHMiLCJfdGVtcGxhdGVPYmplY3QiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJNSU5fVElDS19XSURUSF9MQVJHRSIsIk1JTl9USUNLX1dJRFRIX1NNQUxMIiwiSEVJR0hUIiwiVGltZVNsaWRlckNvbnRhaW5lciIsInN0eWxlZCIsInN2ZyIsIl90YWdnZWRUZW1wbGF0ZUxpdGVyYWwyIiwicHJvcHMiLCJ0aGVtZSIsImF4aXNGb250U2l6ZSIsImF4aXNGb250Q29sb3IiLCJzbGlkZXJCYXJCZ2QiLCJUSUNLX0ZPUk1BVFMiLCJtaWxsaXNlY29uZCIsInNlY29uZCIsIm1pbnV0ZSIsImhvdXIiLCJkYXkiLCJ3ZWVrIiwibW9udGgiLCJ5ZWFyIiwiZ2V0VGlja0Zvcm1hdCIsInRpbWV6b25lIiwidG9Nb21lbnQiLCJkYXRlIiwibW9tZW50IiwidHoiLCJmb3JtYXR0ZXIiLCJkYXRldGltZUZvcm1hdHRlciIsInN0YXJ0T2YiLCJnZXRYQXhpcyIsImRvbWFpbiIsIndpZHRoIiwiaXNFbmxhcmdlZCIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzY2FsZSIsInNjYWxlVXRjIiwicmFuZ2UiLCJ0aWNrcyIsIk1hdGgiLCJmbG9vciIsInRpY2tGb3JtYXQiLCJ4QXhpcyIsImF4aXNCb3R0b20iLCJ0aWNrU2l6ZSIsInRpY2tQYWRkaW5nIiwidXBkYXRlQXhpcyIsInhBeGlzUmVmIiwic2VsZWN0IiwiY3VycmVudCIsIlRpbWVTbGlkZXJNYXJrZXJGYWN0b3J5IiwiVGltZVNsaWRlck1hcmtlciIsIl9yZWYiLCJfcmVmJGlzRW5sYXJnZWQiLCJfcmVmJGhlaWdodCIsImhlaWdodCIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVmIiwidHJhbnNmb3JtIiwiUmVhY3QiLCJtZW1vIiwiX2RlZmF1bHQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbW1vbi90aW1lLXNsaWRlci1tYXJrZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBSZWFjdCwge3VzZVJlZiwgdXNlRWZmZWN0LCB1c2VNZW1vfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC10aW1lem9uZSc7XG5pbXBvcnQge051bWJlclZhbHVlLCBzY2FsZVV0Y30gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHtzZWxlY3R9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQge2F4aXNCb3R0b219IGZyb20gJ2QzLWF4aXMnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQge2RhdGV0aW1lRm9ybWF0dGVyfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcblxuY29uc3QgTUlOX1RJQ0tfV0lEVEhfTEFSR0UgPSA4MDtcbmNvbnN0IE1JTl9USUNLX1dJRFRIX1NNQUxMID0gNTA7XG5jb25zdCBIRUlHSFQgPSAzMDtcblxuY29uc3QgVGltZVNsaWRlckNvbnRhaW5lciA9IHN0eWxlZC5zdmdgXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgb3ZlcmZsb3c6IHZpc2libGU7XG4gIG1hcmdpbi10b3A6IDZweDtcblxuICAuYXhpcyB0ZXh0IHtcbiAgICBmb250LXNpemU6ICR7cHJvcHMgPT4gcHJvcHMudGhlbWUuYXhpc0ZvbnRTaXplfTtcbiAgICBmaWxsOiAke3Byb3BzID0+IHByb3BzLnRoZW1lLmF4aXNGb250Q29sb3J9O1xuICB9XG5cbiAgLmF4aXMgbGluZSB7XG4gICAgc3Ryb2tlOiAke3Byb3BzID0+IHByb3BzLnRoZW1lLmF4aXNGb250Q29sb3J9O1xuICAgIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcbiAgICBzdHJva2Utd2lkdGg6IDE7XG4gIH1cblxuICAuYXhpcyBwYXRoIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogJHtwcm9wcyA9PiBwcm9wcy50aGVtZS5zbGlkZXJCYXJCZ2R9O1xuICAgIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcbiAgICBzdHJva2Utd2lkdGg6IDI7XG4gIH1cblxuICAuYXhpcyAuZG9tYWluIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLnZhbHVlIHtcbiAgICBmaWxsOiAke3Byb3BzID0+IHByb3BzLnRoZW1lLmF4aXNGb250Q29sb3J9O1xuICAgIGZvbnQtc2l6ZTogJHtwcm9wcyA9PiBwcm9wcy50aGVtZS5heGlzRm9udFNpemV9O1xuXG4gICAgJi5zdGFydCB7XG4gICAgICB0ZXh0LWFuY2hvcjogc3RhcnQ7XG4gICAgfVxuXG4gICAgJi5lbmQge1xuICAgICAgdGV4dC1hbmNob3I6IGVuZDtcbiAgICB9XG4gIH1cbmA7XG5cbmNvbnN0IFRJQ0tfRk9STUFUUyA9IHtcbiAgbWlsbGlzZWNvbmQ6ICcuU1NTJyxcbiAgc2Vjb25kOiAnOnNzJyxcbiAgbWludXRlOiAnSEg6bW0nLFxuICBob3VyOiAnSEggQScsXG4gIGRheTogJ2RkZCBERCcsXG4gIHdlZWs6ICdNTU0gREQnLFxuICBtb250aDogJ01NTScsXG4gIHllYXI6ICdZWVlZJ1xufTtcblxuLy8gdGltZXpvbmUgc2Vuc2l0aXZlIHRpY2sgZm9ybWF0dGVyIGJhc2VkIG9uIG1vbWVudFxuLy8gYWRhcHRlZCBiYXNlZCBvbiBkMyB0aW1lIHNjYWxlIHRpY2sgZm9ybWF0IGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9zcmMvdGltZS5qcyNMNTlcbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWNrRm9ybWF0KHRpbWV6b25lOiBzdHJpbmcpIHtcbiAgLy8gZGF0ZSBpcyBqcyBkYXRlIG9iamVjdFxuICBjb25zdCB0b01vbWVudCA9IHRpbWV6b25lID8gZGF0ZSA9PiBtb21lbnQoZGF0ZSkudHoodGltZXpvbmUpIDogbW9tZW50O1xuICBjb25zdCBmb3JtYXR0ZXIgPSBkYXRldGltZUZvcm1hdHRlcih0aW1lem9uZSk7XG5cbiAgcmV0dXJuIGRhdGUgPT5cbiAgICAodG9Nb21lbnQoZGF0ZSkuc3RhcnRPZignc2Vjb25kJykgPCBkYXRlXG4gICAgICA/IGZvcm1hdHRlcihUSUNLX0ZPUk1BVFMubWlsbGlzZWNvbmQpXG4gICAgICA6IHRvTW9tZW50KGRhdGUpLnN0YXJ0T2YoJ21pbnV0ZScpIDwgZGF0ZVxuICAgICAgPyBmb3JtYXR0ZXIoVElDS19GT1JNQVRTLnNlY29uZClcbiAgICAgIDogdG9Nb21lbnQoZGF0ZSkuc3RhcnRPZignaG91cicpIDwgZGF0ZVxuICAgICAgPyBmb3JtYXR0ZXIoVElDS19GT1JNQVRTLm1pbnV0ZSlcbiAgICAgIDogdG9Nb21lbnQoZGF0ZSkuc3RhcnRPZignZGF5JykgPCBkYXRlXG4gICAgICA/IGZvcm1hdHRlcihUSUNLX0ZPUk1BVFMuaG91cilcbiAgICAgIDogdG9Nb21lbnQoZGF0ZSkuc3RhcnRPZignbW9udGgnKSA8IGRhdGVcbiAgICAgID8gdG9Nb21lbnQoZGF0ZSkuc3RhcnRPZignaXNvV2VlaycpIDwgZGF0ZVxuICAgICAgICA/IGZvcm1hdHRlcihUSUNLX0ZPUk1BVFMuZGF5KVxuICAgICAgICA6IGZvcm1hdHRlcihUSUNLX0ZPUk1BVFMud2VlaylcbiAgICAgIDogdG9Nb21lbnQoZGF0ZSkuc3RhcnRPZigneWVhcicpIDwgZGF0ZVxuICAgICAgPyBmb3JtYXR0ZXIoVElDS19GT1JNQVRTLm1vbnRoKVxuICAgICAgOiBmb3JtYXR0ZXIoVElDS19GT1JNQVRTLnllYXIpKShkYXRlKTtcbn1cblxuLy8gY3JlYXRlIGEgaGVscGVyIGZ1bmN0aW9uIHNvIHdlIGNhbiB0ZXN0IGl0XG5leHBvcnQgZnVuY3Rpb24gZ2V0WEF4aXMoXG4gIGRvbWFpbjogRGF0ZVtdIHwgTnVtYmVyVmFsdWVbXSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaXNFbmxhcmdlZDogYm9vbGVhbixcbiAgdGltZXpvbmU6IHN0cmluZ1xuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb21haW4pIHx8ICFkb21haW4uZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHNjYWxlID0gc2NhbGVVdGMoKS5kb21haW4oZG9tYWluKS5yYW5nZShbMCwgd2lkdGhdKTtcbiAgaWYgKCFzY2FsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgdGlja3MgPSBNYXRoLmZsb29yKHdpZHRoIC8gKGlzRW5sYXJnZWQgPyBNSU5fVElDS19XSURUSF9MQVJHRSA6IE1JTl9USUNLX1dJRFRIX1NNQUxMKSk7XG4gIGNvbnN0IHRpY2tGb3JtYXQgPSB0aW1lem9uZSA/IGdldFRpY2tGb3JtYXQodGltZXpvbmUpIDogbnVsbDtcbiAgY29uc3QgeEF4aXMgPSBheGlzQm90dG9tKHNjYWxlKS50aWNrcyh0aWNrcykudGlja1NpemUoNCkudGlja1BhZGRpbmcoNCk7XG4gIGlmICh0aWNrRm9ybWF0KSB7XG4gICAgeEF4aXMudGlja0Zvcm1hdCh0aWNrRm9ybWF0KTtcbiAgfVxuXG4gIHJldHVybiB4QXhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUF4aXMoeEF4aXNSZWYsIHhBeGlzKSB7XG4gIGlmICgheEF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZWxlY3QoeEF4aXNSZWYuY3VycmVudCkuY2FsbCh4QXhpcyk7XG59XG5cbmludGVyZmFjZSBUaW1lU2xpZGVyTWFya2VyUHJvcHMge1xuICB3aWR0aDogbnVtYmVyO1xuICBkb21haW46IERhdGVbXSB8IE51bWJlclZhbHVlW107XG4gIGlzRW5sYXJnZWQ/OiBib29sZWFuO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHRpbWV6b25lOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFRpbWVTbGlkZXJNYXJrZXJGYWN0b3J5KCkge1xuICBjb25zdCBUaW1lU2xpZGVyTWFya2VyID0gKHtcbiAgICB3aWR0aCxcbiAgICBkb21haW4sXG4gICAgaXNFbmxhcmdlZCA9IHRydWUsXG4gICAgaGVpZ2h0ID0gSEVJR0hULFxuICAgIHRpbWV6b25lXG4gIH06IFRpbWVTbGlkZXJNYXJrZXJQcm9wcykgPT4ge1xuICAgIGNvbnN0IHhBeGlzUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHhBeGlzID0gdXNlTWVtbyhcbiAgICAgICgpID0+IGdldFhBeGlzKGRvbWFpbiwgd2lkdGgsIGlzRW5sYXJnZWQsIHRpbWV6b25lKSxcbiAgICAgIFtkb21haW4sIHdpZHRoLCBpc0VubGFyZ2VkLCB0aW1lem9uZV1cbiAgICApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB1cGRhdGVBeGlzKHhBeGlzUmVmLCB4QXhpcyk7XG4gICAgfSwgW3hBeGlzUmVmLCB4QXhpc10pO1xuICAgIHJldHVybiAoXG4gICAgICA8VGltZVNsaWRlckNvbnRhaW5lciBjbGFzc05hbWU9XCJ0aW1lLXNsaWRlci1tYXJrZXJcIiB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fT5cbiAgICAgICAgPGcgY2xhc3NOYW1lPVwieCBheGlzXCIgcmVmPXt4QXhpc1JlZn0gdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsIDApXCIgLz5cbiAgICAgIDwvVGltZVNsaWRlckNvbnRhaW5lcj5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdC5tZW1vKFRpbWVTbGlkZXJNYXJrZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2xpZGVyTWFya2VyRmFjdG9yeTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR0EsSUFBQUEsTUFBQSxHQUFBQyx1QkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsZUFBQSxHQUFBQyxzQkFBQSxDQUFBRixPQUFBO0FBQ0EsSUFBQUcsUUFBQSxHQUFBSCxPQUFBO0FBQ0EsSUFBQUksWUFBQSxHQUFBSixPQUFBO0FBQ0EsSUFBQUssT0FBQSxHQUFBTCxPQUFBO0FBQ0EsSUFBQU0saUJBQUEsR0FBQUosc0JBQUEsQ0FBQUYsT0FBQTtBQUNBLElBQUFPLE1BQUEsR0FBQVAsT0FBQTtBQUFtRCxJQUFBUSxlQUFBLEVBVG5EO0FBQ0E7QUFBQSxTQUFBQyx5QkFBQUMsQ0FBQSw2QkFBQUMsT0FBQSxtQkFBQUMsQ0FBQSxPQUFBRCxPQUFBLElBQUFFLENBQUEsT0FBQUYsT0FBQSxZQUFBRix3QkFBQSxZQUFBQSx5QkFBQUMsQ0FBQSxXQUFBQSxDQUFBLEdBQUFHLENBQUEsR0FBQUQsQ0FBQSxLQUFBRixDQUFBO0FBQUEsU0FBQVgsd0JBQUFXLENBQUEsRUFBQUUsQ0FBQSxTQUFBQSxDQUFBLElBQUFGLENBQUEsSUFBQUEsQ0FBQSxDQUFBSSxVQUFBLFNBQUFKLENBQUEsZUFBQUEsQ0FBQSxnQkFBQUssT0FBQSxDQUFBTCxDQUFBLDBCQUFBQSxDQUFBLHNCQUFBQSxDQUFBLFFBQUFHLENBQUEsR0FBQUosd0JBQUEsQ0FBQUcsQ0FBQSxPQUFBQyxDQUFBLElBQUFBLENBQUEsQ0FBQUcsR0FBQSxDQUFBTixDQUFBLFVBQUFHLENBQUEsQ0FBQUksR0FBQSxDQUFBUCxDQUFBLE9BQUFRLENBQUEsS0FBQUMsU0FBQSxVQUFBQyxDQUFBLEdBQUFDLE1B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