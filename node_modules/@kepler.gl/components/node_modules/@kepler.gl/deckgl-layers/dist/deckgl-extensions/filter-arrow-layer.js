"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _core = require("@deck.gl/core");
var _constants = _interopRequireDefault(require("@luma.gl/constants"));
var _filterShaderModule = _interopRequireDefault(require("./filter-shader-module"));
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var VALUE_FILTERED = 1;
var defaultProps = {
  getFiltered: {
    type: 'accessor',
    value: VALUE_FILTERED
  }
};
/**
 * FilterArrowExtension - a deck.gl extension to filter arrow layer
 *
 * A simple extension to filter arrow layer based on the result of CPU filteredIndex,
 * so we can avoid filtering on the raw Arrow table and recreating geometry attributes.
 * Specifically, an attribute `filtered` is added to the layer to indicate whether the feature has been Filtered
 * the shader module is modified to discard the feature if filtered value is 0
 * the accessor getFiltered is used to get the value of `filtered` based on the value `filteredIndex` in Arrowlayer
 */
var FilterArrowExtension = exports["default"] = /*#__PURE__*/function (_LayerExtension) {
  function FilterArrowExtension() {
    (0, _classCallCheck2["default"])(this, FilterArrowExtension);
    return _callSuper(this, FilterArrowExtension, arguments);
  }
  (0, _inherits2["default"])(FilterArrowExtension, _LayerExtension);
  return (0, _createClass2["default"])(FilterArrowExtension, [{
    key: "getShaders",
    value: function getShaders() {
      return {
        modules: [_filterShaderModule["default"]],
        defines: {}
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.add({
          filtered: {
            size: 1,
            type: _constants["default"].FLOAT,
            accessor: 'getFiltered',
            shaderAttributes: {
              filtered: {
                divisor: 0
              },
              instanceFiltered: {
                divisor: 1
              }
            }
          }
        });
      }
    }
  }]);
}(_core.LayerExtension);
(0, _defineProperty2["default"])(FilterArrowExtension, "defaultProps", defaultProps);
(0, _defineProperty2["default"])(FilterArrowExtension, "extensionName", 'FilterArrowExtension');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY29yZSIsInJlcXVpcmUiLCJfY29uc3RhbnRzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9maWx0ZXJTaGFkZXJNb2R1bGUiLCJfY2FsbFN1cGVyIiwidCIsIm8iLCJlIiwiX2dldFByb3RvdHlwZU9mMiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiY29uc3RydWN0b3IiLCJhcHBseSIsIkJvb2xlYW4iLCJwcm90b3R5cGUiLCJ2YWx1ZU9mIiwiY2FsbCIsIlZBTFVFX0ZJTFRFUkVEIiwiZGVmYXVsdFByb3BzIiwiZ2V0RmlsdGVyZWQiLCJ0eXBlIiwidmFsdWUiLCJGaWx0ZXJBcnJvd0V4dGVuc2lvbiIsImV4cG9ydHMiLCJfTGF5ZXJFeHRlbnNpb24iLCJfY2xhc3NDYWxsQ2hlY2syIiwiYXJndW1lbnRzIiwiX2luaGVyaXRzMiIsIl9jcmVhdGVDbGFzczIiLCJrZXkiLCJnZXRTaGFkZXJzIiwibW9kdWxlcyIsInNoYWRlck1vZHVsZSIsImRlZmluZXMiLCJpbml0aWFsaXplU3RhdGUiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiZ2V0QXR0cmlidXRlTWFuYWdlciIsImFkZCIsImZpbHRlcmVkIiwic2l6ZSIsIkdMIiwiRkxPQVQiLCJhY2Nlc3NvciIsInNoYWRlckF0dHJpYnV0ZXMiLCJkaXZpc29yIiwiaW5zdGFuY2VGaWx0ZXJlZCIsIkxheWVyRXh0ZW5zaW9uIiwiX2RlZmluZVByb3BlcnR5MiJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNrZ2wtZXh0ZW5zaW9ucy9maWx0ZXItYXJyb3ctbGF5ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtMYXllciwgTGF5ZXJFeHRlbnNpb259IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEdMIGZyb20gJ0BsdW1hLmdsL2NvbnN0YW50cyc7XG5cbmltcG9ydCBzaGFkZXJNb2R1bGUgZnJvbSAnLi9maWx0ZXItc2hhZGVyLW1vZHVsZSc7XG5cbmNvbnN0IFZBTFVFX0ZJTFRFUkVEID0gMTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRGaWx0ZXJlZDoge3R5cGU6ICdhY2Nlc3NvcicsIHZhbHVlOiBWQUxVRV9GSUxURVJFRH1cbn07XG5cbmV4cG9ydCB0eXBlIEZpbHRlckFycm93RXh0ZW5zaW9uUHJvcHMgPSB7XG4gIGdldEZpbHRlcmVkPzogKCkgPT4gbnVtYmVyO1xufTtcblxuLyoqXG4gKiBGaWx0ZXJBcnJvd0V4dGVuc2lvbiAtIGEgZGVjay5nbCBleHRlbnNpb24gdG8gZmlsdGVyIGFycm93IGxheWVyXG4gKlxuICogQSBzaW1wbGUgZXh0ZW5zaW9uIHRvIGZpbHRlciBhcnJvdyBsYXllciBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mIENQVSBmaWx0ZXJlZEluZGV4LFxuICogc28gd2UgY2FuIGF2b2lkIGZpbHRlcmluZyBvbiB0aGUgcmF3IEFycm93IHRhYmxlIGFuZCByZWNyZWF0aW5nIGdlb21ldHJ5IGF0dHJpYnV0ZXMuXG4gKiBTcGVjaWZpY2FsbHksIGFuIGF0dHJpYnV0ZSBgZmlsdGVyZWRgIGlzIGFkZGVkIHRvIHRoZSBsYXllciB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBmZWF0dXJlIGhhcyBiZWVuIEZpbHRlcmVkXG4gKiB0aGUgc2hhZGVyIG1vZHVsZSBpcyBtb2RpZmllZCB0byBkaXNjYXJkIHRoZSBmZWF0dXJlIGlmIGZpbHRlcmVkIHZhbHVlIGlzIDBcbiAqIHRoZSBhY2Nlc3NvciBnZXRGaWx0ZXJlZCBpcyB1c2VkIHRvIGdldCB0aGUgdmFsdWUgb2YgYGZpbHRlcmVkYCBiYXNlZCBvbiB0aGUgdmFsdWUgYGZpbHRlcmVkSW5kZXhgIGluIEFycm93bGF5ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyQXJyb3dFeHRlbnNpb24gZXh0ZW5kcyBMYXllckV4dGVuc2lvbiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gIHN0YXRpYyBleHRlbnNpb25OYW1lID0gJ0ZpbHRlckFycm93RXh0ZW5zaW9uJztcblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2R1bGVzOiBbc2hhZGVyTW9kdWxlXSxcbiAgICAgIGRlZmluZXM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSh0aGlzOiBMYXllcjxGaWx0ZXJBcnJvd0V4dGVuc2lvblByb3BzPikge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBpZiAoYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgICBmaWx0ZXJlZDoge1xuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogR0wuRkxPQVQsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWx0ZXJlZCcsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgZmlsdGVyZWQ6IHtcbiAgICAgICAgICAgICAgZGl2aXNvcjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlRmlsdGVyZWQ6IHtcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxLQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxVQUFBLEdBQUFDLHNCQUFBLENBQUFGLE9BQUE7QUFFQSxJQUFBRyxtQkFBQSxHQUFBRCxzQkFBQSxDQUFBRixPQUFBO0FBQWtELFNBQUFJLFdBQUFDLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLFdBQUFELENBQUEsT0FBQUUsZ0JBQUEsYUFBQUYsQ0FBQSxPQUFBRywyQkFBQSxhQUFBSixDQUFBLEVBQUFLLHlCQUFBLEtBQUFDLE9BQUEsQ0FBQUMsU0FBQSxDQUFBTixDQUFBLEVBQUFDLENBQUEsWUFBQUMsZ0JBQUEsYUFBQUgsQ0FBQSxFQUFBUSxXQUFBLElBQUFQLENBQUEsQ0FBQVEsS0FBQSxDQUFBVCxDQUFBLEVBQUFFLENBQUE7QUFBQSxTQUFBRywwQkFBQSxjQUFBTCxDQUFBLElBQUFVLE9BQUEsQ0FBQUMsU0FBQSxDQUFBQyxPQUFBLENBQUFDLElBQUEsQ0FBQVAsT0FBQSxDQUFBQyxTQUFBLENBQUFHLE9BQUEsaUNBQUFWLENBQUEsYUFBQUsseUJBQUEsWUFBQUEsMEJBQUEsYUFBQUwsQ0FBQSxVQU5sRDtBQUNBO0FBT0EsSUFBTWMsY0FBYyxHQUFHLENBQUM7QUFFeEIsSUFBTUMsWUFBWSxHQUFHO0VBQ25CQyxXQUFXLEVBQUU7SUFBQ0MsSUFBSSxFQUFFLFVBQVU7SUFBRUMsS0FBSyxFQUFFSjtFQUFjO0FBQ3ZELENBQUM7QUFNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQSxJQVNxQkssb0JBQW9CLEdBQUFDLE9BQUEscUNBQUFDLGVBQUE7RUFBQSxTQUFBRixxQkFBQTtJQUFBLElBQUFHLGdCQUFBLG1CQUFBSCxvQkFBQTtJQUFBLE9BQUFwQixVQUFBLE9BQUFvQixvQkFBQSxFQUFBSSxTQUFBO0VBQUE7RUFBQSxJQUFBQyxVQUFBLGFBQUFMLG9CQUFBLEVBQUFFLGVBQUE7RUFBQSxXQUFBSSxhQUFBLGFBQUFOLG9CQUFBO0lBQUFPLEdBQUE7SUFBQVIsS0FBQSxFQUl2QyxTQUFBUyxVQUFVQSxDQUFBLEVBQUc7TUFDWCxPQUFPO1FBQ0xDLE9BQU8sRUFBRSxDQUFDQyw4QkFBWSxDQUFDO1FBQ3ZCQyxPQUFPLEVBQUUsQ0FBQztNQUNaLENBQUM7SUFDSDtFQUFDO0lBQUFKLEdBQUE7SUFBQVIsS0FBQSxFQUVELFNBQUFhLGVBQWVBLENBQUEsRUFBeUM7TUFDdEQsSUFBTUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQyxDQUFDO01BQ25ELElBQUlELGdCQUFnQixFQUFFO1FBQ3BCQSxnQkFBZ0IsQ0FBQ0UsR0FBRyxDQUFDO1VBQ25CQyxRQUFRLEVBQUU7WUFDUkMsSUFBSSxFQUFFLENBQUM7WUFDUG5CLElBQUksRUFBRW9CLHFCQUFFLENBQUNDLEtBQUs7WUFDZEMsUUFBUSxFQUFFLGFBQWE7WUFDdkJDLGdCQUFnQixFQUFFO2NBQ2hCTCxRQUFRLEVBQUU7Z0JBQ1JNLE9BQU8sRUFBRTtjQUNYLENBQUM7Y0FDREMsZ0JBQWdCLEVBQUU7Z0JBQ2hCRCxPQUFPLEVBQUU7Y0FDWDtZQUNGO1VBQ0Y7UUFDRixDQUFDLENBQUM7TUFDSjtJQUNGO0VBQUM7QUFBQSxFQTlCK0NFLG9CQUFjO0FBQUEsSUFBQUMsZ0JBQUEsYUFBM0N6QixvQkFBb0Isa0JBQ2pCSixZQUFZO0FBQUEsSUFBQTZCLGdCQUFBLGFBRGZ6QixvQkFBb0IsbUJBRWhCLHNCQUFzQiIsImlnbm9yZUxpc3QiOltdfQ==