import * as arrow from 'apache-arrow';
import { Feature, BBox } from 'geojson';
import { KeplerTable } from '@kepler.gl/table';
import { Field, ProtoDatasetField, FieldPair, SupportedColumnMode, LayerColumn, LayerColumns, RGBColor } from '@kepler.gl/types';
import { DataContainerInterface, ArrowDataContainer } from '@kepler.gl/utils';
import { DeckGlGeoTypes, GeojsonDataMaps } from './geojson-layer/geojson-utils';
export declare type FindDefaultLayerProps = {
    label: string;
    color?: RGBColor;
    isVisible?: boolean;
    columns?: Record<string, LayerColumn>;
};
export declare type FindDefaultLayerPropsReturnValue = {
    /** Layer props to create layers by default when a dataset is added */
    props: FindDefaultLayerProps[];
    /** layer props of possible alternative layer configurations, not created by default */
    altProps?: FindDefaultLayerProps[];
    /** Already found layer configurations */
    foundLayers?: (FindDefaultLayerProps & {
        type: string;
    })[];
};
export declare function assignPointPairToLayerColumn(pair: FieldPair, hasAlt: boolean): Record<string, LayerColumn>;
export declare type GeojsonLayerMetaProps = {
    dataToFeature: GeojsonDataMaps;
    featureTypes: DeckGlGeoTypes;
    bounds: BBox | null;
    fixedRadius: boolean;
    centroids?: Array<number[] | null>;
};
export declare function getGeojsonLayerMetaFromArrow({ geoColumn, geoField, chunkIndex }: {
    dataContainer: DataContainerInterface;
    geoColumn: arrow.Vector;
    geoField: ProtoDatasetField;
    chunkIndex?: number;
}): GeojsonLayerMetaProps;
export declare function isLayerHoveredFromArrow(objectInfo: any, layerId: string): boolean;
export declare function getHoveredObjectFromArrow(objectInfo: any, dataContainer: any, layerId: any, columnAccessor: any, fieldAccessor: any): Feature | null;
/**
 * find requiredColumns of supported column mode based on column mode
 */
export declare function getColumnModeRequiredColumns(supportedColumnModes: SupportedColumnMode[] | null, columnMode?: string): string[] | undefined;
/**
 * Returns geoarrow fields with ARROW:extension:name POINT metadata
 * @param fields Any fields
 * @returns geoarrow fields with ARROW:extension:name POINT metadata
 */
export declare function getGeoArrowPointFields(fields: Field[]): Field[];
/**
 * Builds an arrow vector compatible with ARROW:extension:name geoarrow.point.
 * @param getPosition Position accessor.
 * @param numElements Number of elements in the vector.
 * @returns An arrow vector compatible with ARROW:extension:name geoarrow.point.
 */
export declare function createGeoArrowPointVector(dataContainer: ArrowDataContainer, getPosition: ({ index }: {
    index: number;
}) => number[]): arrow.Vector;
/**
 * Builds a filtered index suitable for FilterArrowExtension.
 * @param numElements Size for filtered index array.
 * @param visibleIndices An array with indices of elements that aren't filtered out.
 * @returns filteredIndex [0|1] array for GPU filtering
 */
export declare function getFilteredIndex(numElements: number, visibleIndices: number[], existingFilteredIndex: Uint8ClampedArray | null): Uint8ClampedArray;
/**
 * Returns an array of neighbors to the specified index.
 * @param neighborsField LayerColumn field with information about neighbors.
 * @param dataContainer Data container.
 * @param index Index of interest.
 * @param getPosition Position accessor.
 * @returns An array with information about neighbors.
 */
export declare function getNeighbors(neighborsField: LayerColumn | undefined, dataContainer: DataContainerInterface, index: number, getPosition: ({ index }: {
    index: number;
}) => number[]): {
    index: number;
    position: number[];
}[];
/**
 * Returns bounds from a geoarrow field.
 * TODO: refactor once metadata extraction from parquet to arrow vectors is in place.
 * @param layerColumn Layer columns for which to check for a bounding box.
 * @param dataContainer Data container with geoarrow metadata.
 * @returns Returns bounding box if exists.
 */
export declare function getBoundsFromArrowMetadata(layerColumn: LayerColumn, dataContainer: ArrowDataContainer): [number, number, number, number] | false;
/**
 * Finds and returns the first satisfied column mode based on the provided columns and fields.
 * @param supportedColumnModes - An array of supported column modes to check.
 * @param columns - The available columns.
 * @param fields - Optional table fields to be used for extra verification.
 * @returns The first column mode that satisfies the required conditions, or undefined if none match.
 */
export declare function getSatisfiedColumnMode(columnModes: SupportedColumnMode[] | null, columns: LayerColumns | undefined, fields?: KeplerTable['fields']): SupportedColumnMode | undefined;
/**
 * Returns true if the field is of geoarrow point format.
 * @param field A field.
 * @returns Returns true if the field is of geoarrow point format.
 */
export declare function isGeoArrowPointField(field: Field): boolean;
/**
 * Create default geoarrow column props based on the dataset.
 * @param dataset A dataset to create layer props from.
 * @returns  geoarrow column props.
 */
export declare function getGeoArrowPointLayerProps(dataset: KeplerTable): FindDefaultLayerProps[];
