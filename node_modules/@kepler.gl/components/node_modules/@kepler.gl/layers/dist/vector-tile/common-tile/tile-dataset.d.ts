import { Field as KeplerField } from '@kepler.gl/types';
import { RowCountAccessor } from './iterable-tile-set';
export declare type Datum = number | string | null;
declare type RowValueAccessor<T> = (field: KeplerField, row: T extends Iterable<infer V> ? V : never) => Datum;
declare type RowValueAccessorFactory<T> = (field?: KeplerField, indexKey?: number | null) => RowValueAccessor<T>;
declare type TileAccessors<T, I extends Iterable<any> = T extends Iterable<any> ? T : never> = {
    getTileId: (tile: T) => string;
    getIterable: (tile: T) => I;
    getRowCount: RowCountAccessor<I>;
    getRowValue: RowValueAccessorFactory<I>;
};
/**
 * Stateful class offering dataset-style functions for the set of tiles.
 */
export default class TileDataset<T, I extends Iterable<any> = T extends Iterable<any> ? T : never> {
    private accessors;
    private tiles;
    private tileSet;
    private tileIds;
    /** Cache for per-tile field stats: tileId -> fieldId -> stats */
    private tileStats;
    constructor(accessors: TileAccessors<T, I>, tiles?: readonly T[]);
    /**
     * Invalidate the cached data
     */
    invalidateCache(): void;
    /**
     * Update the set of tiles in the viewport
     */
    updateTiles(tiles: readonly T[]): void;
    /**
     * Get the min/max domain of a field
     */
    getExtent(field: KeplerField): [number, number];
    /**
     * Get a sample of field values to use in estimating quantiles
     */
    getQuantileSample(field: KeplerField, minRowCount?: number): number[];
    /**
     * Get a set of unique values for a field
     */
    getUniqueValues(field: KeplerField): Datum[];
    private getTileStat;
    private setTileStat;
}
export {};
