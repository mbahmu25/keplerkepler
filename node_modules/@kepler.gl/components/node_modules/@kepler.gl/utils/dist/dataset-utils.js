"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.datasetColorMaker = exports.addTimeLabel = void 0;
exports.findDefaultColorField = findDefaultColorField;
exports.getFieldFormatLabels = getFieldFormatLabels;
exports.getFormatLabels = void 0;
exports.validateInputData = validateInputData;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _constants = require("@kepler.gl/constants");
var _commonUtils = require("@kepler.gl/common-utils");
var _typeAnalyzer = require("type-analyzer");
var _assert = _interopRequireDefault(require("assert"));
var _utils = require("./utils");
var _dataUtils = require("./data-utils");
var _format = require("./format");
var _colorUtils = require("./color-utils");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var _marked = /*#__PURE__*/_regenerator["default"].mark(generateColor); // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// apply a color for each dataset
// to use as label colors
var datasetColors = ['#8F2FBF', '#005CFF', '#C06C84', '#F8B195', '#547A82', '#3EACA8', '#A2D4AB'].map(_colorUtils.hexToRgb);

/**
 * Random color generator
 */
function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        index = 0;
      case 1:
        if (!(index < datasetColors.length + 1)) {
          _context.next = 7;
          break;
        }
        if (index === datasetColors.length) {
          index = 0;
        }
        _context.next = 5;
        return datasetColors[index++];
      case 5:
        _context.next = 1;
        break;
      case 7:
      case "end":
        return _context.stop();
    }
  }, _marked);
}
var datasetColorMaker = exports.datasetColorMaker = generateColor();

/**
 * Field name prefixes and suffixes which should not be considered
 * as metrics. Fields will still be included if a 'metric word'
 * is found on the field name, however.
 */
var EXCLUDED_DEFAULT_FIELDS = [
// Serial numbers and identification numbers
'_id', 'id', 'index', 'uuid', 'guid', 'uid', 'gid', 'serial',
// Geographic IDs are unlikely to be interesting to color
'zip', 'code', 'post', 'region', 'fips', 'cbgs', 'h3', 's2',
// Geographic coords (but not z/elevation/altitude
// since that might be a metric)
'lat', 'lon', 'lng', 'latitude', 'longitude', '_x', '_y'];

/**
 * Prefixes and suffixes that indicate a field is a metric.
 *
 * Note that these are in order of preference, first being
 * most preferred.
 */
var METRIC_DEFAULT_FIELDS = ['metric', 'value', 'sum', 'count', 'unique', 'mean', 'mode', 'median', 'max', 'min', 'deviation', 'variance', 'p99', 'p95', 'p75', 'p50', 'p25', 'p05',
// Abbreviations are less preferred
'cnt', 'val'];

/**
 * Choose a field to use as the default color field of a layer.
 *
 * The heuristic is:
 *
 * First, exclude fields that are on the exclusion list and don't
 * have names that suggest they contain metrics. Also exclude
 * field names that are blank.
 *
 * Next, look for a field that is of real type and contains one
 * of the preferred names (in order of the preferred names).
 *
 * Next, look for a field that is of integer type and contains
 * one of the preferred names (in order of the preferred names).
 *
 * Next, look for the first field that is of real type (in order
 * of field index).
 *
 * Next, look for the first field that is of integer type (in
 * order of field index).
 *
 * It's possible no field will be chosen (i.e. because all fields
 * are strings.)
 *
 * @param dataset
 */
function findDefaultColorField(_ref) {
  var fields = _ref.fields,
    _ref$fieldPairs = _ref.fieldPairs,
    fieldPairs = _ref$fieldPairs === void 0 ? [] : _ref$fieldPairs;
  var fieldsWithoutExcluded = fields.filter(function (field) {
    if (field.type !== _constants.ALL_FIELD_TYPES.real && field.type !== _constants.ALL_FIELD_TYPES.integer) {
      // Only select numeric fields.
      return false;
    }
    if (fieldPairs.find(function (pair) {
      return pair.pair.lat.value === field.name || pair.pair.lng.value === field.name;
    })) {
      // Do not permit lat, lon fields
      return false;
    }
    var normalizedFieldName = field.name.toLowerCase();
    if (normalizedFieldName === '') {
      // Special case excluded name when the name is blank.
      return false;
    }
    var hasExcluded = EXCLUDED_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    var hasInclusion = METRIC_DEFAULT_FIELDS.find(function (f) {
      return normalizedFieldName.startsWith(f) || normalizedFieldName.endsWith(f);
    });
    return !hasExcluded || hasInclusion;
  });
  var sortedFields = fieldsWithoutExcluded.sort(function (left, right) {
    var normalizedLeft = left.name.toLowerCase();
    var normalizedRight = right.name.toLowerCase();
    var leftHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedLeft.startsWith(f) || normalizedLeft.endsWith(f);
    });
    var rightHasInclusion = METRIC_DEFAULT_FIELDS.findIndex(function (f) {
      return normalizedRight.startsWith(f) || normalizedRight.endsWith(f);
    });
    if (leftHasInclusion !== rightHasInclusion) {
      if (leftHasInclusion === -1) {
        // Elements that do not have the inclusion list should go after those that do.
        return 1;
      } else if (rightHasInclusion === -1) {
        // Elements that do have the inclusion list should go before those that don't.
        return -1;
      }
      // Compare based on order in the inclusion list
      return leftHasInclusion - rightHasInclusion;
    }

    // Compare based on type
    if (left.type !== right.type) {
      if (left.type === _constants.ALL_FIELD_TYPES.real) {
        return -1;
      }
      // left is an integer and right is not
      // and reals come before integers
      return 1;
    }

    // Finally, order based on the order in the datasets columns
    // @ts-expect-error
    return left.index - right.index;
  });
  if (sortedFields.length) {
    // There was a best match
    return sortedFields[0];
  }
  // No matches
  return null;
}

/**
 * Validate input data, adding missing field types, rename duplicate columns
 */
function validateInputData(data) {
  if (!(0, _utils.isPlainObject)(data)) {
    (0, _assert["default"])('addDataToMap Error: dataset.data cannot be null');
    return null;
  } else if (!Array.isArray(data.fields)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.fields to be an array');
    return null;
  } else if (!Array.isArray(data.rows)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.rows to be an array');
    return null;
  }
  var fields = data.fields,
    rows = data.rows,
    cols = data.cols;

  // check if all fields has name, format and type
  var allValid = fields.every(function (f, i) {
    if (!(0, _utils.isPlainObject)(f)) {
      (0, _assert["default"])("fields needs to be an array of object, but find ".concat((0, _typeof2["default"])(f)));
      fields[i] = {
        name: "column_".concat(i),
        type: _constants.ALL_FIELD_TYPES.string
      };
    }
    if (!f.name) {
      (0, _assert["default"])("field.name is required but missing in ".concat(JSON.stringify(f)));
      // assign a name
      fields[i].name = "column_".concat(i);
    }
    if (!f.type || !_constants.ALL_FIELD_TYPES[f.type]) {
      (0, _assert["default"])("unknown field type ".concat(f.type));
      return false;
    }
    if (!f.analyzerType) {
      (0, _assert["default"])("field ".concat(i, " missing analyzerType"));
      return false;
    }

    // check time format is correct based on first 10 not empty element
    if (f.type === _constants.ALL_FIELD_TYPES.timestamp) {
      var sample = (cols ? findNonEmptyRowsAtFieldArrow(cols, i, 10) : findNonEmptyRowsAtField(rows, i, 10)).map(function (r) {
        return {
          ts: r[i]
        };
      });
      var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(sample)[0];
      return analyzedType && analyzedType.category === 'TIME' && analyzedType.format === f.format;
    }

    // check existing string field is H3 type
    if (f.type === _constants.ALL_FIELD_TYPES.string) {
      var _sample = (cols ? findNonEmptyRowsAtFieldArrow(cols, i, 10) : findNonEmptyRowsAtField(rows, i, 10)).map(function (r) {
        return r[i];
      });
      return _sample.every(function (item) {
        return !(0, _commonUtils.h3IsValid)(item);
      });
    }
    return true;
  });
  if (allValid) {
    return {
      rows: rows,
      fields: fields,
      cols: cols
    };
  }

  // if any field has missing type, recalculate it for everyone
  // because we simply lost faith in humanity
  var sampleData = cols ? (0, _commonUtils.getSampleForTypeAnalyzeArrow)(cols, fields.map(function (f) {
    return f.name;
  })) : (0, _commonUtils.getSampleForTypeAnalyze)({
    fields: fields.map(function (f) {
      return f.name;
    }),
    rows: rows
  });
  var fieldOrder = fields.map(function (f) {
    return f.name;
  });
  var meta = (0, _commonUtils.getFieldsFromData)(sampleData, fieldOrder);
  var updatedFields = fields.map(function (f, i) {
    return _objectSpread(_objectSpread({}, f), {}, {
      type: meta[i].type,
      format: meta[i].format,
      analyzerType: meta[i].analyzerType
    });
  });
  return _objectSpread({
    fields: updatedFields,
    rows: rows
  }, cols ? {
    cols: cols
  } : {});
}
function findNonEmptyRowsAtField(rows, fieldIdx, total) {
  var sample = [];
  var i = 0;
  while (sample.length < total && i < rows.length) {
    var _rows$i;
    if ((0, _commonUtils.notNullorUndefined)((_rows$i = rows[i]) === null || _rows$i === void 0 ? void 0 : _rows$i[fieldIdx])) {
      sample.push(rows[i]);
    }
    i++;
  }
  return sample;
}
function findNonEmptyRowsAtFieldArrow(cols, fieldIdx, total) {
  var sample = [];
  var numRows = cols[fieldIdx].length;
  var i = 0;
  while (sample.length < total && i < numRows) {
    if ((0, _commonUtils.notNullorUndefined)(cols[fieldIdx].get(i))) {
      var row = cols.map(function (col) {
        return col.get(i);
      });
      sample.push(row);
    }
    i++;
  }
  return sample;
}
var TIME_DISPLAY = '2020-05-11 14:00';
var addTimeLabel = exports.addTimeLabel = function addTimeLabel(formats) {
  return formats.map(function (f) {
    return _objectSpread(_objectSpread({}, f), {}, {
      label: f.type === _constants.TOOLTIP_FORMAT_TYPES.DATE_TIME || f.type === _constants.TOOLTIP_FORMAT_TYPES.DATE ? (0, _dataUtils.getFormatter)((0, _format.getFormatValue)(f))(TIME_DISPLAY) : f.label
    });
  });
};
function getFieldFormatLabels(fieldType) {
  var tooltipTypes = fieldType && _constants.FIELD_OPTS[fieldType].format.tooltip || [];
  var formatLabels = Object.values(_constants.TOOLTIP_FORMATS).filter(function (t) {
    return tooltipTypes.includes(t.type);
  });
  return addTimeLabel(formatLabels);
}
var getFormatLabels = exports.getFormatLabels = function getFormatLabels(fields, fieldName) {
  var _fields$find;
  var fieldType = (_fields$find = fields.find(function (f) {
    return f.name === fieldName;
  })) === null || _fields$find === void 0 ? void 0 : _fields$find.type;
  return getFieldFormatLabels(fieldType);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY29uc3RhbnRzIiwicmVxdWlyZSIsIl9jb21tb25VdGlscyIsIl90eXBlQW5hbHl6ZXIiLCJfYXNzZXJ0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl91dGlscyIsIl9kYXRhVXRpbHMiLCJfZm9ybWF0IiwiX2NvbG9yVXRpbHMiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIl9tYXJrZWQiLCJfcmVnZW5lcmF0b3IiLCJtYXJrIiwiZ2VuZXJhdGVDb2xvciIsImRhdGFzZXRDb2xvcnMiLCJtYXAiLCJoZXhUb1JnYiIsImluZGV4Iiwid3JhcCIsImdlbmVyYXRlQ29sb3IkIiwiX2NvbnRleHQiLCJwcmV2IiwibmV4dCIsInN0b3AiLCJkYXRhc2V0Q29sb3JNYWtlciIsImV4cG9ydHMiLCJFWENMVURFRF9ERUZBVUxUX0ZJRUxEUyIsIk1FVFJJQ19ERUZBVUxUX0ZJRUxEUyIsImZpbmREZWZhdWx0Q29sb3JGaWVsZCIsIl9yZWYiLCJmaWVsZHMiLCJfcmVmJGZpZWxkUGFpcnMiLCJmaWVsZFBhaXJzIiwiZmllbGRzV2l0aG91dEV4Y2x1ZGVkIiwiZmllbGQiLCJ0eXBlIiwiQUxMX0ZJRUxEX1RZUEVTIiwicmVhbCIsImludGVnZXIiLCJmaW5kIiwicGFpciIsImxhdCIsInZhbHVlIiwibmFtZSIsImxuZyIsIm5vcm1hbGl6ZWRGaWVsZE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImhhc0V4Y2x1ZGVkIiwiZiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImhhc0luY2x1c2lvbiIsInNvcnRlZEZpZWxkcyIsInNvcnQiLCJsZWZ0IiwicmlnaHQiLCJub3JtYWxpemVkTGVmdCIsIm5vcm1hbGl6ZWRSaWdodCIsImxlZnRIYXNJbmNsdXNpb24iLCJmaW5kSW5kZXgiLCJyaWdodEhhc0luY2x1c2lvbiIsInZhbGlkYXRlSW5wdXREYXRhIiwiZGF0YSIsImlzUGxhaW5PYmplY3QiLCJhc3NlcnQiLCJBcnJheSIsImlzQXJyYXkiLCJyb3dzIiwiY29scyIsImFsbFZhbGlkIiwiZXZlcnkiLCJpIiwiY29uY2F0IiwiX3R5cGVvZjIiLCJzdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiYW5hbHl6ZXJUeXBlIiwidGltZXN0YW1wIiwic2FtcGxlIiwiZmluZE5vbkVtcHR5Um93c0F0RmllbGRBcnJvdyIsImZpbmROb25FbXB0eVJvd3NBdEZpZWxkIiwidHMiLCJhbmFseXplZFR5cGUiLCJBbmFseXplciIsImNvbXB1dGVDb2xNZXRhIiwiY2F0ZWdvcnkiLCJmb3JtYXQiLCJpdGVtIiwiaDNJc1ZhbGlkIiwic2FtcGxlRGF0YSIsImdldFNhbXBsZUZvclR5cGVBbmFseXplQXJyb3ciLCJnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSIsImZpZWxkT3JkZXIiLCJtZXRhIiwiZ2V0RmllbGRzRnJvbURhdGEiLCJ1cGRhdGVkRmllbGRzIiwiZmllbGRJZHgiLCJ0b3RhbCIsIl9yb3dzJGkiLCJub3ROdWxsb3JVbmRlZmluZWQiLCJudW1Sb3dzIiwiZ2V0Iiwicm93IiwiY29sIiwiVElNRV9ESVNQTEFZIiwiYWRkVGltZUxhYmVsIiwiZm9ybWF0cyIsImxhYmVsIiwiVE9PTFRJUF9GT1JNQVRfVFlQRVMiLCJEQVRFX1RJTUUiLCJEQVRFIiwiZ2V0Rm9ybWF0dGVyIiwiZ2V0Rm9ybWF0VmFsdWUiLCJnZXRGaWVsZEZvcm1hdExhYmVscyIsImZpZWxkVHlwZSIsInRvb2x0aXBUeXBlcyIsIkZJRUxEX09QVFMiLCJ0b29sdGlwIiwiZm9ybWF0TGFiZWxzIiwidmFsdWVzIiwiVE9PTFRJUF9GT1JNQVRTIiwiaW5jbHVkZXMiLCJnZXRGb3JtYXRMYWJlbHMiLCJmaWVsZE5hbWUiLCJfZmllbGRzJGZpbmQiXSwic291cmNlcyI6WyIuLi9zcmMvZGF0YXNldC11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHtcbiAgQUxMX0ZJRUxEX1RZUEVTLFxuICBGSUVMRF9PUFRTLFxuICBUT09MVElQX0ZPUk1BVFMsXG4gIFRPT0xUSVBfRk9STUFUX1RZUEVTXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGdldFNhbXBsZUZvclR5cGVBbmFseXplLFxuICBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZUFycm93LFxuICBnZXRGaWVsZHNGcm9tRGF0YVxufSBmcm9tICdAa2VwbGVyLmdsL2NvbW1vbi11dGlscyc7XG5pbXBvcnQge0FuYWx5emVyfSBmcm9tICd0eXBlLWFuYWx5emVyJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuaW1wb3J0IHtcbiAgUHJvY2Vzc29yUmVzdWx0LFxuICBSR0JDb2xvcixcbiAgRmllbGQsXG4gIEZpZWxkUGFpcixcbiAgVGltZUxhYmVsRm9ybWF0LFxuICBUb29sdGlwRmllbGRzLFxuICBQcm90b0RhdGFzZXRcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge1Rvb2x0aXBGb3JtYXR9IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7bm90TnVsbG9yVW5kZWZpbmVkLCBoM0lzVmFsaWR9IGZyb20gJ0BrZXBsZXIuZ2wvY29tbW9uLXV0aWxzJztcblxuaW1wb3J0IHtpc1BsYWluT2JqZWN0fSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7Z2V0Rm9ybWF0dGVyfSBmcm9tICcuL2RhdGEtdXRpbHMnO1xuaW1wb3J0IHtnZXRGb3JtYXRWYWx1ZX0gZnJvbSAnLi9mb3JtYXQnO1xuaW1wb3J0IHtoZXhUb1JnYn0gZnJvbSAnLi9jb2xvci11dGlscyc7XG5cbi8vIGFwcGx5IGEgY29sb3IgZm9yIGVhY2ggZGF0YXNldFxuLy8gdG8gdXNlIGFzIGxhYmVsIGNvbG9yc1xuY29uc3QgZGF0YXNldENvbG9ycyA9IFtcbiAgJyM4RjJGQkYnLFxuICAnIzAwNUNGRicsXG4gICcjQzA2Qzg0JyxcbiAgJyNGOEIxOTUnLFxuICAnIzU0N0E4MicsXG4gICcjM0VBQ0E4JyxcbiAgJyNBMkQ0QUInXG5dLm1hcChoZXhUb1JnYik7XG5cbi8qKlxuICogUmFuZG9tIGNvbG9yIGdlbmVyYXRvclxuICovXG5mdW5jdGlvbiogZ2VuZXJhdGVDb2xvcigpOiBHZW5lcmF0b3I8UkdCQ29sb3I+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgZGF0YXNldENvbG9ycy5sZW5ndGggKyAxKSB7XG4gICAgaWYgKGluZGV4ID09PSBkYXRhc2V0Q29sb3JzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICB5aWVsZCBkYXRhc2V0Q29sb3JzW2luZGV4KytdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhc2V0Q29sb3JNYWtlciA9IGdlbmVyYXRlQ29sb3IoKTtcblxuLyoqXG4gKiBGaWVsZCBuYW1lIHByZWZpeGVzIGFuZCBzdWZmaXhlcyB3aGljaCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWRcbiAqIGFzIG1ldHJpY3MuIEZpZWxkcyB3aWxsIHN0aWxsIGJlIGluY2x1ZGVkIGlmIGEgJ21ldHJpYyB3b3JkJ1xuICogaXMgZm91bmQgb24gdGhlIGZpZWxkIG5hbWUsIGhvd2V2ZXIuXG4gKi9cbmNvbnN0IEVYQ0xVREVEX0RFRkFVTFRfRklFTERTID0gW1xuICAvLyBTZXJpYWwgbnVtYmVycyBhbmQgaWRlbnRpZmljYXRpb24gbnVtYmVyc1xuICAnX2lkJyxcbiAgJ2lkJyxcbiAgJ2luZGV4JyxcbiAgJ3V1aWQnLFxuICAnZ3VpZCcsXG4gICd1aWQnLFxuICAnZ2lkJyxcbiAgJ3NlcmlhbCcsXG4gIC8vIEdlb2dyYXBoaWMgSURzIGFyZSB1bmxpa2VseSB0byBiZSBpbnRlcmVzdGluZyB0byBjb2xvclxuICAnemlwJyxcbiAgJ2NvZGUnLFxuICAncG9zdCcsXG4gICdyZWdpb24nLFxuICAnZmlwcycsXG4gICdjYmdzJyxcbiAgJ2gzJyxcbiAgJ3MyJyxcbiAgLy8gR2VvZ3JhcGhpYyBjb29yZHMgKGJ1dCBub3Qgei9lbGV2YXRpb24vYWx0aXR1ZGVcbiAgLy8gc2luY2UgdGhhdCBtaWdodCBiZSBhIG1ldHJpYylcbiAgJ2xhdCcsXG4gICdsb24nLFxuICAnbG5nJyxcbiAgJ2xhdGl0dWRlJyxcbiAgJ2xvbmdpdHVkZScsXG4gICdfeCcsXG4gICdfeSdcbl07XG5cbi8qKlxuICogUHJlZml4ZXMgYW5kIHN1ZmZpeGVzIHRoYXQgaW5kaWNhdGUgYSBmaWVsZCBpcyBhIG1ldHJpYy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlc2UgYXJlIGluIG9yZGVyIG9mIHByZWZlcmVuY2UsIGZpcnN0IGJlaW5nXG4gKiBtb3N0IHByZWZlcnJlZC5cbiAqL1xuY29uc3QgTUVUUklDX0RFRkFVTFRfRklFTERTID0gW1xuICAnbWV0cmljJyxcbiAgJ3ZhbHVlJyxcbiAgJ3N1bScsXG4gICdjb3VudCcsXG4gICd1bmlxdWUnLFxuICAnbWVhbicsXG4gICdtb2RlJyxcbiAgJ21lZGlhbicsXG4gICdtYXgnLFxuICAnbWluJyxcbiAgJ2RldmlhdGlvbicsXG4gICd2YXJpYW5jZScsXG4gICdwOTknLFxuICAncDk1JyxcbiAgJ3A3NScsXG4gICdwNTAnLFxuICAncDI1JyxcbiAgJ3AwNScsXG4gIC8vIEFiYnJldmlhdGlvbnMgYXJlIGxlc3MgcHJlZmVycmVkXG4gICdjbnQnLFxuICAndmFsJ1xuXTtcblxuLyoqXG4gKiBDaG9vc2UgYSBmaWVsZCB0byB1c2UgYXMgdGhlIGRlZmF1bHQgY29sb3IgZmllbGQgb2YgYSBsYXllci5cbiAqXG4gKiBUaGUgaGV1cmlzdGljIGlzOlxuICpcbiAqIEZpcnN0LCBleGNsdWRlIGZpZWxkcyB0aGF0IGFyZSBvbiB0aGUgZXhjbHVzaW9uIGxpc3QgYW5kIGRvbid0XG4gKiBoYXZlIG5hbWVzIHRoYXQgc3VnZ2VzdCB0aGV5IGNvbnRhaW4gbWV0cmljcy4gQWxzbyBleGNsdWRlXG4gKiBmaWVsZCBuYW1lcyB0aGF0IGFyZSBibGFuay5cbiAqXG4gKiBOZXh0LCBsb29rIGZvciBhIGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIGFuZCBjb250YWlucyBvbmVcbiAqIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMgKGluIG9yZGVyIG9mIHRoZSBwcmVmZXJyZWQgbmFtZXMpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIGEgZmllbGQgdGhhdCBpcyBvZiBpbnRlZ2VyIHR5cGUgYW5kIGNvbnRhaW5zXG4gKiBvbmUgb2YgdGhlIHByZWZlcnJlZCBuYW1lcyAoaW4gb3JkZXIgb2YgdGhlIHByZWZlcnJlZCBuYW1lcykuXG4gKlxuICogTmV4dCwgbG9vayBmb3IgdGhlIGZpcnN0IGZpZWxkIHRoYXQgaXMgb2YgcmVhbCB0eXBlIChpbiBvcmRlclxuICogb2YgZmllbGQgaW5kZXgpLlxuICpcbiAqIE5leHQsIGxvb2sgZm9yIHRoZSBmaXJzdCBmaWVsZCB0aGF0IGlzIG9mIGludGVnZXIgdHlwZSAoaW5cbiAqIG9yZGVyIG9mIGZpZWxkIGluZGV4KS5cbiAqXG4gKiBJdCdzIHBvc3NpYmxlIG5vIGZpZWxkIHdpbGwgYmUgY2hvc2VuIChpLmUuIGJlY2F1c2UgYWxsIGZpZWxkc1xuICogYXJlIHN0cmluZ3MuKVxuICpcbiAqIEBwYXJhbSBkYXRhc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGVmYXVsdENvbG9yRmllbGQoe1xuICBmaWVsZHMsXG4gIGZpZWxkUGFpcnMgPSBbXVxufToge1xuICBmaWVsZHM6IEZpZWxkW107XG4gIGZpZWxkUGFpcnM6IEZpZWxkUGFpcltdO1xufSk6IG51bGwgfCBGaWVsZCB7XG4gIGNvbnN0IGZpZWxkc1dpdGhvdXRFeGNsdWRlZCA9IGZpZWxkcy5maWx0ZXIoZmllbGQgPT4ge1xuICAgIGlmIChmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMucmVhbCAmJiBmaWVsZC50eXBlICE9PSBBTExfRklFTERfVFlQRVMuaW50ZWdlcikge1xuICAgICAgLy8gT25seSBzZWxlY3QgbnVtZXJpYyBmaWVsZHMuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGZpZWxkUGFpcnMuZmluZChcbiAgICAgICAgcGFpciA9PiBwYWlyLnBhaXIubGF0LnZhbHVlID09PSBmaWVsZC5uYW1lIHx8IHBhaXIucGFpci5sbmcudmFsdWUgPT09IGZpZWxkLm5hbWVcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIERvIG5vdCBwZXJtaXQgbGF0LCBsb24gZmllbGRzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEZpZWxkTmFtZSA9IGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9ybWFsaXplZEZpZWxkTmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBleGNsdWRlZCBuYW1lIHdoZW4gdGhlIG5hbWUgaXMgYmxhbmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc0V4Y2x1ZGVkID0gRVhDTFVERURfREVGQVVMVF9GSUVMRFMuZmluZChcbiAgICAgIGYgPT4gbm9ybWFsaXplZEZpZWxkTmFtZS5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRGaWVsZE5hbWUuZW5kc1dpdGgoZilcbiAgICApO1xuICAgIGNvbnN0IGhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kKFxuICAgICAgZiA9PiBub3JtYWxpemVkRmllbGROYW1lLnN0YXJ0c1dpdGgoZikgfHwgbm9ybWFsaXplZEZpZWxkTmFtZS5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgcmV0dXJuICFoYXNFeGNsdWRlZCB8fCBoYXNJbmNsdXNpb247XG4gIH0pO1xuXG4gIGNvbnN0IHNvcnRlZEZpZWxkcyA9IGZpZWxkc1dpdGhvdXRFeGNsdWRlZC5zb3J0KChsZWZ0LCByaWdodCkgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMZWZ0ID0gbGVmdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFJpZ2h0ID0gcmlnaHQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxlZnRIYXNJbmNsdXNpb24gPSBNRVRSSUNfREVGQVVMVF9GSUVMRFMuZmluZEluZGV4KFxuICAgICAgZiA9PiBub3JtYWxpemVkTGVmdC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRMZWZ0LmVuZHNXaXRoKGYpXG4gICAgKTtcbiAgICBjb25zdCByaWdodEhhc0luY2x1c2lvbiA9IE1FVFJJQ19ERUZBVUxUX0ZJRUxEUy5maW5kSW5kZXgoXG4gICAgICBmID0+IG5vcm1hbGl6ZWRSaWdodC5zdGFydHNXaXRoKGYpIHx8IG5vcm1hbGl6ZWRSaWdodC5lbmRzV2l0aChmKVxuICAgICk7XG4gICAgaWYgKGxlZnRIYXNJbmNsdXNpb24gIT09IHJpZ2h0SGFzSW5jbHVzaW9uKSB7XG4gICAgICBpZiAobGVmdEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgaW5jbHVzaW9uIGxpc3Qgc2hvdWxkIGdvIGFmdGVyIHRob3NlIHRoYXQgZG8uXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChyaWdodEhhc0luY2x1c2lvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBkbyBoYXZlIHRoZSBpbmNsdXNpb24gbGlzdCBzaG91bGQgZ28gYmVmb3JlIHRob3NlIHRoYXQgZG9uJ3QuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBhcmUgYmFzZWQgb24gb3JkZXIgaW4gdGhlIGluY2x1c2lvbiBsaXN0XG4gICAgICByZXR1cm4gbGVmdEhhc0luY2x1c2lvbiAtIHJpZ2h0SGFzSW5jbHVzaW9uO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgYmFzZWQgb24gdHlwZVxuICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpIHtcbiAgICAgIGlmIChsZWZ0LnR5cGUgPT09IEFMTF9GSUVMRF9UWVBFUy5yZWFsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZnQgaXMgYW4gaW50ZWdlciBhbmQgcmlnaHQgaXMgbm90XG4gICAgICAvLyBhbmQgcmVhbHMgY29tZSBiZWZvcmUgaW50ZWdlcnNcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIG9yZGVyIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB0aGUgZGF0YXNldHMgY29sdW1uc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICB9KTtcblxuICBpZiAoc29ydGVkRmllbGRzLmxlbmd0aCkge1xuICAgIC8vIFRoZXJlIHdhcyBhIGJlc3QgbWF0Y2hcbiAgICByZXR1cm4gc29ydGVkRmllbGRzWzBdO1xuICB9XG4gIC8vIE5vIG1hdGNoZXNcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgaW5wdXQgZGF0YSwgYWRkaW5nIG1pc3NpbmcgZmllbGQgdHlwZXMsIHJlbmFtZSBkdXBsaWNhdGUgY29sdW1uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dERhdGEoZGF0YTogUHJvdG9EYXRhc2V0WydkYXRhJ10pOiBQcm9jZXNzb3JSZXN1bHQge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBhc3NlcnQoJ2FkZERhdGFUb01hcCBFcnJvcjogZGF0YXNldC5kYXRhIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5maWVsZHMpKSB7XG4gICAgYXNzZXJ0KCdhZGREYXRhVG9NYXAgRXJyb3I6IGV4cGVjdCBkYXRhc2V0LmRhdGEuZmllbGRzIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yb3dzKSkge1xuICAgIGFzc2VydCgnYWRkRGF0YVRvTWFwIEVycm9yOiBleHBlY3QgZGF0YXNldC5kYXRhLnJvd3MgdG8gYmUgYW4gYXJyYXknKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtmaWVsZHMsIHJvd3MsIGNvbHN9ID0gZGF0YTtcblxuICAvLyBjaGVjayBpZiBhbGwgZmllbGRzIGhhcyBuYW1lLCBmb3JtYXQgYW5kIHR5cGVcbiAgY29uc3QgYWxsVmFsaWQgPSBmaWVsZHMuZXZlcnkoKGYsIGkpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGFzc2VydChgZmllbGRzIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9mIG9iamVjdCwgYnV0IGZpbmQgJHt0eXBlb2YgZn1gKTtcbiAgICAgIGZpZWxkc1tpXSA9IHtuYW1lOiBgY29sdW1uXyR7aX1gLCB0eXBlOiBBTExfRklFTERfVFlQRVMuc3RyaW5nfTtcbiAgICB9XG5cbiAgICBpZiAoIWYubmFtZSkge1xuICAgICAgYXNzZXJ0KGBmaWVsZC5uYW1lIGlzIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZil9YCk7XG4gICAgICAvLyBhc3NpZ24gYSBuYW1lXG4gICAgICBmaWVsZHNbaV0ubmFtZSA9IGBjb2x1bW5fJHtpfWA7XG4gICAgfVxuXG4gICAgaWYgKCFmLnR5cGUgfHwgIUFMTF9GSUVMRF9UWVBFU1tmLnR5cGVdKSB7XG4gICAgICBhc3NlcnQoYHVua25vd24gZmllbGQgdHlwZSAke2YudHlwZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWYuYW5hbHl6ZXJUeXBlKSB7XG4gICAgICBhc3NlcnQoYGZpZWxkICR7aX0gbWlzc2luZyBhbmFseXplclR5cGVgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aW1lIGZvcm1hdCBpcyBjb3JyZWN0IGJhc2VkIG9uIGZpcnN0IDEwIG5vdCBlbXB0eSBlbGVtZW50XG4gICAgaWYgKGYudHlwZSA9PT0gQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcCkge1xuICAgICAgY29uc3Qgc2FtcGxlID0gKFxuICAgICAgICBjb2xzID8gZmluZE5vbkVtcHR5Um93c0F0RmllbGRBcnJvdyhjb2xzLCBpLCAxMCkgOiBmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZChyb3dzLCBpLCAxMClcbiAgICAgICkubWFwKHIgPT4gKHt0czogcltpXX0pKTtcbiAgICAgIGNvbnN0IGFuYWx5emVkVHlwZSA9IEFuYWx5emVyLmNvbXB1dGVDb2xNZXRhKHNhbXBsZSlbMF07XG4gICAgICByZXR1cm4gYW5hbHl6ZWRUeXBlICYmIGFuYWx5emVkVHlwZS5jYXRlZ29yeSA9PT0gJ1RJTUUnICYmIGFuYWx5emVkVHlwZS5mb3JtYXQgPT09IGYuZm9ybWF0O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGV4aXN0aW5nIHN0cmluZyBmaWVsZCBpcyBIMyB0eXBlXG4gICAgaWYgKGYudHlwZSA9PT0gQUxMX0ZJRUxEX1RZUEVTLnN0cmluZykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gKFxuICAgICAgICBjb2xzID8gZmluZE5vbkVtcHR5Um93c0F0RmllbGRBcnJvdyhjb2xzLCBpLCAxMCkgOiBmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZChyb3dzLCBpLCAxMClcbiAgICAgICkubWFwKHIgPT4gcltpXSk7XG4gICAgICByZXR1cm4gc2FtcGxlLmV2ZXJ5KGl0ZW0gPT4gIWgzSXNWYWxpZChpdGVtKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmIChhbGxWYWxpZCkge1xuICAgIHJldHVybiB7cm93cywgZmllbGRzLCBjb2xzfTtcbiAgfVxuXG4gIC8vIGlmIGFueSBmaWVsZCBoYXMgbWlzc2luZyB0eXBlLCByZWNhbGN1bGF0ZSBpdCBmb3IgZXZlcnlvbmVcbiAgLy8gYmVjYXVzZSB3ZSBzaW1wbHkgbG9zdCBmYWl0aCBpbiBodW1hbml0eVxuICBjb25zdCBzYW1wbGVEYXRhID0gY29sc1xuICAgID8gZ2V0U2FtcGxlRm9yVHlwZUFuYWx5emVBcnJvdyhcbiAgICAgICAgY29scyxcbiAgICAgICAgZmllbGRzLm1hcChmID0+IGYubmFtZSlcbiAgICAgIClcbiAgICA6IGdldFNhbXBsZUZvclR5cGVBbmFseXplKHtcbiAgICAgICAgZmllbGRzOiBmaWVsZHMubWFwKGYgPT4gZi5uYW1lKSxcbiAgICAgICAgcm93c1xuICAgICAgfSk7XG4gIGNvbnN0IGZpZWxkT3JkZXIgPSBmaWVsZHMubWFwKGYgPT4gZi5uYW1lKTtcbiAgY29uc3QgbWV0YSA9IGdldEZpZWxkc0Zyb21EYXRhKHNhbXBsZURhdGEsIGZpZWxkT3JkZXIpO1xuICBjb25zdCB1cGRhdGVkRmllbGRzID0gZmllbGRzLm1hcCgoZiwgaSkgPT4gKHtcbiAgICAuLi5mLFxuICAgIHR5cGU6IG1ldGFbaV0udHlwZSxcbiAgICBmb3JtYXQ6IG1ldGFbaV0uZm9ybWF0LFxuICAgIGFuYWx5emVyVHlwZTogbWV0YVtpXS5hbmFseXplclR5cGVcbiAgfSkpO1xuXG4gIHJldHVybiB7ZmllbGRzOiB1cGRhdGVkRmllbGRzLCByb3dzLCAuLi4oY29scyA/IHtjb2xzfSA6IHt9KX07XG59XG5cbmZ1bmN0aW9uIGZpbmROb25FbXB0eVJvd3NBdEZpZWxkKHJvd3M6IHVua25vd25bXVtdLCBmaWVsZElkeDogbnVtYmVyLCB0b3RhbDogbnVtYmVyKTogYW55W10ge1xuICBjb25zdCBzYW1wbGU6IGFueVtdID0gW107XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKHNhbXBsZS5sZW5ndGggPCB0b3RhbCAmJiBpIDwgcm93cy5sZW5ndGgpIHtcbiAgICBpZiAobm90TnVsbG9yVW5kZWZpbmVkKHJvd3NbaV0/LltmaWVsZElkeF0pKSB7XG4gICAgICBzYW1wbGUucHVzaChyb3dzW2ldKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBzYW1wbGU7XG59XG5cbmZ1bmN0aW9uIGZpbmROb25FbXB0eVJvd3NBdEZpZWxkQXJyb3coXG4gIGNvbHM6IGFycm93LlZlY3RvcltdLFxuICBmaWVsZElkeDogbnVtYmVyLFxuICB0b3RhbDogbnVtYmVyXG4pOiBhbnlbXSB7XG4gIGNvbnN0IHNhbXBsZTogYW55W10gPSBbXTtcbiAgY29uc3QgbnVtUm93cyA9IGNvbHNbZmllbGRJZHhdLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoc2FtcGxlLmxlbmd0aCA8IHRvdGFsICYmIGkgPCBudW1Sb3dzKSB7XG4gICAgaWYgKG5vdE51bGxvclVuZGVmaW5lZChjb2xzW2ZpZWxkSWR4XS5nZXQoaSkpKSB7XG4gICAgICBjb25zdCByb3cgPSBjb2xzLm1hcChjb2wgPT4gY29sLmdldChpKSk7XG4gICAgICBzYW1wbGUucHVzaChyb3cpO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHNhbXBsZTtcbn1cblxuY29uc3QgVElNRV9ESVNQTEFZID0gJzIwMjAtMDUtMTEgMTQ6MDAnO1xuXG5leHBvcnQgY29uc3QgYWRkVGltZUxhYmVsID0gKGZvcm1hdHM6IFRpbWVMYWJlbEZvcm1hdFtdKSA9PlxuICBmb3JtYXRzLm1hcChmID0+ICh7XG4gICAgLi4uZixcbiAgICBsYWJlbDpcbiAgICAgIGYudHlwZSA9PT0gVE9PTFRJUF9GT1JNQVRfVFlQRVMuREFURV9USU1FIHx8IGYudHlwZSA9PT0gVE9PTFRJUF9GT1JNQVRfVFlQRVMuREFURVxuICAgICAgICA/IGdldEZvcm1hdHRlcihnZXRGb3JtYXRWYWx1ZShmKSkoVElNRV9ESVNQTEFZKVxuICAgICAgICA6IGYubGFiZWxcbiAgfSkpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRGb3JtYXRMYWJlbHMoZmllbGRUeXBlPzogc3RyaW5nKTogVG9vbHRpcEZvcm1hdFtdIHtcbiAgY29uc3QgdG9vbHRpcFR5cGVzID0gKGZpZWxkVHlwZSAmJiBGSUVMRF9PUFRTW2ZpZWxkVHlwZV0uZm9ybWF0LnRvb2x0aXApIHx8IFtdO1xuICBjb25zdCBmb3JtYXRMYWJlbHM6IFRpbWVMYWJlbEZvcm1hdFtdID0gT2JqZWN0LnZhbHVlcyhUT09MVElQX0ZPUk1BVFMpLmZpbHRlcih0ID0+XG4gICAgdG9vbHRpcFR5cGVzLmluY2x1ZGVzKHQudHlwZSlcbiAgKTtcbiAgcmV0dXJuIGFkZFRpbWVMYWJlbChmb3JtYXRMYWJlbHMpO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Rm9ybWF0TGFiZWxzID0gKGZpZWxkczogVG9vbHRpcEZpZWxkc1tdLCBmaWVsZE5hbWU6IHN0cmluZyk6IFRvb2x0aXBGb3JtYXRbXSA9PiB7XG4gIGNvbnN0IGZpZWxkVHlwZSA9IGZpZWxkcy5maW5kKGYgPT4gZi5uYW1lID09PSBmaWVsZE5hbWUpPy50eXBlO1xuICByZXR1cm4gZ2V0RmllbGRGb3JtYXRMYWJlbHMoZmllbGRUeXBlKTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBSUEsSUFBQUEsVUFBQSxHQUFBQyxPQUFBO0FBTUEsSUFBQUMsWUFBQSxHQUFBRCxPQUFBO0FBS0EsSUFBQUUsYUFBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsT0FBQSxHQUFBQyxzQkFBQSxDQUFBSixPQUFBO0FBY0EsSUFBQUssTUFBQSxHQUFBTCxPQUFBO0FBQ0EsSUFBQU0sVUFBQSxHQUFBTixPQUFBO0FBQ0EsSUFBQU8sT0FBQSxHQUFBUCxPQUFBO0FBQ0EsSUFBQVEsV0FBQSxHQUFBUixPQUFBO0FBQXVDLFNBQUFTLFFBQUFDLENBQUEsRUFBQUMsQ0FBQSxRQUFBQyxDQUFBLEdBQUFDLE1B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