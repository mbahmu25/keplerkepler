"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataRow = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Setting for shared row optimization.
 * - False/undefined indicates that unique row objects should be used (default).
 * - True indicates that a single temporary row object should be created and used without extra allocations.
 * - A DataRow object indicates that the row should be used as a temporary shared row.
 * When used, the content of the shared row isn't preserved between calls.
 */
/**
 * Return type for createSharedRow:
 * - DataRow object that should be used as shared row.
 * - Falsy values indicate that shared row object shouldn't be used.
 */
var DataRow = exports.DataRow = /*#__PURE__*/function () {
  /**
   * Creates new DataRow.
   * @param dataContainer Data container where data is stored. Can be initialized with null for shared rows.
   * @param rowIndex Index of a row in the data container.
   */
  function DataRow(dataContainer, rowIndex) {
    (0, _classCallCheck2["default"])(this, DataRow);
    (0, _defineProperty2["default"])(this, "_dataContainer", void 0);
    (0, _defineProperty2["default"])(this, "_rowIndex", void 0);
    this._dataContainer = dataContainer;
    this._rowIndex = rowIndex;
  }

  /**
   * Conditionally creates a DataRow object.
   * @param sharedRowDesc Accepts forllowing options:
   * - true indicates that new DataRow should be created.
   * - falsy value or a DataRow object is passed through without any change.
   * @returns A new DataRow object or unchanged input argument.
   */
  return (0, _createClass2["default"])(DataRow, [{
    key: "valueAt",
    value:
    /**
     * Returns the value stored at the specified index in the row.
     * @param columnIndex Index of the requested field in the row.
     * @returns Value at the index.
     */
    function valueAt(columnIndex) {
      var _this$_dataContainer;
      return (_this$_dataContainer = this._dataContainer) === null || _this$_dataContainer === void 0 ? void 0 : _this$_dataContainer.valueAt(this._rowIndex, columnIndex);
    }

    /**
     * Returns the row represented as an array.
     * @returns The row represented as an array.
     */
  }, {
    key: "values",
    value: function values() {
      return this._dataContainer ? this._dataContainer.rowAsArray(this._rowIndex) : [];
    }

    /**
     * Setup a row object. The method is used by shared rows to prevent excessive allocations.
     * @param dataContainer Data container.
     * @param rowIndex Index of a row in the data container.
     */
  }, {
    key: "setSource",
    value: function setSource(dataContainer, rowIndex) {
      this._dataContainer = dataContainer;
      this._rowIndex = rowIndex;
    }

    /**
     * Creates a new array populated with the results of calling the provided function
     * on every element of the row.
     * @param handler The callback is called with the following arguments:
     * - elem: The current element being processed in the row.
     * - index: The index of the current element being processed in the row.
     * @returns A new array with each element being the result of the func callback.
     */
  }, {
    key: "map",
    value: function map(handler) {
      var _this$_dataContainer2;
      var numColumns = ((_this$_dataContainer2 = this._dataContainer) === null || _this$_dataContainer2 === void 0 ? void 0 : _this$_dataContainer2.numColumns()) || 0;
      var out = [];
      for (var column = 0; column < numColumns; ++column) {
        out[column] = handler(this.valueAt(column), column);
      }
      return out;
    }
  }], [{
    key: "createSharedRow",
    value: function createSharedRow(sharedRowDesc) {
      if (sharedRowDesc === true) {
        return new DataRow(null, 0);
      }
      return sharedRowDesc;
    }
  }]);
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEYXRhUm93IiwiZXhwb3J0cyIsImRhdGFDb250YWluZXIiLCJyb3dJbmRleCIsIl9jbGFzc0NhbGxDaGVjazIiLCJfZGVmaW5lUHJvcGVydHkyIiwiX2RhdGFDb250YWluZXIiLCJfcm93SW5kZXgiLCJfY3JlYXRlQ2xhc3MyIiwia2V5IiwidmFsdWUiLCJ2YWx1ZUF0IiwiY29sdW1uSW5kZXgiLCJfdGhpcyRfZGF0YUNvbnRhaW5lciIsInZhbHVlcyIsInJvd0FzQXJyYXkiLCJzZXRTb3VyY2UiLCJtYXAiLCJoYW5kbGVyIiwiX3RoaXMkX2RhdGFDb250YWluZXIyIiwibnVtQ29sdW1ucyIsIm91dCIsImNvbHVtbiIsImNyZWF0ZVNoYXJlZFJvdyIsInNoYXJlZFJvd0Rlc2MiXSwic291cmNlcyI6WyIuLi9zcmMvZGF0YS1yb3cudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtEYXRhQ29udGFpbmVySW50ZXJmYWNlfSBmcm9tICcuL2RhdGEtY29udGFpbmVyLWludGVyZmFjZSc7XG5cbi8qKlxuICogU2V0dGluZyBmb3Igc2hhcmVkIHJvdyBvcHRpbWl6YXRpb24uXG4gKiAtIEZhbHNlL3VuZGVmaW5lZCBpbmRpY2F0ZXMgdGhhdCB1bmlxdWUgcm93IG9iamVjdHMgc2hvdWxkIGJlIHVzZWQgKGRlZmF1bHQpLlxuICogLSBUcnVlIGluZGljYXRlcyB0aGF0IGEgc2luZ2xlIHRlbXBvcmFyeSByb3cgb2JqZWN0IHNob3VsZCBiZSBjcmVhdGVkIGFuZCB1c2VkIHdpdGhvdXQgZXh0cmEgYWxsb2NhdGlvbnMuXG4gKiAtIEEgRGF0YVJvdyBvYmplY3QgaW5kaWNhdGVzIHRoYXQgdGhlIHJvdyBzaG91bGQgYmUgdXNlZCBhcyBhIHRlbXBvcmFyeSBzaGFyZWQgcm93LlxuICogV2hlbiB1c2VkLCB0aGUgY29udGVudCBvZiB0aGUgc2hhcmVkIHJvdyBpc24ndCBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscy5cbiAqL1xuZXhwb3J0IHR5cGUgU2hhcmVkUm93T3B0aW9ucyA9IERhdGFSb3cgfCBib29sZWFuIHwgdW5kZWZpbmVkO1xuLyoqXG4gKiBSZXR1cm4gdHlwZSBmb3IgY3JlYXRlU2hhcmVkUm93OlxuICogLSBEYXRhUm93IG9iamVjdCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHNoYXJlZCByb3cuXG4gKiAtIEZhbHN5IHZhbHVlcyBpbmRpY2F0ZSB0aGF0IHNoYXJlZCByb3cgb2JqZWN0IHNob3VsZG4ndCBiZSB1c2VkLlxuICovXG5leHBvcnQgdHlwZSBTaGFyZWRSb3dPcHRpb25zUmVzdWx0ID0gRGF0YVJvdyB8IGZhbHNlIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY2xhc3MgRGF0YVJvdyB7XG4gIF9kYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlIHwgbnVsbDtcblxuICBfcm93SW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBuZXcgRGF0YVJvdy5cbiAgICogQHBhcmFtIGRhdGFDb250YWluZXIgRGF0YSBjb250YWluZXIgd2hlcmUgZGF0YSBpcyBzdG9yZWQuIENhbiBiZSBpbml0aWFsaXplZCB3aXRoIG51bGwgZm9yIHNoYXJlZCByb3dzLlxuICAgKiBAcGFyYW0gcm93SW5kZXggSW5kZXggb2YgYSByb3cgaW4gdGhlIGRhdGEgY29udGFpbmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSB8IG51bGwsIHJvd0luZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcbiAgICB0aGlzLl9yb3dJbmRleCA9IHJvd0luZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgY3JlYXRlcyBhIERhdGFSb3cgb2JqZWN0LlxuICAgKiBAcGFyYW0gc2hhcmVkUm93RGVzYyBBY2NlcHRzIGZvcmxsb3dpbmcgb3B0aW9uczpcbiAgICogLSB0cnVlIGluZGljYXRlcyB0aGF0IG5ldyBEYXRhUm93IHNob3VsZCBiZSBjcmVhdGVkLlxuICAgKiAtIGZhbHN5IHZhbHVlIG9yIGEgRGF0YVJvdyBvYmplY3QgaXMgcGFzc2VkIHRocm91Z2ggd2l0aG91dCBhbnkgY2hhbmdlLlxuICAgKiBAcmV0dXJucyBBIG5ldyBEYXRhUm93IG9iamVjdCBvciB1bmNoYW5nZWQgaW5wdXQgYXJndW1lbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlU2hhcmVkUm93KHNoYXJlZFJvd0Rlc2M6IFNoYXJlZFJvd09wdGlvbnMpOiBTaGFyZWRSb3dPcHRpb25zUmVzdWx0IHtcbiAgICBpZiAoc2hhcmVkUm93RGVzYyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhUm93KG51bGwsIDApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkUm93RGVzYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBpbiB0aGUgcm93LlxuICAgKiBAcGFyYW0gY29sdW1uSW5kZXggSW5kZXggb2YgdGhlIHJlcXVlc3RlZCBmaWVsZCBpbiB0aGUgcm93LlxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aGUgaW5kZXguXG4gICAqL1xuICB2YWx1ZUF0KGNvbHVtbkluZGV4OiBudW1iZXIpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhQ29udGFpbmVyPy52YWx1ZUF0KHRoaXMuX3Jvd0luZGV4LCBjb2x1bW5JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93IHJlcHJlc2VudGVkIGFzIGFuIGFycmF5LlxuICAgKiBAcmV0dXJucyBUaGUgcm93IHJlcHJlc2VudGVkIGFzIGFuIGFycmF5LlxuICAgKi9cbiAgdmFsdWVzKCk6IGFueVtdIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvbnRhaW5lciA/IHRoaXMuX2RhdGFDb250YWluZXIucm93QXNBcnJheSh0aGlzLl9yb3dJbmRleCkgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhIHJvdyBvYmplY3QuIFRoZSBtZXRob2QgaXMgdXNlZCBieSBzaGFyZWQgcm93cyB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBhbGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIGRhdGFDb250YWluZXIgRGF0YSBjb250YWluZXIuXG4gICAqIEBwYXJhbSByb3dJbmRleCBJbmRleCBvZiBhIHJvdyBpbiB0aGUgZGF0YSBjb250YWluZXIuXG4gICAqL1xuICBzZXRTb3VyY2UoZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSwgcm93SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xuICAgIHRoaXMuX3Jvd0luZGV4ID0gcm93SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICAgKiBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSByb3cuXG4gICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAgICogLSBlbGVtOiBUaGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgcm93LlxuICAgKiAtIGluZGV4OiBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHJvdy5cbiAgICogQHJldHVybnMgQSBuZXcgYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgZnVuYyBjYWxsYmFjay5cbiAgICovXG4gIG1hcChoYW5kbGVyOiAoZWxlbTogYW55LCBpbmRleDogbnVtYmVyKSA9PiBhbnkpOiBhbnlbXSB7XG4gICAgY29uc3QgbnVtQ29sdW1ucyA9IHRoaXMuX2RhdGFDb250YWluZXI/Lm51bUNvbHVtbnMoKSB8fCAwO1xuICAgIGNvbnN0IG91dDogYW55W10gPSBbXTtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBudW1Db2x1bW5zOyArK2NvbHVtbikge1xuICAgICAgb3V0W2NvbHVtbl0gPSBoYW5kbGVyKHRoaXMudmFsdWVBdChjb2x1bW4pLCBjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFPYUEsT0FBTyxHQUFBQyxPQUFBLENBQUFELE9BQUE7RUFLbEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLFNBQUFBLFFBQVlFLGFBQTRDLEVBQUVDLFFBQWdCLEVBQUU7SUFBQSxJQUFBQyxnQkFBQSxtQkFBQUosT0FBQTtJQUFBLElBQUFLLGdCQUFBO0lBQUEsSUFBQUEsZ0JBQUE7SUFDMUUsSUFBSSxDQUFDQyxjQUFjLEdBQUdKLGFBQWE7SUFDbkMsSUFBSSxDQUFDSyxTQUFTLEdBQUdKLFFBQVE7RUFDM0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFORSxXQUFBSyxhQUFBLGFBQUFSLE9BQUE7SUFBQVMsR0FBQTtJQUFBQyxLQUFBO0lBY0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtJQUNFLFNBQUFDLE9BQU9BLENBQUNDLFdBQW1CLEVBQU87TUFBQSxJQUFBQyxvQkFBQTtNQUNoQyxRQUFBQSxvQkFBQSxHQUFPLElBQUksQ0FBQ1AsY0FBYyxjQUFBTyxvQkFBQSx1QkFBbkJBLG9CQUFBLENBQXFCRixPQUFPLENBQUMsSUFBSSxDQUFDSixTQUFTLEVBQUVLLFdBQVcsQ0FBQztJQUNsRTs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUhFO0lBQUFILEdBQUE7SUFBQUMsS0FBQSxFQUlBLFNBQUFJLE1BQU1BLENBQUEsRUFBVTtNQUNkLE9BQU8sSUFBSSxDQUFDUixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjLENBQUNTLFVBQVUsQ0FBQyxJQUFJLENBQUNSLFNBQVMsQ0FBQyxHQUFHLEVBQUU7SUFDbEY7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUpFO0lBQUFFLEdBQUE7SUFBQUMsS0FBQSxFQUtBLFNBQUFNLFNBQVNBLENBQUNkLGFBQXFDLEVBQUVDLFFBQWdCLEVBQVE7TUFDdkUsSUFBSSxDQUFDRyxjQUFjLEdBQUdKLGFBQWE7TUFDbkMsSUFBSSxDQUFDSyxTQUFTLEdBQUdKLFFBQVE7SUFDM0I7O0lBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBFO0lBQUFNLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUFPLEdBQUdBLENBQUNDLE9BQTBDLEVBQVM7TUFBQSxJQUFBQyxxQkFBQTtNQUNyRCxJQUFNQyxVQUFVLEdBQUcsRUFBQUQscUJBQUEsT0FBSSxDQUFDYixjQUFjLGNBQUFhLHFCQUFBLHVCQUFuQkEscUJBQUEsQ0FBcUJDLFVBQVUsQ0FBQyxDQUFDLEtBQUksQ0FBQztNQUN6RCxJQUFNQyxHQUFVLEdBQUcsRUFBRTtNQUNyQixLQUFLLElBQUlDLE1BQU0sR0FBRyxDQUFDLEVBQUVBLE1BQU0sR0FBR0YsVUFBVSxFQUFFLEVBQUVFLE1BQU0sRUFBRTtRQUNsREQsR0FBRyxDQUFDQyxNQUFNLENBQUMsR0FBR0osT0FBTyxDQUFDLElBQUksQ0FBQ1AsT0FBTyxDQUFDVyxNQUFNLENBQUMsRUFBRUEsTUFBTSxDQUFDO01BQ3JEO01BQ0EsT0FBT0QsR0FBRztJQUNaO0VBQUM7SUFBQVosR0FBQTtJQUFBQyxLQUFBLEVBakRELFNBQU9hLGVBQWVBLENBQUNDLGFBQStCLEVBQTBCO01BQzlFLElBQUlBLGFBQWEsS0FBSyxJQUFJLEVBQUU7UUFDMUIsT0FBTyxJQUFJeEIsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7TUFDN0I7TUFDQSxPQUFPd0IsYUFBYTtJQUN0QjtFQUFDO0FBQUEiLCJpZ25vcmVMaXN0IjpbXX0=