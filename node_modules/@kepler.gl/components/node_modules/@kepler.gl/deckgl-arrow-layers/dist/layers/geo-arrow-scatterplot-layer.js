"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoArrowScatterplotLayer = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _typed = require("@deck.gl/core/typed");
var _typed2 = require("@deck.gl/layers/typed");
var ga = _interopRequireWildcard(require("@geoarrow/geoarrow-js"));
var _constants = require("@kepler.gl/constants");
var _utils = require("../utils/utils");
var _picking = require("../utils/picking");
var _validate = require("../utils/validate");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// deck.gl-community
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/** All properties supported by GeoArrowScatterplotLayer */

/** Properties added by GeoArrowScatterplotLayer */

// Remove data and getPosition from the upstream default props
var _ScatterplotLayer$def = _typed2.ScatterplotLayer.defaultProps,
  _data = _ScatterplotLayer$def.data,
  _getPosition = _ScatterplotLayer$def.getPosition,
  _upstreamDefaultProps = (0, _objectWithoutProperties2["default"])(_ScatterplotLayer$def, ["data", "getPosition"]);

// Default props added by us
var ourDefaultProps = {
  _validate: true
};

// @ts-expect-error
var defaultProps = _objectSpread(_objectSpread({}, _upstreamDefaultProps), ourDefaultProps);
var GeoArrowScatterplotLayer = exports.GeoArrowScatterplotLayer = /*#__PURE__*/function (_CompositeLayer) {
  function GeoArrowScatterplotLayer() {
    (0, _classCallCheck2["default"])(this, GeoArrowScatterplotLayer);
    return _callSuper(this, GeoArrowScatterplotLayer, arguments);
  }
  (0, _inherits2["default"])(GeoArrowScatterplotLayer, _CompositeLayer);
  return (0, _createClass2["default"])(GeoArrowScatterplotLayer, [{
    key: "getPickingInfo",
    value: function getPickingInfo(params) {
      return (0, _picking.getPickingInfo)(params, this.props.data);
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var table = this.props.data;
      if (this.props.getPosition !== undefined) {
        var geometryColumn = this.props.getPosition;
        if (geometryColumn !== undefined && ga.vector.isPointVector(geometryColumn)) {
          return this._renderLayersPoint(geometryColumn);
        }
        if (geometryColumn !== undefined && ga.vector.isMultiPointVector(geometryColumn)) {
          return this._renderLayersMultiPoint(geometryColumn);
        }
        throw new Error('getPosition should pass in an arrow Vector of Point or MultiPoint type');
      } else {
        var pointVector = (0, _utils.getGeometryVector)(table, _constants.GEOARROW_EXTENSIONS.POINT);
        if (pointVector !== null) {
          return this._renderLayersPoint(pointVector);
        }
        var multiPointVector = (0, _utils.getGeometryVector)(table, _constants.GEOARROW_EXTENSIONS.MULTIPOINT);
        if (multiPointVector !== null) {
          return this._renderLayersMultiPoint(multiPointVector);
        }
      }
      throw new Error('getPosition not GeoArrow point or multipoint');
    }
  }, {
    key: "_renderLayersPoint",
    value: function _renderLayersPoint(geometryColumn) {
      var table = this.props.data;
      if (this.props._validate) {
        (0, _typed.assert)(ga.vector.isPointVector(geometryColumn));
        (0, _validate.validateAccessors)(this.props, table);
      }

      // Exclude manually-set accessors
      var _extractAccessorsFrom = (0, _utils.extractAccessorsFromProps)(this.props, ['getPosition']),
        _extractAccessorsFrom2 = (0, _slicedToArray2["default"])(_extractAccessorsFrom, 2),
        accessors = _extractAccessorsFrom2[0],
        otherProps = _extractAccessorsFrom2[1];
      var tableOffsets = (0, _picking.computeChunkOffsets)(table.data);
      var layers = [];
      for (var recordBatchIdx = 0; recordBatchIdx < table.batches.length; recordBatchIdx++) {
        var geometryData = geometryColumn.data[recordBatchIdx];
        var flatCoordsData = ga.child.getPointChild(geometryData);
        var flatCoordinateArray = flatCoordsData.values;

        // @ts-expect-error how to properly retrieve batch offset?
        var batchOffset = geometryColumn._offsets[recordBatchIdx];
        var props = _objectSpread(_objectSpread(_objectSpread({}, ourDefaultProps), otherProps), {}, {
          // used for picking purposes
          recordBatchIdx: recordBatchIdx,
          tableOffsets: tableOffsets,
          id: "".concat(this.props.id, "-geoarrow-scatterplot-").concat(recordBatchIdx),
          data: {
            // @ts-expect-error
            data: table.batches[recordBatchIdx],
            length: geometryData.length,
            attributes: {
              getPosition: {
                value: flatCoordinateArray,
                size: geometryData.type.listSize
              }
            }
          }
        });
        for (var _i = 0, _Object$entries = Object.entries(accessors); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2),
            propName = _Object$entries$_i[0],
            propInput = _Object$entries$_i[1];
          (0, _utils.assignAccessor)({
            props: props,
            propName: propName,
            propInput: propInput,
            chunkIdx: recordBatchIdx,
            batchOffset: batchOffset
          });
        }
        var layer = new _typed2.ScatterplotLayer(_objectSpread(_objectSpread({}, this.getSubLayerProps(props)), {}, {
          // preserve binded accessors, as they are overwriten back by pass-through accessors from extensions
          getFiltered: props.getFiltered,
          getFilterValue: props.getFilterValue
        }));
        layers.push(layer);
      }
      return layers;
    }
  }, {
    key: "_renderLayersMultiPoint",
    value: function _renderLayersMultiPoint(geometryColumn) {
      var table = this.props.data;

      // TODO: validate that if nested, accessor props have the same nesting
      // structure as the main geometry column.
      if (this.props._validate) {
        (0, _typed.assert)(ga.vector.isMultiPointVector(geometryColumn));
        (0, _validate.validateAccessors)(this.props, table);
      }

      // Exclude manually-set accessors
      var _extractAccessorsFrom3 = (0, _utils.extractAccessorsFromProps)(this.props, ['getPosition']),
        _extractAccessorsFrom4 = (0, _slicedToArray2["default"])(_extractAccessorsFrom3, 2),
        accessors = _extractAccessorsFrom4[0],
        otherProps = _extractAccessorsFrom4[1];
      var tableOffsets = (0, _picking.computeChunkOffsets)(table.data);
      var layers = [];
      for (var recordBatchIdx = 0; recordBatchIdx < table.batches.length; recordBatchIdx++) {
        var multiPointData = geometryColumn.data[recordBatchIdx];
        var pointData = ga.child.getMultiPointChild(multiPointData);
        var geomOffsets = multiPointData.valueOffsets;
        var flatCoordsData = ga.child.getPointChild(pointData);
        var flatCoordinateArray = flatCoordsData.values;

        // @ts-expect-error how to properly retrieve batch offset?
        var batchOffset = geometryColumn._offsets[recordBatchIdx];
        var props = _objectSpread(_objectSpread(_objectSpread({}, ourDefaultProps), otherProps), {}, {
          // used for picking purposes
          recordBatchIdx: recordBatchIdx,
          tableOffsets: tableOffsets,
          id: "".concat(this.props.id, "-geoarrow-scatterplot-").concat(recordBatchIdx),
          data: {
            // @ts-expect-error
            data: table.batches[recordBatchIdx],
            // Map from expanded multi-geometry index to original index
            // Used both in picking and for function callbacks
            invertedGeomOffsets: (0, _utils.invertOffsets)(geomOffsets),
            // Note: this needs to be the length one level down.
            length: pointData.length,
            attributes: {
              getPosition: {
                value: flatCoordinateArray,
                size: pointData.type.listSize
              }
            }
          }
        });
        for (var _i2 = 0, _Object$entries2 = Object.entries(accessors); _i2 < _Object$entries2.length; _i2++) {
          var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i2], 2),
            propName = _Object$entries2$_i[0],
            propInput = _Object$entries2$_i[1];
          (0, _utils.assignAccessor)({
            props: props,
            propName: propName,
            propInput: propInput,
            chunkIdx: recordBatchIdx,
            geomCoordOffsets: geomOffsets,
            batchOffset: batchOffset
          });
        }
        var layer = new _typed2.ScatterplotLayer(_objectSpread(_objectSpread({}, this.getSubLayerProps(props)), {}, {
          // preserve binded accessors, as they are overwriten back by pass-through accessors from extensions
          getFiltered: props.getFiltered,
          getFilterValue: props.getFilterValue
        }));
        layers.push(layer);
      }
      return layers;
    }
  }]);
}(_typed.CompositeLayer);
(0, _defineProperty2["default"])(GeoArrowScatterplotLayer, "defaultProps", defaultProps);
(0, _defineProperty2["default"])(GeoArrowScatterplotLayer, "layerName", 'GeoArrowScatterplotLayer');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdHlwZWQiLCJyZXF1aXJlIiwiX3R5cGVkMiIsImdhIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfY29uc3RhbnRzIiwiX3V0aWxzIiwiX3BpY2tpbmciLCJfdmFsaWRhdGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfY2FsbFN1cGVyIiwibyIsIl9nZXRQcm90b3R5cGVPZjIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImNvbnN0cnVjdG9yIiwiYXBwbHkiLCJCb29sZWFuIiwicHJvdG90eXBlIiwidmFsdWVPZiIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9TY2F0dGVycGxvdExheWVyJGRlZiIsIlNjYXR0ZXJwbG90TGF5ZXIiLCJkZWZhdWx0UHJvcHMiLCJfZGF0YSIsImRhdGEiLCJfZ2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsIl91cHN0cmVhbURlZmF1bHRQcm9wcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllczIiLCJvdXJEZWZhdWx0UHJvcHMiLCJHZW9BcnJvd1NjYXR0ZXJwbG90TGF5ZXIiLCJleHBvcnRzIiwiX0NvbXBvc2l0ZUxheWVyIiwiX2NsYXNzQ2FsbENoZWNrMiIsIl9pbmhlcml0czIiLCJfY3JlYXRlQ2xhc3MyIiwia2V5IiwidmFsdWUiLCJnZXRQaWNraW5nSW5mbyIsInBhcmFtcyIsInByb3BzIiwicmVuZGVyTGF5ZXJzIiwidGFibGUiLCJ1bmRlZmluZWQiLCJnZW9tZXRyeUNvbHVtbiIsInZlY3RvciIsImlzUG9pbnRWZWN0b3IiLCJfcmVuZGVyTGF5ZXJzUG9pbnQiLCJpc011bHRpUG9pbnRWZWN0b3IiLCJfcmVuZGVyTGF5ZXJzTXVsdGlQb2ludCIsIkVycm9yIiwicG9pbnRWZWN0b3IiLCJnZXRHZW9tZXRyeVZlY3RvciIsIkdFT0FSUk9XX0VYVEVOU0lPTlMiLCJQT0lOVCIsIm11bHRpUG9pbnRWZWN0b3IiLCJNVUxUSVBPSU5UIiwiYXNzZXJ0IiwidmFsaWRhdGVBY2Nlc3NvcnMiLCJfZXh0cmFjdEFjY2Vzc29yc0Zyb20iLCJleHRyYWN0QWNjZXNzb3JzRnJvbVByb3BzIiwiX2V4dHJhY3RBY2Nlc3NvcnNGcm9tMiIsIl9zbGljZWRUb0FycmF5MiIsImFjY2Vzc29ycyIsIm90aGVyUHJvcHMiLCJ0YWJsZU9mZnNldHMiLCJjb21wdXRlQ2h1bmtPZmZzZXRzIiwibGF5ZXJzIiwicmVjb3JkQmF0Y2hJZHgiLCJiYXRjaGVzIiwiZ2VvbWV0cnlEYXRhIiwiZmxhdENvb3Jkc0RhdGEiLCJjaGlsZCIsImdldFBvaW50Q2hpbGQiLCJmbGF0Q29vcmRpbmF0ZUFycmF5IiwidmFsdWVzIiwiYmF0Y2hPZmZzZXQiLCJfb2Zmc2V0cyIsImlkIiwiY29uY2F0IiwiYXR0cmlidXRlcyIsInNpemUiLCJ0eXBlIiwibGlzdFNpemUiLCJfaSIsIl9PYmplY3QkZW50cmllcyIsImVudHJpZXMiLCJfT2JqZWN0JGVudHJpZXMkX2kiLCJwcm9wTmFtZSIsInByb3BJbnB1dCIsImFzc2lnbkFjY2Vzc29yIiwiY2h1bmtJZHgiLCJsYXllciIsImdldFN1YkxheWVyUHJvcHMiLCJnZXRGaWx0ZXJlZCIsImdldEZpbHRlclZhbHVlIiwiX2V4dHJhY3RBY2Nlc3NvcnNGcm9tMyIsIl9leHRyYWN0QWNjZXNzb3JzRnJvbTQiLCJtdWx0aVBvaW50RGF0YSIsInBvaW50RGF0YSIsImdldE11bHRpUG9pbnRDaGlsZCIsImdlb21PZmZzZXRzIiwidmFsdWVPZmZzZXRzIiwiaW52ZXJ0ZWRHZW9tT2Zmc2V0cyIsImludmVydE9mZnNldHMiLCJfaTIiLCJfT2JqZWN0JGVudHJpZXMyIiwiX09iamVjdCRlbnRyaWVzMiRfaSIsImdlb21Db29yZE9mZnNldHMiLCJDb21wb3NpdGVMYXllciJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvZ2VvLWFycm93LXNjYXR0ZXJwbG90LWxheWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbi8vIGRlY2suZ2wtY29tbXVuaXR5XG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgKGMpIHZpcy5nbCBjb250cmlidXRvcnNcblxuaW1wb3J0IHtcbiAgQ29tcG9zaXRlTGF5ZXIsXG4gIENvbXBvc2l0ZUxheWVyUHJvcHMsXG4gIERlZmF1bHRQcm9wcyxcbiAgR2V0UGlja2luZ0luZm9QYXJhbXMsXG4gIExheWVyLFxuICBMYXllcnNMaXN0LFxuICBhc3NlcnRcbn0gZnJvbSAnQGRlY2suZ2wvY29yZS90eXBlZCc7XG5pbXBvcnQge1NjYXR0ZXJwbG90TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycy90eXBlZCc7XG5pbXBvcnQgdHlwZSB7U2NhdHRlcnBsb3RMYXllclByb3BzfSBmcm9tICdAZGVjay5nbC9sYXllcnMvdHlwZWQnO1xuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcbmltcG9ydCAqIGFzIGdhIGZyb20gJ0BnZW9hcnJvdy9nZW9hcnJvdy1qcyc7XG5cbmltcG9ydCB7R0VPQVJST1dfRVhURU5TSU9OU30gZnJvbSAnQGtlcGxlci5nbC9jb25zdGFudHMnO1xuXG5pbXBvcnQge1xuICBhc3NpZ25BY2Nlc3NvcixcbiAgZXh0cmFjdEFjY2Vzc29yc0Zyb21Qcm9wcyxcbiAgZ2V0R2VvbWV0cnlWZWN0b3IsXG4gIGludmVydE9mZnNldHNcbn0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHtHZW9BcnJvd0V4dHJhUGlja2luZ1Byb3BzLCBjb21wdXRlQ2h1bmtPZmZzZXRzLCBnZXRQaWNraW5nSW5mb30gZnJvbSAnLi4vdXRpbHMvcGlja2luZyc7XG5pbXBvcnQge0NvbG9yQWNjZXNzb3IsIEZsb2F0QWNjZXNzb3IsIEdlb0Fycm93UGlja2luZ0luZm8sIEV4dGVuc2lvblByb3BzfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge3ZhbGlkYXRlQWNjZXNzb3JzfSBmcm9tICcuLi91dGlscy92YWxpZGF0ZSc7XG5cbi8qKiBBbGwgcHJvcGVydGllcyBzdXBwb3J0ZWQgYnkgR2VvQXJyb3dTY2F0dGVycGxvdExheWVyICovXG5leHBvcnQgdHlwZSBHZW9BcnJvd1NjYXR0ZXJwbG90TGF5ZXJQcm9wcyA9IE9taXQ8XG4gIFNjYXR0ZXJwbG90TGF5ZXJQcm9wczxhcnJvdy5UYWJsZT4sXG4gICdkYXRhJyB8ICdnZXRQb3NpdGlvbicgfCAnZ2V0UmFkaXVzJyB8ICdnZXRGaWxsQ29sb3InIHwgJ2dldExpbmVDb2xvcidcbj4gJlxuICBfR2VvQXJyb3dTY2F0dGVycGxvdExheWVyUHJvcHMgJlxuICBDb21wb3NpdGVMYXllclByb3BzO1xuXG4vKiogUHJvcGVydGllcyBhZGRlZCBieSBHZW9BcnJvd1NjYXR0ZXJwbG90TGF5ZXIgKi9cbnR5cGUgX0dlb0Fycm93U2NhdHRlcnBsb3RMYXllclByb3BzID0ge1xuICBkYXRhOiBhcnJvdy5UYWJsZTtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB2YWxpZGF0ZSB0aGUgYXJyYXlzIHByb3ZpZGVkIChlLmcuIGNodW5rIGxlbmd0aHMpXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIF92YWxpZGF0ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBDZW50ZXIgcG9zaXRpb24gYWNjZXNzb3IuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgd2lsbCBiZSBpbmZlcnJlZCBieSBmaW5kaW5nIGEgY29sdW1uIHdpdGggZXh0ZW5zaW9uIHR5cGVcbiAgICogYFwiZ2VvYXJyb3cucG9pbnRcImAgb3IgYFwiZ2VvYXJyb3cubXVsdGlwb2ludFwiYC5cbiAgICovXG4gIGdldFBvc2l0aW9uPzogZ2EudmVjdG9yLlBvaW50VmVjdG9yIHwgZ2EudmVjdG9yLk11bHRpUG9pbnRWZWN0b3I7XG4gIC8qKlxuICAgKiBSYWRpdXMgYWNjZXNzb3IuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldFJhZGl1cz86IEZsb2F0QWNjZXNzb3I7XG4gIC8qKlxuICAgKiBGaWxsIGNvbG9yIGFjY2Vzc29yLlxuICAgKiBAZGVmYXVsdCBbMCwgMCwgMCwgMjU1XVxuICAgKi9cbiAgZ2V0RmlsbENvbG9yPzogQ29sb3JBY2Nlc3NvcjtcbiAgLyoqXG4gICAqIFN0cm9rZSBjb2xvciBhY2Nlc3Nvci5cbiAgICogQGRlZmF1bHQgWzAsIDAsIDAsIDI1NV1cbiAgICovXG4gIGdldExpbmVDb2xvcj86IENvbG9yQWNjZXNzb3I7XG4gIC8qKlxuICAgKiBTdHJva2Ugd2lkdGggYWNjZXNzb3IuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldExpbmVXaWR0aD86IEZsb2F0QWNjZXNzb3I7XG59O1xuXG4vLyBSZW1vdmUgZGF0YSBhbmQgZ2V0UG9zaXRpb24gZnJvbSB0aGUgdXBzdHJlYW0gZGVmYXVsdCBwcm9wc1xuY29uc3Qge1xuICBkYXRhOiBfZGF0YSxcbiAgZ2V0UG9zaXRpb246IF9nZXRQb3NpdGlvbixcbiAgLi4uX3Vwc3RyZWFtRGVmYXVsdFByb3BzXG59ID0gU2NhdHRlcnBsb3RMYXllci5kZWZhdWx0UHJvcHM7XG5cbi8vIERlZmF1bHQgcHJvcHMgYWRkZWQgYnkgdXNcbmNvbnN0IG91ckRlZmF1bHRQcm9wcyA9IHtcbiAgX3ZhbGlkYXRlOiB0cnVlXG59O1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBkZWZhdWx0UHJvcHM6IERlZmF1bHRQcm9wczxHZW9BcnJvd1NjYXR0ZXJwbG90TGF5ZXJQcm9wcz4gPSB7XG4gIC4uLl91cHN0cmVhbURlZmF1bHRQcm9wcyxcbiAgLi4ub3VyRGVmYXVsdFByb3BzXG59O1xuXG5leHBvcnQgY2xhc3MgR2VvQXJyb3dTY2F0dGVycGxvdExheWVyPEV4dHJhUHJvcHMgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3Q+IGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXI8XG4gIEdlb0Fycm93U2NhdHRlcnBsb3RMYXllclByb3BzICYgRXh0cmFQcm9wc1xuPiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gIHN0YXRpYyBsYXllck5hbWUgPSAnR2VvQXJyb3dTY2F0dGVycGxvdExheWVyJztcblxuICBnZXRQaWNraW5nSW5mbyhcbiAgICBwYXJhbXM6IEdldFBpY2tpbmdJbmZvUGFyYW1zICYge1xuICAgICAgc291cmNlTGF5ZXI6IHtwcm9wczogR2VvQXJyb3dFeHRyYVBpY2tpbmdQcm9wc307XG4gICAgfVxuICApOiBHZW9BcnJvd1BpY2tpbmdJbmZvIHtcbiAgICByZXR1cm4gZ2V0UGlja2luZ0luZm8ocGFyYW1zLCB0aGlzLnByb3BzLmRhdGEpO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCk6IExheWVyPG9iamVjdD4gfCBMYXllcnNMaXN0IHwgbnVsbCB7XG4gICAgY29uc3Qge2RhdGE6IHRhYmxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5nZXRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeUNvbHVtbiA9IHRoaXMucHJvcHMuZ2V0UG9zaXRpb247XG4gICAgICBpZiAoZ2VvbWV0cnlDb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBnYS52ZWN0b3IuaXNQb2ludFZlY3RvcihnZW9tZXRyeUNvbHVtbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckxheWVyc1BvaW50KGdlb21ldHJ5Q29sdW1uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdlb21ldHJ5Q29sdW1uICE9PSB1bmRlZmluZWQgJiYgZ2EudmVjdG9yLmlzTXVsdGlQb2ludFZlY3RvcihnZW9tZXRyeUNvbHVtbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckxheWVyc011bHRpUG9pbnQoZ2VvbWV0cnlDb2x1bW4pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFBvc2l0aW9uIHNob3VsZCBwYXNzIGluIGFuIGFycm93IFZlY3RvciBvZiBQb2ludCBvciBNdWx0aVBvaW50IHR5cGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9pbnRWZWN0b3IgPSBnZXRHZW9tZXRyeVZlY3Rvcih0YWJsZSwgR0VPQVJST1dfRVhURU5TSU9OUy5QT0lOVCk7XG4gICAgICBpZiAocG9pbnRWZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckxheWVyc1BvaW50KHBvaW50VmVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbXVsdGlQb2ludFZlY3RvciA9IGdldEdlb21ldHJ5VmVjdG9yKHRhYmxlLCBHRU9BUlJPV19FWFRFTlNJT05TLk1VTFRJUE9JTlQpO1xuICAgICAgaWYgKG11bHRpUG9pbnRWZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckxheWVyc011bHRpUG9pbnQobXVsdGlQb2ludFZlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRQb3NpdGlvbiBub3QgR2VvQXJyb3cgcG9pbnQgb3IgbXVsdGlwb2ludCcpO1xuICB9XG5cbiAgX3JlbmRlckxheWVyc1BvaW50KGdlb21ldHJ5Q29sdW1uOiBnYS52ZWN0b3IuUG9pbnRWZWN0b3IpOiBMYXllcjxvYmplY3Q+IHwgTGF5ZXJzTGlzdCB8IG51bGwge1xuICAgIGNvbnN0IHtkYXRhOiB0YWJsZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuX3ZhbGlkYXRlKSB7XG4gICAgICBhc3NlcnQoZ2EudmVjdG9yLmlzUG9pbnRWZWN0b3IoZ2VvbWV0cnlDb2x1bW4pKTtcbiAgICAgIHZhbGlkYXRlQWNjZXNzb3JzKHRoaXMucHJvcHMsIHRhYmxlKTtcbiAgICB9XG5cbiAgICAvLyBFeGNsdWRlIG1hbnVhbGx5LXNldCBhY2Nlc3NvcnNcbiAgICBjb25zdCBbYWNjZXNzb3JzLCBvdGhlclByb3BzXSA9IGV4dHJhY3RBY2Nlc3NvcnNGcm9tUHJvcHModGhpcy5wcm9wcywgWydnZXRQb3NpdGlvbiddKTtcbiAgICBjb25zdCB0YWJsZU9mZnNldHMgPSBjb21wdXRlQ2h1bmtPZmZzZXRzKHRhYmxlLmRhdGEpO1xuXG4gICAgY29uc3QgbGF5ZXJzOiBTY2F0dGVycGxvdExheWVyPGFueT5bXSA9IFtdO1xuICAgIGZvciAobGV0IHJlY29yZEJhdGNoSWR4ID0gMDsgcmVjb3JkQmF0Y2hJZHggPCB0YWJsZS5iYXRjaGVzLmxlbmd0aDsgcmVjb3JkQmF0Y2hJZHgrKykge1xuICAgICAgY29uc3QgZ2VvbWV0cnlEYXRhID0gZ2VvbWV0cnlDb2x1bW4uZGF0YVtyZWNvcmRCYXRjaElkeF07XG4gICAgICBjb25zdCBmbGF0Q29vcmRzRGF0YSA9IGdhLmNoaWxkLmdldFBvaW50Q2hpbGQoZ2VvbWV0cnlEYXRhKTtcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlQXJyYXkgPSBmbGF0Q29vcmRzRGF0YS52YWx1ZXM7XG5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaG93IHRvIHByb3Blcmx5IHJldHJpZXZlIGJhdGNoIG9mZnNldD9cbiAgICAgIGNvbnN0IGJhdGNoT2Zmc2V0ID0gZ2VvbWV0cnlDb2x1bW4uX29mZnNldHNbcmVjb3JkQmF0Y2hJZHhdO1xuXG4gICAgICBjb25zdCBwcm9wczogU2NhdHRlcnBsb3RMYXllclByb3BzPGFueT4gJiBFeHRlbnNpb25Qcm9wcyA9IHtcbiAgICAgICAgLy8gTm90ZTogYmVjYXVzZSB0aGlzIGlzIGEgY29tcG9zaXRlIGxheWVyIGFuZCBub3QgZG9pbmcgdGhlIHJlbmRlcmluZ1xuICAgICAgICAvLyBpdHNlbGYsIHdlIHN0aWxsIGhhdmUgdG8gcGFzcyBpbiBvdXIgZGVmYXVsdFByb3BzXG4gICAgICAgIC4uLm91ckRlZmF1bHRQcm9wcyxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcblxuICAgICAgICAvLyB1c2VkIGZvciBwaWNraW5nIHB1cnBvc2VzXG4gICAgICAgIHJlY29yZEJhdGNoSWR4LFxuICAgICAgICB0YWJsZU9mZnNldHMsXG5cbiAgICAgICAgaWQ6IGAke3RoaXMucHJvcHMuaWR9LWdlb2Fycm93LXNjYXR0ZXJwbG90LSR7cmVjb3JkQmF0Y2hJZHh9YCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBkYXRhOiB0YWJsZS5iYXRjaGVzW3JlY29yZEJhdGNoSWR4XSxcbiAgICAgICAgICBsZW5ndGg6IGdlb21ldHJ5RGF0YS5sZW5ndGgsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgZ2V0UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgdmFsdWU6IGZsYXRDb29yZGluYXRlQXJyYXksXG4gICAgICAgICAgICAgIHNpemU6IGdlb21ldHJ5RGF0YS50eXBlLmxpc3RTaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IFtwcm9wTmFtZSwgcHJvcElucHV0XSBvZiBPYmplY3QuZW50cmllcyhhY2Nlc3NvcnMpKSB7XG4gICAgICAgIGFzc2lnbkFjY2Vzc29yKHtcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICBwcm9wSW5wdXQsXG4gICAgICAgICAgY2h1bmtJZHg6IHJlY29yZEJhdGNoSWR4LFxuICAgICAgICAgIGJhdGNoT2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXllciA9IG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgLi4udGhpcy5nZXRTdWJMYXllclByb3BzKHByb3BzKSxcbiAgICAgICAgLy8gcHJlc2VydmUgYmluZGVkIGFjY2Vzc29ycywgYXMgdGhleSBhcmUgb3ZlcndyaXRlbiBiYWNrIGJ5IHBhc3MtdGhyb3VnaCBhY2Nlc3NvcnMgZnJvbSBleHRlbnNpb25zXG4gICAgICAgIGdldEZpbHRlcmVkOiBwcm9wcy5nZXRGaWx0ZXJlZCxcbiAgICAgICAgZ2V0RmlsdGVyVmFsdWU6IHByb3BzLmdldEZpbHRlclZhbHVlXG4gICAgICB9KTtcbiAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgX3JlbmRlckxheWVyc011bHRpUG9pbnQoXG4gICAgZ2VvbWV0cnlDb2x1bW46IGdhLnZlY3Rvci5NdWx0aVBvaW50VmVjdG9yXG4gICk6IExheWVyPG9iamVjdD4gfCBMYXllcnNMaXN0IHwgbnVsbCB7XG4gICAgY29uc3Qge2RhdGE6IHRhYmxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSB0aGF0IGlmIG5lc3RlZCwgYWNjZXNzb3IgcHJvcHMgaGF2ZSB0aGUgc2FtZSBuZXN0aW5nXG4gICAgLy8gc3RydWN0dXJlIGFzIHRoZSBtYWluIGdlb21ldHJ5IGNvbHVtbi5cbiAgICBpZiAodGhpcy5wcm9wcy5fdmFsaWRhdGUpIHtcbiAgICAgIGFzc2VydChnYS52ZWN0b3IuaXNNdWx0aVBvaW50VmVjdG9yKGdlb21ldHJ5Q29sdW1uKSk7XG4gICAgICB2YWxpZGF0ZUFjY2Vzc29ycyh0aGlzLnByb3BzLCB0YWJsZSk7XG4gICAgfVxuXG4gICAgLy8gRXhjbHVkZSBtYW51YWxseS1zZXQgYWNjZXNzb3JzXG4gICAgY29uc3QgW2FjY2Vzc29ycywgb3RoZXJQcm9wc10gPSBleHRyYWN0QWNjZXNzb3JzRnJvbVByb3BzKHRoaXMucHJvcHMsIFsnZ2V0UG9zaXRpb24nXSk7XG4gICAgY29uc3QgdGFibGVPZmZzZXRzID0gY29tcHV0ZUNodW5rT2Zmc2V0cyh0YWJsZS5kYXRhKTtcblxuICAgIGNvbnN0IGxheWVyczogU2NhdHRlcnBsb3RMYXllcltdID0gW107XG4gICAgZm9yIChsZXQgcmVjb3JkQmF0Y2hJZHggPSAwOyByZWNvcmRCYXRjaElkeCA8IHRhYmxlLmJhdGNoZXMubGVuZ3RoOyByZWNvcmRCYXRjaElkeCsrKSB7XG4gICAgICBjb25zdCBtdWx0aVBvaW50RGF0YSA9IGdlb21ldHJ5Q29sdW1uLmRhdGFbcmVjb3JkQmF0Y2hJZHhdO1xuICAgICAgY29uc3QgcG9pbnREYXRhID0gZ2EuY2hpbGQuZ2V0TXVsdGlQb2ludENoaWxkKG11bHRpUG9pbnREYXRhKTtcbiAgICAgIGNvbnN0IGdlb21PZmZzZXRzID0gbXVsdGlQb2ludERhdGEudmFsdWVPZmZzZXRzO1xuICAgICAgY29uc3QgZmxhdENvb3Jkc0RhdGEgPSBnYS5jaGlsZC5nZXRQb2ludENoaWxkKHBvaW50RGF0YSk7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZUFycmF5ID0gZmxhdENvb3Jkc0RhdGEudmFsdWVzO1xuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGhvdyB0byBwcm9wZXJseSByZXRyaWV2ZSBiYXRjaCBvZmZzZXQ/XG4gICAgICBjb25zdCBiYXRjaE9mZnNldCA9IGdlb21ldHJ5Q29sdW1uLl9vZmZzZXRzW3JlY29yZEJhdGNoSWR4XTtcblxuICAgICAgY29uc3QgcHJvcHM6IFNjYXR0ZXJwbG90TGF5ZXJQcm9wcyAmIEV4dGVuc2lvblByb3BzID0ge1xuICAgICAgICAvLyBOb3RlOiBiZWNhdXNlIHRoaXMgaXMgYSBjb21wb3NpdGUgbGF5ZXIgYW5kIG5vdCBkb2luZyB0aGUgcmVuZGVyaW5nXG4gICAgICAgIC8vIGl0c2VsZiwgd2Ugc3RpbGwgaGF2ZSB0byBwYXNzIGluIG91ciBkZWZhdWx0UHJvcHNcbiAgICAgICAgLi4ub3VyRGVmYXVsdFByb3BzLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuXG4gICAgICAgIC8vIHVzZWQgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgcmVjb3JkQmF0Y2hJZHgsXG4gICAgICAgIHRhYmxlT2Zmc2V0cyxcblxuICAgICAgICBpZDogYCR7dGhpcy5wcm9wcy5pZH0tZ2VvYXJyb3ctc2NhdHRlcnBsb3QtJHtyZWNvcmRCYXRjaElkeH1gLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGRhdGE6IHRhYmxlLmJhdGNoZXNbcmVjb3JkQmF0Y2hJZHhdLFxuICAgICAgICAgIC8vIE1hcCBmcm9tIGV4cGFuZGVkIG11bHRpLWdlb21ldHJ5IGluZGV4IHRvIG9yaWdpbmFsIGluZGV4XG4gICAgICAgICAgLy8gVXNlZCBib3RoIGluIHBpY2tpbmcgYW5kIGZvciBmdW5jdGlvbiBjYWxsYmFja3NcbiAgICAgICAgICBpbnZlcnRlZEdlb21PZmZzZXRzOiBpbnZlcnRPZmZzZXRzKGdlb21PZmZzZXRzKSxcbiAgICAgICAgICAvLyBOb3RlOiB0aGlzIG5lZWRzIHRvIGJlIHRoZSBsZW5ndGggb25lIGxldmVsIGRvd24uXG4gICAgICAgICAgbGVuZ3RoOiBwb2ludERhdGEubGVuZ3RoLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGdldFBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmbGF0Q29vcmRpbmF0ZUFycmF5LFxuICAgICAgICAgICAgICBzaXplOiBwb2ludERhdGEudHlwZS5saXN0U2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBbcHJvcE5hbWUsIHByb3BJbnB1dF0gb2YgT2JqZWN0LmVudHJpZXMoYWNjZXNzb3JzKSkge1xuICAgICAgICBhc3NpZ25BY2Nlc3Nvcih7XG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgcHJvcElucHV0LFxuICAgICAgICAgIGNodW5rSWR4OiByZWNvcmRCYXRjaElkeCxcbiAgICAgICAgICBnZW9tQ29vcmRPZmZzZXRzOiBnZW9tT2Zmc2V0cyxcbiAgICAgICAgICBiYXRjaE9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGF5ZXIgPSBuZXcgU2NhdHRlcnBsb3RMYXllcih7XG4gICAgICAgIC4uLnRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyhwcm9wcyksXG4gICAgICAgIC8vIHByZXNlcnZlIGJpbmRlZCBhY2Nlc3NvcnMsIGFzIHRoZXkgYXJlIG92ZXJ3cml0ZW4gYmFjayBieSBwYXNzLXRocm91Z2ggYWNjZXNzb3JzIGZyb20gZXh0ZW5zaW9uc1xuICAgICAgICBnZXRGaWx0ZXJlZDogcHJvcHMuZ2V0RmlsdGVyZWQsXG4gICAgICAgIGdldEZpbHRlclZhbHVlOiBwcm9wcy5nZXRGaWx0ZXJWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsYXllcnMucHVzaChsYXllcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBT0EsSUFBQUEsTUFBQSxHQUFBQyxPQUFBO0FBU0EsSUFBQUMsT0FBQSxHQUFBRCxPQUFBO0FBR0EsSUFBQUUsRUFBQSxHQUFBQyx1QkFBQSxDQUFBSCxPQUFBO0FBRUEsSUFBQUksVUFBQSxHQUFBSixPQUFBO0FBRUEsSUFBQUssTUFBQSxHQUFBTCxPQUFBO0FBTUEsSUFBQU0sUUFBQSxHQUFBTixPQUFBO0FBRUEsSUFBQU8sU0FBQSxHQUFBUCxPQUFBO0FBQW9ELFNBQUFRLHlCQUFBQyxDQUFBLDZCQUFBQyxPQUFBLG1CQUFBQyxDQUFBLE9BQUFELE9BQUEsSUFBQUUsQ0FBQSxPQUFBRixPQUFBLFlBQUFGLHdCQUFBLFlBQUFBLHlCQUFBQyxDQUFBLFdBQUFBLENBQUEsR0FBQUcsQ0FBQSxHQUFBRCxDQUFBLEtBQUFGLENBQUE7QUFBQSxTQUFBTix3QkFBQU0sQ0FBQSxFQUFBRSxDQUFBLFNBQUFBLENBQUEsSUFBQUYsQ0FBQSxJQUFBQSxDQUFBLENBQUFJLFVBQUEsU0FBQUosQ0FBQSxlQUFBQSxDQUFBLGdCQUFBSyxPQUFBLENBQUFMLENBQUEsMEJBQUFBLENBQUEsc0JBQUFBLENBQUEsUUFBQUcsQ0FBQSxHQUFBSix3QkFBQSxDQUFBRyxDQUFBLE9BQUFDLENBQUEsSUFBQUEsQ0FBQSxDQUFBRyxHQUFBLENBQUFOLENBQUEsVUFBQUcsQ0FBQSxDQUFBSSxHQUFBLENBQUFQLENBQUEsT0FBQVEsQ0FBQSxLQUFBQyxTQUFBLFVBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxjQUFBLElBQUFELE1BQUEsQ0FBQUUsd0JBQUEsV0FBQUMsQ0FBQSxJQUFBZCxDQUFBLG9CQUFBYyxDQUFBLE9BQUFDLGNBQUEsQ0FBQUMsSUFBQSxDQUFBaEIsQ0FBQSxFQUFBYyxDQUFBLFNBQUFHLENBQUEsR0FBQVAsQ0FBQSxHQUFBQyxNQUFBLENBQUFFLHdCQUFBLENBQUFiLENBQUEsRUFBQWMsQ0FBQSxVQUFBRyxDQUFBLEtBQUFBLENBQUEsQ0FBQVYsR0FBQSxJQUFBVSxDQUFBLENBQUFDLEdBQUEsSUFBQVAsTUFBQSxDQUFBQyxjQUFBLENBQUFKLENBQUEsRUFBQU0sQ0FBQSxFQUFBRyxDQUFBLElBQUFULENBQUEsQ0FBQU0sQ0FBQSxJQUFBZCxDQUFBLENBQUFjLENBQUEsWUFBQU4sQ0FBQSxjQUFBUixDQUFBLEVBQUFHLENBQUEsSUFBQUEsQ0FBQSxDQUFBZSxHQUFBLENBQUFsQixDQUFBLEVBQUFRLENBQUEsR0FBQUEsQ0FBQTtBQUFBLFNBQUFXLFdBQUFoQixDQUFBLEVBQUFpQixDQUFBLEVBQUFwQixDQUFBLFdBQUFvQixDQUFBLE9BQUFDLGdCQUFBLGFBQUFELENBQUEsT0FBQUUsMkJBQUEsYUFBQW5CLENBQUEsRUFBQW9CLHlCQUFBLEtBQUFDLE9BQUEsQ0FBQUMsU0FBQSxDQUFBTCxDQUFBLEVBQUFwQixDQUFBLFlBQUFxQixnQkFBQSxhQUFBbEIsQ0FBQSxFQUFBdUIsV0FBQSxJQUFBTixDQUFBLENBQUFPLEtBQUEsQ0FBQXhCLENBQUEsRUFBQUgsQ0FBQTtBQUFBLFNBQUF1QiwwQkFBQSxjQUFBcEIsQ0FBQSxJQUFBeUIsT0FBQSxDQUFBQyxTQUFBLENBQUFDLE9BQUEsQ0FBQWQsSUFBQSxDQUFBUSxPQUFBLENBQUFDLFNBQUEsQ0FBQUcsT0FBQSxpQ0FBQXpCLENBQUEsYUFBQW9CLHlCQUFBLFlBQUFBLDBCQUFBLGFBQUFwQixDQUFBO0FBQUEsU0FBQTRCLFFBQUEvQixDQUFBLEVBQUFFLENBQUEsUUFBQUMsQ0FBQSxHQUFBUSxNQUFBLENBQUFxQixJQUFBLENBQUFoQyxDQUFBLE9BQUFXLE1BQUEsQ0FBQXNCLHFCQUFBLFFBQUFiLENBQUEsR0FBQVQsTUFBQSxDQUFBc0IscUJBQUEsQ0FBQWpDLENBQUEsR0FBQUUsQ0FBQSxLQUFBa0IsQ0FBQSxHQUFBQSxDQUFBLENBQUFjLE1BQUEsV0FBQWhDLENBQUEsV0FBQVMsTUFBQSxDQUFBRSx3QkFBQSxDQUFBYixDQUFBLEVBQUFFLENBQUEsRUFBQWlDLFVBQUEsT0FBQWhDLENBQUEsQ0FBQWlDLElBQUEsQ0FBQVQsS0FBQSxDQUFBeEIsQ0FBQSxFQUFBaUIsQ0FBQSxZQUFBakIsQ0FBQTtBQUFBLFNBQUFrQyxjQUFBckMsQ0FBQSxhQUFBRSxDQUFBLE1BQUFBLENBQUEsR0FBQW9DLFNBQUEsQ0FBQUMsTUFBQSxFQUFBckMsQ0FBQSxVQUFBQyxDQUFBLFdBQUFtQyxTQUFBLENBQUFwQyxDQUFBLElBQUFvQyxTQUFBLENBQUFwQyxDQUFBLFFBQUFBLENBQUEsT0FBQTZCLE9BQUEsQ0FBQXBCLE1BQUEsQ0FBQVIsQ0FBQSxPQUFBcUMsT0FBQSxXQUFBdEMsQ0FBQSxRQUFBdUMsZ0JBQUEsYUFBQXpDLENBQUEsRUFBQUUsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQVMsTUFBQSxDQUFBK0IseUJBQUEsR0FBQS9CLE1BQUEsQ0FBQWdDLGdCQUFBLENBQUEzQyxDQUFBLEVBQUFXLE1BQUEsQ0FBQStCLHlCQUFBLENBQUF2QyxDQUFBLEtBQUE0QixPQUFBLENBQUFwQixNQUFBLENBQUFSLENBQUEsR0FBQXFDLE9BQUEsV0FBQXRDLENBQUEsSUFBQVMsTUFBQSxDQUFBQyxjQUFBLENBQUFaLENBQUEsRUFBQUUsQ0FBQSxFQUFBUyxNQUFBLENBQUFFLHdCQUFBLENBQUFWLENBQUEsRUFBQUQsQ0FBQSxpQkFBQUYsQ0FBQSxJQS9CcEQ7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTRCQTs7QUFRQTs7QUFxQ0E7QUFDQSxJQUFBNEMscUJBQUEsR0FJSUMsd0JBQWdCLENBQUNDLFlBQVk7RUFIekJDLEtBQUssR0FBQUgscUJBQUEsQ0FBWEksSUFBSTtFQUNTQyxZQUFZLEdBQUFMLHFCQUFBLENBQXpCTSxXQUFXO0VBQ1JDLHFCQUFxQixPQUFBQyx5QkFBQSxhQUFBUixxQkFBQTs7QUFHMUI7QUFDQSxJQUFNUyxlQUFlLEdBQUc7RUFDdEJ2RCxTQUFTLEVBQUU7QUFDYixDQUFDOztBQUVEO0FBQ0EsSUFBTWdELFlBQXlELEdBQUFULGFBQUEsQ0FBQUEsYUFBQSxLQUMxRGMscUJBQXFCLEdBQ3JCRSxlQUFlLENBQ25CO0FBQUMsSUFFV0Msd0JBQXdCLEdBQUFDLE9BQUEsQ0FBQUQsd0JBQUEsMEJBQUFFLGVBQUE7RUFBQSxTQUFBRix5QkFBQTtJQUFBLElBQUFHLGdCQUFBLG1CQUFBSCx3QkFBQTtJQUFBLE9BQUFuQyxVQUFBLE9BQUFtQyx3QkFBQSxFQUFBaEIsU0FBQTtFQUFBO0VBQUEsSUFBQW9CLFVBQUEsYUFBQUosd0JBQUEsRUFBQUUsZUFBQTtFQUFBLFdBQUFHLGFBQUEsYUFBQUwsd0JBQUE7SUFBQU0sR0FBQTtJQUFBQyxLQUFBLEVBTW5DLFNBQUFDLGNBQWNBLENBQ1pDLE1BRUMsRUFDb0I7TUFDckIsT0FBTyxJQUFBRCx1QkFBYyxFQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDQyxLQUFLLENBQUNoQixJQUFJLENBQUM7SUFDaEQ7RUFBQztJQUFBWSxHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBSSxZQUFZQSxDQUFBLEVBQXNDO01BQ2hELElBQWFDLEtBQUssR0FBSSxJQUFJLENBQUNGLEtBQUssQ0FBekJoQixJQUFJO01BRVgsSUFBSSxJQUFJLENBQUNnQixLQUFLLENBQUNkLFdBQVcsS0FBS2lCLFNBQVMsRUFBRTtRQUN4QyxJQUFNQyxjQUFjLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNkLFdBQVc7UUFDN0MsSUFBSWtCLGNBQWMsS0FBS0QsU0FBUyxJQUFJMUUsRUFBRSxDQUFDNEUsTUFBTSxDQUFDQyxhQUFhLENBQUNGLGNBQWMsQ0FBQyxFQUFFO1VBQzNFLE9BQU8sSUFBSSxDQUFDRyxrQkFBa0IsQ0FBQ0gsY0FBYyxDQUFDO1FBQ2hEO1FBRUEsSUFBSUEsY0FBYyxLQUFLRCxTQUFTLElBQUkxRSxFQUFFLENBQUM0RSxNQUFNLENBQUNHLGtCQUFrQixDQUFDSixjQUFjLENBQUMsRUFBRTtVQUNoRixPQUFPLElBQUksQ0FBQ0ssdUJBQXVCLENBQUNMLGNBQWMsQ0FBQztRQUNyRDtRQUVBLE1BQU0sSUFBSU0sS0FBSyxDQUFDLHdFQUF3RSxDQUFDO01BQzNGLENBQUMsTUFBTTtRQUNMLElBQU1DLFdBQVcsR0FBRyxJQUFBQyx3QkFBaUIsRUFBQ1YsS0FBSyxFQUFFVyw4QkFBbUIsQ0FBQ0MsS0FBSyxDQUFDO1FBQ3ZFLElBQUlILFdBQVcsS0FBSyxJQUFJLEVBQUU7VUFDeEIsT0FBTyxJQUFJLENBQUNKLGtCQUFrQixDQUFDSSxXQUFXLENBQUM7UUFDN0M7UUFFQSxJQUFNSSxnQkFBZ0IsR0FBRyxJQUFBSCx3QkFBaUIsRUFBQ1YsS0FBSyxFQUFFVyw4QkFBbUIsQ0FBQ0csVUFBVSxDQUFDO1FBQ2pGLElBQUlELGdCQUFnQixLQUFLLElBQUksRUFBRTtVQUM3QixPQUFPLElBQUksQ0FBQ04sdUJBQXVCLENBQUNNLGdCQUFnQixDQUFDO1FBQ3ZEO01BQ0Y7TUFFQSxNQUFNLElBQUlMLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQztJQUNqRTtFQUFDO0lBQUFkLEdBQUE7SUFBQUMsS0FBQSxFQUVELFNBQUFVLGtCQUFrQkEsQ0FBQ0gsY0FBcUMsRUFBcUM7TUFDM0YsSUFBYUYsS0FBSyxHQUFJLElBQUksQ0FBQ0YsS0FBSyxDQUF6QmhCLElBQUk7TUFFWCxJQUFJLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ2xFLFNBQVMsRUFBRTtRQUN4QixJQUFBbUYsYUFBTSxFQUFDeEYsRUFBRSxDQUFDNEUsTUFBTSxDQUFDQyxhQUFhLENBQUNGLGNBQWMsQ0FBQyxDQUFDO1FBQy9DLElBQUFjLDJCQUFpQixFQUFDLElBQUksQ0FBQ2xCLEtBQUssRUFBRUUsS0FBSyxDQUFDO01BQ3RDOztNQUVBO01BQ0EsSUFBQWlCLHFCQUFBLEdBQWdDLElBQUFDLGdDQUF5QixFQUFDLElBQUksQ0FBQ3BCLEtBQUssRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQUFxQixzQkFBQSxPQUFBQyxlQUFBLGFBQUFILHFCQUFBO1FBQS9FSSxTQUFTLEdBQUFGLHNCQUFBO1FBQUVHLFVBQVUsR0FBQUgsc0JBQUE7TUFDNUIsSUFBTUksWUFBWSxHQUFHLElBQUFDLDRCQUFtQixFQUFDeEIsS0FBSyxDQUFDbEIsSUFBSSxDQUFDO01BRXBELElBQU0yQyxNQUErQixHQUFHLEVBQUU7TUFDMUMsS0FBSyxJQUFJQyxjQUFjLEdBQUcsQ0FBQyxFQUFFQSxjQUFjLEdBQUcxQixLQUFLLENBQUMyQixPQUFPLENBQUN0RCxNQUFNLEVBQUVxRCxjQUFjLEVBQUUsRUFBRTtRQUNwRixJQUFNRSxZQUFZLEdBQUcxQixjQUFjLENBQUNwQixJQUFJLENBQUM0QyxjQUFjLENBQUM7UUFDeEQsSUFBTUcsY0FBYyxHQUFHdEcsRUFBRSxDQUFDdUcsS0FBSyxDQUFDQyxhQUFhLENBQUNILFlBQVksQ0FBQztRQUMzRCxJQUFNSSxtQkFBbUIsR0FBR0gsY0FBYyxDQUFDSSxNQUFNOztRQUVqRDtRQUNBLElBQU1DLFdBQVcsR0FBR2hDLGNBQWMsQ0FBQ2lDLFFBQVEsQ0FBQ1QsY0FBYyxDQUFDO1FBRTNELElBQU01QixLQUFrRCxHQUFBM0IsYUFBQSxDQUFBQSxhQUFBLENBQUFBLGFBQUEsS0FHbkRnQixlQUFlLEdBQ2ZtQyxVQUFVO1VBRWI7VUFDQUksY0FBYyxFQUFkQSxjQUFjO1VBQ2RILFlBQVksRUFBWkEsWUFBWTtVQUVaYSxFQUFFLEtBQUFDLE1BQUEsQ0FBSyxJQUFJLENBQUN2QyxLQUFLLENBQUNzQyxFQUFFLDRCQUFBQyxNQUFBLENBQXlCWCxjQUFjLENBQUU7VUFDN0Q1QyxJQUFJLEVBQUU7WUFDSjtZQUNBQSxJQUFJLEVBQUVrQixLQUFLLENBQUMyQixPQUFPLENBQUNELGNBQWMsQ0FBQztZQUNuQ3JELE1BQU0sRUFBRXVELFlBQVksQ0FBQ3ZELE1BQU07WUFDM0JpRSxVQUFVLEVBQUU7Y0FDVnRELFdBQVcsRUFBRTtnQkFDWFcsS0FBSyxFQUFFcUMsbUJBQW1CO2dCQUMxQk8sSUFBSSxFQUFFWCxZQUFZLENBQUNZLElBQUksQ0FBQ0M7Y0FDMUI7WUFDRjtVQUNGO1FBQUMsRUFDRjtRQUVELFNBQUFDLEVBQUEsTUFBQUMsZUFBQSxHQUFvQ2xHLE1BQU0sQ0FBQ21HLE9BQU8sQ0FBQ3ZCLFNBQVMsQ0FBQyxFQUFBcUIsRUFBQSxHQUFBQyxlQUFBLENBQUF0RSxNQUFBLEVBQUFxRSxFQUFBLElBQUU7VUFBMUQsSUFBQUcsa0JBQUEsT0FBQXpCLGVBQUEsYUFBQXVCLGVBQUEsQ0FBQUQsRUFBQTtZQUFPSSxRQUFRLEdBQUFELGtCQUFBO1lBQUVFLFNBQVMsR0FBQUYsa0JBQUE7VUFDN0IsSUFBQUcscUJBQWMsRUFBQztZQUNibEQsS0FBSyxFQUFMQSxLQUFLO1lBQ0xnRCxRQUFRLEVBQVJBLFFBQVE7WUFDUkMsU0FBUyxFQUFUQSxTQUFTO1lBQ1RFLFFBQVEsRUFBRXZCLGNBQWM7WUFDeEJRLFdBQVcsRUFBWEE7VUFDRixDQUFDLENBQUM7UUFDSjtRQUVBLElBQU1nQixLQUFLLEdBQUcsSUFBSXZFLHdCQUFnQixDQUFBUixhQUFBLENBQUFBLGFBQUEsS0FDN0IsSUFBSSxDQUFDZ0YsZ0JBQWdCLENBQUNyRCxLQUFLLENBQUM7VUFDL0I7VUFDQXNELFdBQVcsRUFBRXRELEtBQUssQ0FBQ3NELFdBQVc7VUFDOUJDLGNBQWMsRUFBRXZELEtBQUssQ0FBQ3VEO1FBQWMsRUFDckMsQ0FBQztRQUNGNUIsTUFBTSxDQUFDdkQsSUFBSSxDQUFDZ0YsS0FBSyxDQUFDO01BQ3BCO01BRUEsT0FBT3pCLE1BQU07SUFDZjtFQUFDO0lBQUEvQixHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBWSx1QkFBdUJBLENBQ3JCTCxjQUEwQyxFQUNQO01BQ25DLElBQWFGLEtBQUssR0FBSSxJQUFJLENBQUNGLEtBQUssQ0FBekJoQixJQUFJOztNQUVYO01BQ0E7TUFDQSxJQUFJLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ2xFLFNBQVMsRUFBRTtRQUN4QixJQUFBbUYsYUFBTSxFQUFDeEYsRUFBRSxDQUFDNEUsTUFBTSxDQUFDRyxrQkFBa0IsQ0FBQ0osY0FBYyxDQUFDLENBQUM7UUFDcEQsSUFBQWMsMkJBQWlCLEVBQUMsSUFBSSxDQUFDbEIsS0FBSyxFQUFFRSxLQUFLLENBQUM7TUFDdEM7O01BRUE7TUFDQSxJQUFBc0Qsc0JBQUEsR0FBZ0MsSUFBQXBDLGdDQUF5QixFQUFDLElBQUksQ0FBQ3BCLEtBQUssRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQUF5RCxzQkFBQSxPQUFBbkMsZUFBQSxhQUFBa0Msc0JBQUE7UUFBL0VqQyxTQUFTLEdBQUFrQyxzQkFBQTtRQUFFakMsVUFBVSxHQUFBaUMsc0JBQUE7TUFDNUIsSUFBTWhDLFlBQVksR0FBRyxJQUFBQyw0QkFBbUIsRUFBQ3hCLEtBQUssQ0FBQ2xCLElBQUksQ0FBQztNQUVwRCxJQUFNMkMsTUFBMEIsR0FBRyxFQUFFO01BQ3JDLEtBQUssSUFBSUMsY0FBYyxHQUFHLENBQUMsRUFBRUEsY0FBYyxHQUFHMUIsS0FBSyxDQUFDMkIsT0FBTyxDQUFDdEQsTUFBTSxFQUFFcUQsY0FBYyxFQUFFLEVBQUU7UUFDcEYsSUFBTThCLGNBQWMsR0FBR3RELGNBQWMsQ0FBQ3BCLElBQUksQ0FBQzRDLGNBQWMsQ0FBQztRQUMxRCxJQUFNK0IsU0FBUyxHQUFHbEksRUFBRSxDQUFDdUcsS0FBSyxDQUFDNEIsa0JBQWtCLENBQUNGLGNBQWMsQ0FBQztRQUM3RCxJQUFNRyxXQUFXLEdBQUdILGNBQWMsQ0FBQ0ksWUFBWTtRQUMvQyxJQUFNL0IsY0FBYyxHQUFHdEcsRUFBRSxDQUFDdUcsS0FBSyxDQUFDQyxhQUFhLENBQUMwQixTQUFTLENBQUM7UUFDeEQsSUFBTXpCLG1CQUFtQixHQUFHSCxjQUFjLENBQUNJLE1BQU07O1FBRWpEO1FBQ0EsSUFBTUMsV0FBVyxHQUFHaEMsY0FBYyxDQUFDaUMsUUFBUSxDQUFDVCxjQUFjLENBQUM7UUFFM0QsSUFBTTVCLEtBQTZDLEdBQUEzQixhQUFBLENBQUFBLGFBQUEsQ0FBQUEsYUFBQSxLQUc5Q2dCLGVBQWUsR0FDZm1DLFVBQVU7VUFFYjtVQUNBSSxjQUFjLEVBQWRBLGNBQWM7VUFDZEgsWUFBWSxFQUFaQSxZQUFZO1VBRVphLEVBQUUsS0FBQUMsTUFBQSxDQUFLLElBQUksQ0FBQ3ZDLEtBQUssQ0FBQ3NDLEVBQUUsNEJBQUFDLE1BQUEsQ0FBeUJYLGNBQWMsQ0FBRTtVQUM3RDVDLElBQUksRUFBRTtZQUNKO1lBQ0FBLElBQUksRUFBRWtCLEtBQUssQ0FBQzJCLE9BQU8sQ0FBQ0QsY0FBYyxDQUFDO1lBQ25DO1lBQ0E7WUFDQW1DLG1CQUFtQixFQUFFLElBQUFDLG9CQUFhLEVBQUNILFdBQVcsQ0FBQztZQUMvQztZQUNBdEYsTUFBTSxFQUFFb0YsU0FBUyxDQUFDcEYsTUFBTTtZQUN4QmlFLFVBQVUsRUFBRTtjQUNWdEQsV0FBVyxFQUFFO2dCQUNYVyxLQUFLLEVBQUVxQyxtQkFBbUI7Z0JBQzFCTyxJQUFJLEVBQUVrQixTQUFTLENBQUNqQixJQUFJLENBQUNDO2NBQ3ZCO1lBQ0Y7VUFDRjtRQUFDLEVBQ0Y7UUFFRCxTQUFBc0IsR0FBQSxNQUFBQyxnQkFBQSxHQUFvQ3ZILE1BQU0sQ0FBQ21HLE9BQU8sQ0FBQ3ZCLFNBQVMsQ0FBQyxFQUFBMEMsR0FBQSxHQUFBQyxnQkFBQSxDQUFBM0YsTUFBQSxFQUFBMEYsR0FBQSxJQUFFO1VBQTFELElBQUFFLG1CQUFBLE9BQUE3QyxlQUFBLGFBQUE0QyxnQkFBQSxDQUFBRCxHQUFBO1lBQU9qQixRQUFRLEdBQUFtQixtQkFBQTtZQUFFbEIsU0FBUyxHQUFBa0IsbUJBQUE7VUFDN0IsSUFBQWpCLHFCQUFjLEVBQUM7WUFDYmxELEtBQUssRUFBTEEsS0FBSztZQUNMZ0QsUUFBUSxFQUFSQSxRQUFRO1lBQ1JDLFNBQVMsRUFBVEEsU0FBUztZQUNURSxRQUFRLEVBQUV2QixjQUFjO1lBQ3hCd0MsZ0JBQWdCLEVBQUVQLFdBQVc7WUFDN0J6QixXQUFXLEVBQVhBO1VBQ0YsQ0FBQyxDQUFDO1FBQ0o7UUFFQSxJQUFNZ0IsS0FBSyxHQUFHLElBQUl2RSx3QkFBZ0IsQ0FBQVIsYUFBQSxDQUFBQSxhQUFBLEtBQzdCLElBQUksQ0FBQ2dGLGdCQUFnQixDQUFDckQsS0FBSyxDQUFDO1VBQy9CO1VBQ0FzRCxXQUFXLEVBQUV0RCxLQUFLLENBQUNzRCxXQUFXO1VBQzlCQyxjQUFjLEVBQUV2RCxLQUFLLENBQUN1RDtRQUFjLEVBQ3JDLENBQUM7UUFDRjVCLE1BQU0sQ0FBQ3ZELElBQUksQ0FBQ2dGLEtBQUssQ0FBQztNQUNwQjtNQUVBLE9BQU96QixNQUFNO0lBQ2Y7RUFBQztBQUFBLEVBMUwrRTBDLHFCQUFjO0FBQUEsSUFBQTVGLGdCQUFBLGFBQW5GYSx3QkFBd0Isa0JBR2JSLFlBQVk7QUFBQSxJQUFBTCxnQkFBQSxhQUh2QmEsd0JBQXdCLGVBSWhCLDBCQUEwQiIsImlnbm9yZUxpc3QiOltdfQ==