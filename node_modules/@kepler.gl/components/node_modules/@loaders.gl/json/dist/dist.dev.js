(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['loaders'] = factory();
  else root['loaders'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global-plugin:@loaders.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@loaders.gl/core"(exports, module) {
      module.exports = globalThis.loaders;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    JSONLoader: () => JSONLoader,
    JSONWriter: () => JSONWriter,
    NDJSONLoader: () => NDJSONLoader,
    _ClarinetParser: () => ClarinetParser,
    _GeoJSONLoader: () => GeoJSONLoader,
    _GeoJSONWorkerLoader: () => GeoJSONWorkerLoader,
    _GeoJSONWriter: () => GeoJSONWriter,
    _JSONPath: () => JSONPath,
    _rebuildJsonObject: () => rebuildJsonObject
  });
  __reExport(bundle_exports, __toESM(require_core(), 1));

  // ../schema/src/lib/table/simple-table/data-type.ts
  function getDataTypeFromValue(value, defaultNumberType = "float32") {
    if (value instanceof Date) {
      return "date-millisecond";
    }
    if (value instanceof Number) {
      return defaultNumberType;
    }
    if (typeof value === "string") {
      return "utf8";
    }
    if (value === null || value === "undefined") {
      return "null";
    }
    return "null";
  }
  function getDataTypeFromArray(array) {
    let type = getDataTypeFromTypedArray(array);
    if (type !== "null") {
      return { type, nullable: false };
    }
    if (array.length > 0) {
      type = getDataTypeFromValue(array[0]);
      return { type, nullable: true };
    }
    return { type: "null", nullable: true };
  }
  function getDataTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return "int8";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int16Array:
        return "int16";
      case Uint16Array:
        return "uint16";
      case Int32Array:
        return "int32";
      case Uint32Array:
        return "uint32";
      case Float32Array:
        return "float32";
      case Float64Array:
        return "float64";
      default:
        return "null";
    }
  }

  // ../schema/src/lib/table/batches/base-table-batch-aggregator.ts
  var DEFAULT_ROW_COUNT = 100;
  var BaseTableBatchAggregator = class {
    schema;
    options;
    shape;
    length = 0;
    rows = null;
    cursor = 0;
    _headers = [];
    constructor(schema, options) {
      this.options = options;
      this.schema = schema;
      if (!Array.isArray(schema)) {
        this._headers = [];
        for (const key in schema) {
          this._headers[schema[key].index] = schema[key].name;
        }
      }
    }
    rowCount() {
      return this.length;
    }
    addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }
      this.shape = "array-row-table";
      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
    addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }
      this.shape = "object-row-table";
      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
    getBatch() {
      let rows = this.rows;
      if (!rows) {
        return null;
      }
      rows = rows.slice(0, this.length);
      this.rows = null;
      const batch = {
        shape: this.shape || "array-row-table",
        batchType: "data",
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
      return batch;
    }
  };

  // ../schema/src/lib/table/simple-table/row-utils.ts
  function convertToObjectRow(arrayRow, headers) {
    if (!arrayRow) {
      throw new Error("null row");
    }
    const objectRow = {};
    if (headers) {
      for (let i = 0; i < headers.length; i++) {
        objectRow[headers[i]] = arrayRow[i];
      }
    } else {
      for (let i = 0; i < arrayRow.length; i++) {
        const columnName = `column-${i}`;
        objectRow[columnName] = arrayRow[i];
      }
    }
    return objectRow;
  }
  function convertToArrayRow(objectRow, headers) {
    if (!objectRow) {
      throw new Error("null row");
    }
    if (headers) {
      const arrayRow = new Array(headers.length);
      for (let i = 0; i < headers.length; i++) {
        arrayRow[i] = objectRow[headers[i]];
      }
      return arrayRow;
    }
    return Object.values(objectRow);
  }
  function inferHeadersFromArrayRow(arrayRow) {
    const headers = [];
    for (let i = 0; i < arrayRow.length; i++) {
      const columnName = `column-${i}`;
      headers.push(columnName);
    }
    return headers;
  }
  function inferHeadersFromObjectRow(row) {
    return Object.keys(row);
  }

  // ../schema/src/lib/table/batches/row-table-batch-aggregator.ts
  var DEFAULT_ROW_COUNT2 = 100;
  var RowTableBatchAggregator = class {
    schema;
    options;
    length = 0;
    objectRows = null;
    arrayRows = null;
    cursor = 0;
    _headers = null;
    constructor(schema, options) {
      this.options = options;
      this.schema = schema;
      if (schema) {
        this._headers = [];
        for (const key in schema) {
          this._headers[schema[key].index] = schema[key].name;
        }
      }
    }
    rowCount() {
      return this.length;
    }
    addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }
      this._headers ||= inferHeadersFromArrayRow(row);
      switch (this.options.shape) {
        case "object-row-table":
          const rowObject = convertToObjectRow(row, this._headers);
          this.addObjectRow(rowObject, cursor);
          break;
        case "array-row-table":
          this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT2);
          this.arrayRows[this.length] = row;
          this.length++;
          break;
      }
    }
    addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }
      this._headers ||= inferHeadersFromObjectRow(row);
      switch (this.options.shape) {
        case "array-row-table":
          const rowArray = convertToArrayRow(row, this._headers);
          this.addArrayRow(rowArray, cursor);
          break;
        case "object-row-table":
          this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT2);
          this.objectRows[this.length] = row;
          this.length++;
          break;
      }
    }
    getBatch() {
      let rows = this.arrayRows || this.objectRows;
      if (!rows) {
        return null;
      }
      rows = rows.slice(0, this.length);
      this.arrayRows = null;
      this.objectRows = null;
      return {
        shape: this.options.shape,
        batchType: "data",
        data: rows,
        length: this.length,
        // @ts-expect-error we should infer a schema
        schema: this.schema,
        cursor: this.cursor
      };
    }
  };

  // ../schema/src/lib/table/batches/columnar-table-batch-aggregator.ts
  var DEFAULT_ROW_COUNT3 = 100;
  var ColumnarTableBatchAggregator = class {
    schema;
    length = 0;
    allocated = 0;
    columns = {};
    constructor(schema, options) {
      this.schema = schema;
      this._reallocateColumns();
    }
    rowCount() {
      return this.length;
    }
    addArrayRow(row) {
      this._reallocateColumns();
      let i = 0;
      for (const fieldName in this.columns) {
        this.columns[fieldName][this.length] = row[i++];
      }
      this.length++;
    }
    addObjectRow(row) {
      this._reallocateColumns();
      for (const fieldName in row) {
        this.columns[fieldName][this.length] = row[fieldName];
      }
      this.length++;
    }
    getBatch() {
      this._pruneColumns();
      const columns = Array.isArray(this.schema) ? this.columns : {};
      if (!Array.isArray(this.schema)) {
        for (const fieldName in this.schema) {
          const field = this.schema[fieldName];
          columns[field.name] = this.columns[field.index];
        }
      }
      this.columns = {};
      const batch = {
        shape: "columnar-table",
        batchType: "data",
        data: columns,
        schema: this.schema,
        length: this.length
      };
      return batch;
    }
    // HELPERS
    _reallocateColumns() {
      if (this.length < this.allocated) {
        return;
      }
      this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT3;
      this.columns = {};
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        const ArrayType = field.type || Float32Array;
        const oldColumn = this.columns[field.index];
        if (oldColumn && ArrayBuffer.isView(oldColumn)) {
          const typedArray = new ArrayType(this.allocated);
          typedArray.set(oldColumn);
          this.columns[field.index] = typedArray;
        } else if (oldColumn) {
          oldColumn.length = this.allocated;
          this.columns[field.index] = oldColumn;
        } else {
          this.columns[field.index] = new ArrayType(this.allocated);
        }
      }
    }
    _pruneColumns() {
      for (const [columnName, column] of Object.entries(this.columns)) {
        this.columns[columnName] = column.slice(0, this.length);
      }
    }
  };

  // ../schema/src/lib/table/batches/table-batch-builder.ts
  var DEFAULT_OPTIONS = {
    shape: void 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    limit: 0,
    _limitMB: 0
  };
  var ERR_MESSAGE = "TableBatchBuilder";
  var _TableBatchBuilder = class {
    schema;
    options;
    aggregator = null;
    batchCount = 0;
    bytesUsed = 0;
    isChunkComplete = false;
    lastBatchEmittedMs = Date.now();
    totalLength = 0;
    totalBytes = 0;
    rowBytes = 0;
    constructor(schema, options) {
      this.schema = schema;
      this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    limitReached() {
      if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {
        return true;
      }
      if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
        return true;
      }
      return false;
    }
    /** @deprecated Use addArrayRow or addObjectRow */
    addRow(row) {
      if (this.limitReached()) {
        return;
      }
      this.totalLength++;
      this.rowBytes = this.rowBytes || this._estimateRowMB(row);
      this.totalBytes += this.rowBytes;
      if (Array.isArray(row)) {
        this.addArrayRow(row);
      } else {
        this.addObjectRow(row);
      }
    }
    /** Add one row to the batch */
    addArrayRow(row) {
      if (!this.aggregator) {
        const TableBatchType = this._getTableBatchType();
        this.aggregator = new TableBatchType(this.schema, this.options);
      }
      this.aggregator.addArrayRow(row);
    }
    /** Add one row to the batch */
    addObjectRow(row) {
      if (!this.aggregator) {
        const TableBatchType = this._getTableBatchType();
        this.aggregator = new TableBatchType(this.schema, this.options);
      }
      this.aggregator.addObjectRow(row);
    }
    /** Mark an incoming raw memory chunk has completed */
    chunkComplete(chunk) {
      if (chunk instanceof ArrayBuffer) {
        this.bytesUsed += chunk.byteLength;
      }
      if (typeof chunk === "string") {
        this.bytesUsed += chunk.length;
      }
      this.isChunkComplete = true;
    }
    getFullBatch(options) {
      return this._isFull() ? this._getBatch(options) : null;
    }
    getFinalBatch(options) {
      return this._getBatch(options);
    }
    // INTERNAL
    _estimateRowMB(row) {
      return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
    }
    _isFull() {
      if (!this.aggregator || this.aggregator.rowCount() === 0) {
        return false;
      }
      if (this.options.batchSize === "auto") {
        if (!this.isChunkComplete) {
          return false;
        }
      } else if (this.options.batchSize > this.aggregator.rowCount()) {
        return false;
      }
      if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
        return false;
      }
      this.isChunkComplete = false;
      this.lastBatchEmittedMs = Date.now();
      return true;
    }
    /**
     * bytesUsed can be set via chunkComplete or via getBatch*
     */
    _getBatch(options) {
      if (!this.aggregator) {
        return null;
      }
      if (options?.bytesUsed) {
        this.bytesUsed = options.bytesUsed;
      }
      const normalizedBatch = this.aggregator.getBatch();
      normalizedBatch.count = this.batchCount;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      this.batchCount++;
      this.aggregator = null;
      return normalizedBatch;
    }
    _getTableBatchType() {
      switch (this.options.shape) {
        case "array-row-table":
        case "object-row-table":
          return RowTableBatchAggregator;
        case "columnar-table":
          return ColumnarTableBatchAggregator;
        case "arrow-table":
          if (!_TableBatchBuilder.ArrowBatch) {
            throw new Error(ERR_MESSAGE);
          }
          return _TableBatchBuilder.ArrowBatch;
        default:
          return BaseTableBatchAggregator;
      }
    }
  };
  var TableBatchBuilder = _TableBatchBuilder;
  __publicField(TableBatchBuilder, "ArrowBatch");

  // ../schema/src/lib/table/simple-table/table-accessors.ts
  function getTableLength(table) {
    switch (table.shape) {
      case "array-row-table":
      case "object-row-table":
        return table.data.length;
      case "geojson-table":
        return table.features.length;
      case "arrow-table":
        const arrowTable = table.data;
        return arrowTable.numRows;
      case "columnar-table":
        for (const column of Object.values(table.data)) {
          return column.length || 0;
        }
        return 0;
      default:
        throw new Error("table");
    }
  }
  function getTableNumCols(table) {
    if (table.schema) {
      return table.schema.fields.length;
    }
    if (getTableLength(table) === 0) {
      throw new Error("empty table");
    }
    switch (table.shape) {
      case "array-row-table":
        return table.data[0].length;
      case "object-row-table":
        return Object.keys(table.data[0]).length;
      case "geojson-table":
        return Object.keys(table.features[0]).length;
      case "columnar-table":
        return Object.keys(table.data).length;
      case "arrow-table":
        const arrowTable = table.data;
        return arrowTable.numCols;
      default:
        throw new Error("table");
    }
  }
  function getTableRowAsObject(table, rowIndex, target, copy2) {
    switch (table.shape) {
      case "object-row-table":
        return copy2 ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];
      case "array-row-table":
        if (table.schema) {
          const objectRow2 = target || {};
          for (let i = 0; i < table.schema.fields.length; i++) {
            objectRow2[table.schema.fields[i].name] = table.data[rowIndex][i];
          }
          return objectRow2;
        }
        throw new Error("no schema");
      case "geojson-table":
        if (table.schema) {
          const objectRow2 = target || {};
          for (let i = 0; i < table.schema.fields.length; i++) {
            objectRow2[table.schema.fields[i].name] = table.features[rowIndex][i];
          }
          return objectRow2;
        }
        throw new Error("no schema");
      case "columnar-table":
        if (table.schema) {
          const objectRow2 = target || {};
          for (let i = 0; i < table.schema.fields.length; i++) {
            objectRow2[table.schema.fields[i].name] = table.data[table.schema.fields[i].name][rowIndex];
          }
          return objectRow2;
        } else {
          const objectRow2 = target || {};
          for (const [name, column] of Object.entries(table.data)) {
            objectRow2[name] = column[rowIndex];
          }
          return objectRow2;
        }
      case "arrow-table":
        const arrowTable = table.data;
        const objectRow = target || {};
        const row = arrowTable.get(rowIndex);
        const schema = arrowTable.schema;
        for (let i = 0; i < schema.fields.length; i++) {
          objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];
        }
        return objectRow;
      default:
        throw new Error("shape");
    }
  }
  function getTableRowAsArray(table, rowIndex, target, copy2) {
    switch (table.shape) {
      case "array-row-table":
        return copy2 ? Array.from(table.data[rowIndex]) : table.data[rowIndex];
      case "object-row-table":
        if (table.schema) {
          const arrayRow2 = target || [];
          for (let i = 0; i < table.schema.fields.length; i++) {
            arrayRow2[i] = table.data[rowIndex][table.schema.fields[i].name];
          }
          return arrayRow2;
        }
        return Object.values(table.data[rowIndex]);
      case "geojson-table":
        if (table.schema) {
          const arrayRow2 = target || [];
          for (let i = 0; i < table.schema.fields.length; i++) {
            arrayRow2[i] = table.features[rowIndex][table.schema.fields[i].name];
          }
          return arrayRow2;
        }
        return Object.values(table.features[rowIndex]);
      case "columnar-table":
        if (table.schema) {
          const arrayRow2 = target || [];
          for (let i = 0; i < table.schema.fields.length; i++) {
            arrayRow2[i] = table.data[table.schema.fields[i].name][rowIndex];
          }
          return arrayRow2;
        } else {
          const arrayRow2 = target || [];
          let i = 0;
          for (const column of Object.values(table.data)) {
            arrayRow2[i] = column[rowIndex];
            i++;
          }
          return arrayRow2;
        }
      case "arrow-table":
        const arrowTable = table.data;
        const arrayRow = target || [];
        const row = arrowTable.get(rowIndex);
        const schema = arrowTable.schema;
        for (let i = 0; i < schema.fields.length; i++) {
          arrayRow[i] = row?.[schema.fields[i].name];
        }
        return arrayRow;
      default:
        throw new Error("shape");
    }
  }
  function* makeRowIterator(table, shape) {
    switch (shape) {
      case "array-row-table":
        yield* makeArrayRowIterator(table);
        break;
      case "object-row-table":
        yield* makeObjectRowIterator(table);
        break;
      default:
        throw new Error(`Unknown row type ${shape}`);
    }
  }
  function* makeArrayRowIterator(table, target = []) {
    const length = getTableLength(table);
    for (let rowIndex = 0; rowIndex < length; rowIndex++) {
      yield getTableRowAsArray(table, rowIndex, target);
    }
  }
  function* makeObjectRowIterator(table, target = {}) {
    const length = getTableLength(table);
    for (let rowIndex = 0; rowIndex < length; rowIndex++) {
      yield getTableRowAsObject(table, rowIndex, target);
    }
  }

  // ../schema/src/lib/table/simple-table/table-schema.ts
  function deduceTableSchema(table) {
    switch (table.shape) {
      case "array-row-table":
      case "object-row-table":
        return deduceSchemaFromRows(table.data);
      case "geojson-table":
        return deduceSchemaFromGeoJSON(table.features);
      case "columnar-table":
        return deduceSchemaFromColumns(table.data);
      case "arrow-table":
      default:
        throw new Error("Deduce schema");
    }
  }
  function deduceSchemaFromColumns(columnarTable) {
    const fields = [];
    for (const [columnName, column] of Object.entries(columnarTable)) {
      const field = deduceFieldFromColumn(column, columnName);
      fields.push(field);
    }
    return { fields, metadata: {} };
  }
  function deduceSchemaFromRows(rowTable) {
    if (!rowTable.length) {
      throw new Error("deduce from empty table");
    }
    const fields = [];
    const row0 = rowTable[0];
    for (const [columnName, value] of Object.entries(row0)) {
      fields.push(deduceFieldFromValue(value, columnName));
    }
    return { fields, metadata: {} };
  }
  function deduceSchemaFromGeoJSON(features) {
    if (!features.length) {
      throw new Error("deduce from empty table");
    }
    const fields = [];
    const row0 = features[0].properties || {};
    for (const [columnName, value] of Object.entries(row0)) {
      fields.push(deduceFieldFromValue(value, columnName));
    }
    return { fields, metadata: {} };
  }
  function deduceFieldFromColumn(column, name) {
    if (ArrayBuffer.isView(column)) {
      const type = getDataTypeFromArray(column);
      return {
        name,
        type: type.type || "null",
        nullable: type.nullable
        // metadata: {}
      };
    }
    if (Array.isArray(column) && column.length > 0) {
      const value = column[0];
      const type = getDataTypeFromValue(value);
      return {
        name,
        type,
        nullable: true
        // metadata: {},
      };
    }
    throw new Error("empty table");
  }
  function deduceFieldFromValue(value, name) {
    const type = getDataTypeFromValue(value);
    return {
      name,
      type,
      nullable: true
      // metadata: {}
    };
  }

  // ../schema/src/lib/table/simple-table/make-table.ts
  function makeTableFromData(data) {
    let table;
    switch (getTableShapeFromData(data)) {
      case "array-row-table":
        table = { shape: "array-row-table", data };
        break;
      case "object-row-table":
        table = { shape: "object-row-table", data };
        break;
      case "columnar-table":
        table = { shape: "columnar-table", data };
        break;
      default:
        throw new Error("table");
    }
    const schema = deduceTableSchema(table);
    return { ...table, schema };
  }
  function getTableShapeFromData(data) {
    if (Array.isArray(data)) {
      if (data.length === 0) {
        throw new Error("cannot deduce type of empty table");
      }
      const firstRow = data[0];
      if (Array.isArray(firstRow)) {
        return "array-row-table";
      }
      if (firstRow && typeof firstRow === "object") {
        return "object-row-table";
      }
    }
    if (data && typeof data === "object") {
      return "columnar-table";
    }
    throw new Error("invalid table");
  }

  // src/lib/parsers/parse-json.ts
  function parseJSONSync(jsonText, options) {
    try {
      const json = JSON.parse(jsonText);
      if (options.json?.table) {
        const data = getFirstArray(json) || json;
        return makeTableFromData(data);
      }
      return json;
    } catch (error) {
      throw new Error("JSONLoader: failed to parse JSON");
    }
  }
  function getFirstArray(json) {
    if (Array.isArray(json)) {
      return json;
    }
    if (json && typeof json === "object") {
      for (const value of Object.values(json)) {
        const array = getFirstArray(value);
        if (array) {
          return array;
        }
      }
    }
    return null;
  }

  // ../loader-utils/src/lib/env-utils/assert.ts
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../loader-utils/src/lib/binary-utils/array-buffer-utils.ts
  function concatenateArrayBuffers(...sources) {
    return concatenateArrayBuffersFromArray(sources);
  }
  function concatenateArrayBuffersFromArray(sources) {
    const sourceArrays = sources.map(
      (source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2
    );
    const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }

  // ../loader-utils/src/lib/iterators/text-iterators.ts
  async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {
    const textDecoder = new TextDecoder(void 0, options);
    for await (const arrayBuffer of arrayBufferIterator) {
      yield typeof arrayBuffer === "string" ? arrayBuffer : textDecoder.decode(arrayBuffer, { stream: true });
    }
  }
  async function* makeLineIterator(textIterator) {
    let previous = "";
    for await (const textChunk of textIterator) {
      previous += textChunk;
      let eolIndex;
      while ((eolIndex = previous.indexOf("\n")) >= 0) {
        const line = previous.slice(0, eolIndex + 1);
        previous = previous.slice(eolIndex + 1);
        yield line;
      }
    }
    if (previous.length > 0) {
      yield previous;
    }
  }
  async function* makeNumberedLineIterator(lineIterator) {
    let counter = 1;
    for await (const line of lineIterator) {
      yield { counter, line };
      counter++;
    }
  }

  // ../loader-utils/src/lib/iterators/async-iteration.ts
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // src/lib/clarinet/clarinet.ts
  var MAX_BUFFER_LENGTH = Number.MAX_SAFE_INTEGER;
  var Char = {
    tab: 9,
    // \t
    lineFeed: 10,
    // \n
    carriageReturn: 13,
    // \r
    space: 32,
    // " "
    doubleQuote: 34,
    // "
    plus: 43,
    // +
    comma: 44,
    // ,
    minus: 45,
    // -
    period: 46,
    // .
    _0: 48,
    // 0
    _9: 57,
    // 9
    colon: 58,
    // :
    E: 69,
    // E
    openBracket: 91,
    // [
    backslash: 92,
    // \
    closeBracket: 93,
    // ]
    a: 97,
    // a
    b: 98,
    // b
    e: 101,
    // e
    f: 102,
    // f
    l: 108,
    // l
    n: 110,
    // n
    r: 114,
    // r
    s: 115,
    // s
    t: 116,
    // t
    u: 117,
    // u
    openBrace: 123,
    // {
    closeBrace: 125
    // }
  };
  var stringTokenPattern = /[\\"\n]/g;
  var DEFAULT_OPTIONS2 = {
    onready: () => {
    },
    onopenobject: () => {
    },
    onkey: () => {
    },
    oncloseobject: () => {
    },
    onopenarray: () => {
    },
    onclosearray: () => {
    },
    onvalue: () => {
    },
    onerror: () => {
    },
    onend: () => {
    },
    onchunkparsed: () => {
    }
  };
  var ClarinetParser = class {
    options = DEFAULT_OPTIONS2;
    bufferCheckPosition = MAX_BUFFER_LENGTH;
    q = "";
    c = "";
    p = "";
    closed = false;
    closedRoot = false;
    sawRoot = false;
    // tag = null;
    error = null;
    state = 0 /* BEGIN */;
    stack = [];
    // mostly just for error reporting
    position = 0;
    column = 0;
    line = 1;
    slashed = false;
    unicodeI = 0;
    unicodeS = null;
    depth = 0;
    textNode;
    numberNode;
    constructor(options = {}) {
      this.options = { ...DEFAULT_OPTIONS2, ...options };
      this.textNode = void 0;
      this.numberNode = "";
      this.emit("onready");
    }
    end() {
      if (this.state !== 1 /* VALUE */ || this.depth !== 0)
        this._error("Unexpected end");
      this._closeValue();
      this.c = "";
      this.closed = true;
      this.emit("onend");
      return this;
    }
    resume() {
      this.error = null;
      return this;
    }
    close() {
      return this.write(null);
    }
    // protected
    emit(event, data) {
      this.options[event]?.(data, this);
    }
    emitNode(event, data) {
      this._closeValue();
      this.emit(event, data);
    }
    /* eslint-disable no-continue */
    // eslint-disable-next-line complexity, max-statements
    write(chunk) {
      if (this.error) {
        throw this.error;
      }
      if (this.closed) {
        return this._error("Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return this.end();
      }
      let i = 0;
      let c = chunk.charCodeAt(0);
      let p = this.p;
      while (c) {
        p = c;
        this.c = c = chunk.charCodeAt(i++);
        if (p !== c) {
          this.p = p;
        } else {
          p = this.p;
        }
        if (!c)
          break;
        this.position++;
        if (c === Char.lineFeed) {
          this.line++;
          this.column = 0;
        } else
          this.column++;
        switch (this.state) {
          case 0 /* BEGIN */:
            if (c === Char.openBrace)
              this.state = 2 /* OPEN_OBJECT */;
            else if (c === Char.openBracket)
              this.state = 4 /* OPEN_ARRAY */;
            else if (!isWhitespace(c)) {
              this._error("Non-whitespace before {[.");
            }
            continue;
          case 10 /* OPEN_KEY */:
          case 2 /* OPEN_OBJECT */:
            if (isWhitespace(c))
              continue;
            if (this.state === 10 /* OPEN_KEY */)
              this.stack.push(11 /* CLOSE_KEY */);
            else if (c === Char.closeBrace) {
              this.emit("onopenobject");
              this.depth++;
              this.emit("oncloseobject");
              this.depth--;
              this.state = this.stack.pop() || 1 /* VALUE */;
              continue;
            } else
              this.stack.push(3 /* CLOSE_OBJECT */);
            if (c === Char.doubleQuote)
              this.state = 7 /* STRING */;
            else
              this._error('Malformed object key should start with "');
            continue;
          case 11 /* CLOSE_KEY */:
          case 3 /* CLOSE_OBJECT */:
            if (isWhitespace(c))
              continue;
            if (c === Char.colon) {
              if (this.state === 3 /* CLOSE_OBJECT */) {
                this.stack.push(3 /* CLOSE_OBJECT */);
                this._closeValue("onopenobject");
                this.depth++;
              } else
                this._closeValue("onkey");
              this.state = 1 /* VALUE */;
            } else if (c === Char.closeBrace) {
              this.emitNode("oncloseobject");
              this.depth--;
              this.state = this.stack.pop() || 1 /* VALUE */;
            } else if (c === Char.comma) {
              if (this.state === 3 /* CLOSE_OBJECT */)
                this.stack.push(3 /* CLOSE_OBJECT */);
              this._closeValue();
              this.state = 10 /* OPEN_KEY */;
            } else
              this._error("Bad object");
            continue;
          case 4 /* OPEN_ARRAY */:
          case 1 /* VALUE */:
            if (isWhitespace(c))
              continue;
            if (this.state === 4 /* OPEN_ARRAY */) {
              this.emit("onopenarray");
              this.depth++;
              this.state = 1 /* VALUE */;
              if (c === Char.closeBracket) {
                this.emit("onclosearray");
                this.depth--;
                this.state = this.stack.pop() || 1 /* VALUE */;
                continue;
              } else {
                this.stack.push(5 /* CLOSE_ARRAY */);
              }
            }
            if (c === Char.doubleQuote)
              this.state = 7 /* STRING */;
            else if (c === Char.openBrace)
              this.state = 2 /* OPEN_OBJECT */;
            else if (c === Char.openBracket)
              this.state = 4 /* OPEN_ARRAY */;
            else if (c === Char.t)
              this.state = 12 /* TRUE */;
            else if (c === Char.f)
              this.state = 15 /* FALSE */;
            else if (c === Char.n)
              this.state = 19 /* NULL */;
            else if (c === Char.minus) {
              this.numberNode += "-";
            } else if (Char._0 <= c && c <= Char._9) {
              this.numberNode += String.fromCharCode(c);
              this.state = 23 /* NUMBER_DIGIT */;
            } else
              this._error("Bad value");
            continue;
          case 5 /* CLOSE_ARRAY */:
            if (c === Char.comma) {
              this.stack.push(5 /* CLOSE_ARRAY */);
              this._closeValue("onvalue");
              this.state = 1 /* VALUE */;
            } else if (c === Char.closeBracket) {
              this.emitNode("onclosearray");
              this.depth--;
              this.state = this.stack.pop() || 1 /* VALUE */;
            } else if (isWhitespace(c))
              continue;
            else
              this._error("Bad array");
            continue;
          case 7 /* STRING */:
            if (this.textNode === void 0) {
              this.textNode = "";
            }
            let starti = i - 1;
            let slashed = this.slashed;
            let unicodeI = this.unicodeI;
            STRING_BIGLOOP:
              while (true) {
                while (unicodeI > 0) {
                  this.unicodeS += String.fromCharCode(c);
                  c = chunk.charCodeAt(i++);
                  this.position++;
                  if (unicodeI === 4) {
                    this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16));
                    unicodeI = 0;
                    starti = i - 1;
                  } else {
                    unicodeI++;
                  }
                  if (!c)
                    break STRING_BIGLOOP;
                }
                if (c === Char.doubleQuote && !slashed) {
                  this.state = this.stack.pop() || 1 /* VALUE */;
                  this.textNode += chunk.substring(starti, i - 1);
                  this.position += i - 1 - starti;
                  break;
                }
                if (c === Char.backslash && !slashed) {
                  slashed = true;
                  this.textNode += chunk.substring(starti, i - 1);
                  this.position += i - 1 - starti;
                  c = chunk.charCodeAt(i++);
                  this.position++;
                  if (!c)
                    break;
                }
                if (slashed) {
                  slashed = false;
                  if (c === Char.n) {
                    this.textNode += "\n";
                  } else if (c === Char.r) {
                    this.textNode += "\r";
                  } else if (c === Char.t) {
                    this.textNode += "	";
                  } else if (c === Char.f) {
                    this.textNode += "\f";
                  } else if (c === Char.b) {
                    this.textNode += "\b";
                  } else if (c === Char.u) {
                    unicodeI = 1;
                    this.unicodeS = "";
                  } else {
                    this.textNode += String.fromCharCode(c);
                  }
                  c = chunk.charCodeAt(i++);
                  this.position++;
                  starti = i - 1;
                  if (!c)
                    break;
                  else
                    continue;
                }
                stringTokenPattern.lastIndex = i;
                const reResult = stringTokenPattern.exec(chunk);
                if (reResult === null) {
                  i = chunk.length + 1;
                  this.textNode += chunk.substring(starti, i - 1);
                  this.position += i - 1 - starti;
                  break;
                }
                i = reResult.index + 1;
                c = chunk.charCodeAt(reResult.index);
                if (!c) {
                  this.textNode += chunk.substring(starti, i - 1);
                  this.position += i - 1 - starti;
                  break;
                }
              }
            this.slashed = slashed;
            this.unicodeI = unicodeI;
            continue;
          case 12 /* TRUE */:
            if (c === Char.r)
              this.state = 13 /* TRUE2 */;
            else
              this._error(`Invalid true started with t${c}`);
            continue;
          case 13 /* TRUE2 */:
            if (c === Char.u)
              this.state = 14 /* TRUE3 */;
            else
              this._error(`Invalid true started with tr${c}`);
            continue;
          case 14 /* TRUE3 */:
            if (c === Char.e) {
              this.emit("onvalue", true);
              this.state = this.stack.pop() || 1 /* VALUE */;
            } else
              this._error(`Invalid true started with tru${c}`);
            continue;
          case 15 /* FALSE */:
            if (c === Char.a)
              this.state = 16 /* FALSE2 */;
            else
              this._error(`Invalid false started with f${c}`);
            continue;
          case 16 /* FALSE2 */:
            if (c === Char.l)
              this.state = 17 /* FALSE3 */;
            else
              this._error(`Invalid false started with fa${c}`);
            continue;
          case 17 /* FALSE3 */:
            if (c === Char.s)
              this.state = 18 /* FALSE4 */;
            else
              this._error(`Invalid false started with fal${c}`);
            continue;
          case 18 /* FALSE4 */:
            if (c === Char.e) {
              this.emit("onvalue", false);
              this.state = this.stack.pop() || 1 /* VALUE */;
            } else
              this._error(`Invalid false started with fals${c}`);
            continue;
          case 19 /* NULL */:
            if (c === Char.u)
              this.state = 20 /* NULL2 */;
            else
              this._error(`Invalid null started with n${c}`);
            continue;
          case 20 /* NULL2 */:
            if (c === Char.l)
              this.state = 21 /* NULL3 */;
            else
              this._error(`Invalid null started with nu${c}`);
            continue;
          case 21 /* NULL3 */:
            if (c === Char.l) {
              this.emit("onvalue", null);
              this.state = this.stack.pop() || 1 /* VALUE */;
            } else
              this._error(`Invalid null started with nul${c}`);
            continue;
          case 22 /* NUMBER_DECIMAL_POINT */:
            if (c === Char.period) {
              this.numberNode += ".";
              this.state = 23 /* NUMBER_DIGIT */;
            } else
              this._error("Leading zero not followed by .");
            continue;
          case 23 /* NUMBER_DIGIT */:
            if (Char._0 <= c && c <= Char._9)
              this.numberNode += String.fromCharCode(c);
            else if (c === Char.period) {
              if (this.numberNode.indexOf(".") !== -1)
                this._error("Invalid number has two dots");
              this.numberNode += ".";
            } else if (c === Char.e || c === Char.E) {
              if (this.numberNode.indexOf("e") !== -1 || this.numberNode.indexOf("E") !== -1)
                this._error("Invalid number has two exponential");
              this.numberNode += "e";
            } else if (c === Char.plus || c === Char.minus) {
              if (!(p === Char.e || p === Char.E))
                this._error("Invalid symbol in number");
              this.numberNode += String.fromCharCode(c);
            } else {
              this._closeNumber();
              i--;
              this.state = this.stack.pop() || 1 /* VALUE */;
            }
            continue;
          default:
            this._error(`Unknown state: ${this.state}`);
        }
      }
      if (this.position >= this.bufferCheckPosition) {
        checkBufferLength(this);
      }
      this.emit("onchunkparsed");
      return this;
    }
    _closeValue(event = "onvalue") {
      if (this.textNode !== void 0) {
        this.emit(event, this.textNode);
      }
      this.textNode = void 0;
    }
    _closeNumber() {
      if (this.numberNode)
        this.emit("onvalue", parseFloat(this.numberNode));
      this.numberNode = "";
    }
    _error(message = "") {
      this._closeValue();
      message += `
Line: ${this.line}
Column: ${this.column}
Char: ${this.c}`;
      const error = new Error(message);
      this.error = error;
      this.emit("onerror", error);
    }
  };
  function isWhitespace(c) {
    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;
  }
  function checkBufferLength(parser) {
    const maxAllowed = Math.max(MAX_BUFFER_LENGTH, 10);
    let maxActual = 0;
    for (const buffer of ["textNode", "numberNode"]) {
      const len = parser[buffer] === void 0 ? 0 : parser[buffer].length;
      if (len > maxAllowed) {
        switch (buffer) {
          case "text":
            break;
          default:
            parser._error(`Max buffer length exceeded: ${buffer}`);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    parser.bufferCheckPosition = MAX_BUFFER_LENGTH - maxActual + parser.position;
  }

  // src/lib/jsonpath/jsonpath.ts
  var JSONPath = class {
    path;
    constructor(path = null) {
      this.path = ["$"];
      if (path instanceof JSONPath) {
        this.path = [...path.path];
        return;
      }
      if (Array.isArray(path)) {
        this.path.push(...path);
        return;
      }
      if (typeof path === "string") {
        this.path = path.split(".");
        if (this.path[0] !== "$") {
          throw new Error("JSONPaths must start with $");
        }
      }
    }
    clone() {
      return new JSONPath(this);
    }
    toString() {
      return this.path.join(".");
    }
    push(name) {
      this.path.push(name);
    }
    pop() {
      return this.path.pop();
    }
    set(name) {
      this.path[this.path.length - 1] = name;
    }
    equals(other) {
      if (!this || !other || this.path.length !== other.path.length) {
        return false;
      }
      for (let i = 0; i < this.path.length; ++i) {
        if (this.path[i] !== other.path[i]) {
          return false;
        }
      }
      return true;
    }
    /**
     * Sets the value pointed at by path
     * TODO - handle root path
     * @param object
     * @param value
     */
    setFieldAtPath(object, value) {
      const path = [...this.path];
      path.shift();
      const field = path.pop();
      for (const component of path) {
        object = object[component];
      }
      object[field] = value;
    }
    /**
     * Gets the value pointed at by path
     * TODO - handle root path
     * @param object
     */
    getFieldAtPath(object) {
      const path = [...this.path];
      path.shift();
      const field = path.pop();
      for (const component of path) {
        object = object[component];
      }
      return object[field];
    }
  };

  // src/lib/json-parser/json-parser.ts
  var JSONParser = class {
    parser;
    result = void 0;
    previousStates = [];
    currentState = Object.freeze({ container: [], key: null });
    jsonpath = new JSONPath();
    constructor(options) {
      this.reset();
      this.parser = new ClarinetParser({
        onready: () => {
          this.jsonpath = new JSONPath();
          this.previousStates.length = 0;
          this.currentState.container.length = 0;
        },
        onopenobject: (name) => {
          this._openObject({});
          if (typeof name !== "undefined") {
            this.parser.emit("onkey", name);
          }
        },
        onkey: (name) => {
          this.jsonpath.set(name);
          this.currentState.key = name;
        },
        oncloseobject: () => {
          this._closeObject();
        },
        onopenarray: () => {
          this._openArray();
        },
        onclosearray: () => {
          this._closeArray();
        },
        onvalue: (value) => {
          this._pushOrSet(value);
        },
        onerror: (error) => {
          throw error;
        },
        onend: () => {
          this.result = this.currentState.container.pop();
        },
        ...options
      });
    }
    reset() {
      this.result = void 0;
      this.previousStates = [];
      this.currentState = Object.freeze({ container: [], key: null });
      this.jsonpath = new JSONPath();
    }
    write(chunk) {
      this.parser.write(chunk);
    }
    close() {
      this.parser.close();
    }
    // PRIVATE METHODS
    _pushOrSet(value) {
      const { container, key } = this.currentState;
      if (key !== null) {
        container[key] = value;
        this.currentState.key = null;
      } else {
        container.push(value);
      }
    }
    _openArray(newContainer = []) {
      this.jsonpath.push(null);
      this._pushOrSet(newContainer);
      this.previousStates.push(this.currentState);
      this.currentState = { container: newContainer, isArray: true, key: null };
    }
    _closeArray() {
      this.jsonpath.pop();
      this.currentState = this.previousStates.pop();
    }
    _openObject(newContainer = {}) {
      this.jsonpath.push(null);
      this._pushOrSet(newContainer);
      this.previousStates.push(this.currentState);
      this.currentState = { container: newContainer, isArray: false, key: null };
    }
    _closeObject() {
      this.jsonpath.pop();
      this.currentState = this.previousStates.pop();
    }
  };

  // src/lib/json-parser/streaming-json-parser.ts
  var StreamingJSONParser = class extends JSONParser {
    jsonPaths;
    streamingJsonPath = null;
    streamingArray = null;
    topLevelObject = null;
    constructor(options = {}) {
      super({
        onopenarray: () => {
          if (!this.streamingArray) {
            if (this._matchJSONPath()) {
              this.streamingJsonPath = this.getJsonPath().clone();
              this.streamingArray = [];
              this._openArray(this.streamingArray);
              return;
            }
          }
          this._openArray();
        },
        // Redefine onopenarray to inject value for top-level object
        onopenobject: (name) => {
          if (!this.topLevelObject) {
            this.topLevelObject = {};
            this._openObject(this.topLevelObject);
          } else {
            this._openObject({});
          }
          if (typeof name !== "undefined") {
            this.parser.emit("onkey", name);
          }
        }
      });
      const jsonpaths = options.jsonpaths || [];
      this.jsonPaths = jsonpaths.map((jsonpath) => new JSONPath(jsonpath));
    }
    /**
     * write REDEFINITION
     * - super.write() chunk to parser
     * - get the contents (so far) of "topmost-level" array as batch of rows
     * - clear top-level array
     * - return the batch of rows\
     */
    write(chunk) {
      super.write(chunk);
      let array = [];
      if (this.streamingArray) {
        array = [...this.streamingArray];
        this.streamingArray.length = 0;
      }
      return array;
    }
    /**
     * Returns a partially formed result object
     * Useful for returning the "wrapper" object when array is not top level
     * e.g. GeoJSON
     */
    getPartialResult() {
      return this.topLevelObject;
    }
    getStreamingJsonPath() {
      return this.streamingJsonPath;
    }
    getStreamingJsonPathAsString() {
      return this.streamingJsonPath && this.streamingJsonPath.toString();
    }
    getJsonPath() {
      return this.jsonpath;
    }
    // PRIVATE METHODS
    /**
     * Checks is this.getJsonPath matches the jsonpaths provided in options
     */
    _matchJSONPath() {
      const currentPath = this.getJsonPath();
      if (this.jsonPaths.length === 0) {
        return true;
      }
      for (const jsonPath of this.jsonPaths) {
        if (jsonPath.equals(currentPath)) {
          return true;
        }
      }
      return false;
    }
  };

  // src/lib/parsers/parse-json-in-batches.ts
  async function* parseJSONInBatches(binaryAsyncIterator, options) {
    const asyncIterator = makeTextDecoderIterator(binaryAsyncIterator);
    const { metadata } = options;
    const { jsonpaths } = options.json || {};
    let isFirstChunk = true;
    const schema = null;
    const tableBatchBuilder = new TableBatchBuilder(schema, options);
    const parser = new StreamingJSONParser({ jsonpaths });
    for await (const chunk of asyncIterator) {
      const rows = parser.write(chunk);
      const jsonpath2 = rows.length > 0 && parser.getStreamingJsonPathAsString();
      if (rows.length > 0 && isFirstChunk) {
        if (metadata) {
          const initialBatch = {
            // Common fields
            shape: options?.json?.shape || "array-row-table",
            batchType: "partial-result",
            data: [],
            length: 0,
            bytesUsed: 0,
            // JSON additions
            container: parser.getPartialResult(),
            jsonpath: jsonpath2
          };
          yield initialBatch;
        }
        isFirstChunk = false;
      }
      for (const row of rows) {
        tableBatchBuilder.addRow(row);
        const batch3 = tableBatchBuilder.getFullBatch({ jsonpath: jsonpath2 });
        if (batch3) {
          yield batch3;
        }
      }
      tableBatchBuilder.chunkComplete(chunk);
      const batch2 = tableBatchBuilder.getFullBatch({ jsonpath: jsonpath2 });
      if (batch2) {
        yield batch2;
      }
    }
    const jsonpath = parser.getStreamingJsonPathAsString();
    const batch = tableBatchBuilder.getFinalBatch({ jsonpath });
    if (batch) {
      yield batch;
    }
    if (metadata) {
      const finalBatch = {
        shape: "json",
        batchType: "final-result",
        container: parser.getPartialResult(),
        jsonpath: parser.getStreamingJsonPathAsString(),
        /** Data Just to avoid crashing? */
        data: [],
        length: 0
        // schema: null
      };
      yield finalBatch;
    }
  }
  function rebuildJsonObject(batch, data) {
    assert(batch.batchType === "final-result");
    if (batch.jsonpath === "$") {
      return data;
    }
    if (batch.jsonpath && batch.jsonpath.length > 1) {
      const topLevelObject = batch.container;
      const streamingPath = new JSONPath(batch.jsonpath);
      streamingPath.setFieldAtPath(topLevelObject, data);
      return topLevelObject;
    }
    return batch.container;
  }

  // src/json-loader.ts
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var JSONLoader = {
    dataType: null,
    batchType: null,
    name: "JSON",
    id: "json",
    module: "json",
    version: VERSION,
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json"],
    category: "table",
    text: true,
    options: {
      json: {
        shape: void 0,
        table: false,
        jsonpaths: []
        // batchSize: 'auto'
      }
    },
    parse,
    parseTextSync,
    parseInBatches
  };
  async function parse(arrayBuffer, options) {
    return parseTextSync(new TextDecoder().decode(arrayBuffer), options);
  }
  function parseTextSync(text, options) {
    const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options?.json } };
    return parseJSONSync(text, jsonOptions);
  }
  function parseInBatches(asyncIterator, options) {
    const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options?.json } };
    return parseJSONInBatches(asyncIterator, jsonOptions);
  }

  // src/lib/parsers/parse-ndjson.ts
  function parseNDJSONSync(ndjsonText) {
    const lines = ndjsonText.trim().split("\n");
    const parsedLines = lines.map((line, counter) => {
      try {
        return JSON.parse(line);
      } catch (error) {
        throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter + 1}`);
      }
    });
    return makeTableFromData(parsedLines);
  }

  // src/lib/parsers/parse-ndjson-in-batches.ts
  async function* parseNDJSONInBatches(binaryAsyncIterator, options) {
    const textIterator = makeTextDecoderIterator(binaryAsyncIterator);
    const lineIterator = makeLineIterator(textIterator);
    const numberedLineIterator = makeNumberedLineIterator(lineIterator);
    const schema = null;
    const shape = "row-table";
    const tableBatchBuilder = new TableBatchBuilder(schema, {
      ...options,
      shape
    });
    for await (const { counter, line } of numberedLineIterator) {
      try {
        const row = JSON.parse(line);
        tableBatchBuilder.addRow(row);
        tableBatchBuilder.chunkComplete(line);
        const batch2 = tableBatchBuilder.getFullBatch();
        if (batch2) {
          yield batch2;
        }
      } catch (error) {
        throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter}`);
      }
    }
    const batch = tableBatchBuilder.getFinalBatch();
    if (batch) {
      yield batch;
    }
  }

  // src/ndjson-loader.ts
  var VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var NDJSONLoader = {
    dataType: null,
    batchType: null,
    name: "NDJSON",
    id: "ndjson",
    module: "json",
    version: VERSION2,
    extensions: ["ndjson", "jsonl"],
    mimeTypes: [
      "application/x-ndjson",
      "application/jsonlines",
      // https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html#cm-batch
      "application/json-seq"
    ],
    category: "table",
    text: true,
    parse: async (arrayBuffer) => parseNDJSONSync(new TextDecoder().decode(arrayBuffer)),
    parseTextSync: parseNDJSONSync,
    parseInBatches: parseNDJSONInBatches,
    options: {}
  };

  // src/lib/encoders/json-encoder.ts
  function encodeTableAsJSON(table, options) {
    const shape = options?.json?.shape || "object-row-table";
    const strings = [];
    const rowIterator = makeRowIterator(table, shape);
    for (const row of rowIterator) {
      strings.push(JSON.stringify(row));
    }
    return `[${strings.join(",")}]`;
  }

  // src/json-writer.ts
  var JSONWriter = {
    id: "json",
    version: "latest",
    module: "json",
    name: "JSON",
    extensions: ["json"],
    mimeTypes: ["application/json"],
    options: {},
    text: true,
    encode: async (table, options) => new TextEncoder().encode(encodeTableAsJSON(table, options)).buffer,
    encodeTextSync: (table, options) => encodeTableAsJSON(table, options)
  };

  // ../../node_modules/@math.gl/polygon/dist/polygon-utils.js
  var DimIndex = {
    x: 0,
    y: 1,
    z: 2
  };
  function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = "xy" } = options;
    const dim = options.size || 2;
    let area2 = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for (let i = start, j = end - dim; i < end; i += dim) {
      area2 += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);
      j = i;
    }
    return area2 / 2;
  }

  // ../../node_modules/@math.gl/polygon/dist/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas, plane = "xy") {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x;
    let y;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = positions[i];
        y = positions[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2, plane) {
    let i;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, { start, end, size: dim, plane });
    }
    let i0 = DimIndex[plane[0]];
    let i1 = DimIndex[plane[1]];
    if (clockwise === area2 < 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i + i0], data[i + i1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i + i0], data[i + i1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start;
    let again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ;
    let n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
      const a = p.prev;
      const b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i;
    let len;
    let start;
    let end;
    let list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx)
            return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === 0)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let e;
    let i;
    let inSize = 1;
    let numMerges;
    let p;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p = start;
    let leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Vertex(a.i, a.x, a.y);
    const b2 = new Vertex(b.i, b.x, b.y);
    const an = a.next;
    const bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = new Vertex(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  var Vertex = class {
    constructor(i, x, y) {
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
      this.i = i;
      this.x = x;
      this.y = y;
    }
  };

  // ../gis/src/lib/binary-features/flat-geojson-to-binary.ts
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
    return fillArrays(
      features,
      {
        propArrayTypes,
        ...geometryInfo
      },
      {
        numericPropKeys: options && options.numericPropKeys || numericPropKeys,
        PositionDataType: options ? options.PositionDataType : Float32Array,
        triangulate: options ? options.triangulate : true
      }
    );
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    if (triangulate) {
      polygons.triangles = [];
    }
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T = propArrayTypes[propName];
        object.numericProps[propName] = new T(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({ id: feature.id });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({ id: feature.id });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({ id: feature.id });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.pointPosition,
      indexMap.pointPosition + nPositions
    );
    points.featureIds.fill(
      indexMap.pointFeature,
      indexMap.pointPosition,
      indexMap.pointPosition + nPositions
    );
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.linePosition,
      indexMap.linePosition + nPositions
    );
    lines.featureIds.fill(
      indexMap.lineFeature,
      indexMap.linePosition,
      indexMap.linePosition + nPositions
    );
    for (let i = 0, il = geometry.indices.length; i < il; ++i) {
      const start = geometry.indices[i];
      const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.polygonPosition,
      indexMap.polygonPosition + nPositions
    );
    polygons.featureIds.fill(
      indexMap.polygonFeature,
      indexMap.polygonPosition,
      indexMap.polygonPosition + nPositions
    );
    for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l];
      const indices = geometry.indices[l];
      const nextIndices = geometry.indices[l + 1];
      for (let i = 0, il = indices.length; i < il; ++i) {
        const start = indices[i];
        const end = i === il - 1 ? (
          // last line, so either read to:
          nextIndices === void 0 ? geometry.data.length : nextIndices[0]
        ) : indices[i + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
    }
  }
  function triangulatePolygon(polygons, areas, indices, {
    startPosition,
    endPosition,
    coordLength
  }) {
    if (!polygons.triangles) {
      return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t = 0, tl = triangles.length; t < tl; ++t) {
      polygons.triangles.push(startPosition + triangles[t]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = { value: obj[key], size };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
      shape: "binary-feature-collection",
      points: {
        ...points,
        positions: { value: points.positions, size: coordLength },
        globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
        featureIds: { value: points.featureIds, size: 1 },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: { value: lines.positions, size: coordLength },
        pathIndices: { value: lines.pathIndices, size: 1 },
        globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
        featureIds: { value: lines.featureIds, size: 1 },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: { value: polygons.positions, size: coordLength },
        polygonIndices: { value: polygons.polygonIndices, size: 1 },
        primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
        globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
        featureIds: { value: polygons.featureIds, size: 1 },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
      // triangles not expected
    };
    if (binaryFeatures.polygons && polygons.triangles) {
      binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
    }
    return binaryFeatures;
  }
  function fillNumericProperties(object, properties, index, length) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x, constructor) {
    if (constructor === Array || !Number.isFinite(x)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
  }

  // ../gis/src/lib/binary-features/extract-geometry-info.ts
  function extractGeometryInfo(features) {
    let pointPositionsCount = 0;
    let pointFeaturesCount = 0;
    let linePositionsCount = 0;
    let linePathsCount = 0;
    let lineFeaturesCount = 0;
    let polygonPositionsCount = 0;
    let polygonObjectsCount = 0;
    let polygonRingsCount = 0;
    let polygonFeaturesCount = 0;
    const coordLengths = /* @__PURE__ */ new Set();
    for (const feature of features) {
      const geometry = feature.geometry;
      switch (geometry.type) {
        case "Point":
          pointFeaturesCount++;
          pointPositionsCount++;
          coordLengths.add(geometry.coordinates.length);
          break;
        case "MultiPoint":
          pointFeaturesCount++;
          pointPositionsCount += geometry.coordinates.length;
          for (const point of geometry.coordinates) {
            coordLengths.add(point.length);
          }
          break;
        case "LineString":
          lineFeaturesCount++;
          linePositionsCount += geometry.coordinates.length;
          linePathsCount++;
          for (const coord of geometry.coordinates) {
            coordLengths.add(coord.length);
          }
          break;
        case "MultiLineString":
          lineFeaturesCount++;
          for (const line of geometry.coordinates) {
            linePositionsCount += line.length;
            linePathsCount++;
            for (const coord of line) {
              coordLengths.add(coord.length);
            }
          }
          break;
        case "Polygon":
          polygonFeaturesCount++;
          polygonObjectsCount++;
          polygonRingsCount += geometry.coordinates.length;
          const flattened = geometry.coordinates.flat();
          polygonPositionsCount += flattened.length;
          for (const coord of flattened) {
            coordLengths.add(coord.length);
          }
          break;
        case "MultiPolygon":
          polygonFeaturesCount++;
          for (const polygon of geometry.coordinates) {
            polygonObjectsCount++;
            polygonRingsCount += polygon.length;
            const flattened2 = polygon.flat();
            polygonPositionsCount += flattened2.length;
            for (const coord of flattened2) {
              coordLengths.add(coord.length);
            }
          }
          break;
        default:
          throw new Error(`Unsupported geometry type: ${geometry.type}`);
      }
    }
    return {
      coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount
    };
  }

  // ../gis/src/lib/binary-features/geojson-to-flat-geojson.ts
  function geojsonToFlatGeojson(features, options = { coordLength: 2, fixRingWinding: true }) {
    return features.map((feature) => flattenFeature(feature, options));
  }
  function flattenPoint(coordinates, data, indices, options) {
    indices.push(data.length);
    data.push(...coordinates);
    for (let i = coordinates.length; i < options.coordLength; i++) {
      data.push(0);
    }
  }
  function flattenLineString(coordinates, data, indices, options) {
    indices.push(data.length);
    for (const c of coordinates) {
      data.push(...c);
      for (let i = c.length; i < options.coordLength; i++) {
        data.push(0);
      }
    }
  }
  function flattenPolygon(coordinates, data, indices, areas, options) {
    let count = 0;
    const ringAreas = [];
    const polygons = [];
    for (const lineString of coordinates) {
      const lineString2d = lineString.map((p) => p.slice(0, 2));
      let area2 = getPolygonSignedArea(lineString2d.flat());
      const ccw = area2 < 0;
      if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {
        lineString.reverse();
        area2 = -area2;
      }
      ringAreas.push(area2);
      flattenLineString(lineString, data, polygons, options);
      count++;
    }
    if (count > 0) {
      areas.push(ringAreas);
      indices.push(polygons);
    }
  }
  function flattenFeature(feature, options) {
    const { geometry } = feature;
    if (geometry.type === "GeometryCollection") {
      throw new Error("GeometryCollection type not supported");
    }
    const data = [];
    const indices = [];
    let areas;
    let type;
    switch (geometry.type) {
      case "Point":
        type = "Point";
        flattenPoint(geometry.coordinates, data, indices, options);
        break;
      case "MultiPoint":
        type = "Point";
        geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));
        break;
      case "LineString":
        type = "LineString";
        flattenLineString(geometry.coordinates, data, indices, options);
        break;
      case "MultiLineString":
        type = "LineString";
        geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));
        break;
      case "Polygon":
        type = "Polygon";
        areas = [];
        flattenPolygon(geometry.coordinates, data, indices, areas, options);
        break;
      case "MultiPolygon":
        type = "Polygon";
        areas = [];
        geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));
        break;
      default:
        throw new Error(`Unknown type: ${type}`);
    }
    return { ...feature, geometry: { type, indices, data, areas } };
  }

  // ../gis/src/lib/binary-features/geojson-to-binary.ts
  function geojsonToBinary(features, options = { fixRingWinding: true, triangulate: true }) {
    const geometryInfo = extractGeometryInfo(features);
    const coordLength = geometryInfo.coordLength;
    const { fixRingWinding } = options;
    const flatFeatures = geojsonToFlatGeojson(features, { coordLength, fixRingWinding });
    return flatGeojsonToBinary(flatFeatures, geometryInfo, {
      numericPropKeys: options.numericPropKeys,
      PositionDataType: options.PositionDataType || Float32Array,
      triangulate: options.triangulate
    });
  }

  // src/geojson-loader.ts
  var VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var GeoJSONWorkerLoader = {
    dataType: null,
    batchType: null,
    name: "GeoJSON",
    id: "geojson",
    module: "geojson",
    version: VERSION3,
    worker: true,
    extensions: ["geojson"],
    mimeTypes: ["application/geo+json"],
    category: "geometry",
    text: true,
    options: {
      geojson: {
        shape: "geojson-table"
      },
      json: {
        shape: "object-row-table",
        jsonpaths: ["$", "$.features"]
      },
      gis: {
        format: "geojson"
      }
    }
  };
  var GeoJSONLoader = {
    ...GeoJSONWorkerLoader,
    // @ts-expect-error
    parse: parse2,
    // @ts-expect-error
    parseTextSync: parseTextSync2,
    parseInBatches: parseInBatches2
  };
  async function parse2(arrayBuffer, options) {
    return parseTextSync2(new TextDecoder().decode(arrayBuffer), options);
  }
  function parseTextSync2(text, options) {
    options = { ...GeoJSONLoader.options, ...options };
    options.geojson = { ...GeoJSONLoader.options.geojson, ...options.geojson };
    options.gis = options.gis || {};
    let geojson;
    try {
      geojson = JSON.parse(text);
    } catch {
      geojson = {};
    }
    const table = {
      shape: "geojson-table",
      // TODO - deduce schema from geojson
      // TODO check that parsed data is of type FeatureCollection
      type: "FeatureCollection",
      features: geojson?.features || []
    };
    switch (options.gis.format) {
      case "binary":
        return geojsonToBinary(table.features);
      default:
        return table;
    }
  }
  function parseInBatches2(asyncIterator, options) {
    options = { ...GeoJSONLoader.options, ...options };
    options.json = { ...GeoJSONLoader.options.geojson, ...options.geojson };
    const geojsonIterator = parseJSONInBatches(asyncIterator, options);
    switch (options.gis.format) {
      case "binary":
        return makeBinaryGeometryIterator(geojsonIterator);
      default:
        return geojsonIterator;
    }
  }
  async function* makeBinaryGeometryIterator(geojsonIterator) {
    for await (const batch of geojsonIterator) {
      batch.data = geojsonToBinary(batch.data);
      yield batch;
    }
  }

  // src/lib/encoder-utils/encode-utils.ts
  function detectGeometryColumnIndex(table) {
    const geometryIndex = table.schema?.fields.findIndex((field) => field.name === "geometry") ?? -1;
    if (geometryIndex > -1) {
      return geometryIndex;
    }
    if (getTableLength(table) > 0) {
      const row = getTableRowAsArray(table, 0);
      for (let columnIndex = 0; columnIndex < getTableNumCols(table); columnIndex++) {
        const value = row?.[columnIndex];
        if (value && typeof value === "object") {
          return columnIndex;
        }
      }
    }
    throw new Error("Failed to detect geometry column");
  }
  function getRowPropertyObject(table, row, excludeColumnIndices = []) {
    const properties = {};
    for (let columnIndex = 0; columnIndex < getTableNumCols(table); ++columnIndex) {
      const columnName = table.schema?.fields[columnIndex].name;
      if (columnName && !excludeColumnIndices.includes(columnIndex)) {
        properties[columnName] = row[columnName];
      }
    }
    return properties;
  }

  // src/lib/encoder-utils/encode-table-row.ts
  function encodeTableRow(table, rowIndex, geometryColumnIndex, utf8Encoder) {
    const row = getTableRowAsObject(table, rowIndex);
    if (!row)
      return;
    const featureWithProperties = getFeatureFromRow(table, row, geometryColumnIndex);
    const featureString = JSON.stringify(featureWithProperties);
    utf8Encoder.push(featureString);
  }
  function getFeatureFromRow(table, row, geometryColumnIndex) {
    const properties = getRowPropertyObject(table, row, [geometryColumnIndex]);
    const columnName = table.schema?.fields[geometryColumnIndex].name;
    let featureOrGeometry = columnName && row[columnName];
    if (!featureOrGeometry) {
      return { type: "Feature", geometry: null, properties };
    }
    if (typeof featureOrGeometry === "string") {
      try {
        featureOrGeometry = JSON.parse(featureOrGeometry);
      } catch (err) {
        throw new Error("Invalid string geometry");
      }
    }
    if (typeof featureOrGeometry !== "object" || typeof featureOrGeometry?.type !== "string") {
      throw new Error("invalid geometry column value");
    }
    if (featureOrGeometry?.type === "Feature") {
      return { ...featureOrGeometry, properties };
    }
    return { type: "Feature", geometry: featureOrGeometry, properties };
  }

  // src/lib/encoder-utils/utf8-encoder.ts
  var Utf8ArrayBufferEncoder = class {
    chunkSize;
    strings = [];
    totalLength = 0;
    textEncoder = new TextEncoder();
    constructor(chunkSize) {
      this.chunkSize = chunkSize;
    }
    push(...strings) {
      for (const string of strings) {
        this.strings.push(string);
        this.totalLength += string.length;
      }
    }
    isFull() {
      return this.totalLength >= this.chunkSize;
    }
    getArrayBufferBatch() {
      return this.textEncoder.encode(this.getStringBatch()).buffer;
    }
    getStringBatch() {
      const stringChunk = this.strings.join("");
      this.strings = [];
      this.totalLength = 0;
      return stringChunk;
    }
  };

  // src/lib/encoders/geojson-encoder.ts
  async function* encodeTableAsGeojsonInBatches(batchIterator, inputOpts = {}) {
    const options = { geojson: {}, chunkSize: 1e4, ...inputOpts };
    const utf8Encoder = new Utf8ArrayBufferEncoder(options.chunkSize);
    if (!options.geojson.featureArray) {
      utf8Encoder.push("{\n", '"type": "FeatureCollection",\n', '"features":\n');
    }
    utf8Encoder.push("[");
    let geometryColumn = options.geojson.geometryColumn;
    let isFirstLine = true;
    let start = 0;
    for await (const tableBatch of batchIterator) {
      const end = start + getTableLength(tableBatch);
      if (!geometryColumn) {
        geometryColumn = geometryColumn || detectGeometryColumnIndex(tableBatch);
      }
      for (let rowIndex = start; rowIndex < end; ++rowIndex) {
        if (!isFirstLine) {
          utf8Encoder.push(",");
        }
        utf8Encoder.push("\n");
        isFirstLine = false;
        encodeTableRow(tableBatch, rowIndex, geometryColumn, utf8Encoder);
        if (utf8Encoder.isFull()) {
          yield utf8Encoder.getArrayBufferBatch();
        }
        start = end;
      }
      const arrayBufferBatch = utf8Encoder.getArrayBufferBatch();
      if (arrayBufferBatch.byteLength > 0) {
        yield arrayBufferBatch;
      }
    }
    utf8Encoder.push("\n");
    utf8Encoder.push("]\n");
    if (!options.geojson.featureArray) {
      utf8Encoder.push("}");
    }
    yield utf8Encoder.getArrayBufferBatch();
  }

  // src/geojson-writer.ts
  var GeoJSONWriter = {
    id: "geojson",
    version: "latest",
    module: "geojson",
    name: "GeoJSON",
    extensions: ["geojson"],
    mimeTypes: ["application/geo+json"],
    text: true,
    options: {
      geojson: {
        featureArray: false,
        geometryColumn: null
      }
    },
    async encode(table, options) {
      const tableIterator = [table];
      const batches = encodeTableAsGeojsonInBatches(tableIterator, options);
      return await concatenateArrayBuffersAsync(batches);
    },
    encodeInBatches: (tableIterator, options) => encodeTableAsGeojsonInBatches(tableIterator, options)
  };
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
