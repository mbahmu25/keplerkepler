// loaders.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { geojsonToBinary } from '@loaders.gl/gis';
// import {parseJSONSync} from './lib/parsers/parse-json';
import { parseJSONInBatches } from "./lib/parsers/parse-json-in-batches.js";
// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION = typeof "4.3.3" !== 'undefined' ? "4.3.3" : 'latest';
/**
 * GeoJSON loader
 */
export const GeoJSONWorkerLoader = {
    dataType: null,
    batchType: null,
    name: 'GeoJSON',
    id: 'geojson',
    module: 'geojson',
    version: VERSION,
    worker: true,
    extensions: ['geojson'],
    mimeTypes: ['application/geo+json'],
    category: 'geometry',
    text: true,
    options: {
        geojson: {
            shape: 'geojson-table'
        },
        json: {
            shape: 'object-row-table',
            jsonpaths: ['$', '$.features']
        },
        gis: {
            format: 'geojson'
        }
    }
};
export const GeoJSONLoader = {
    ...GeoJSONWorkerLoader,
    // @ts-expect-error
    parse,
    // @ts-expect-error
    parseTextSync,
    parseInBatches
};
async function parse(arrayBuffer, options) {
    return parseTextSync(new TextDecoder().decode(arrayBuffer), options);
}
function parseTextSync(text, options) {
    // Apps can call the parse method directly, we so apply default options here
    options = { ...GeoJSONLoader.options, ...options };
    options.geojson = { ...GeoJSONLoader.options.geojson, ...options.geojson };
    options.gis = options.gis || {};
    let geojson;
    try {
        geojson = JSON.parse(text);
    }
    catch {
        geojson = {};
    }
    const table = {
        shape: 'geojson-table',
        // TODO - deduce schema from geojson
        // TODO check that parsed data is of type FeatureCollection
        type: 'FeatureCollection',
        features: geojson?.features || []
    };
    switch (options.gis.format) {
        case 'binary':
            return geojsonToBinary(table.features);
        default:
            return table;
    }
}
function parseInBatches(asyncIterator, options) {
    // Apps can call the parse method directly, we so apply default options here
    options = { ...GeoJSONLoader.options, ...options };
    options.json = { ...GeoJSONLoader.options.geojson, ...options.geojson };
    const geojsonIterator = parseJSONInBatches(asyncIterator, options);
    switch (options.gis.format) {
        case 'binary':
            return makeBinaryGeometryIterator(geojsonIterator);
        default:
            return geojsonIterator;
    }
}
async function* makeBinaryGeometryIterator(geojsonIterator) {
    for await (const batch of geojsonIterator) {
        batch.data = geojsonToBinary(batch.data);
        yield batch;
    }
}
