import * as arrow from 'apache-arrow';
import Layer, { LayerBaseConfig, LayerColorConfig, LayerSizeConfig, LayerBounds, LayerBaseConfigPartial, VisualChannel } from '../base-layer';
import { DataContainerInterface, ArrowDataContainer } from '@kepler.gl/utils';
import ArcLayerIcon from './arc-layer-icon';
import { ColorRange, RGBColor, Merge, VisConfigColorRange, VisConfigColorSelect, VisConfigNumber, VisConfigRange, LayerColumn, Field, AnimationConfig } from '@kepler.gl/types';
import { KeplerTable } from '@kepler.gl/table';
export declare type ArcLayerVisConfigSettings = {
    opacity: VisConfigNumber;
    thickness: VisConfigNumber;
    colorRange: VisConfigColorRange;
    sizeRange: VisConfigRange;
    targetColor: VisConfigColorSelect;
};
export declare type ArcLayerColumnsConfig = {
    lat0: LayerColumn;
    lat1: LayerColumn;
    lng0: LayerColumn;
    lng1: LayerColumn;
    lat: LayerColumn;
    lng: LayerColumn;
    neighbors: LayerColumn;
    geoarrow0: LayerColumn;
    geoarrow1: LayerColumn;
};
export declare type ArcLayerVisConfig = {
    colorRange: ColorRange;
    opacity: number;
    sizeRange: [number, number];
    targetColor: RGBColor;
    thickness: number;
};
export declare type ArcLayerVisualChannelConfig = LayerColorConfig & LayerSizeConfig;
export declare type ArcLayerConfig = Merge<LayerBaseConfig, {
    columns: ArcLayerColumnsConfig;
    visConfig: ArcLayerVisConfig;
}> & ArcLayerVisualChannelConfig;
export declare type ArcLayerData = {
    index: number;
    sourcePosition: [number, number, number];
    targetPosition: [number, number, number];
};
export declare type ArcLayerMeta = {
    bounds: LayerBounds;
};
export declare const arcRequiredColumns: string[];
export declare const neighborRequiredColumns: string[];
export declare const geoarrowRequiredColumns: string[];
export declare const arcColumnLabels: {
    lat0: string;
    lng0: string;
    lat1: string;
    lng1: string;
    neighbors: string;
};
export declare const arcVisConfigs: {
    opacity: 'opacity';
    thickness: 'thickness';
    colorRange: 'colorRange';
    sizeRange: 'strokeWidthRange';
    targetColor: 'targetColor';
};
export declare const COLUMN_MODE_POINTS = "points";
export declare const COLUMN_MODE_NEIGHBORS = "neighbors";
export declare const COLUMN_MODE_GEOARROW = "geoarrow";
export declare const arcPosAccessor: ({ lat0, lng0, lat1, lng1, lat, lng, geoarrow0, geoarrow1 }: ArcLayerColumnsConfig, columnMode: any) => (dc: DataContainerInterface) => (d: any) => any[];
export default class ArcLayer extends Layer {
    visConfigSettings: ArcLayerVisConfigSettings;
    config: ArcLayerConfig;
    meta: ArcLayerMeta;
    dataContainer: DataContainerInterface | null;
    geoArrowVector0: arrow.Vector | undefined;
    geoArrowVector1: arrow.Vector | undefined;
    filteredIndex: Uint8ClampedArray | null;
    filteredIndexTrigger: number[];
    constructor(props: any);
    get type(): string;
    get isAggregated(): boolean;
    get layerIcon(): typeof ArcLayerIcon;
    get columnLabels(): Record<string, string>;
    get columnPairs(): import("@kepler.gl/types").ColumnPairs;
    get supportedColumnModes(): {
        key: string;
        label: string;
        requiredColumns: string[];
    }[];
    get visualChannels(): {
        sourceColor: {
            property: string;
            key: string;
            accessor: string;
            defaultValue: (config: any) => any;
            field: string;
            scale: string;
            domain: string;
            range: string;
            channelScaleType: string;
            nullValue?: any;
            defaultMeasure?: any;
            condition?: ((config: any) => boolean) | undefined;
            getAttributeValue?: ((config: any) => (d: any) => any) | undefined;
            fixed?: any;
            supportedFieldTypes?: import("@kepler.gl/types").SupportedFieldTypes[] | undefined;
            aggregation?: import("@kepler.gl/types").VisualChannelAggregation | undefined;
        };
        targetColor: {
            property: string;
            key: string;
            accessor: string;
            defaultValue: (config: any) => any;
            field: string;
            scale: string;
            domain: string;
            range: string;
            channelScaleType: string;
            nullValue?: any;
            defaultMeasure?: any;
            condition?: ((config: any) => boolean) | undefined;
            getAttributeValue?: ((config: any) => (d: any) => any) | undefined;
            fixed?: any;
            supportedFieldTypes?: import("@kepler.gl/types").SupportedFieldTypes[] | undefined;
            aggregation?: import("@kepler.gl/types").VisualChannelAggregation | undefined;
        };
        size: {
            accessor: string;
            property: string;
            field: string;
            scale: string;
            domain: string;
            range: string;
            key: string;
            channelScaleType: string;
            nullValue?: any;
            defaultMeasure?: any;
            condition?: ((config: any) => boolean) | undefined;
            defaultValue?: any;
            getAttributeValue?: ((config: any) => (d: any) => any) | undefined;
            fixed?: any;
            supportedFieldTypes?: import("@kepler.gl/types").SupportedFieldTypes[] | undefined;
            aggregation?: import("@kepler.gl/types").VisualChannelAggregation | undefined;
        };
    };
    get columnValidators(): {
        lat0: (column: any, columns: any, allFields: any) => boolean;
        lng0: (column: any, columns: any, allFields: any) => boolean;
        lat1: (column: any, columns: any, allFields: any) => boolean;
        lng1: (column: any, columns: any, allFields: any) => boolean;
        lat: (column: any, columns: any, allFields: any) => boolean;
        lng: (column: any, columns: any, allFields: any) => boolean;
    };
    hasAllColumns(): boolean;
    static findDefaultLayerProps({ fieldPairs }: KeplerTable): {
        props: {
            color?: RGBColor;
            columns: ArcLayerColumnsConfig;
            label: string;
        }[];
    };
    getDefaultLayerConfig(props: LayerBaseConfigPartial): {
        columnMode: string;
        dataId: string;
        label: string;
        color: RGBColor;
        columns: import("@kepler.gl/types").LayerColumns;
        isVisible: boolean;
        isConfigActive: boolean;
        highlightColor: RGBColor | import("@kepler.gl/types").RGBAColor;
        hidden: boolean;
        visConfig: import("@kepler.gl/types").LayerVisConfig;
        textLabel: import("@kepler.gl/types").LayerTextLabel[];
        colorUI: {
            color: import("@kepler.gl/types").ColorUI;
            colorRange: import("@kepler.gl/types").ColorUI;
        };
        animation: {
            enabled: boolean;
            domain?: [number, number] | null | undefined;
        };
        aggregatedBins?: import("@kepler.gl/types").AggregatedBin[] | undefined;
        heightField?: import("@kepler.gl/types").VisualChannelField | undefined;
        heightDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        heightScale?: string | undefined;
        colorField?: import("@kepler.gl/types").VisualChannelField | undefined;
        colorDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        colorScale?: string | number | symbol | undefined;
        sizeDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        sizeScale?: string | number | symbol | undefined;
        sizeField?: import("@kepler.gl/types").VisualChannelField | undefined;
    };
    calculateDataAttributeForGeoArrow({ dataContainer, filteredIndex }: {
        dataContainer: ArrowDataContainer;
        filteredIndex: number[];
    }, getPosition: any): arrow.Table<any>;
    calculateDataAttributeForPoints({ filteredIndex }: {
        dataContainer: DataContainerInterface;
        filteredIndex: number[];
    }, getPosition: any): ArcLayerData[];
    calculateDataAttributeForPointNNeighbors({ dataContainer, filteredIndex }: {
        dataContainer: DataContainerInterface;
        filteredIndex: number[];
    }, getPosition: any): {
        index: number;
        sourcePosition: number[];
        targetPosition: number[];
    }[];
    calculateDataAttribute({ dataContainer, filteredIndex }: KeplerTable, getPosition: any): arrow.Table<any> | {
        index: number;
        sourcePosition: number[];
        targetPosition: number[];
    }[];
    formatLayerData(datasets: any, oldLayerData: any): {};
    updateLayerMeta(dataset: KeplerTable): void;
    renderLayer(opts: any): any[];
    hasHoveredObject(objectInfo: {
        index: number;
    }): any;
    getHoverData(object: {
        index: number;
    } | arrow.StructRow | undefined, dataContainer: DataContainerInterface, fields: Field[], animationConfig: AnimationConfig, hoverInfo: {
        index: number;
    }): import("@kepler.gl/utils").DataRow | null;
    getLegendVisualChannels(): {
        [key: string]: VisualChannel;
    };
}
