import { RGBColor, Field, FieldPair, FieldDomain, Filter, ProtoDataset, FilterRecord, FilterDatasetOpt, RangeFieldDomain, SelectFieldDomain, MultiSelectFieldDomain, TimeRangeFieldDomain } from '@kepler.gl/types';
import { DataContainerInterface, FilterChanged } from '@kepler.gl/utils';
declare type Layer = any;
export declare type GpuFilter = {
    filterRange: number[][];
    filterValueUpdateTriggers: {
        [id: string]: {
            name: string;
            domain0: number;
        } | null;
    };
    filterValueAccessor: (dc: DataContainerInterface) => (getIndex?: (any: any) => number, getData?: (dc_: DataContainerInterface, d: any, fieldIndex: number) => any) => (d: any, objectInfo?: {
        index: number;
    }) => (number | number[])[];
};
export declare type FilterProps = NumericFieldFilterProps | BooleanFieldFilterProps | StringFieldFilterProps | TimeFieldFilterProps;
export declare type NumericFieldFilterProps = RangeFieldDomain & {
    value: [number, number];
    type: string;
    typeOptions: string[];
    gpu: boolean;
    columnStats?: Record<string, any>;
};
export declare type BooleanFieldFilterProps = SelectFieldDomain & {
    type: string;
    value: boolean;
    gpu: boolean;
    columnStats?: Record<string, any>;
};
export declare type StringFieldFilterProps = MultiSelectFieldDomain & {
    type: string;
    value: string[];
    gpu: boolean;
    columnStats?: Record<string, any>;
};
export declare type TimeFieldFilterProps = TimeRangeFieldDomain & {
    type: string;
    view: Filter['view'];
    fixedDomain: boolean;
    value: number[];
    gpu: boolean;
    columnStats?: Record<string, any>;
};
export declare function maybeToDate(isTime: boolean, fieldIdx: number, format: string, dc: DataContainerInterface, d: {
    index: number;
}): any;
declare class KeplerTable<F extends Field = Field> {
    readonly id: string;
    type?: string;
    label: string;
    color: RGBColor;
    fields: F[];
    dataContainer: DataContainerInterface;
    allIndexes: number[];
    filteredIndex: number[];
    filteredIdxCPU?: number[];
    filteredIndexForDomain: number[];
    fieldPairs: FieldPair[];
    gpuFilter: GpuFilter;
    filterRecord?: FilterRecord;
    filterRecordCPU?: FilterRecord;
    changedFilters?: FilterChanged;
    sortColumn?: {
        [key: string]: string;
    };
    sortOrder?: number[] | null;
    pinnedColumns?: string[];
    supportedFilterTypes?: string[] | null;
    disableDataOperation?: boolean;
    metadata: Record<string, any>;
    getFileProcessor?: (data: any, inputFormat?: string) => {
        data: any;
        format: string;
    };
    constructor({ info, color, metadata, supportedFilterTypes, disableDataOperation }: {
        info?: ProtoDataset['info'];
        color: RGBColor;
        metadata?: ProtoDataset['metadata'];
        supportedFilterTypes?: ProtoDataset['supportedFilterTypes'];
        disableDataOperation?: ProtoDataset['disableDataOperation'];
    });
    importData({ data }: {
        data: ProtoDataset['data'];
    }): Promise<void>;
    /**
     * update table with new data
     * @param data - new data e.g. the arrow data with new batches loaded
     */
    update(data: ProtoDataset['data']): Promise<this>;
    get length(): number;
    /**
     * Get field
     * @param columnName
     */
    getColumnField(columnName: string): F | undefined;
    /**
     * Get fieldIdx
     * @param columnName
     */
    getColumnFieldIdx(columnName: string): number;
    /**
     * Get displayFormat
     * @param columnName
     */
    getColumnDisplayFormat(columnName: any): string | undefined;
    /**
     * Get the value of a cell
     */
    getValue(columnName: string, rowIdx: number): any;
    /**
     * Updates existing field with a new object
     * @param fieldIdx
     * @param newField
     */
    updateColumnField(fieldIdx: number, newField: F): void;
    /**
     * Update dataset color by custom color
     * @param newColor
     */
    updateTableColor(newColor: RGBColor): void;
    /**
     * Save filterProps to field and retrieve it
     * @param columnName
     */
    getColumnFilterProps(columnName: string): F['filterProps'] | null | undefined;
    /**
     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`
     * @param filters
     * @param layers
     * @param opt
     */
    filterTable(filters: Filter[], layers: Layer[], opt?: FilterDatasetOpt): KeplerTable<Field>;
    /**
     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`
     * @param filters
     * @param layers
     */
    filterTableCPU(filters: Filter[], layers: Layer[]): KeplerTable<Field>;
    /**
     * Calculate field domain based on field type and data
     * for Filter
     */
    getColumnFilterDomain(field: F): FieldDomain;
    /**
     *  Get the domain of this column based on scale type
     */
    getColumnLayerDomain(field: F, scaleType: string): number[] | string[] | [number, number] | null;
    /**
     * Get a sample of rows to calculate layer boundaries
     */
    /**
     * Parse cell value based on column type and return a string representation
     * Value the field value, type the field type
     */
    /**
     * Assert whether field exist
     * @param fieldName
     * @param condition
     */
    _assetField(fieldName: string, condition: any): void;
}
export declare type Datasets = {
    [key: string]: KeplerTable<Field>;
};
/**
 * Find point fields pairs from fields
 *
 * @param fields
 * @returns found point fields
 */
export declare function findPointFieldPairs(fields: Field[]): FieldPair[];
/**
 *
 * @param dataset
 * @param column
 * @param mode
 * @type
 */
export declare function sortDatasetByColumn(dataset: KeplerTable<Field>, column: string, mode?: string): KeplerTable<Field>;
export declare function pinTableColumns(dataset: KeplerTable<Field>, column: string): KeplerTable<Field>;
export declare function copyTable(original: KeplerTable<Field>): KeplerTable<Field>;
/**
 * @type
 * @returns
 */
export declare function copyTableAndUpdate(original: KeplerTable<Field>, options?: Partial<KeplerTable<Field>>): KeplerTable<Field>;
export declare function getFieldValueAccessor<F extends {
    type?: Field['type'];
    format?: Field['format'];
}>(f: F, i: number, dc: DataContainerInterface): (d: {
    index: number;
}) => any;
export default KeplerTable;
