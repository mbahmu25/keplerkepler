import { Bin, TimeBins, Millisecond, TimeRangeFilter, RangeFilter, PlotType, Filter, LineChart, Field, ValueOf } from '@kepler.gl/types';
import { AggregationTypes } from '@kepler.gl/constants';
import { DataContainerInterface } from '.';
import { KeplerTableModel } from './types';
declare type Datasets = any;
/**
 *
 * @param thresholds
 * @param values
 * @param indexes
 */
export declare function histogramFromThreshold(thresholds: number[], values: number[], valueAccessor?: (d: unknown) => number, filterEmptyBins?: boolean): Bin[];
/**
 *
 * @param values
 * @param numBins
 * @param valueAccessor
 */
export declare function histogramFromValues(values: (Millisecond | null | number)[], numBins: number, valueAccessor?: (d: number) => number): {
    count: number;
    indexes: import("d3-array").Bin<number, number>;
    x0: number | undefined;
    x1: number | undefined;
}[];
export declare function histogramFromOrdinal(domain: [string], values: (Millisecond | null | number)[], valueAccessor?: (d: unknown) => string): Bin[];
/**
 *
 * @param domain
 * @param values
 * @param numBins
 * @param valueAccessor
 */
export declare function histogramFromDomain(domain: [number, number], values: (Millisecond | null | number)[], numBins: number, valueAccessor?: (d: unknown) => number): Bin[];
/**
 * @param filter
 * @param datasets
 * @param interval
 */
export declare function getTimeBins(filter: TimeRangeFilter, datasets: Datasets, interval: PlotType['interval']): TimeBins;
export declare function binByTime(indexes: any, dataset: any, interval: any, filter: any): Bin[] | null;
export declare function getBinThresholds(interval: string, domain: number[]): number[];
/**
 * Run GPU filter on current filter result to generate indexes for ploting chart
 * Skip ruuning for the same field
 * @param dataset
 * @param filter
 */
export declare function runGpuFilterForPlot<K extends KeplerTableModel<K, L>, L>(dataset: K, filter?: Filter): number[];
export declare function getFilterDataFunc(filterRange: any, getFilterValue: any, dataContainer: DataContainerInterface, skips: any): (index: any) => any;
export declare function validBin(b: any): boolean;
/**
 * Use in slider, given a number and an array of numbers, return the nears number from the array.
 * Takes a value, timesteps and return the actual step.
 * @param value
 * @param marks
 */
export declare function snapToMarks(value: number, marks: number[]): number;
export declare function normalizeValue(val: any, minValue: any, step: any, marks: any): number;
export declare function isPercentField(field: any): any;
export declare function updateAggregationByField(field: Field, aggregation: ValueOf<AggregationTypes>): ValueOf<"count" | "average" | "maximum" | "minimum" | "median" | "stdev" | "sum" | "variance" | "mode" | "countUnique">;
export declare const getValueAggrFunc: (field: Field | string | null, aggregation: string, dataset: KeplerTableModel<any, any>) => (bin: Bin) => number;
export declare const getAggregationOptiosnBasedOnField: (field: any) => import("@kepler.gl/constants").TimeAggregation[];
export declare function getPctChange(y: unknown, y0: unknown): number | null;
/**
 *
 * @param datasets
 * @param filter
 */
export declare function getLineChart(datasets: Datasets, filter: Filter): LineChart;
export declare function splitSeries(series: any): {
    lines: any[];
    markers: any;
};
declare type MinVisStateForAnimationWindow = {
    datasets: Datasets;
};
export declare function adjustValueToAnimationWindow<S extends MinVisStateForAnimationWindow>(state: S, filter: TimeRangeFilter): {
    plotType: {
        interval: any;
    };
    timeBins: TimeBins;
    value: any[];
    dataId: string[];
    id: string;
    enabled: boolean;
    fixedDomain: boolean;
    view: import("@kepler.gl/types").FilterViewType;
    isAnimating: boolean;
    speed: number;
    showTimeDisplay?: boolean | undefined;
    name: string[];
    type: "timeRange";
    fieldIdx: number[];
    domain: any[] & [number, number];
    mappedValue: number[] & (number | null)[];
    yAxis: any;
    lineChart?: LineChart | undefined;
    gpu: boolean;
    gpuChannel?: number[] | undefined;
    fieldType: "timestamp";
    layerId?: string[] | undefined;
    step: number;
    defaultTimeFormat?: string | null | undefined;
    timeFormat?: string | null | undefined;
    timezone?: string | null | undefined;
    syncedWithLayerTimeline: boolean;
    syncTimelineMode: import("@kepler.gl/types").SyncTimelineMode;
    animationWindow: string;
    invertTrendColor: boolean;
};
/**
 *
 * @param filter
 * @param plotType
 * @param datasets
 * @param dataId
 */
export declare function updateTimeFilterPlotType(filter: TimeRangeFilter, plotType: TimeRangeFilter['plotType'], datasets: Datasets, _dataId?: string): TimeRangeFilter;
export declare function getRangeFilterBins(filter: any, datasets: any, numBins: any): any;
export declare function updateRangeFilterPlotType(filter: RangeFilter, plotType: RangeFilter['plotType'], datasets: Datasets, _dataId?: string): RangeFilter;
export declare function getChartTitle(yAxis: Field, plotType: PlotType): string;
export declare function getDefaultPlotType(filter: any, datasets: any): {
    interval: string;
    defaultTimeFormat: string;
    type: "histogram";
    aggregation: "sum";
};
export {};
