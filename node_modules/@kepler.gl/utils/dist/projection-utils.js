"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAPBOX_TILE_SIZE = void 0;
exports.getCenterAndZoomFromBounds = getCenterAndZoomFromBounds;
exports.normalizeEvent = normalizeEvent;
exports.validateBounds = validateBounds;
var _geoViewport = _interopRequireDefault(require("@mapbox/geo-viewport"));
var _console = _interopRequireDefault(require("global/console"));
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

var MAPBOX_TILE_SIZE = exports.MAPBOX_TILE_SIZE = 512;
function isLat(num) {
  return Number.isFinite(num) && num <= 90 && num >= -90;
}
function isLng(num) {
  return Number.isFinite(num) && num <= 180 && num >= -180;
}

/**
 * bounds should be [minLng, minLat, maxLng, maxLat]
 * @param {*} bounds
 */
function validateBounds(bounds) {
  // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]
  // validate bounds
  if (Array.isArray(bounds) && bounds.length === 4 && [bounds[0], bounds[2]].every(isLng) && [bounds[1], bounds[3]].every(isLat)) {
    return bounds;
  }
  return null;
}
function getCenterAndZoomFromBounds(bounds, _ref) {
  var width = _ref.width,
    height = _ref.height;
  var validBounds = validateBounds(bounds);
  if (!validBounds) {
    _console["default"].warn('invalid map bounds provided');
    return null;
  }

  // viewport(bounds, dimensions, minzoom, maxzoom, tileSize, allowFloat)
  var _geoViewport$viewport = _geoViewport["default"].viewport(bounds, [width, height], undefined, undefined, MAPBOX_TILE_SIZE, true),
    zoom = _geoViewport$viewport.zoom;
  // center being calculated by geo-vieweport.viewport has a complex logic that
  // projects and then unprojects the coordinates to determine the center
  // Calculating a simple average instead as that is the expected behavior in most of cases
  var center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2];

  // NOTE: this logic is used in deck.gl normalizeViewportProps
  // This is required in order to prevent projection matrix mismatch between basemap and layers
  var minZoom = Math.log2(height / MAPBOX_TILE_SIZE);
  if (zoom <= minZoom) {
    zoom = minZoom;
    center[1] = 0;
  }
  return {
    zoom: zoom,
    center: center
  };
}

/**
 * Add extra info about screen space position and world position to the event.
 * @param {*} event Event to normalize.
 * @param {*} viewport Current viewport.
 * @returns Normalized event with extra information compatible with React-map-gl MapLayerMouseEvent
 * https://visgl.github.io/react-map-gl/docs/api-reference/types#maplayermouseevent
 */
function normalizeEvent(event, viewport) {
  var _event$target;
  var bounds = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.getBoundingClientRect();
  if (!bounds) {
    return event;
  }
  var x = event.clientX - bounds.left;
  var y = event.clientY - bounds.top;
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return event;
  }
  event.point = [x, y];
  var location = viewport.unproject(event.point, {
    targetZ: 0
  });
  event.lngLat = [location[0], location[1]];
  return event;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2VvVmlld3BvcnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9jb25zb2xlIiwiTUFQQk9YX1RJTEVfU0laRSIsImV4cG9ydHMiLCJpc0xhdCIsIm51bSIsIk51bWJlciIsImlzRmluaXRlIiwiaXNMbmciLCJ2YWxpZGF0ZUJvdW5kcyIsImJvdW5kcyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImV2ZXJ5IiwiZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMiLCJfcmVmIiwid2lkdGgiLCJoZWlnaHQiLCJ2YWxpZEJvdW5kcyIsIkNvbnNvbGUiLCJ3YXJuIiwiX2dlb1ZpZXdwb3J0JHZpZXdwb3J0IiwiZ2VvVmlld3BvcnQiLCJ2aWV3cG9ydCIsInVuZGVmaW5lZCIsInpvb20iLCJjZW50ZXIiLCJtaW5ab29tIiwiTWF0aCIsImxvZzIiLCJub3JtYWxpemVFdmVudCIsImV2ZW50IiwiX2V2ZW50JHRhcmdldCIsInRhcmdldCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIngiLCJjbGllbnRYIiwibGVmdCIsInkiLCJjbGllbnRZIiwidG9wIiwicG9pbnQiLCJsb2NhdGlvbiIsInVucHJvamVjdCIsInRhcmdldFoiLCJsbmdMYXQiXSwic291cmNlcyI6WyIuLi9zcmMvcHJvamVjdGlvbi11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgZ2VvVmlld3BvcnQgZnJvbSAnQG1hcGJveC9nZW8tdmlld3BvcnQnO1xuXG5pbXBvcnQgV2ViTWVyY2F0b3JWaWV3cG9ydCBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCBDb25zb2xlIGZyb20gJ2dsb2JhbC9jb25zb2xlJztcblxuZXhwb3J0IGNvbnN0IE1BUEJPWF9USUxFX1NJWkUgPSA1MTI7XG5cbmZ1bmN0aW9uIGlzTGF0KG51bSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG51bSkgJiYgbnVtIDw9IDkwICYmIG51bSA+PSAtOTA7XG59XG5mdW5jdGlvbiBpc0xuZyhudW0pIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW0pICYmIG51bSA8PSAxODAgJiYgbnVtID49IC0xODA7XG59XG5cbi8qKlxuICogYm91bmRzIHNob3VsZCBiZSBbbWluTG5nLCBtaW5MYXQsIG1heExuZywgbWF4TGF0XVxuICogQHBhcmFtIHsqfSBib3VuZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQm91bmRzKGJvdW5kcykge1xuICAvLyBhcnJheTogWyAtMTgwLCAtODUuMDUxMTI4Nzc5ODA2NTksIDE4MCwgODUuMDUxMTI4Nzc5ODA2NiBdXG4gIC8vIHZhbGlkYXRlIGJvdW5kc1xuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShib3VuZHMpICYmXG4gICAgYm91bmRzLmxlbmd0aCA9PT0gNCAmJlxuICAgIFtib3VuZHNbMF0sIGJvdW5kc1syXV0uZXZlcnkoaXNMbmcpICYmXG4gICAgW2JvdW5kc1sxXSwgYm91bmRzWzNdXS5ldmVyeShpc0xhdClcbiAgKSB7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlckFuZFpvb21Gcm9tQm91bmRzKGJvdW5kcywge3dpZHRoLCBoZWlnaHR9KSB7XG4gIGNvbnN0IHZhbGlkQm91bmRzID0gdmFsaWRhdGVCb3VuZHMoYm91bmRzKTtcbiAgaWYgKCF2YWxpZEJvdW5kcykge1xuICAgIENvbnNvbGUud2FybignaW52YWxpZCBtYXAgYm91bmRzIHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB2aWV3cG9ydChib3VuZHMsIGRpbWVuc2lvbnMsIG1pbnpvb20sIG1heHpvb20sIHRpbGVTaXplLCBhbGxvd0Zsb2F0KVxuICBsZXQge3pvb219ID0gZ2VvVmlld3BvcnQudmlld3BvcnQoXG4gICAgYm91bmRzLFxuICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIE1BUEJPWF9USUxFX1NJWkUsXG4gICAgdHJ1ZVxuICApO1xuICAvLyBjZW50ZXIgYmVpbmcgY2FsY3VsYXRlZCBieSBnZW8tdmlld2Vwb3J0LnZpZXdwb3J0IGhhcyBhIGNvbXBsZXggbG9naWMgdGhhdFxuICAvLyBwcm9qZWN0cyBhbmQgdGhlbiB1bnByb2plY3RzIHRoZSBjb29yZGluYXRlcyB0byBkZXRlcm1pbmUgdGhlIGNlbnRlclxuICAvLyBDYWxjdWxhdGluZyBhIHNpbXBsZSBhdmVyYWdlIGluc3RlYWQgYXMgdGhhdCBpcyB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IgaW4gbW9zdCBvZiBjYXNlc1xuICBjb25zdCBjZW50ZXIgPSBbKGJvdW5kc1swXSArIGJvdW5kc1syXSkgLyAyLCAoYm91bmRzWzFdICsgYm91bmRzWzNdKSAvIDJdO1xuXG4gIC8vIE5PVEU6IHRoaXMgbG9naWMgaXMgdXNlZCBpbiBkZWNrLmdsIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHNcbiAgLy8gVGhpcyBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBwcmV2ZW50IHByb2plY3Rpb24gbWF0cml4IG1pc21hdGNoIGJldHdlZW4gYmFzZW1hcCBhbmQgbGF5ZXJzXG4gIGNvbnN0IG1pblpvb20gPSBNYXRoLmxvZzIoaGVpZ2h0IC8gTUFQQk9YX1RJTEVfU0laRSk7XG4gIGlmICh6b29tIDw9IG1pblpvb20pIHtcbiAgICB6b29tID0gbWluWm9vbTtcbiAgICBjZW50ZXJbMV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHt6b29tLCBjZW50ZXJ9O1xufVxuXG4vKipcbiAqIEFkZCBleHRyYSBpbmZvIGFib3V0IHNjcmVlbiBzcGFjZSBwb3NpdGlvbiBhbmQgd29ybGQgcG9zaXRpb24gdG8gdGhlIGV2ZW50LlxuICogQHBhcmFtIHsqfSBldmVudCBFdmVudCB0byBub3JtYWxpemUuXG4gKiBAcGFyYW0geyp9IHZpZXdwb3J0IEN1cnJlbnQgdmlld3BvcnQuXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGV2ZW50IHdpdGggZXh0cmEgaW5mb3JtYXRpb24gY29tcGF0aWJsZSB3aXRoIFJlYWN0LW1hcC1nbCBNYXBMYXllck1vdXNlRXZlbnRcbiAqIGh0dHBzOi8vdmlzZ2wuZ2l0aHViLmlvL3JlYWN0LW1hcC1nbC9kb2NzL2FwaS1yZWZlcmVuY2UvdHlwZXMjbWFwbGF5ZXJtb3VzZWV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVFdmVudChldmVudDogYW55LCB2aWV3cG9ydDogV2ViTWVyY2F0b3JWaWV3cG9ydCkge1xuICBjb25zdCBib3VuZHMgPSBldmVudC50YXJnZXQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gYm91bmRzLnRvcDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGV2ZW50LnBvaW50ID0gW3gsIHldO1xuICBjb25zdCBsb2NhdGlvbiA9IHZpZXdwb3J0LnVucHJvamVjdChldmVudC5wb2ludCwge3RhcmdldFo6IDB9KTtcbiAgZXZlbnQubG5nTGF0ID0gW2xvY2F0aW9uWzBdLCBsb2NhdGlvblsxXV07XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBR0EsSUFBQUEsWUFBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBR0EsSUFBQUMsUUFBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBTkE7QUFDQTs7QUFPTyxJQUFNRSxnQkFBZ0IsR0FBQUMsT0FBQSxDQUFBRCxnQkFB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