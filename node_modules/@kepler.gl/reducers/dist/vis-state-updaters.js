"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.DEFAULT_ANIMATION_CONFIG = void 0;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.applyCPUFilterUpdater = exports.addLayerUpdater = exports.addFilterUpdater = exports.addEffectUpdater = void 0;
exports.applyFilterConfigUpdater = applyFilterConfigUpdater;
exports.applyLayerConfigUpdater = applyLayerConfigUpdater;
exports.applyMergersUpdater = applyMergersUpdater;
exports.closeSpecificMapAtIndex = closeSpecificMapAtIndex;
exports.copyTableColumnUpdater = copyTableColumnUpdater;
exports.defaultInteractionConfig = exports.createOrUpdateFilterUpdater = exports.createNewDatasetSuccessUpdater = void 0;
exports.deleteFeatureUpdater = deleteFeatureUpdater;
exports.duplicateLayerUpdater = void 0;
exports.initialFileLoadingProgress = initialFileLoadingProgress;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.isFilterAnimationConfig = isFilterAnimationConfig;
exports.layerAnimationChangeUpdater = layerAnimationChangeUpdater;
exports.layerColorUIChangeUpdater = exports.layerClickUpdater = void 0;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerDataIdChangeUpdater = layerDataIdChangeUpdater;
exports.layerFilteredItemsChangeUpdater = layerFilteredItemsChangeUpdater;
exports.layerHoverUpdater = void 0;
exports.layerSetIsValidUpdater = layerSetIsValidUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerToggleVisibilityUpdater = layerToggleVisibilityUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.loadFileStepSuccessUpdater = loadFileStepSuccessUpdater;
exports.loadFilesUpdater = exports.loadFilesErrUpdater = void 0;
exports.loadNextFileUpdater = loadNextFileUpdater;
exports.makeLoadFileTask = makeLoadFileTask;
exports.nextFileBatchUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = void 0;
exports.parseProgress = parseProgress;
exports.pinTableColumnUpdater = pinTableColumnUpdater;
exports.prepareStateForDatasetReplace = prepareStateForDatasetReplace;
exports.processFileContentUpdater = processFileContentUpdater;
exports.receiveMapConfigUpdater = void 0;
exports.removeDatasetUpdater = removeDatasetUpdater;
exports.removeFilterUpdater = exports.removeEffectUpdater = void 0;
exports.removeLayerUpdater = removeLayerUpdater;
exports.renameDatasetUpdater = renameDatasetUpdater;
exports.reorderLayerUpdater = exports.reorderEffectUpdater = void 0;
exports.replaceDatasetDepsInState = replaceDatasetDepsInState;
exports.resetMapConfigUpdater = void 0;
exports.setAnimationConfigUpdater = setAnimationConfigUpdater;
exports.setColumnDisplayFormatUpdater = setColumnDisplayFormatUpdater;
exports.setEditorModeUpdater = void 0;
exports.setFeaturesUpdater = setFeaturesUpdater;
exports.setFilterAnimationTimeConfigUpdater = setFilterAnimationTimeConfigUpdater;
exports.setFilterAnimationTimeUpdater = setFilterAnimationTimeUpdater;
exports.setFilterAnimationWindowUpdater = setFilterAnimationWindowUpdater;
exports.setFilterPlotUpdater = void 0;
exports.setFilterUpdater = setFilterUpdater;
exports.setFilterViewUpdater = void 0;
exports.setInitialLayerConfig = setInitialLayerConfig;
exports.setLayerAnimationTimeConfigUpdater = setLayerAnimationTimeConfigUpdater;
exports.setMapInfoUpdater = exports.setLayerAnimationTimeUpdater = void 0;
exports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;
exports.setSelectedFeatureUpdater = void 0;
exports.setTimeFilterTimelineModeUpdater = setTimeFilterTimelineModeUpdater;
exports.showDatasetTableUpdater = void 0;
exports.sortTableColumnUpdater = sortTableColumnUpdater;
exports.syncTimeFilterWithLayerTimelineUpdater = syncTimeFilterWithLayerTimelineUpdater;
exports.toggleEditorVisibilityUpdater = toggleEditorVisibilityUpdater;
exports.toggleSplitMapUpdater = exports.toggleLayerForMapUpdater = exports.toggleLayerAnimationUpdater = exports.toggleLayerAnimationControlUpdater = exports.toggleFilterFeatureUpdater = exports.toggleFilterAnimationUpdater = void 0;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.updateDatasetPropsUpdater = updateDatasetPropsUpdater;
exports.updateEffectUpdater = void 0;
exports.updateFileLoadingProgressUpdater = updateFileLoadingProgressUpdater;
exports.updateOverlayBlendingUpdater = exports.updateLayerBlendingUpdater = exports.updateLayerAnimationSpeedUpdater = exports.updateFilterAnimationSpeedUpdater = void 0;
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.updateStateWithLayerAndData = updateStateWithLayerAndData;
exports.updateVisDataUpdater = exports.updateTableColorUpdater = void 0;
var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _bbox = _interopRequireDefault(require("@turf/bbox"));
var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _window = require("global/window");
var _lodash = _interopRequireDefault(require("lodash.clonedeep"));
var _lodash2 = _interopRequireDefault(require("lodash.get"));
var _lodash3 = _interopRequireDefault(require("lodash.isequal"));
var _lodash4 = _interopRequireDefault(require("lodash.pick"));
var _lodash5 = _interopRequireDefault(require("lodash.uniq"));
var _lodash6 = _interopRequireDefault(require("lodash.xor"));
var _tasks = _interopRequireWildcard(require("react-palm/tasks"));
var _tasks2 = require("@kepler.gl/tasks");
var _actions = require("@kepler.gl/actions");
var _utils = require("@kepler.gl/utils");
var _commonUtils = require("@kepler.gl/common-utils");
var _constants = require("@kepler.gl/constants");
var _layers = require("@kepler.gl/layers");
var _composerHelpers = require("./composer-helpers");
var _mergerHandler = require("./merger-handler");
var _visStateMerger = require("./vis-state-merger");
var _schemas = _interopRequireDefault(require("@kepler.gl/schemas"));
var _table = require("@kepler.gl/table");
var _interactionUtils = require("./interaction-utils");
var _layerUtils = require("./layer-utils");
var _effects = require("@kepler.gl/effects");
var _dataUtils = require("./data-utils");
var _excluded = ["dataId"],
  _excluded2 = ["info"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
// Tasks
// Actions
// Utils
// Mergers
// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();

/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var visStateUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */

var defaultInteractionConfig = exports.defaultInteractionConfig = {
  tooltip: {
    id: 'tooltip',
    label: 'interactions.tooltip',
    enabled: true,
    config: {
      fieldsToShow: {},
      compareMode: false,
      compareType: _constants.COMPARE_TYPES.ABSOLUTE
    }
  },
  geocoder: {
    id: 'geocoder',
    label: 'interactions.geocoder',
    enabled: false,
    position: null
  },
  brush: {
    id: 'brush',
    label: 'interactions.brush',
    enabled: false,
    config: {
      // size is in km
      size: 0.5
    }
  },
  coordinate: {
    id: 'coordinate',
    label: 'interactions.coordinate',
    enabled: false,
    position: null
  }
};
var DEFAULT_ANIMATION_CONFIG = exports.DEFAULT_ANIMATION_CONFIG = {
  domain: null,
  currentTime: null,
  speed: 1,
  isAnimating: false,
  timeSteps: null,
  timeFormat: null,
  timezone: null,
  defaultTimeFormat: null,
  hideControl: false,
  duration: null
};
var DEFAULT_EDITOR = exports.DEFAULT_EDITOR = {
  mode: _constants.EDITOR_MODES.DRAW_POLYGON,
  features: [],
  selectedFeature: null,
  visible: true
};

/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @public
 */
var INITIAL_VIS_STATE = exports.INITIAL_VIS_STATE = {
  // map info
  mapInfo: {
    title: '',
    description: ''
  },
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  // effects
  effects: [],
  effectOrder: [],
  interactionConfig: defaultInteractionConfig,
  interactionToBeMerged: {},
  layerBlending: 'normal',
  overlayBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  maxDefaultTooltips: _constants.MAX_DEFAULT_TOOLTIPS,
  // this is used when user split maps
  splitMaps: [
    // this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  splitMapsToBeMerged: [],
  isMergingDatasets: {},
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: DEFAULT_ANIMATION_CONFIG,
  editor: DEFAULT_EDITOR,
  fileLoading: false,
  fileLoadingProgress: {},
  loaders: [],
  loadOptions: {},
  // visStateMergers
  mergers: _visStateMerger.VIS_STATE_MERGERS,
  // kepler schemas
  schema: _schemas["default"]
};
/**
 * Update state with updated layer and layerData
 *
 */
function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
    layer = _ref.layer,
    idx = _ref.idx;
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}
function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;
  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, state), {}, {
      splitMaps: layer.config.isVisible ? (0, _utils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }
  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }
  return newState;
}

/**
 * Compares two objects (or arrays) and returns a new object with only the
 * properties that have changed between the two objects.
 */
function pickChangedProps(prev, next) {
  var changedProps = {};
  var pickPropsOf = function pickPropsOf(obj) {
    Object.keys(obj).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(changedProps, key) && !(0, _lodash3["default"])(prev[key], next[key])) {
        changedProps[key] = next[key];
      }
    });
  };
  pickPropsOf(prev);
  pickPropsOf(next);
  return changedProps;
}
var VISUAL_CHANNEL_PROP_TYPES = ['field', 'scale', 'domain', 'aggregation'];

/**
 * Apply layer config
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity, max-statements
function applyLayerConfigUpdater(state, action) {
  var _serializeLayer;
  var oldLayerId = action.oldLayerId,
    newLayerConfig = action.newLayerConfig,
    layerIndex = action.layerIndex;
  var newParsedLayer =
  // will move visualChannels to the config prop
  (0, _visStateMerger.parseLayerConfig)(state.schema, newLayerConfig);
  var oldLayer = state.layers.find(function (l) {
    return l.id === oldLayerId;
  });
  if (!oldLayer || !newParsedLayer) {
    return state;
  }
  if (layerIndex !== null && layerIndex !== undefined && state.layers[layerIndex] !== oldLayer) {
    // layerIndex is provided, but it doesn't match the oldLayer
    return state;
  }
  var dataset = state.datasets[newParsedLayer.config.dataId];
  if (!dataset) {
    return state;
  }
  // Make sure the layer is valid and convert it to Layer
  var newLayer = (0, _visStateMerger.validateLayerWithData)(dataset, newParsedLayer, state.layerClasses);
  if (!newLayer) {
    return state;
  }
  var nextState = state;
  if (newLayer.type && newLayer.type !== oldLayer.type) {
    var oldLayerIndex = state.layers.findIndex(function (l) {
      return l.id === oldLayerId;
    });
    if (oldLayerIndex >= 0) {
      nextState = layerTypeChangeUpdater(nextState, (0, _actions.layerTypeChange)(oldLayer, newLayer.type));
      // layerTypeChangeUpdater changes the id of the layer, so we need to obtain the new id
      // but first make sure that the layer was not removed
      if (nextState.layers.length === state.layers.length) {
        var newLayerId = nextState.layers[oldLayerIndex].id;
        nextState = applyLayerConfigUpdater(nextState, (0, _actions.applyLayerConfig)(newLayerId, _objectSpread(_objectSpread({}, newLayerConfig), {}, {
          id: newLayerId
        })));
      }
    }
    return nextState;
  }

  // serializeLayer() might return null if the old layer is not valid,
  // we should still apply the changes in that case
  var serializedOldLayer = (_serializeLayer = (0, _visStateMerger.serializeLayer)(oldLayer, state.schema)) !== null && _serializeLayer !== void 0 ? _serializeLayer : {
    config: {}
  };
  var serializedNewLayer = (0, _visStateMerger.serializeLayer)(newLayer, state.schema);
  if (!serializedNewLayer) {
    return state;
  }
  if (!(0, _lodash3["default"])(serializedOldLayer, serializedNewLayer)) {
    var changed = pickChangedProps(serializedOldLayer.config, serializedNewLayer.config);
    if ('visConfig' in changed) {
      if (changed.visConfig) {
        nextState = layerVisConfigChangeUpdater(nextState, (0, _actions.layerVisConfigChange)(oldLayer, changed.visConfig));
      }
      delete changed.visConfig;
    }
    Object.keys(oldLayer.visualChannels).forEach(function (channelName) {
      var channel = oldLayer.visualChannels[channelName];
      var channelPropNames = VISUAL_CHANNEL_PROP_TYPES.map(function (prop) {
        return channel[prop];
      });
      if (channelPropNames.some(function (prop) {
        return prop in changed;
      })) {
        nextState = layerVisualChannelChangeUpdater(nextState, (0, _actions.layerVisualChannelConfigChange)(oldLayer, (0, _lodash4["default"])(newLayer.config, channelPropNames), channelName));
        var _iterator = _createForOfIteratorHelper(channelPropNames),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var prop = _step.value;
            delete changed[prop];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    });
    if (Object.keys(changed).length > 0) {
      nextState = layerConfigChangeUpdater(nextState, (0, _actions.layerConfigChange)(oldLayer, (0, _lodash4["default"])(newLayer.config, Object.keys(changed))));
    }
  }
  return nextState;
}
function updatelayerVisibilty(state, newLayer, isVisible) {
  var newState = updateStateOnLayerVisibilityChange(state, newLayer);
  var filterIndex = filterSyncedWithTimeline(state);
  if ((0, _utils.isLayerAnimatable)(newLayer) && filterIndex !== -1) {
    // if layer is going to be visible we sync with filter otherwise we need to check whether other animatable layers exists and are visible
    newState = syncTimeFilterWithLayerTimelineUpdater(newState, {
      idx: filterIndex,
      enable: isVisible ? isVisible : (0, _utils.getAnimatableVisibleLayers)(state.layers).length > 0
    });
  }
  return newState;
}

/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */
// eslint-disable-next-line complexity
function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);
  if (typeof action.newConfig.dataId === 'string' && action.newConfig.dataId !== oldLayer.config.dataId) {
    var _action$newConfig = action.newConfig,
      dataId = _action$newConfig.dataId,
      restConfig = (0, _objectWithoutProperties2["default"])(_action$newConfig, _excluded);
    var stateWithDataId = layerDataIdChangeUpdater(state, {
      oldLayer: oldLayer,
      newConfig: {
        dataId: dataId
      }
    });
    var nextLayer = stateWithDataId.layers.find(function (l) {
      return l.id === oldLayer.id;
    });
    return nextLayer && Object.keys(restConfig).length ? layerConfigChangeUpdater(stateWithDataId, {
      oldLayer: nextLayer,
      newConfig: restConfig
    }) : stateWithDataId;
  }
  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData;
  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);
    newLayer = updateLayerDataResult.layer;
    layerData = updateLayerDataResult.layerData;
  }
  var newState = state;
  if ('isVisible' in action.newConfig) {
    newState = updatelayerVisibilty(newState, newLayer, action.newConfig.isVisible);
  }
  if ('columns' in action.newConfig && newLayer.config.animation.enabled) {
    // TODO: Shan, make the animation config function more robust
    newState = updateAnimationDomain(newState);
  }
  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}
function layerAnimationChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    prop = action.prop,
    value = action.value;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    animation: _objectSpread(_objectSpread({}, oldLayer.config.animation), {}, (0, _defineProperty2["default"])({}, prop, value))
  });
  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[idx]),
    layerData = _calculateLayerData.layerData,
    layer = _calculateLayerData.layer;
  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

/**
 * Update layerId, isVisible, splitMapId
 * handles two cases:
 * 1) toggle the visibility of local SplitMap layer (visState.splitMap.layers)
 * 2) toggle the visibility of global layer (visState.layers)

 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerToggleVisibilityUpdater(state, action) {
  var layerId = action.layerId,
    isVisible = action.isVisible,
    splitMapId = action.splitMapId;
  var layer = state.layers.find(function (d) {
    return d.id === layerId;
  });
  if (!layer) {
    return state;
  }
  var newState = state;
  if (splitMapId) {
    // [case 1]: toggle local layer visibility for each SplitMap
    var mapIndex = newState.splitMaps.findIndex(function (sm) {
      return sm.id === splitMapId;
    });
    if (isVisible) {
      // 1) if the layer is invisible globally
      // -> set global visibility to true
      newState = layerConfigChangeUpdater(newState, (0, _actions.layerConfigChange)(layer, {
        isVisible: true
      }));

      // -> set local visibility to true and the local visibilities of all other SplitMaps to false
      return _objectSpread(_objectSpread({}, newState), {}, {
        splitMaps: newState.splitMaps.map(function (sm) {
          return sm.id !== splitMapId ? _objectSpread(_objectSpread({}, sm), {}, {
            layers: _objectSpread(_objectSpread({}, sm.layers), {}, (0, _defineProperty2["default"])({}, layerId, false))
          }) : _objectSpread(_objectSpread({}, sm), {}, {
            layers: _objectSpread(_objectSpread({}, sm.layers), {}, (0, _defineProperty2["default"])({}, layerId, true))
          });
        })
      });
    }
    // 2) else when the layer is visible globally
    return toggleLayerForMapUpdater(newState, (0, _actions.toggleLayerForMap)(mapIndex, layerId));
  } else {
    // [case 2]: toggle global layer visibility
    var newLayer = layer.updateLayerConfig({
      isVisible: isVisible
    });
    var idx = newState.layers.findIndex(function (l) {
      return l.id === layerId;
    });
    newState = updatelayerVisibilty(newState, newLayer, isVisible);
    return updateStateWithLayerAndData(newState, {
      layer: newLayer,
      idx: idx
    });
  }
}

/**
 *
 * @param state
 * @returns index of the filter synced to timeline or -1
 */
function filterSyncedWithTimeline(state) {
  return state.filters.findIndex(function (f) {
    return f.syncedWithLayerTimeline;
  });
}

/**
 * Updates isValid flag of a layer.
 * Updates isVisible based on the value of isValid.
 * Triggers update of data for the layer in order to get errors again during next update iteration.
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerSetIsValidUpdater(state, action) {
  var oldLayer = action.oldLayer,
    isValid = action.isValid;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var layerToUpdate = state.layers[idx];
  if (layerToUpdate) {
    var newLayer;
    var newData = null;
    if (isValid) {
      // Trigger data update in order to show errors again if present.
      var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(layerToUpdate, state, undefined),
        layer = _calculateLayerData2.layer,
        layerData = _calculateLayerData2.layerData;
      newLayer = layer;
      newData = layerData;
    } else {
      newLayer = layerToUpdate.updateLayerConfig({
        isVisible: false
      });
      newLayer.isValid = false;
    }
    return updateStateWithLayerAndData(state, {
      idx: idx,
      layer: newLayer,
      layerData: newData
    });
  }
  return state;
}
function addOrRemoveTextLabels(newFields, textLabel) {
  var defaultTextLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  });

  // delete
  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [defaultTextLabel] : newTextLabel;

  // add
  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread(_objectSpread({}, defaultTextLabel), {}, {
      field: af
    });
  })));
  return newTextLabel;
}
function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!Object.prototype.hasOwnProperty.call(textLabel[idx], prop)) {
    return textLabel;
  }
  var newTextLabel = textLabel.slice();
  if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  } else if (prop) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread(_objectSpread({}, tl), {}, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  }
  return newTextLabel;
}

/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerTextLabelChangeUpdater(state, action) {
  var _oldLayer$getDefaultL, _oldLayer$getDefaultL2;
  var oldLayer = action.oldLayer,
    idx = action.idx,
    prop = action.prop,
    value = action.value;
  var textLabel = oldLayer.config.textLabel;

  // when adding a new empty text label,
  // rely on the layer's default config, or use the constant DEFAULT_TEXT_LABEL
  var defaultTextLabel = (_oldLayer$getDefaultL = (_oldLayer$getDefaultL2 = oldLayer.getDefaultLayerConfig({
    dataId: ''
  })) === null || _oldLayer$getDefaultL2 === void 0 || (_oldLayer$getDefaultL2 = _oldLayer$getDefaultL2.textLabel) === null || _oldLayer$getDefaultL2 === void 0 ? void 0 : _oldLayer$getDefaultL2[0]) !== null && _oldLayer$getDefaultL !== void 0 ? _oldLayer$getDefaultL : _constants.DEFAULT_TEXT_LABEL;
  var newTextLabel = textLabel.slice();
  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [defaultTextLabel]);
  }
  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel, defaultTextLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  }
  // update text label prop and value
  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}
function validateExistingLayerWithData(dataset, layerClasses, layer, schema) {
  var loadedLayer = (0, _visStateMerger.serializeLayer)(layer, schema);
  return loadedLayer ? (0, _visStateMerger.validateLayerWithData)(dataset, loadedLayer, layerClasses, {
    allowEmptyColumn: true
  }) : null;
}

/**
 * Update layer config dataId
 * @memberof visStateUpdaters
 * @returns nextState
 */
function layerDataIdChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newConfig = action.newConfig;
  var dataId = newConfig.dataId;
  if (!oldLayer || !state.datasets[dataId]) {
    return state;
  }
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig({
    dataId: dataId
  });

  // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved
  if (newLayer.isValidToSave()) {
    var validated = validateExistingLayerWithData(state.datasets[dataId], state.layerClasses, newLayer, state.schema);
    // if cant validate it with data create a new one
    if (!validated) {
      var oldLayerType = oldLayer.type;
      if (oldLayerType) {
        newLayer = new state.layerClasses[oldLayerType]({
          dataId: dataId,
          id: oldLayer.id
        });
      }
    } else {
      newLayer = validated;
    }
  }
  newLayer = newLayer.updateLayerConfig({
    isVisible: oldLayer.config.isVisible,
    isConfigActive: true
  });
  newLayer.updateLayerDomain(state.datasets);
  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, undefined),
    layerData = _calculateLayerData3.layerData,
    layer = _calculateLayerData3.layer;
  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
function setInitialLayerConfig(layer, datasets, layerClasses) {
  var newLayer = layer;
  if (!Object.keys(datasets).length) {
    // no data is loaded
    return layer;
  }
  if (!layer.config.dataId) {
    // set layer dataId
    newLayer = layer.updateLayerConfig({
      dataId: Object.keys(datasets)[0]
    });
  }
  var dataset = datasets[newLayer.config.dataId];
  if (!dataset) {
    return layer;
  }

  // find defaut layer props
  var result = typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function' ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, []) : {
    props: []
  };

  // an array of possible props, use 1st one
  var props = Array.isArray(result) ? result : result.props || [];
  if (props.length) {
    newLayer = new layerClasses[layer.type](_objectSpread(_objectSpread({}, props[0]), {}, {
      label: newLayer.config.label,
      dataId: newLayer.config.dataId,
      isConfigActive: newLayer.config.isConfigActive
    }));
  }
  return typeof newLayer.setInitialLayerConfig === 'function' ? newLayer.setInitialLayerConfig(dataset) : newLayer;
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @public
 */
function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newType = action.newType;
  if (!oldLayer) {
    return state;
  }
  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });
  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));
    return state;
  }
  var newLayer = new state.layerClasses[newType]({
    // keep old layer lable and isConfigActive
    label: oldLayer.config.label,
    isConfigActive: oldLayer.config.isConfigActive,
    dataId: oldLayer.config.dataId
  });
  if (!oldLayer.type) {
    // if setting layer type on an empty layer
    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);
  } else {
    // get a mint layer, with new id and type
    // because deck.gl uses id to match between new and old layer.
    // If type has changed but id is the same, it will break

    var defaultLayerProps = typeof state.layerClasses[newType].findDefaultLayerProps === 'function' ? state.layerClasses[newType].findDefaultLayerProps(state.datasets[newLayer.config.dataId]) : null;
    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings, state.datasets, defaultLayerProps);
    newLayer.updateLayerDomain(state.datasets);
  }
  var clicked = state.clicked,
    hoverInfo = state.hoverInfo;
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo
  });
  var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, newState),
    layerData = _calculateLayerData4.layerData,
    layer = _calculateLayerData4.layer;
  newState = updateStateWithLayerAndData(newState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }

  // update splitMap layer id
  if (state.splitMaps.length) {
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
          oldLayerMap = _settings$layers[oldId],
          otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread(_objectSpread({}, settings), {}, {
          layers: _objectSpread(_objectSpread({}, otherLayers), {}, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  }

  // update layerOrder with new id
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    layerOrder: newState.layerOrder.map(function (layerId) {
      return layerId === oldLayer.id ? newLayer.id : layerId;
    })
  });
  return newState;
}

/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @returns {Object} nextState
 * @public
 */
function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
    newConfig = action.newConfig,
    newVisConfig = action.newVisConfig,
    channel = action.channel;
  if (!oldLayer.config.dataId) {
    return state;
  }
  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  if (newVisConfig) newLayer = newLayer.updateLayerVisConfig(newVisConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);

  // calling update animation domain first to merge all layer animation domain
  var updatedState = updateAnimationDomain(state);
  var visualChannel = oldLayer.visualChannels[channel];
  if ((visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.channelScaleType) === _constants.CHANNEL_SCALES.color && newConfig[visualChannel.field]) {
    // if color field changed, set customBreaks to false
    newLayer.updateLayerColorUI(visualChannel.range, {
      colorRangeConfig: _objectSpread(_objectSpread({}, newLayer.config.colorUI[visualChannel.range].colorRangeConfig), {}, {
        customBreaks: false
      })
    });
    updatedState = _objectSpread(_objectSpread({}, updatedState), {}, {
      layers: updatedState.layers.map(function (l) {
        return l.id === oldLayer.id ? newLayer : l;
      })
    });
  }
  var oldLayerData = updatedState.layerData[idx];
  var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, updatedState, oldLayerData),
    layerData = _calculateLayerData5.layerData,
    layer = _calculateLayerData5.layer;
  if ((visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.channelScaleType) === _constants.CHANNEL_SCALES.color && newConfig[visualChannel === null || visualChannel === void 0 ? void 0 : visualChannel.scale] === _constants.SCALE_TYPES.customOrdinal && !newVisConfig) {
    // when switching to customOrdinal scale, create a customPalette in colorUI with updated colorDomain
    var customPalette = (0, _utils.initCustomPaletteByCustomScale)({
      scale: _constants.SCALE_TYPES.customOrdinal,
      field: layer.config[visualChannel.field],
      ordinalDomain: layer.config[layer.visualChannels[channel].domain],
      range: layer.config.visConfig[visualChannel.range],
      colorBreaks: null
    });
    // update colorRange with new customPalette
    layer.updateLayerColorUI(visualChannel.range, {
      showColorChart: true,
      colorRangeConfig: _objectSpread(_objectSpread({}, layer.config.colorUI[visualChannel.range].colorRangeConfig), {}, {
        customBreaks: true
      }),
      customPalette: customPalette
    });
  }
  return updateStateWithLayerAndData(updatedState, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}

/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @public
 */
function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);
  var newVisConfig = _objectSpread(_objectSpread({}, oldLayer.config.visConfig), action.newVisConfig);
  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });
  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var _calculateLayerData6 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),
      layerData = _calculateLayerData6.layerData,
      layer = _calculateLayerData6.layer;
    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }
  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}

/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @public
 *
 */
var setLayerAnimationTimeUpdater = exports.setLayerAnimationTimeUpdater = function setLayerAnimationTimeUpdater(state, _ref2) {
  var value = _ref2.value;
  var currentTime = Array.isArray(value) ? value[0] : value;
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      currentTime: currentTime
    })
  });
  // update animation config for each layer
  return state.layers.reduce(function (accu, l) {
    if (l.config.animation.enabled && l.type !== 'trip') {
      return layerAnimationChangeUpdater(accu, {
        oldLayer: l,
        prop: 'currentTime',
        currentTime: currentTime
      });
    }
    return accu;
  }, nextState);
};

/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */
function setFilterAnimationTimeUpdater(state, action) {
  return setFilterUpdater(state, action);
}

/**
 * Update filter animation window
 * @memberof visStateUpdaters
 * @public
 */
function setFilterAnimationWindowUpdater(state, _ref3) {
  var id = _ref3.id,
    animationWindow = _ref3.animationWindow;
  var filter = state.filters.find(function (f) {
    return f.id === id;
  });
  if (!filter) {
    return state;
  }
  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    animationWindow: animationWindow
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(state.filters)
  });
  var newSyncTimelineMode = getSyncAnimationMode(newFilter);
  return setTimeFilterTimelineModeUpdater(newState, {
    id: id,
    mode: newSyncTimelineMode
  });
}
function applyFilterConfigUpdater(state, action) {
  var _serializeFilter;
  var filterId = action.filterId,
    newFilter = action.newFilter;
  var oldFilter = state.filters.find(function (f) {
    return f.id === filterId;
  });
  if (!oldFilter) {
    return state;
  }

  // Serialize the filters to only compare the saved properties
  var serializedOldFilter = (_serializeFilter = (0, _visStateMerger.serializeFilter)(oldFilter, state.schema)) !== null && _serializeFilter !== void 0 ? _serializeFilter : {
    config: {}
  };
  var serializedNewFilter = (0, _visStateMerger.serializeFilter)(newFilter, state.schema);
  if (!serializedNewFilter || (0, _lodash3["default"])(serializedOldFilter, serializedNewFilter)) {
    return state;
  }

  // If there are any changes to the filter, apply them
  var changed = pickChangedProps(serializedOldFilter, serializedNewFilter);
  delete changed['id']; // id should not be changed

  var filterIndex = state.filters.findIndex(function (f) {
    return f.id === filterId;
  });
  if (filterIndex < 0) {
    return state;
  }
  return setFilterUpdater(state, (0, _actions.setFilter)(filterIndex, Object.keys(changed), Object.values(changed)));
}

/**
 * Update filter property
 * @memberof visStateUpdaters
 * @public
 */
function setFilterUpdater(state, action) {
  var idx = action.idx,
    _action$valueIndex = action.valueIndex,
    valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;
  var oldFilter = state.filters[idx];
  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));
    return state;
  }
  if (Array.isArray(action.prop) && (!Array.isArray(action.value) || action.prop.length !== action.value.length)) {
    _window.console.error('Expecting value to be an array of the same length, since prop is an array');
    return state;
  }
  // convert prop and value to array
  var props = (0, _commonUtils.toArray)(action.prop);
  var values = Array.isArray(action.prop) ? (0, _commonUtils.toArray)(action.value) : [action.value];
  var newFilter = oldFilter;
  var newState = state;
  var datasetIdsToFilter = [];
  var _loop = function _loop() {
    var prop = props[i];
    var value = values[i];
    // We currently do not support passing in name as an array into _updateFilterProp, so we call it multiple times with each name
    // See the comment in there as to what should be addressed
    var res;
    if (prop === 'name' && Array.isArray(value)) {
      // eslint-disable-next-line no-loop-func
      res = value.reduce(function (accu, v) {
        return _updateFilterProp(accu, newFilter, prop, v, valueIndex);
      }, newState);
    } else {
      res = _updateFilterProp(newState, newFilter, prop, value, valueIndex);
    }
    newFilter = res.filter;
    newState = res.state;
    datasetIdsToFilter = datasetIdsToFilter.concat(res.datasetIdsToFilter);
  };
  for (var i = 0; i < props.length; i++) {
    _loop();
  }
  var enlargedFilter = state.filters.find(function (f) {
    return f.view === _constants.FILTER_VIEW_TYPES.enlarged;
  });
  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {
    // there should be only one enlarged filter
    newFilter.view = _constants.FILTER_VIEW_TYPES.side;
  }

  // save new filters to newState
  newState = (0, _utils.set)(['filters', idx], newFilter, newState);

  // filter data
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)((0, _lodash5["default"])(datasetIdsToFilter), newState.datasets, newState.filters, newState.layers);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);

  // need to update filterPlot after filter Dataset for plot to update on filtered result
  var filterWithPLot = (0, _utils.updateFilterPlot)(newState.datasets, newState.filters[idx]);
  newState = (0, _utils.set)(['filters', idx], filterWithPLot, newState);

  // dataId is an array
  // pass only the dataset we need to update
  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);

  // If time range filter value was updated, adjust animation config
  if (newFilter.type === _constants.FILTER_TYPES.timeRange && props.includes('value')) {
    newState = adjustAnimationConfigWithFilter(newState, action.idx);
  }
  return newState;
}
function _updateFilterDataIdAtValueIndex(filter, valueIndex, value, datasets) {
  var newFilter = filter;
  if (filter.dataId[valueIndex]) {
    // if dataId already exist
    newFilter = _removeFilterDataIdAtValueIndex(filter, valueIndex, datasets);
  }
  if (value) {
    var nextValue = newFilter.dataId.slice();
    nextValue[valueIndex] = value;
    newFilter = (0, _utils.set)(['dataId'], nextValue, newFilter);
  }
  return newFilter;
}
function _removeFilterDataIdAtValueIndex(filter, valueIndex, datasets) {
  var dataId = filter.dataId[valueIndex];
  if (filter.dataId.length === 1 && valueIndex === 0) {
    // if remove the only dataId, create an empty filter instead;
    return (0, _utils.getDefaultFilter)({
      id: filter.id
    });
  }
  if (dataId) {
    filter = (0, _utils.removeFilterPlot)(filter, dataId);
  }
  for (var _i = 0, _arr = ['dataId', 'name', 'fieldIdx', 'gpuChannel']; _i < _arr.length; _i++) {
    var prop = _arr[_i];
    if (Array.isArray(filter[prop])) {
      var nextVal = filter[prop].slice();
      nextVal.splice(valueIndex, 1);
      filter = (0, _utils.set)([prop], nextVal, filter);
    }
  }

  // mergeFieldDomain for the remaining fields
  var domainSteps = (0, _utils.mergeFilterDomain)(filter, datasets);
  var nextFilter = _objectSpread(_objectSpread({}, filter), domainSteps ? {
    domain: domainSteps === null || domainSteps === void 0 ? void 0 : domainSteps.domain,
    step: domainSteps === null || domainSteps === void 0 ? void 0 : domainSteps.step
  } : {});
  var nextValue = (0, _utils.adjustValueToFilterDomain)(nextFilter.value, nextFilter);
  return _objectSpread(_objectSpread({}, nextFilter), {}, {
    value: nextValue
  });
}

/** *
 * Updates a single property of a filter
 */
function _updateFilterProp(state, filter, prop, value, valueIndex, datasetIds) {
  var datasetIdsToFilter = [];
  switch (prop) {
    // TODO: Next PR for UI if we update filterDataId, we need to consider two cases:
    // 1. dataId is empty: create a default filter
    // 2. Add a new dataset id
    case _utils.FILTER_UPDATER_PROPS.dataId:
      {
        var oldDataId = (0, _toConsumableArray2["default"])(filter.dataId);
        filter = _updateFilterDataIdAtValueIndex(filter, valueIndex, value, state.datasets);
        datasetIdsToFilter = (0, _lodash5["default"])([].concat((0, _toConsumableArray2["default"])(oldDataId), (0, _toConsumableArray2["default"])(filter.dataId)));
        break;
      }
    case _utils.FILTER_UPDATER_PROPS.name:
      {
        // we are supporting the current functionality
        // TODO: Next PR for UI filter name will only update filter name but it won't have side effects
        // we are gonna use pair of datasets and fieldIdx to update the filter
        var datasetId = filter.dataId[valueIndex];
        var _applyFilterFieldName = (0, _utils.applyFilterFieldName)(filter, state.datasets, datasetId, value, valueIndex, {
            mergeDomain: valueIndex > 0
          }),
          updatedFilter = _applyFilterFieldName.filter,
          newDataset = _applyFilterFieldName.dataset;
        if (updatedFilter) {
          filter = updatedFilter;
          if (filter.gpu) {
            filter = (0, _table.setFilterGpuMode)(filter, state.filters);
            filter = (0, _table.assignGpuChannel)(filter, state.filters);
          }
          state = (0, _utils.set)(['datasets', datasetId], newDataset, state);
          // remove filter Plot at datasetId, so it will be recalculated
          filter = (0, _utils.removeFilterPlot)(filter, datasetId);
          datasetIdsToFilter = updatedFilter.dataId;
        }
        // only filter the current dataset
        break;
      }
    case _utils.FILTER_UPDATER_PROPS.layerId:
      {
        // We need to update only datasetId/s if we have added/removed layers
        // - check for layerId changes (XOR works because of string values)
        // if no differences between layerIds, don't do any filtering
        // @ts-ignore
        var layerIdDifference = (0, _lodash6["default"])(value, filter.layerId);
        var layerDataIds = (0, _lodash5["default"])(layerIdDifference.map(function (lid) {
          return (0, _lodash2["default"])(state.layers.find(function (l) {
            return l.id === lid;
          }), ['config', 'dataId']);
        }).filter(function (d) {
          return d;
        }));

        // only filter datasetsIds
        datasetIdsToFilter = layerDataIds;

        // Update newFilter dataIds
        var newDataIds = (0, _lodash5["default"])(value === null || value === void 0 ? void 0 : value.map(function (lid) {
          return (0, _lodash2["default"])(state.layers.find(function (l) {
            return l.id === lid;
          }), ['config', 'dataId']);
        }).filter(function (d) {
          return d;
        }));
        filter = _objectSpread(_objectSpread({}, filter), {}, {
          layerId: value,
          dataId: newDataIds
        });
        break;
      }
    default:
      filter = (0, _utils.set)([prop], value, filter);
      datasetIdsToFilter = (0, _toConsumableArray2["default"])(filter.dataId);
      break;
  }
  return {
    filter: filter,
    datasetIds: datasetIds,
    datasetIdsToFilter: datasetIdsToFilter,
    state: state
  };
}
/* eslint-enable max-statements */

/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @public
 */
var setFilterPlotUpdater = exports.setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref4) {
  var idx = _ref4.idx,
    newProp = _ref4.newProp;
  if (!state.filters[idx]) {
    _window.console.error("filters[".concat(idx, "] is undefined"));
    return state;
  }
  var newFilter = state.filters[idx];
  for (var prop in newProp) {
    if (prop === 'plotType') {
      newFilter = (0, _composerHelpers.pick_)('plotType')((0, _composerHelpers.merge_)(newProp.plotType))(newFilter);
    } else if (prop === 'yAxis') {
      var chartType = newProp.yAxis ? _constants.PLOT_TYPES.lineChart : _constants.PLOT_TYPES.histogram;
      newFilter = (0, _composerHelpers.pick_)('plotType')((0, _composerHelpers.merge_)({
        type: chartType
      }))((0, _composerHelpers.merge_)(newProp)(newFilter));
    }
  }
  newFilter = (0, _utils.updateFilterPlot)(state.datasets, newFilter);
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};

/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @public
 */
var addFilterUpdater = exports.addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread(_objectSpread({}, state), {}, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _utils.getDefaultFilter)({
      dataId: action.dataId,
      id: action.id
    })])
  });
};

/**
 * Create or update a filter
 * @memberof visStateUpdaters
 * @public
 */
var createOrUpdateFilterUpdater = exports.createOrUpdateFilterUpdater = function createOrUpdateFilterUpdater(state, action) {
  var id = action.id,
    dataId = action.dataId,
    field = action.field,
    value = action.value;
  var newState = state;
  var originalIndex = newState.filters.findIndex(function (f) {
    return f.id === id;
  });
  var filterIndex = originalIndex;
  if (!id && !dataId) {
    return newState;
  }
  if (originalIndex < 0 && dataId) {
    newState = addFilterUpdater(newState, {
      dataId: dataId
    });
    if (newState.filters.length !== state.filters.length + 1) {
      // No new filter was added
      return state;
    }
    // Here we are assuming that the filter was added at the end
    filterIndex = newState.filters.length - 1;
    newState.filters[filterIndex] = _objectSpread(_objectSpread({}, newState.filters[filterIndex]), id ? {
      id: id
    } : null);
  }

  // No need to update this if it's a newly created filter
  // First we make sure all the dataIds that fields refer to are updated
  if (originalIndex >= 0 && dataId) {
    // If the dataId is an array, we need to update each one individually as they need a correct valueIndex passed
    newState = (Array.isArray(dataId) ? dataId : [dataId]).reduce(function (accu, d, index) {
      return setFilterUpdater(accu, {
        idx: filterIndex,
        prop: 'dataId',
        value: d,
        valueIndex: index
      });
    }, newState);
  }
  // Then we update the fields
  if (field) {
    // If the field is an array, we need to update each field individually as they need a correct valueIndex passed
    newState = (Array.isArray(field) ? field : [field]).reduce(function (accu, f, index) {
      return setFilterUpdater(accu, {
        idx: filterIndex,
        prop: 'name',
        value: f,
        valueIndex: index
      });
    }, newState);
  }
  // Then we update the value separately
  if (value !== null && typeof value !== 'undefined') {
    newState = setFilterUpdater(newState, {
      idx: filterIndex,
      prop: 'value',
      value: value
    });
  }
  return newState;
};

/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 */
var layerColorUIChangeUpdater = exports.layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref5) {
  var oldLayer = _ref5.oldLayer,
    prop = _ref5.prop,
    newConfig = _ref5.newConfig;
  var oldVixConfig = oldLayer.config.visConfig[prop];
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  var newVisConfig = newLayer.config.visConfig[prop];
  if (oldVixConfig !== newVisConfig) {
    return layerVisConfigChangeUpdater(state, {
      oldLayer: oldLayer,
      newVisConfig: (0, _defineProperty2["default"])({}, prop, newVisConfig)
    });
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};

/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @public
 */
var toggleFilterAnimationUpdater = exports.toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
function isFilterAnimationConfig(config) {
  return 'dataId' in config && 'animationWindow' in config;
}
function setAnimationConfigUpdater(state, action) {
  var config = action.config;
  if (isFilterAnimationConfig(config)) {
    // Find filter used for animation
    // Assuming there's only one filter used for animation, see setFilterViewUpdater
    var filter = state.filters.find(function (f) {
      return !(0, _utils.isSideFilter)(f);
    });
    if (!filter) {
      return state;
    }
    var newFilter = _objectSpread(_objectSpread({}, filter), config);
    return applyFilterConfigUpdater(state, (0, _actions.applyFilterConfig)(filter.id, newFilter));
  } else {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), config)
    });
  }
}

/**
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerAnimationUpdater = exports.toggleLayerAnimationUpdater = function toggleLayerAnimationUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      isAnimating: !state.animationConfig.isAnimating
    })
  });
};

/**
 * Hide and show layer animation control
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerAnimationControlUpdater = exports.toggleLayerAnimationControlUpdater = function toggleLayerAnimationControlUpdater(state) {
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      hideControl: !state.animationConfig.hideControl
    })
  });
};

/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @public
 */
var updateFilterAnimationSpeedUpdater = exports.updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {
        speed: action.speed
      }) : f;
    })
  });
};

/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @public
 *
 */
var updateLayerAnimationSpeedUpdater = exports.updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref6) {
  var speed = _ref6.speed;
  return _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      speed: speed
    })
  });
};

/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @public
 */
var setFilterViewUpdater = exports.setFilterViewUpdater = function setFilterViewUpdater(state, action) {
  var view = action.view,
    idx = action.idx;
  var shouldResetOtherFiltersView = view === _constants.FILTER_VIEW_TYPES.enlarged;
  return _objectSpread(_objectSpread({}, state), {}, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? _objectSpread(_objectSpread({}, f), {}, {
        view: view
      }) : shouldResetOtherFiltersView ? _objectSpread(_objectSpread({}, f), {}, {
        view: _constants.FILTER_VIEW_TYPES.side
      }) : f;
    })
  });
};

/**
 * Toggles filter feature visibility
 * @memberof visStateUpdaters
 */
var toggleFilterFeatureUpdater = exports.toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {
  var filter = state.filters[action.idx];
  var isVisible = (0, _lodash2["default"])(filter, ['value', 'properties', 'isVisible']);
  var newState = setFilterUpdater(state, {
    idx: action.idx,
    prop: 'enabled',
    value: !isVisible
  });
  newState = setFilterUpdater(newState, {
    idx: action.idx,
    prop: 'value',
    value: (0, _utils.featureToFilterValue)(filter.value, filter.id, {
      isVisible: !isVisible
    })
  });
  return newState;
};

/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @public
 */
var removeFilterUpdater = exports.removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var _state$filters$idx = state.filters[idx],
    dataId = _state$filters$idx.dataId,
    id = _state$filters$idx.id;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));
  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);
  var newEditor = (0, _utils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread(_objectSpread({}, state.editor), {}, {
    selectedFeature: null
  }) : state.editor;
  var newState = (0, _utils.set)(['filters'], newFilters, state);
  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);
  newState = (0, _utils.set)(['editor'], newEditor, newState);
  return updateAllLayerDomainData(newState, dataId, undefined);
};

/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @public
 */
var addLayerUpdater = exports.addLayerUpdater = function addLayerUpdater(state, action) {
  var newLayer;
  var newLayerData;
  if (action.config) {
    newLayer = (0, _visStateMerger.createLayerFromConfig)(state, action.config);
    if (!newLayer) {
      _window.console.warn('Failed to create layer from config, it usually means the config is not be in correct format', action.config);
      return state;
    }
    var result = (0, _layerUtils.calculateLayerData)(newLayer, state);
    newLayer = result.layer;
    newLayerData = result.layerData;
  } else {
    var _action$datasetId;
    // create an empty layer with a specific dataset or a default one
    var defaultDataset = (_action$datasetId = action.datasetId) !== null && _action$datasetId !== void 0 ? _action$datasetId : Object.keys(state.datasets)[0];
    newLayer = new _layers.Layer({
      isVisible: true,
      isConfigActive: true,
      dataId: defaultDataset
    });
    newLayerData = {};
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [newLayerData]),
    // add new layer at the top
    layerOrder: [newLayer.id].concat((0, _toConsumableArray2["default"])(state.layerOrder)),
    splitMaps: (0, _utils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });
  if (newLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  }
  return newState;
};

/**
 * remove layer
 * @memberof visStateUpdaters
 * @public
 */
function removeLayerUpdater(state, _ref7) {
  var id = _ref7.id;
  var idx = Number.isFinite(id) ?
  // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.layers.length) {
    // invalid index
    _window.console.warn("can not remove layer with invalid id|idx ".concat(id));
    return state;
  }
  var layers = state.layers,
    layerData = state.layerData,
    layerOrder = state.layerOrder,
    clicked = state.clicked,
    hoverInfo = state.hoverInfo;
  var layerToRemove = layers[idx];
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: (0, _composerHelpers.filterOutById)(layerToRemove.id)(layers),
    layerData: (0, _composerHelpers.removeElementAtIndex)(idx)(layerData),
    layerOrder: layerOrder.filter(function (layerId) {
      return layerId !== layerToRemove.id;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove)
    // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped
  });
  return updateAnimationDomain(newState);
}

/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @public
 */
var reorderLayerUpdater = exports.reorderLayerUpdater = function reorderLayerUpdater(state, _ref8) {
  var order = _ref8.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    layerOrder: order
  });
};

/**
 * duplicate layer
 * @memberof visStateUpdaters
 * @public
 */
var duplicateLayerUpdater = exports.duplicateLayerUpdater = function duplicateLayerUpdater(state, _ref9) {
  var id = _ref9.id;
  var idx = Number.isFinite(id) ?
  // support older API, remove layer by idx
  Number(id) : state.layers.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || !state.layers[idx]) {
    _window.console.warn("layer ".concat(idx, " not found in layerOrder"));
    return state;
  }
  var layers = state.layers;
  var original = layers[idx];
  var originalLayerOrderIdx = state.layerOrder.findIndex(function (lid) {
    return lid === original.id;
  });
  var newLabel = "Copy of ".concat(original.config.label);
  var postfix = 0;
  // eslint-disable-next-line no-loop-func
  while (layers.find(function (l) {
    return l.config.label === newLabel;
  })) {
    newLabel = "Copy of ".concat(original.config.label, " ").concat(++postfix);
  }

  // collect layer config from original
  var loadedLayer = (0, _visStateMerger.serializeLayer)(original, state.schema);

  // assign new id and label to copied layer
  if (!(loadedLayer !== null && loadedLayer !== void 0 && loadedLayer.config)) {
    return state;
  }
  loadedLayer.config.label = newLabel;
  loadedLayer.id = (0, _commonUtils.generateHashId)(_layers.LAYER_ID_LENGTH);

  // add layer to state
  var nextState = addLayerUpdater(state, {
    config: loadedLayer
  });
  // retrieve newly created layer
  var newLayer = nextState.layers[nextState.layers.length - 1];
  // update layer order with newLyaer.id
  var newLayerOrder = (0, _utils.arrayInsert)(nextState.layerOrder.slice(1, nextState.layerOrder.length), originalLayerOrderIdx, newLayer.id);
  nextState = reorderLayerUpdater(nextState, {
    order: newLayerOrder
  });
  return updateAnimationDomain(nextState);
};

/**
 * Add a new effect
 * @memberof visStateUpdaters
 * @public
 */
var addEffectUpdater = exports.addEffectUpdater = function addEffectUpdater(state, action) {
  var _action$config;
  if (((_action$config = action.config) === null || _action$config === void 0 ? void 0 : _action$config.type) === _constants.LIGHT_AND_SHADOW_EFFECT.type && state.effects.some(function (effect) {
    return effect.type === _constants.LIGHT_AND_SHADOW_EFFECT.type;
  })) {
    _window.console.warn("Can't add more than one ".concat(_constants.LIGHT_AND_SHADOW_EFFECT.name, " effect"));
    return state;
  }
  var newEffect = (0, _effects.createEffect)(action.config);

  // collapse configurators for other effects
  state.effects.forEach(function (effect) {
    return effect.setProps({
      isConfigActive: false
    });
  });
  var effects = [].concat((0, _toConsumableArray2["default"])(state.effects), [newEffect]);
  var effectOrder = (0, _utils.fixEffectOrder)(effects, [newEffect.id].concat((0, _toConsumableArray2["default"])(state.effectOrder)));
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: effects,
    effectOrder: effectOrder
  });
};

/**
 * remove effect
 * @memberof visStateUpdaters
 * @public
 */
var removeEffectUpdater = exports.removeEffectUpdater = function removeEffectUpdater(state, _ref10) {
  var id = _ref10.id;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not remove effect with invalid id ".concat(id));
    return state;
  }
  var effects = state.effects,
    effectOrder = state.effectOrder;
  var effectToRemove = effects[idx];
  return _objectSpread(_objectSpread({}, state), {}, {
    // @ts-expect-error fixed in ts
    effects: (0, _composerHelpers.filterOutById)(effectToRemove.id)(effects),
    effectOrder: effectOrder.filter(function (effectId) {
      return effectId !== effectToRemove.id;
    })
  });
};

/**
 * Reorder effect
 * @memberof visStateUpdaters
 * @public
 */
var reorderEffectUpdater = exports.reorderEffectUpdater = function reorderEffectUpdater(state, _ref11) {
  var order = _ref11.order;
  return _objectSpread(_objectSpread({}, state), {}, {
    effectOrder: (0, _utils.fixEffectOrder)(state.effects, (0, _toConsumableArray2["default"])(order))
  });
};

/**
 * Update effect
 * @memberof visStateUpdaters
 * @public
 */
var updateEffectUpdater = exports.updateEffectUpdater = function updateEffectUpdater(state, _ref12) {
  var id = _ref12.id,
    props = _ref12.props;
  var idx = state.effects.findIndex(function (l) {
    return l.id === id;
  });
  if (idx < 0 || idx >= state.effects.length) {
    _window.console.warn("can not update effect with invalid id ".concat(id));
    return state;
  }
  var effectOrder = state.effectOrder;
  if (props.id !== undefined && props.id !== id) {
    var idx2 = state.effects.findIndex(function (l) {
      return l.id === props.id;
    });
    if (idx2 >= 0) {
      _window.console.warn("can not update effect with existing effect id ".concat(id));
      return state;
    }
    effectOrder = effectOrder.map(function (effectOrderId) {
      return effectOrderId === id ? props.id : effectOrderId;
    });
  }
  var newEffects = (0, _toConsumableArray2["default"])(state.effects);
  newEffects[idx].setProps(props);
  return _objectSpread(_objectSpread({}, state), {}, {
    effects: newEffects,
    effectOrder: effectOrder
  });
};

/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @public
 */
function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.dataId;
  var datasets = state.datasets;

  // check if dataset is present
  if (!datasets[datasetKey]) {
    return state;
  }
  var layers = state.layers,
    _state$datasets = state.datasets,
    dataset = _state$datasets[datasetKey],
    newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  var layersToRemove = layers.filter(function (l) {
    return l.config.dataId === datasetKey;
  }).map(function (l) {
    return l.id;
  });

  // remove layers and datasets
  var newState = layersToRemove.reduce(function (accu, id) {
    return removeLayerUpdater(accu, {
      id: id
    });
  }, _objectSpread(_objectSpread({}, state), {}, {
    datasets: newDatasets
  }));

  // update filters
  var filters = [];
  var _iterator2 = _createForOfIteratorHelper(newState.filters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var filter = _step2.value;
      var valueIndex = filter.dataId.indexOf(datasetKey);
      if (valueIndex >= 0 && filter.dataId.length > 1) {
        // only remove one synced dataset from the filter
        filters.push(_removeFilterDataIdAtValueIndex(filter, valueIndex, datasets));
      } else if (valueIndex < 0) {
        // leave the filter as is
        filters.push(filter);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    filters: filters
  });
  return removeDatasetFromInteractionConfig(newState, {
    dataId: datasetKey
  });
}
function removeDatasetFromInteractionConfig(state, _ref13) {
  var dataId = _ref13.dataId;
  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
    tooltip = _interactionConfig.tooltip;
  if (tooltip) {
    var config = tooltip.config;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _config$fieldsToShow = config.fieldsToShow,
      fields = _config$fieldsToShow[dataId],
      fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [dataId].map(_toPropertyKey));
    interactionConfig = _objectSpread(_objectSpread({}, interactionConfig), {}, {
      tooltip: _objectSpread(_objectSpread({}, tooltip), {}, {
        config: _objectSpread(_objectSpread({}, config), {}, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }
  return _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });
}
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @public
 */
var updateLayerBlendingUpdater = exports.updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    layerBlending: action.mode
  });
};

/**
 * update overlay blending mode
 * @memberof visStateUpdaters
 * @public
 */
var updateOverlayBlendingUpdater = exports.updateOverlayBlendingUpdater = function updateOverlayBlendingUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    overlayBlending: action.mode
  });
};

/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @public
 */
var showDatasetTableUpdater = exports.showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editingDataset: action.dataId
  });
};

/**
 * Add custom color for datasets and layers
 * @memberof visStateUpdaters
 * @public
 */
var updateTableColorUpdater = exports.updateTableColorUpdater = function updateTableColorUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      color: action.newColor
    }
  });
};

/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @public
 */
var resetMapConfigUpdater = exports.resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};

/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @public
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref14) {
  var _ref14$payload = _ref14.payload,
    _ref14$payload$config = _ref14$payload.config,
    config = _ref14$payload$config === void 0 ? {} : _ref14$payload$config,
    _ref14$payload$option = _ref14$payload.options,
    options = _ref14$payload$option === void 0 ? {} : _ref14$payload$option;
  if (!config.visState) {
    return state;
  }
  var keepExistingConfig = options.keepExistingConfig;

  // reset config if keepExistingConfig is falsy
  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;
  var _iterator3 = _createForOfIteratorHelper(state.mergers),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var merger = _step3.value;
      if ((0, _mergerHandler.isValidMerger)(merger) && (0, _mergerHandler.hasPropsToMerge)(config.visState, merger.prop)) {
        mergedState = merger.merge(mergedState, (0, _mergerHandler.getPropValueToMerger)(config.visState, merger.prop, merger.toMergeProp),
        // fromConfig
        true);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return mergedState;
};

/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @public
 */
var layerHoverUpdater = exports.layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    hoverInfo: _objectSpread(_objectSpread({}, action.info), Number.isFinite(action.mapIndex) ? {
      mapIndex: action.mapIndex
    } : {})
  });
};

/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @public
 */
function interactionConfigChangeUpdater(state, action) {
  var config = action.config;
  var interactionConfig = _objectSpread(_objectSpread({}, state.interactionConfig), (0, _defineProperty2["default"])({}, config.id, config));

  // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time
  var contradict = ['brush', 'tooltip'];
  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread(_objectSpread({}, interactionConfig[k]), {}, {
          enabled: false
        });
      }
    });
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    interactionConfig: interactionConfig
  });
  if (config.id === 'geocoder' && !config.enabled) {
    return removeDatasetUpdater(newState, {
      dataId: 'geocoder_dataset'
    });
  }
  return newState;
}

/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @public
 */
var layerClickUpdater = exports.layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread(_objectSpread({}, state.mousePos), {}, {
      pinned: state.mousePos.pinned ? null : (0, _lodash["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};

/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @public
 */
var mapClickUpdater = exports.mapClickUpdater = function mapClickUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    clicked: null
  });
};

/**
 * Trigger map move event
 * @memberof visStateUpdaters
 * @public
 */
var mouseMoveUpdater = exports.mouseMoveUpdater = function mouseMoveUpdater(state, _ref15) {
  var evt = _ref15.evt;
  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread(_objectSpread({}, state), {}, {
      mousePos: _objectSpread(_objectSpread(_objectSpread({}, state.mousePos), Array.isArray(evt.point) ? {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point)
      } : {}), Array.isArray(evt.lngLat) ? {
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      } : {})
    });
  }
  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @public
 */
var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread(_objectSpread({}, state), {}, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _utils.computeSplitMapLayers)(state.layers, {
      duplicate: false
    })
  }) : closeSpecificMapAtIndex(state, action);
};

/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @public
 */
var toggleLayerForMapUpdater = exports.toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref16) {
  var mapIndex = _ref16.mapIndex,
    layerId = _ref16.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread(_objectSpread({}, state), {}, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread(_objectSpread({}, splitMaps[i]), {}, {
        layers: _objectSpread(_objectSpread({}, splitMaps[i].layers), {}, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @public
 */
// eslint-disable-next-line complexity
var updateVisDataUpdater = exports.updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
    options = action.options;

  // apply config if passed from action
  // TODO: we don't handle async mergers here yet
  var previousState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;

  // indicate that something is in progress
  var setIsLoadingTask = (0, _tasks2.ACTION_TASK)().map(function () {
    return (0, _actions.setLoadingIndicator)({
      change: 1
    });
  });
  var updatedState = (0, _tasks.withTask)(previousState, setIsLoadingTask);
  var datasets = (0, _commonUtils.toArray)(action.datasets);
  var createDatasetTasks = [];
  var notificationTasks = [];
  datasets.forEach(function (_ref17, datasetIndex) {
    var _ref17$info = _ref17.info,
      info = _ref17$info === void 0 ? {} : _ref17$info,
      rest = (0, _objectWithoutProperties2["default"])(_ref17, _excluded2);
    var task = (0, _table.createNewDataEntry)(_objectSpread({
      info: info
    }, rest), state.datasets);
    if (task) {
      createDatasetTasks.push(task);
    } else {
      notificationTasks.push((0, _tasks2.ACTION_TASK)().map(function () {
        return (0, _actions.addNotification)((0, _utils.errorNotification)({
          message: "Failed to create a new dataset due to data verification errors",
          id: "dataset-failed-".concat(datasetIndex)
        }));
      }));
    }
  });
  var datasetsAllSettledTask = createDatasetTasks.length ? _tasks["default"].allSettled(createDatasetTasks).map(function (results) {
    return (0, _actions.createNewDatasetSuccess)({
      results: results,
      addToMapOptions: options
    });
  }) : null;
  return (0, _tasks.withTask)(updatedState, [].concat((0, _toConsumableArray2["default"])(datasetsAllSettledTask ? [datasetsAllSettledTask] : []), notificationTasks));
};
var createNewDatasetSuccessUpdater = exports.createNewDatasetSuccessUpdater = function createNewDatasetSuccessUpdater(state, action) {
  // console.log('createNewDatasetSuccessUpdater', action.payload);
  var _action$payload = action.payload,
    results = _action$payload.results,
    addToMapOptions = _action$payload.addToMapOptions;
  var newDataEntries = results.reduce(function (accu, result) {
    if (result.status === 'fulfilled') {
      var dataset = result.value;
      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, dataset.id, dataset));
    } else {
      // handle create dataset error
      console.error('createNewDatasetSuccessUpdater: failed', result.reason || result.value);
      return accu;
    }
  }, {});
  // save new dataset entry to state
  var mergedState = _objectSpread(_objectSpread({}, state), {}, {
    datasets: (0, _visStateMerger.mergeDatasetsByOrder)(state, newDataEntries)
  });

  // merge state with config to be merged
  var layerMergers = state.mergers.filter(function (m) {
    return m.waitForLayerData;
  });
  var datasetMergers = state.mergers.filter(function (m) {
    return !layerMergers.includes(m);
  });
  var newDataIds = Object.keys(newDataEntries);
  var postMergerPayload = {
    newDataIds: newDataIds,
    options: addToMapOptions,
    layerMergers: layerMergers
  };
  var updatedState = applyMergersUpdater(mergedState, {
    mergers: datasetMergers,
    postMergerPayload: postMergerPayload
  });

  // resolve active loading initiated by updateVisDataUpdater
  var setIsLoadingTask = (0, _tasks2.ACTION_TASK)().map(function () {
    return (0, _actions.setLoadingIndicator)({
      change: -1
    });
  });
  return (0, _tasks.withTask)(updatedState, setIsLoadingTask);
};

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */
function applyMergersUpdater(state, action) {
  var mergers = action.mergers,
    postMergerPayload = action.postMergerPayload;

  // merge state with config to be merged
  var mergeStateResult = (0, _mergerHandler.mergeStateFromMergers)(state, _objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), mergers,
  // newDataIds,
  postMergerPayload);

  // if all merged, kickup post merge process
  // if not wait
  return mergeStateResult.allMerged ? postMergeUpdater(mergeStateResult.mergedState, postMergerPayload) : mergeStateResult.mergedState;
}

/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 */
function postMergeUpdater(mergedState, postMergerPayload) {
  var newDataIds = postMergerPayload.newDataIds,
    options = postMergerPayload.options,
    layerMergers = postMergerPayload.layerMergers;
  var newFilters = mergedState.filters.filter(function (f) {
    return f.dataId.find(function (fDataId) {
      return newDataIds.includes(fDataId);
    });
  });
  var datasetFiltered = (0, _lodash5["default"])(newFilters.reduce(function (accu, f) {
    return [].concat((0, _toConsumableArray2["default"])(accu), (0, _toConsumableArray2["default"])(f.dataId));
  }, []));
  var dataEmpty = newDataIds.length < 1;
  var newLayers = !dataEmpty ? mergedState.layers.filter(function (l) {
    return l.config.dataId && newDataIds.includes(l.config.dataId);
  }) : [];
  var newDataEntries = newDataIds.reduce(function (accu, id) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, id, mergedState.datasets[id]));
  }, {});
  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDataEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }
  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId && newDataIds.includes(l.config.dataId);
    });
    mergedState = _objectSpread(_objectSpread({}, mergedState), {}, {
      splitMaps: (0, _utils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  }

  // if no tooltips merged add default tooltips
  newDataIds.forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];
    // loading dataset: autoCreateTooltips is false and we don't want to run addDefaultTooltips when tooltipFields is empty
    if ((options === null || options === void 0 ? void 0 : options.autoCreateTooltips) !== false && (!Array.isArray(tooltipFields) || !tooltipFields.length)) {
      // adding dataset: autoCreateTooltips is true
      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);
    }
  });
  var updatedDatasets = dataEmpty ? Object.keys(mergedState.datasets) : (0, _lodash5["default"])(Object.keys(newDataEntries).concat(datasetFiltered));
  var updatedState = updateAllLayerDomainData(mergedState, updatedDatasets, undefined);

  // register layer animation domain,
  // need to be called after layer data is calculated
  updatedState = updateAnimationDomain(updatedState);

  // try to process layerMergers after dataset+datasetMergers
  updatedState = layerMergers && layerMergers.length > 0 ? applyMergersUpdater(updatedState, {
    mergers: layerMergers,
    postMergerPayload: _objectSpread(_objectSpread({}, postMergerPayload), {}, {
      layerMergers: []
    })
  }) : updatedState;

  // center the map once the dataset is created
  if (newLayers.length && (options || {}).centerMap) {
    var bounds = (0, _dataUtils.findMapBounds)(newLayers);
    if (bounds) {
      var fitBoundsTask = (0, _tasks2.ACTION_TASK)().map(function () {
        return (0, _actions.fitBounds)(bounds);
      });
      updatedState = (0, _tasks.withTask)(updatedState, fitBoundsTask);
    }
  }
  return updatedState;
}

/**
 * Rename an existing dataset in `visState`
 * @memberof visStateUpdaters
 * @public
 */
function renameDatasetUpdater(state, action) {
  return updateDatasetPropsUpdater(state, {
    dataId: action.dataId,
    props: {
      label: action.label
    }
  });
}
var ALLOWED_UPDATE_DATASET_PROPS = ['label', 'color', 'metadata'];

/**
 * Validates properties before updating the dataset.
 * Makes sure each property is in the allowed list
 * Makes sure color value is RGB
 * Performs deep merge when updating metadata
 */
var validateDatasetUpdateProps = function validateDatasetUpdateProps(props, dataset) {
  var validatedProps = Object.entries(props).reduce(function (acc, entry) {
    var _entry = (0, _slicedToArray2["default"])(entry, 2),
      key = _entry[0],
      value = _entry[1];
    // is it allowed ?
    if (!ALLOWED_UPDATE_DATASET_PROPS.includes(key)) {
      return acc;
    }

    // if we are adding a color but it is not RGB we don't accept the value
    // in the future as we add more props we should change this if into a switch
    if (key === 'color' && !(0, _utils.isRgbColor)(value)) {
      return acc;
    }

    // do we need deep merge ?
    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(value) ? (0, _deepmerge["default"])(dataset[key] || {}, value) : value));
  }, {});
  return validatedProps;
};

/**
 * Update Dataset props (label, color, meta). Do not use to update data or any related properties
 * @memberof visStateUpdaters
 * @public
 */
function updateDatasetPropsUpdater(state, action) {
  var dataId = action.dataId,
    props = action.props;
  var datasets = state.datasets;
  var existing = datasets[dataId];
  if (existing) {
    var validatedProps = validateDatasetUpdateProps(props, existing);
    //  validate props: just color for now
    //  we only allow label, color and meta to be updated
    // const newTable = copyTableAndUpdate(existing, validatedProps);
    return _objectSpread(_objectSpread({}, state), {}, {
      datasets: _objectSpread(_objectSpread({}, datasets), {}, (0, _defineProperty2["default"])({}, dataId, (0, _table.copyTableAndUpdate)(existing, validatedProps)))
    });
  }
  return state;
}

/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */
function closeSpecificMapAtIndex(state, action) {
  var _state$splitMaps$inde;
  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = (_state$splitMaps$inde = state.splitMaps[indexToRetrieve]) === null || _state$splitMaps$inde === void 0 ? void 0 : _state$splitMaps$inde.layers;
  var layers = state.layers;

  // update layer visibility
  var newLayers = layers.map(function (layer) {
    return mapLayers && !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  });

  // delete map
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    splitMaps: []
  });
}

/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @public
 */
var loadFilesUpdater = exports.loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files,
    _action$onFinish = action.onFinish,
    onFinish = _action$onFinish === void 0 ? _actions.loadFilesSuccess : _action$onFinish;
  if (!files.length) {
    return state;
  }
  var fileLoadingProgress = Array.from(files).reduce(function (accu, f, i) {
    return (0, _composerHelpers.merge_)(initialFileLoadingProgress(f, i))(accu);
  }, {});
  var fileLoading = {
    fileCache: [],
    filesToLoad: files,
    onFinish: onFinish
  };
  var nextState = (0, _composerHelpers.merge_)({
    fileLoadingProgress: fileLoadingProgress,
    fileLoading: fileLoading
  })(state);
  return loadNextFileUpdater(nextState);
};

/**
 * Sucessfully loaded one file, move on to the next one
 * @memberof visStateUpdaters
 * @public
 */
function loadFileStepSuccessUpdater(state, action) {
  if (!state.fileLoading) {
    return state;
  }
  var fileName = action.fileName,
    fileCache = action.fileCache;
  var _state$fileLoading = state.fileLoading,
    filesToLoad = _state$fileLoading.filesToLoad,
    onFinish = _state$fileLoading.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      percent: 1,
      message: 'Done'
    }
  });

  // save processed file to fileCache
  var stateWithCache = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    fileCache: fileCache
  }))(stateWithProgress);
  return (0, _tasks.withTask)(stateWithCache, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
}

// withTask<T>(state: T, task: any): T

/**
 *
 * @memberof visStateUpdaters
 * @public
 */
function loadNextFileUpdater(state) {
  if (!state.fileLoading) {
    return state;
  }
  var filesToLoad = state.fileLoading.filesToLoad;
  var _filesToLoad = (0, _toArray2["default"])(filesToLoad),
    file = _filesToLoad[0],
    remainingFilesToLoad = _filesToLoad.slice(1);

  // save filesToLoad to state
  var nextState = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({
    filesToLoad: remainingFilesToLoad
  }))(state);
  var stateWithProgress = updateFileLoadingProgressUpdater(nextState, {
    fileName: file.name,
    progress: {
      percent: 0,
      message: 'loading...'
    }
  });
  var loaders = state.loaders,
    loadOptions = state.loadOptions;
  return (0, _tasks.withTask)(stateWithProgress, makeLoadFileTask(file, nextState.fileLoading && nextState.fileLoading.fileCache, loaders, loadOptions));
}
function makeLoadFileTask(file, fileCache) {
  var loaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var loadOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return (0, _tasks2.LOAD_FILE_TASK)({
    file: file,
    fileCache: fileCache,
    loaders: loaders,
    loadOptions: loadOptions
  }).bimap(
  // prettier ignore
  // success
  function (gen) {
    return (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: file.name,
      onFinish: function onFinish(result) {
        return (0, _actions.processFileContent)({
          content: result,
          fileCache: fileCache
        });
      }
    });
  },
  // error
  function (err) {
    return (0, _actions.loadFilesErr)(file.name, err);
  });
}

/**
 *
 * @memberof visStateUpdaters
 * @public
 */
function processFileContentUpdater(state, action) {
  var _action$payload2 = action.payload,
    content = _action$payload2.content,
    fileCache = _action$payload2.fileCache;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: content.fileName,
    progress: {
      percent: 1,
      message: 'processing...'
    }
  });
  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.PROCESS_FILE_DATA)({
    content: content,
    fileCache: fileCache
  }).bimap(function (result) {
    return (0, _actions.loadFileStepSuccess)({
      fileName: content.fileName,
      fileCache: result
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(content.fileName, err);
  }));
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function parseProgress() {
  var prevProgress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var progress = arguments.length > 1 ? arguments[1] : undefined;
  // This happens when receiving query metadata or other cases we don't
  // have an update for the user.
  if (!progress || !progress.percent) {
    return {};
  }
  return {
    percent: progress.percent
  };
}

/**
 * gets called with payload = AsyncGenerator<???>
 * @memberof visStateUpdaters
 * @public
 */
var nextFileBatchUpdater = exports.nextFileBatchUpdater = function nextFileBatchUpdater(state, _ref18) {
  var _accumulated$data;
  var _ref18$payload = _ref18.payload,
    gen = _ref18$payload.gen,
    fileName = _ref18$payload.fileName,
    progress = _ref18$payload.progress,
    accumulated = _ref18$payload.accumulated,
    onFinish = _ref18$payload.onFinish;
  var stateWithProgress = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: parseProgress(state.fileLoadingProgress[fileName], progress)
  });
  return (0, _tasks.withTask)(stateWithProgress, [].concat((0, _toConsumableArray2["default"])((0, _utils.getApplicationConfig)().useArrowProgressiveLoading && fileName.endsWith('arrow') && (accumulated === null || accumulated === void 0 || (_accumulated$data = accumulated.data) === null || _accumulated$data === void 0 ? void 0 : _accumulated$data.length) > 0 ? [(0, _tasks2.PROCESS_FILE_DATA)({
    content: accumulated,
    fileCache: []
  }).bimap(function (result) {
    return (0, _actions.loadFilesSuccess)(result);
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })] : []), [(0, _tasks2.UNWRAP_TASK)(gen.next()).bimap(function (_ref19) {
    var value = _ref19.value,
      done = _ref19.done;
    return done ? onFinish(accumulated) : (0, _actions.nextFileBatch)({
      gen: gen,
      fileName: fileName,
      progress: value.progress,
      accumulated: value,
      onFinish: onFinish
    });
  }, function (err) {
    return (0, _actions.loadFilesErr)(fileName, err);
  })]));
};

/**
 * Trigger loading file error
 * @memberof visStateUpdaters
 * @public
 */
var loadFilesErrUpdater = exports.loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref20) {
  var error = _ref20.error,
    fileName = _ref20.fileName;
  // update ui with error message
  _window.console.warn(error);
  if (!state.fileLoading) {
    return state;
  }
  var _state$fileLoading2 = state.fileLoading,
    filesToLoad = _state$fileLoading2.filesToLoad,
    onFinish = _state$fileLoading2.onFinish,
    fileCache = _state$fileLoading2.fileCache;
  var nextState = updateFileLoadingProgressUpdater(state, {
    fileName: fileName,
    progress: {
      error: error
    }
  });

  // kick off next file or finish
  return (0, _tasks.withTask)(nextState, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {
    return onFinish(fileCache);
  }));
};

/**
 * When select dataset for export, apply cpu filter to selected dataset
 * @memberof visStateUpdaters
 * @public
 */
var applyCPUFilterUpdater = exports.applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref21) {
  var dataId = _ref21.dataId;
  // apply cpuFilter
  var dataIds = (0, _commonUtils.toArray)(dataId);
  return dataIds.reduce(function (accu, id) {
    return (0, _utils.filterDatasetCPU)(accu, id);
  }, state);
};

/**
 * User input to update the info of the map
 * @memberof visStateUpdaters
 * @public
 */
var setMapInfoUpdater = exports.setMapInfoUpdater = function setMapInfoUpdater(state, action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    mapInfo: _objectSpread(_objectSpread({}, state.mapInfo), action.info)
  });
};
/**
 * Helper function to update All layer domain and layer data of state
 */
function addDefaultLayers(state, datasets) {
  var empty = [];
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    var foundLayers = (0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses);
    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;
  }, empty);
  return {
    state: _objectSpread(_objectSpread({}, state), {}, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])((0, _layerUtils.getLayerOrderFromLayers)(defaultLayers)), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}

/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */
function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(_objectSpread(_objectSpread({}, dataset), {}, {
    maxDefaultTooltips: state.maxDefaultTooltips
  }));
  var merged = _objectSpread(_objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow), tooltipFields);
  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);
}
function initialFileLoadingProgress(file, index) {
  var fileName = file.name || "Untitled File ".concat(index);
  return (0, _defineProperty2["default"])({}, fileName, {
    // percent of current file
    percent: 0,
    message: '',
    fileName: fileName,
    error: null
  });
}
function updateFileLoadingProgressUpdater(state, _ref23) {
  var fileName = _ref23.fileName,
    progress = _ref23.progress;
  // @ts-expect-error
  return (0, _composerHelpers.pick_)('fileLoadingProgress')((0, _composerHelpers.pick_)(fileName)((0, _composerHelpers.merge_)(progress)))(state);
}
/**
 * Helper function to update layer domains for an array of datasets
 */
function updateAllLayerDomainData(state, dataId, updatedFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerData = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);
      var _calculateLayerData7 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
        layerData = _calculateLayerData7.layerData,
        layer = _calculateLayerData7.layer;
      newLayers.push(layer);
      newLayerData.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerData.push(state.layerData[i]);
    }
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    layers: newLayers,
    layerData: newLayerData
  });
  return newState;
}
function updateAnimationDomain(state) {
  var _state$filters;
  // merge all animatable layer domain and update global config
  var animatableLayers = (0, _utils.getAnimatableVisibleLayers)(state.layers);
  if (!animatableLayers.length) {
    return _objectSpread(_objectSpread({}, state), {}, {
      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
        domain: null,
        isAnimating: false,
        timeSteps: null,
        defaultTimeFormat: null
      })
    });
  }
  var layerDomains = animatableLayers.map(function (l) {
    return l.config.animation.domain || [];
  });
  // @ts-ignore
  var mergedDomain = (0, _utils.mergeTimeDomains)(layerDomains);
  var defaultTimeFormat = (0, _utils.getTimeWidgetTitleFormatter)(mergedDomain);

  // merge timeSteps
  var mergedTimeSteps = (0, _lodash5["default"])(animatableLayers.reduce(function (accu, layer) {
    accu.push.apply(accu, (0, _toConsumableArray2["default"])(layer.config.animation.timeSteps || []));
    return accu;
  }, [])).sort();
  mergedTimeSteps = mergedTimeSteps.length ? mergedTimeSteps : null;

  // TODO: better handling of duration calculation
  var duration = mergedTimeSteps ? _constants.BASE_SPEED * (1000 / _constants.FPS) / mergedTimeSteps.length / (state.animationConfig.speed || 1) : null;
  var nextState = _objectSpread(_objectSpread({}, state), {}, {
    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {
      domain: mergedDomain,
      defaultTimeFormat: defaultTimeFormat,
      duration: duration,
      timeSteps: mergedTimeSteps
    })
  });

  // reset currentTime based on new domain
  var syncedFilter = (_state$filters = state.filters) === null || _state$filters === void 0 ? void 0 : _state$filters.find(function (f) {
    return f.syncedWithLayerTimeline;
  });

  // if synced filter exist wee need to merge animationConfig and filter domains
  // and validate the current time against the new merged domain
  var newAnimationDomain = syncedFilter ? (0, _utils.mergeTimeDomains)([mergedDomain, syncedFilter.domain]) : mergedDomain;
  var currentTime = (0, _utils.isInRange)(state.animationConfig.currentTime, newAnimationDomain) ? state.animationConfig.currentTime : newAnimationDomain[0];
  if (currentTime !== state.animationConfig.currentTime) {
    // if currentTime changed, need to call animationTimeUpdater to re call formatLayerData
    return setLayerAnimationTimeUpdater(nextState, {
      value: currentTime
    });
  }
  return nextState;
}

/**
 * Update the status of the editor
 * @memberof visStateUpdaters
 */
var setEditorModeUpdater = exports.setEditorModeUpdater = function setEditorModeUpdater(state, _ref24) {
  var mode = _ref24.mode;
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      mode: mode,
      selectedFeature: null
    })
  });
};

// const featureToFilterValue = (feature) => ({...feature, id: feature.id});
/**
 * Update editor features
 * @memberof visStateUpdaters
 */
function setFeaturesUpdater(state, _ref25) {
  var _lastFeature$properti;
  var _ref25$features = _ref25.features,
    features = _ref25$features === void 0 ? [] : _ref25$features;
  var lastFeature = features.length && features[features.length - 1];
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      // only save none filter features to editor
      features: features.filter(function (f) {
        return !(0, _utils.getFilterIdInFeature)(f);
      }),
      mode: lastFeature && (_lastFeature$properti = lastFeature.properties) !== null && _lastFeature$properti !== void 0 && _lastFeature$properti.isClosed ? _constants.EDITOR_MODES.EDIT : state.editor.mode
    })
  });

  // Retrieve existing feature
  var selectedFeature = state.editor.selectedFeature;

  // If no feature is selected we can simply return since no operations
  if (!selectedFeature) {
    return newState;
  }

  // TODO: check if the feature has changed
  var feature = features.find(function (f) {
    return f.id === selectedFeature.id;
  });

  // if feature is part of a filter
  var filterId = feature && (0, _utils.getFilterIdInFeature)(feature);
  if (filterId && feature) {
    // add bbox for polygon filter to speed up filtering
    if (feature.properties) feature.properties.bbox = (0, _bbox["default"])(feature);
    var featureValue = (0, _utils.featureToFilterValue)(feature, filterId);
    var filterIdx = state.filters.findIndex(function (fil) {
      return fil.id === filterId;
    });
    // @ts-ignore
    return setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: featureValue
    });
  }
  return newState;
}

/**
 * Set the current selected feature
 * @memberof uiStateUpdaters
 */
var setSelectedFeatureUpdater = exports.setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref26) {
  var feature = _ref26.feature,
    selectionContext = _ref26.selectionContext;
  // add bbox for polygon filter to speed up filtering
  if (feature && feature.properties) feature.properties.bbox = (0, _bbox["default"])(feature);
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: feature,
      selectionContext: selectionContext
    })
  });
};

/**
 * Delete existing feature from filters
 * @memberof visStateUpdaters
 */
function deleteFeatureUpdater(state, _ref27) {
  var feature = _ref27.feature;
  if (!feature) {
    return state;
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      selectedFeature: null
    })
  });
  if ((0, _utils.getFilterIdInFeature)(feature)) {
    var filterIdx = newState.filters.findIndex(function (f) {
      return f.id === (0, _utils.getFilterIdInFeature)(feature);
    });
    return filterIdx > -1 ? removeFilterUpdater(newState, {
      idx: filterIdx
    }) : newState;
  }

  // modify editor object
  var newEditor = _objectSpread(_objectSpread({}, state.editor), {}, {
    features: state.editor.features.filter(function (f) {
      return f.id !== feature.id;
    }),
    selectedFeature: null
  });
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: newEditor
  });
}

/**
 * Toggle feature as layer filter
 * @memberof visStateUpdaters
 */
function setPolygonFilterLayerUpdater(state, payload) {
  var layer = payload.layer,
    feature = payload.feature;
  var filterId = (0, _utils.getFilterIdInFeature)(feature);

  // let newFilter = null;
  var filterIdx;
  var newLayerId = [layer.id];
  var newState = state;
  // If polygon filter already exists, we need to find out if the current layer is already included
  if (filterId) {
    filterIdx = state.filters.findIndex(function (f) {
      return f.id === filterId;
    });
    if (!state.filters[filterIdx]) {
      // what if filter doesn't exist?... not possible.
      // because features in the editor is passed in from filters and editors.
      // but we will move this feature back to editor just in case
      var noneFilterFeature = _objectSpread(_objectSpread({}, feature), {}, {
        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {
          filterId: null
        })
      });
      return _objectSpread(_objectSpread({}, state), {}, {
        editor: _objectSpread(_objectSpread({}, state.editor), {}, {
          features: [].concat((0, _toConsumableArray2["default"])(state.editor.features), [noneFilterFeature]),
          selectedFeature: noneFilterFeature
        })
      });
    }
    var filter = state.filters[filterIdx];
    var _filter$layerId = filter.layerId,
      layerId = _filter$layerId === void 0 ? [] : _filter$layerId;
    var isLayerIncluded = layerId.includes(layer.id);
    newLayerId = isLayerIncluded ?
    // if layer is included, remove it
    layerId.filter(function (l) {
      return l !== layer.id;
    }) : [].concat((0, _toConsumableArray2["default"])(layerId), [layer.id]);
  } else {
    // if we haven't create the polygon filter, create it
    var newFilter = (0, _utils.generatePolygonFilter)([], feature);
    filterIdx = state.filters.length;

    // add feature, remove feature from eidtor
    newState = _objectSpread(_objectSpread({}, state), {}, {
      filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [newFilter]),
      editor: _objectSpread(_objectSpread({}, state.editor), {}, {
        features: state.editor.features.filter(function (f) {
          return f.id !== feature.id;
        }),
        selectedFeature: newFilter.value
      })
    });
  }
  return setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'layerId',
    value: newLayerId
  });
}

/**
 * @memberof visStateUpdaters
 * @public
 */
function sortTableColumnUpdater(state, _ref28) {
  var dataId = _ref28.dataId,
    column = _ref28.column,
    mode = _ref28.mode;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var sortMode = mode;
  if (!sortMode) {
    var currentMode = (0, _lodash2["default"])(dataset, ['sortColumn', column]);
    // @ts-ignore - should be fixable in a TS file
    sortMode = currentMode ? Object.keys(_constants.SORT_ORDER).find(function (m) {
      return m !== currentMode;
    }) : _constants.SORT_ORDER.ASCENDING;
  }
  var sorted = (0, _table.sortDatasetByColumn)(dataset, column, sortMode);
  return (0, _utils.set)(['datasets', dataId], sorted, state);
}

/**
 * @memberof visStateUpdaters
 * @public
 */
function pinTableColumnUpdater(state, _ref29) {
  var dataId = _ref29.dataId,
    column = _ref29.column;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var newDataset = (0, _table.pinTableColumns)(dataset, column);
  return (0, _utils.set)(['datasets', dataId], newDataset, state);
}

/**
 * Copy column content as strings
 * @memberof visStateUpdaters
 * @public
 */
function copyTableColumnUpdater(state, _ref30) {
  var dataId = _ref30.dataId,
    column = _ref30.column;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var fieldIdx = dataset.fields.findIndex(function (f) {
    return f.name === column;
  });
  if (fieldIdx < 0) {
    return state;
  }
  var type = dataset.fields[fieldIdx].type;
  var text = dataset.dataContainer.map(function (row) {
    return (0, _utils.parseFieldValue)(row.valueAt(fieldIdx), type);
  }, true).join('\n');
  (0, _copyToClipboard["default"])(text);
  return state;
}

/**
 * Set display format from columns from user selection
 * @memberof visStateUpdaters
 * @public
 */
function setColumnDisplayFormatUpdater(state, _ref31) {
  var dataId = _ref31.dataId,
    formats = _ref31.formats;
  var dataset = state.datasets[dataId];
  if (!dataset) {
    return state;
  }
  var newFields = dataset.fields;
  Object.keys(formats).forEach(function (column) {
    var fieldIdx = dataset.fields.findIndex(function (f) {
      return f.name === column;
    });
    if (fieldIdx >= 0) {
      var displayFormat = formats[column];
      var field = newFields[fieldIdx];
      newFields = (0, _composerHelpers.swap_)((0, _composerHelpers.merge_)({
        displayFormat: displayFormat
      })(field))(newFields);
    }
  });
  var newDataset = (0, _table.copyTableAndUpdate)(dataset, {
    fields: newFields
  });
  var newState = (0, _composerHelpers.pick_)('datasets')((0, _composerHelpers.merge_)((0, _defineProperty2["default"])({}, dataId, newDataset)))(state);

  // update colorField displayFormat
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    layers: newState.layers.map(function (layer) {
      var _layer$config;
      return (_layer$config = layer.config) !== null && _layer$config !== void 0 && (_layer$config = _layer$config.colorField) !== null && _layer$config !== void 0 && _layer$config.name && layer.config.colorField.name in formats ? layer.updateLayerConfig({
        colorField: _objectSpread(_objectSpread({}, layer.config.colorField), {}, {
          displayFormat: formats[layer.config.colorField.name]
        })
      }) : layer;
    })
  });
  return newState;
}

/**
 * Update editor
 */
function toggleEditorVisibilityUpdater(state,
// eslint-disable-next-line @typescript-eslint/no-unused-vars
action) {
  return _objectSpread(_objectSpread({}, state), {}, {
    editor: _objectSpread(_objectSpread({}, state.editor), {}, {
      visible: !state.editor.visible
    })
  });
}
function setFilterAnimationTimeConfigUpdater(state, _ref32) {
  var idx = _ref32.idx,
    config = _ref32.config;
  var oldFilter = state.filters[idx];
  if (!oldFilter) {
    _window.console.error("filters.".concat(idx, " is undefined"));
    return state;
  }
  if (oldFilter.type !== _constants.FILTER_TYPES.timeRange) {
    _window.console.error("setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'");
    return state;
  }
  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('filters')((0, _composerHelpers.swap_)((0, _composerHelpers.merge_)(updates)(oldFilter)))(state);
}
function checkTimeConfigArgs(config) {
  var allowed = ['timeFormat', 'timezone'];
  return Object.keys(config).reduce(function (accu, prop) {
    if (!allowed.includes(prop)) {
      _window.console.error("setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found ".concat(prop));
      return accu;
    }

    // here we are NOT checking if timezone or timeFormat input is valid
    accu[prop] = config[prop];
    return accu;
  }, {});
}

/**
 * Update editor
 */
function setLayerAnimationTimeConfigUpdater(state, _ref33) {
  var config = _ref33.config;
  if (!config) {
    return state;
  }
  var updates = checkTimeConfigArgs(config);
  return (0, _composerHelpers.pick_)('animationConfig')((0, _composerHelpers.merge_)(updates))(state);
}

/**
 * Update editor
 */
function layerFilteredItemsChangeUpdater(state, action) {
  var _layer$filteredItemCo;
  var event = action.event,
    layer = action.layer;
  var deckglLayerId = event.id,
    count = event.count;
  if (!layer) {
    _window.console.warn("layerFilteredItems layer doesnt exists");
    return state;
  }
  if (((_layer$filteredItemCo = layer.filteredItemCount) === null || _layer$filteredItemCo === void 0 ? void 0 : _layer$filteredItemCo[deckglLayerId]) === count) {
    return state;
  }
  layer.filteredItemCount = _objectSpread(_objectSpread({}, layer.filteredItemCount), {}, (0, _defineProperty2["default"])({}, deckglLayerId, count));
  return _objectSpread(_objectSpread({}, state), {}, {
    layers: (0, _composerHelpers.swap_)(layer)(state.layers)
  });
}

// eslint-disable-next-line max-statements
function syncTimeFilterWithLayerTimelineUpdater(state, action) {
  var _newState$animationCo, _newState$animationCo2;
  var filterIdx = action.idx,
    _action$enable = action.enable,
    enable = _action$enable === void 0 ? false : _action$enable;
  var filter = state.filters[filterIdx];
  var newState = state;
  var newFilter = filter;

  // if we enable sync we are going to merge filter and animationConfig domains and store into filter.domain
  if (enable) {
    var animatableLayers = (0, _utils.getAnimatableVisibleLayers)(newState.layers);
    // if no animatableLayers are present we simply return
    if (!animatableLayers.length) {
      return newState;
    }
    var intervalBasedAnimationLayers = (0, _utils.getIntervalBasedAnimationLayers)(animatableLayers);
    var hasIntervalBasedAnimationLayer = Boolean(intervalBasedAnimationLayers.length);
    var newFilterDomain = (0, _utils.mergeTimeDomains)([filter.domain, newState.animationConfig.domain]);

    // we only update animationWindow if we have interval based animation layers with defined intervals and the current filter animation window is not interval
    if (hasIntervalBasedAnimationLayer) {
      if (filter.animationWindow !== _constants.ANIMATION_WINDOW.interval) {
        newState = setFilterAnimationWindowUpdater(newState, {
          id: filter.id,
          animationWindow: _constants.ANIMATION_WINDOW.interval
        });
      }
      newFilter = newState.filters[filterIdx];

      // adjust time filter interval
      newFilter = adjustTimeFilterInterval(newState, newFilter);

      // replace filter in state with newFilter
      newState = _objectSpread(_objectSpread({}, newState), {}, {
        filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
      });
    }
    newFilter = newState.filters[filterIdx];

    // adjust value based on new domain
    var _newFilterValue = (0, _utils.adjustValueToFilterDomain)(newFilter.animationWindow === _constants.ANIMATION_WINDOW.interval ? [newFilterDomain[0], newFilterDomain[0]] : newFilterDomain, _objectSpread(_objectSpread({}, newFilter), {}, {
      domain: newFilterDomain
    }));
    newState = setFilterUpdater(newState, {
      idx: filterIdx,
      prop: 'value',
      value: _newFilterValue
    });
    newFilter = _objectSpread(_objectSpread({}, newState.filters[filterIdx]), {}, {
      syncedWithLayerTimeline: true
    });

    // replace filter in state with newFilter
    newState = _objectSpread(_objectSpread({}, newState), {}, {
      filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
    });
    newState = setTimeFilterTimelineModeUpdater(newState, {
      id: newFilter.id,
      mode: getSyncAnimationMode(newFilter)
    });
    newFilter = newState.filters[filterIdx];

    // set the animation config value to match filter value
    return setLayerAnimationTimeUpdater(newState, {
      value: newFilter.value[newFilter.syncTimelineMode]
    });
  }

  // set domain and step
  newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    syncedWithLayerTimeline: false
  });

  // replace filter in state with newFilter
  newState = _objectSpread(_objectSpread({}, newState), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(newState.filters)
  });

  // reset sync timeline mode
  newState = setTimeFilterTimelineModeUpdater(newState, {
    id: newFilter.id,
    mode: _constants.SYNC_TIMELINE_MODES.end
  });
  newFilter = newState.filters[filterIdx];

  // reset filter value
  var newFilterValue = (0, _utils.adjustValueToFilterDomain)(newFilter.domain, newFilter);
  newState = setFilterUpdater(newState, {
    idx: filterIdx,
    prop: 'value',
    value: newFilterValue
  });
  newState = setTimeFilterTimelineModeUpdater(newState, {
    id: newFilter.id,
    mode: getSyncAnimationMode(newFilter)
  });

  // reset animation config current time to
  return setLayerAnimationTimeUpdater(newState, {
    value: (_newState$animationCo = (_newState$animationCo2 = newState.animationConfig.domain) === null || _newState$animationCo2 === void 0 ? void 0 : _newState$animationCo2[0]) !== null && _newState$animationCo !== void 0 ? _newState$animationCo : null
  });
}
function setTimeFilterTimelineModeUpdater(state, action) {
  var filterId = action.id,
    syncTimelineMode = action.mode;
  var filterIdx = state.filters.findIndex(function (f) {
    return f.id === filterId;
  });
  if (filterIdx === -1) {
    return state;
  }
  var filter = state.filters[filterIdx];
  if (!validateSyncAnimationMode(filter, syncTimelineMode)) {
    return state;
  }
  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {
    syncTimelineMode: syncTimelineMode
  });
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    filters: (0, _composerHelpers.swap_)(newFilter)(state.filters)
  });
  return adjustAnimationConfigWithFilter(newState, filterIdx);
}
function adjustAnimationConfigWithFilter(state, filterIdx) {
  var filter = state.filters[filterIdx];
  if (filter.syncedWithLayerTimeline) {
    var timelineValue = getTimelineValueFromFilter(filter);
    var value = state.animationConfig.timeSteps ? (0, _utils.snapToMarks)(timelineValue, state.animationConfig.timeSteps) : timelineValue;
    return setLayerAnimationTimeUpdater(state, {
      value: value
    });
  }
  return state;
}
function getTimelineValueFromFilter(filter) {
  return filter.value[filter.syncTimelineMode];
}
function getSyncAnimationMode(filter) {
  if (filter.animationWindow === _constants.ANIMATION_WINDOW.free) {
    var _filter$syncTimelineM;
    return (_filter$syncTimelineM = filter.syncTimelineMode) !== null && _filter$syncTimelineM !== void 0 ? _filter$syncTimelineM : _constants.SYNC_TIMELINE_MODES.end;
  }
  return _constants.SYNC_TIMELINE_MODES.end;
}
function validateSyncAnimationMode(filter, newMode) {
  return !(filter.animationWindow !== _constants.ANIMATION_WINDOW.free && newMode === _constants.SYNC_TIMELINE_MODES.start);
}
function adjustTimeFilterInterval(state, filter) {
  var intervalBasedAnimationLayers = (0, _utils.getIntervalBasedAnimationLayers)(state.layers);
  var interval = null;
  if (intervalBasedAnimationLayers.length > 0) {
    // @ts-ignore
    var intervalIndex = intervalBasedAnimationLayers.reduce(function (currentIndex, l) {
      if (l.meta.targetTimeInterval) {
        var newIndex = _utils.TIME_INTERVALS_ORDERED.findIndex(function (i) {
          return i === l.meta.targetTimeInterval;
        });
        return newIndex > -1 && newIndex < currentIndex ? newIndex : currentIndex;
      }
    }, _utils.TIME_INTERVALS_ORDERED.length - 1);
    // @ts-ignore
    var hexTileInterval = _utils.TIME_INTERVALS_ORDERED[intervalIndex];
    interval = _utils.LayerToFilterTimeInterval[hexTileInterval];
  }
  if (!interval) {
    return filter;
  }

  // adjust filter
  var timeFormat = (0, _utils.getDefaultTimeFormat)(interval);
  var updatedPlotType = _objectSpread(_objectSpread({}, filter.plotType), {}, {
    interval: interval,
    timeFormat: timeFormat
  });
  var newFilter = (0, _utils.updateTimeFilterPlotType)(filter, updatedPlotType, state.datasets);
  return (0, _utils.adjustValueToAnimationWindow)(state, newFilter);
}

// Find dataId from a saved visState property:
// layers, filters, interactions, layerBlending, overlayBlending, splitMaps, animationConfig, editor
// replace it with another dataId
function defaultReplaceParentDatasetIds(value, dataId, dataIdToReplace) {
  var _value$config, _value$config2;
  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var replaced = value.map(function (v) {
      return defaultReplaceParentDatasetIds(v, dataId, dataIdToReplace);
    }).filter(function (d) {
      return d;
    });
    return replaced.length ? replaced : null;
  }
  if (typeof value.dataId === 'string' && value.dataId === dataId) {
    // others
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: dataIdToReplace
    });
  } else if (Array.isArray(value.dataId) && value.dataId.includes(dataId)) {
    // filter
    return _objectSpread(_objectSpread({}, value), {}, {
      dataId: value.dataId.map(function (d) {
        return d === dataId ? dataIdToReplace : d;
      })
    });
  } else if ((_value$config = value.config) !== null && _value$config !== void 0 && _value$config.dataId && ((_value$config2 = value.config) === null || _value$config2 === void 0 ? void 0 : _value$config2.dataId) === dataId) {
    // layer
    return _objectSpread(_objectSpread({}, value), {}, {
      config: _objectSpread(_objectSpread({}, value.config), {}, {
        dataId: dataIdToReplace
      })
    });
  } else if ((0, _utils.isObject)(value) && Object.prototype.hasOwnProperty.call(value, dataId)) {
    // for value saved as {[dataId]: {...}}
    return (0, _defineProperty2["default"])({}, dataIdToReplace, value[dataId]);
  }
  return null;
}

// Find datasetIds derived a saved visState Property;
function findChildDatasetIds(value) {
  var _value$newDataset;
  if (Array.isArray(value)) {
    // for layers, filters, call defaultReplaceParentDatasetIds on each item in array
    var childDataIds = value.map(findChildDatasetIds).filter(function (d) {
      return d;
    });
    return childDataIds.length ? childDataIds : null;
  }

  // child data id usually stores in the derived dataset info
  return (value === null || value === void 0 || (_value$newDataset = value.newDataset) === null || _value$newDataset === void 0 ? void 0 : _value$newDataset.info.id) || null;
}

// moved unmerged layers, filters, interactions
function moveValueToBeMerged(state, propValues, _ref35) {
  var prop = _ref35.prop,
    toMergeProp = _ref35.toMergeProp,
    saveUnmerged = _ref35.saveUnmerged;
  // remove prop value from state
  // TODO: should we add remove updater to merger as well?
  if (!propValues) {
    return state;
  }
  var stateRemoved = prop === 'layers' ? propValues.reduce(function (accu, propValue) {
    return removeLayerUpdater(accu, {
      id: propValue.id
    });
  }, state) : Array.isArray(state[prop]) ? _objectSpread(_objectSpread({}, state), {}, (0, _defineProperty2["default"])({}, prop, state[prop].filter(function (p) {
    return !propValues.find(function (propValue) {
      return p.id === propValue.id;
    });
  }))) :
  // if not array, we won't remove it, remove dataset should handle it
  state;

  // move to stateToBeMerged
  var toBeMerged = (0, _defineProperty2["default"])({}, toMergeProp, saveUnmerged ?
  // call merge saveUnmerged method
  saveUnmerged(stateRemoved, propValues) :
  // if toMergeProp is araay, append to it
  Array.isArray(stateRemoved[toMergeProp]) ? [].concat((0, _toConsumableArray2["default"])(stateRemoved[toMergeProp]), (0, _toConsumableArray2["default"])(propValues)) :
  // save propValues to toMerge
  (0, _utils.isObject)(stateRemoved[toMergeProp]) ? _objectSpread(_objectSpread({}, stateRemoved[toMergeProp]), propValues) : stateRemoved[toMergeProp]);
  return _objectSpread(_objectSpread({}, stateRemoved), toBeMerged);
}
function replaceDatasetAndDeps(state, dataId, dataIdToUse) {
  return (0, _composerHelpers.compose_)([(0, _composerHelpers.apply_)(replaceDatasetDepsInState, {
    dataId: dataId,
    dataIdToUse: dataIdToUse
  }), (0, _composerHelpers.apply_)(removeDatasetUpdater, {
    dataId: dataId
  })])(state);
}
function prepareStateForDatasetReplace(state, dataId, dataIdToUse) {
  var _nextState$layerToBeM;
  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = replaceDatasetAndDeps(state, dataId, dataIdToUse);
  // make a copy of layerOrder, because layer id will be removed from it by calling removeLayerUpdater
  var preserveLayerOrder = (0, _toConsumableArray2["default"])(state.layerOrder);

  // preserve dataset order
  nextState.preserveDatasetOrder = Object.keys(state.datasets).map(function (d) {
    return d === dataId ? dataIdToUse : d;
  });

  // preserveLayerOrder
  if ((_nextState$layerToBeM = nextState.layerToBeMerged) !== null && _nextState$layerToBeM !== void 0 && _nextState$layerToBeM.length) {
    var _serializedState$spli;
    // copy split maps to be merged, because it will be reset in remove layer
    nextState.splitMapsToBeMerged = (_serializedState$spli = serializedState === null || serializedState === void 0 ? void 0 : serializedState.splitMaps) !== null && _serializedState$spli !== void 0 ? _serializedState$spli : [];
    nextState.layerOrder = (0, _toConsumableArray2["default"])(preserveLayerOrder);
  }
  return nextState;
}
function replaceDatasetDepsInState(state, _ref36) {
  var dataId = _ref36.dataId,
    dataIdToUse = _ref36.dataIdToUse;
  var serializedState = (0, _visStateMerger.serializeVisState)(state, state.schema);
  var nextState = state.mergers.reduce(function (accuState, _ref37) {
    var prop = _ref37.prop,
      toMergeProp = _ref37.toMergeProp,
      replaceParentDatasetIds = _ref37.replaceParentDatasetIds,
      getChildDatasetIds = _ref37.getChildDatasetIds,
      saveUnmerged = _ref37.saveUnmerged,
      preserveOrder = _ref37.preserveOrder;
    // get dataset ids that are depends on this dataset
    var props = (0, _commonUtils.toArray)(prop);
    var toMergeProps = (0, _commonUtils.toArray)(toMergeProp);
    var savedProps = serializedState ? props.map(function (p) {
      return serializedState[p];
    }) : [];
    var replacedState = accuState;
    savedProps.forEach(function (propValue, i) {
      var _replacedState$merger;
      var mergerOptions = {
        prop: props[i],
        toMergeProp: toMergeProps[i],
        getChildDatasetIds: getChildDatasetIds,
        saveUnmerged: saveUnmerged
      };
      var replacedItem = (replaceParentDatasetIds === null || replaceParentDatasetIds === void 0 ? void 0 : replaceParentDatasetIds(propValue, dataId, dataIdToUse)) || defaultReplaceParentDatasetIds(propValue, dataId, dataIdToUse);
      replacedState = replacedItem ? replacePropValueInState(replacedState, replacedItem, mergerOptions) : replacedState;
      if (mergerOptions.toMergeProp !== undefined && (_replacedState$merger = replacedState[mergerOptions.toMergeProp]) !== null && _replacedState$merger !== void 0 && _replacedState$merger.length && preserveOrder) {
        replacedState[preserveOrder] = propValue.map(function (item) {
          return item.id;
        });
      }
    });
    return replacedState;
  }, state);
  return nextState;
}
function replacePropValueInState(state, replacedItem, _ref38) {
  var prop = _ref38.prop,
    toMergeProp = _ref38.toMergeProp,
    getChildDatasetIds = _ref38.getChildDatasetIds,
    saveUnmerged = _ref38.saveUnmerged;
  // prop is depends on the dataset to be replaced
  // remove prop from state, and move it to toBeMerged
  var nextState = moveValueToBeMerged(state, replacedItem, {
    prop: prop,
    toMergeProp: toMergeProp,
    saveUnmerged: saveUnmerged
  });
  var childDataIds = (getChildDatasetIds === null || getChildDatasetIds === void 0 ? void 0 : getChildDatasetIds(replacedItem)) || findChildDatasetIds(replacedItem);
  if (childDataIds) {
    nextState = (0, _commonUtils.toArray)(childDataIds).reduce(function (accu, childDataId) {
      // shouldn't need to change child dataset id,
      // but still need to move out of state and merge back in
      return replaceDatasetAndDeps(accu, childDataId, childDataId);
    }, nextState);
  }
  return nextState;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYmJveCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2NvcHlUb0NsaXBib2FyZCIsIl9kZWVwbWVyZ2UiLCJfd2luZG93IiwiX2xvZGFzaCIsIl9sb2Rhc2gyIiwiX2xvZGFzaDMiLCJfbG9kYXNoNCIsIl9sb2Rhc2g1IiwiX2xvZGFzaDYiLCJfdGFza3MiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl90YXNrczIiLCJfYWN0aW9ucyIsIl91dGlscyIsIl9jb21tb25VdGlscyIsIl9jb25zdGFudHMiLCJfbGF5ZXJzIiwiX2NvbXBvc2VySGVscGVycyIsIl9tZXJnZXJIYW5kbGVyIiwiX3Zpc1N0YXRlTWVyZ2VyIiwiX3NjaGVtYXMiLCJfdGFibGUiLCJfaW50ZXJhY3Rpb25VdGlscyIsIl9sYXllclV0aWxzIiwiX2VmZmVjdHMiLCJfZGF0YVV0aWxzIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsIl90b1Byb3BlcnR5S2V5IiwiX3RvUHJpbWl0aXZlIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIml0ZXJhdG9yIiwiQXJyYXkiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibGVuZ3RoIiwiX24iLCJGIiwicyIsImRvbmUiLCJ2YWx1ZSIsImYiLCJvIiwibmV4dCIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkaXNhYmxlU3RhY2tDYXB0dXJpbmciLCJ2aXNTdGF0ZVVwZGF0ZXJzIiwiZGVmYXVsdEludGVyYWN0aW9uQ29uZmlnIiwiZXhwb3J0cyIsInRvb2x0aXAiLCJpZCIsImxhYmVsIiwiZW5hYmxlZCIsImNvbmZpZyIsImZpZWxkc1RvU2hvdyIsImNvbXBhcmVNb2RlIiwiY29tcGFyZVR5cGUiLCJDT01QQVJFX1RZUEVTIiwiQUJTT0xVVEUiLCJnZW9jb2RlciIsInBvc2l0aW9uIiwiYnJ1c2giLCJzaXplIiwiY29vcmRpbmF0ZSIsIkRFRkFVTFRfQU5JTUFUSU9OX0NPTkZJRyIsImRvbWFpbiIsImN1cnJlbnRUaW1lIiwic3BlZWQiLCJpc0FuaW1hdGluZyIsInRpbWVTdGVwcyIsInRpbWVGb3JtYXQiLCJ0aW1lem9uZSIsImRlZmF1bHRUaW1lRm9ybWF0IiwiaGlkZUNvbnRyb2wiLCJkdXJhdGlvbiIsIkRFRkFVTFRfRURJVE9SIiwibW9kZSIsIkVESVRPUl9NT0RFUyIsIkRSQVdfUE9MWUdPTiIsImZlYXR1cmVzIiwic2VsZWN0ZWRGZWF0dXJlIiwidmlzaWJsZSIsIklOSVRJQUxfVklTX1NUQVRFIiwibWFwSW5mbyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllclRvQmVNZXJnZWQiLCJsYXllck9yZGVyIiwiZmlsdGVycyIsImZpbHRlclRvQmVNZXJnZWQiLCJkYXRhc2V0cyIsImVkaXRpbmdEYXRhc2V0IiwidW5kZWZpbmVkIiwiZWZmZWN0cyIsImVmZmVjdE9yZGVyIiwiaW50ZXJhY3Rpb25Db25maWciLCJpbnRlcmFjdGlvblRvQmVNZXJnZWQiLCJsYXllckJsZW5kaW5nIiwib3ZlcmxheUJsZW5kaW5nIiwiaG92ZXJJbmZvIiwiY2xpY2tlZCIsIm1vdXNlUG9zIiwibWF4RGVmYXVsdFRvb2x0aXBzIiwiTUFYX0RFRkFVTFRfVE9PTFRJUFMiLCJzcGxpdE1hcHMiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwiaXNNZXJnaW5nRGF0YXNldHMiLCJsYXllckNsYXNzZXMiLCJMYXllckNsYXNzZXMiLCJhbmltYXRpb25Db25maWciLCJlZGl0b3IiLCJmaWxlTG9hZGluZyIsImZpbGVMb2FkaW5nUHJvZ3Jlc3MiLCJsb2FkZXJzIiwibG9hZE9wdGlvbnMiLCJtZXJnZXJzIiwiVklTX1NUQVRFX01FUkdFUlMiLCJzY2hlbWEiLCJLZXBsZXJHTFNjaGVtYSIsInVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YSIsInN0YXRlIiwiX3JlZiIsImxheWVyIiwiaWR4IiwibWFwIiwibHlyIiwiZCIsInVwZGF0ZVN0YXRlT25MYXllclZpc2liaWxpdHlDaGFuZ2UiLCJuZXdTdGF0ZSIsImlzVmlzaWJsZSIsImFkZE5ld0xheWVyc1RvU3BsaXRNYXAiLCJyZW1vdmVMYXllckZyb21TcGxpdE1hcHMiLCJhbmltYXRpb24iLCJ1cGRhdGVBbmltYXRpb25Eb21haW4iLCJwaWNrQ2hhbmdlZFByb3BzIiwicHJldiIsImNoYW5nZWRQcm9wcyIsInBpY2tQcm9wc09mIiwib2JqIiwia2V5IiwicHJvdG90eXBlIiwiaXNFcXVhbCIsIlZJU1VBTF9DSEFOTkVMX1BST1BfVFlQRVMiLCJhcHBseUxheWVyQ29uZmlnVXBkYXRlciIsImFjdGlvbiIsIl9zZXJpYWxpemVMYXllciIsIm9sZExheWVySWQiLCJuZXdMYXllckNvbmZpZyIsImxheWVySW5kZXgiLCJuZXdQYXJzZWRMYXllciIsInBhcnNlTGF5ZXJDb25maWciLCJvbGRMYXllciIsImZpbmQiLCJsIiwiZGF0YXNldCIsImRhdGFJZCIsIm5ld0xheWVyIiwidmFsaWRhdGVMYXllcldpdGhEYXRhIiwibmV4dFN0YXRlIiwidHlwZSIsIm9sZExheWVySW5kZXgiLCJmaW5kSW5kZXgiLCJsYXllclR5cGVDaGFuZ2VVcGRhdGVyIiwibGF5ZXJUeXBlQ2hhbmdlIiwibmV3TGF5ZXJJZCIsImFwcGx5TGF5ZXJDb25maWciLCJzZXJpYWxpemVkT2xkTGF5ZXIiLCJzZXJpYWxpemVMYXllciIsInNlcmlhbGl6ZWROZXdMYXllciIsImNoYW5nZWQiLCJ2aXNDb25maWciLCJsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIiLCJsYXllclZpc0NvbmZpZ0NoYW5nZSIsInZpc3VhbENoYW5uZWxzIiwiY2hhbm5lbE5hbWUiLCJjaGFubmVsIiwiY2hhbm5lbFByb3BOYW1lcyIsInByb3AiLCJzb21lIiwibGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlciIsImxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZSIsInBpY2siLCJfaXRlcmF0b3IiLCJfc3RlcCIsImVyciIsImxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlciIsImxheWVyQ29uZmlnQ2hhbmdlIiwidXBkYXRlbGF5ZXJWaXNpYmlsdHkiLCJmaWx0ZXJJbmRleCIsImZpbHRlclN5bmNlZFdpdGhUaW1lbGluZSIsImlzTGF5ZXJBbmltYXRhYmxlIiwic3luY1RpbWVGaWx0ZXJXaXRoTGF5ZXJUaW1lbGluZVVwZGF0ZXIiLCJlbmFibGUiLCJnZXRBbmltYXRhYmxlVmlzaWJsZUxheWVycyIsInByb3BzIiwibmV3Q29uZmlnIiwiX2FjdGlvbiRuZXdDb25maWciLCJyZXN0Q29uZmlnIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMiIsInN0YXRlV2l0aERhdGFJZCIsImxheWVyRGF0YUlkQ2hhbmdlVXBkYXRlciIsIm5leHRMYXllciIsInVwZGF0ZUxheWVyQ29uZmlnIiwic2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhIiwib2xkTGF5ZXJEYXRhIiwidXBkYXRlTGF5ZXJEYXRhUmVzdWx0IiwiY2FsY3VsYXRlTGF5ZXJEYXRhIiwibGF5ZXJBbmltYXRpb25DaGFuZ2VVcGRhdGVyIiwiX2NhbGN1bGF0ZUxheWVyRGF0YSIsImxheWVyVG9nZ2xlVmlzaWJpbGl0eVVwZGF0ZXIiLCJsYXllcklkIiwic3BsaXRNYXBJZCIsIm1hcEluZGV4Iiwic20iLCJ0b2dnbGVMYXllckZvck1hcFVwZGF0ZXIiLCJ0b2dnbGVMYXllckZvck1hcCIsInN5bmNlZFdpdGhMYXllclRpbWVsaW5lIiwibGF5ZXJTZXRJc1ZhbGlkVXBkYXRlciIsImlzVmFsaWQiLCJsYXllclRvVXBkYXRlIiwibmV3RGF0YSIsIl9jYWxjdWxhdGVMYXllckRhdGEyIiwiYWRkT3JSZW1vdmVUZXh0TGFiZWxzIiwibmV3RmllbGRzIiwidGV4dExhYmVsIiwiZGVmYXVsdFRleHRMYWJlbCIsIkRFRkFVTFRfVEVYVF9MQUJFTCIsIm5ld1RleHRMYWJlbCIsImN1cnJlbnRGaWVsZHMiLCJ0bCIsImZpZWxkIiwiYWRkRmllbGRzIiwiaW5jbHVkZXMiLCJkZWxldGVGaWVsZHMiLCJmZCIsImNvbmNhdCIsIl90b0NvbnN1bWFibGVBcnJheTIiLCJhZiIsInVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZSIsInNwbGljZSIsImxheWVyVGV4dExhYmVsQ2hhbmdlVXBkYXRlciIsIl9vbGRMYXllciRnZXREZWZhdWx0TCIsIl9vbGRMYXllciRnZXREZWZhdWx0TDIiLCJnZXREZWZhdWx0TGF5ZXJDb25maWciLCJ2YWxpZGF0ZUV4aXN0aW5nTGF5ZXJXaXRoRGF0YSIsImxvYWRlZExheWVyIiwiYWxsb3dFbXB0eUNvbHVtbiIsImlzVmFsaWRUb1NhdmUiLCJ2YWxpZGF0ZWQiLCJvbGRMYXllclR5cGUiLCJpc0NvbmZpZ0FjdGl2ZSIsInVwZGF0ZUxheWVyRG9tYWluIiwiX2NhbGN1bGF0ZUxheWVyRGF0YTMiLCJzZXRJbml0aWFsTGF5ZXJDb25maWciLCJyZXN1bHQiLCJmaW5kRGVmYXVsdExheWVyUHJvcHMiLCJuZXdUeXBlIiwib2xkSWQiLCJDb25zb2xlIiwiZXJyb3IiLCJkZWZhdWx0TGF5ZXJQcm9wcyIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsImlzTGF5ZXJIb3ZlcmVkIiwiX2NhbGN1bGF0ZUxheWVyRGF0YTQiLCJzZXR0aW5ncyIsIl9zZXR0aW5ncyRsYXllcnMiLCJvbGRMYXllck1hcCIsIm90aGVyTGF5ZXJzIiwibmV3VmlzQ29uZmlnIiwidXBkYXRlTGF5ZXJWaXNDb25maWciLCJ1cGRhdGVMYXllclZpc3VhbENoYW5uZWwiLCJ1cGRhdGVkU3RhdGUiLCJ2aXN1YWxDaGFubmVsIiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwiY29sb3IiLCJ1cGRhdGVMYXllckNvbG9yVUkiLCJyYW5nZSIsImNvbG9yUmFuZ2VDb25maWciLCJjb2xvclVJIiwiY3VzdG9tQnJlYWtzIiwiX2NhbGN1bGF0ZUxheWVyRGF0YTUiLCJzY2FsZSIsIlNDQUxFX1RZUEVTIiwiY3VzdG9tT3JkaW5hbCIsImN1c3RvbVBhbGV0dGUiLCJpbml0Q3VzdG9tUGFsZXR0ZUJ5Q3VzdG9tU2NhbGUiLCJvcmRpbmFsRG9tYWluIiwiY29sb3JCcmVha3MiLCJzaG93Q29sb3JDaGFydCIsIl9jYWxjdWxhdGVMYXllckRhdGE2Iiwic2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlciIsIl9yZWYyIiwicmVkdWNlIiwiYWNjdSIsInNldEZpbHRlckFuaW1hdGlvblRpbWVVcGRhdGVyIiwic2V0RmlsdGVyVXBkYXRlciIsInNldEZpbHRlckFuaW1hdGlvbldpbmRvd1VwZGF0ZXIiLCJfcmVmMyIsImFuaW1hdGlvbldpbmRvdyIsIm5ld0ZpbHRlciIsInN3YXBfIiwibmV3U3luY1RpbWVsaW5lTW9kZSIsImdldFN5bmNBbmltYXRpb25Nb2RlIiwic2V0VGltZUZpbHRlclRpbWVsaW5lTW9kZVVwZGF0ZXIiLCJhcHBseUZpbHRlckNvbmZpZ1VwZGF0ZXIiLCJfc2VyaWFsaXplRmlsdGVyIiwiZmlsdGVySWQiLCJvbGRGaWx0ZXIiLCJzZXJpYWxpemVkT2xkRmlsdGVyIiwic2VyaWFsaXplRmlsdGVyIiwic2VyaWFsaXplZE5ld0ZpbHRlciIsInNldEZpbHRlciIsInZhbHVlcyIsIl9hY3Rpb24kdmFsdWVJbmRleCIsInZhbHVlSW5kZXgiLCJ0b0FycmF5IiwiZGF0YXNldElkc1RvRmlsdGVyIiwiX2xvb3AiLCJyZXMiLCJ2IiwiX3VwZGF0ZUZpbHRlclByb3AiLCJlbmxhcmdlZEZpbHRlciIsInZpZXciLCJGSUxURVJfVklFV19UWVBFUyIsImVubGFyZ2VkIiwic2lkZSIsImZpbHRlcmVkRGF0YXNldHMiLCJhcHBseUZpbHRlcnNUb0RhdGFzZXRzIiwidW5pcSIsImZpbHRlcldpdGhQTG90IiwidXBkYXRlRmlsdGVyUGxvdCIsInVwZGF0ZUFsbExheWVyRG9tYWluRGF0YSIsIkZJTFRFUl9UWVBFUyIsInRpbWVSYW5nZSIsImFkanVzdEFuaW1hdGlvbkNvbmZpZ1dpdGhGaWx0ZXIiLCJfdXBkYXRlRmlsdGVyRGF0YUlkQXRWYWx1ZUluZGV4IiwiX3JlbW92ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleCIsIm5leHRWYWx1ZSIsImdldERlZmF1bHRGaWx0ZXIiLCJyZW1vdmVGaWx0ZXJQbG90IiwiX2kiLCJfYXJyIiwibmV4dFZhbCIsImRvbWFpblN0ZXBzIiwibWVyZ2VGaWx0ZXJEb21haW4iLCJuZXh0RmlsdGVyIiwic3RlcCIsImFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4iLCJkYXRhc2V0SWRzIiwiRklMVEVSX1VQREFURVJfUFJPUFMiLCJvbGREYXRhSWQiLCJkYXRhc2V0SWQiLCJfYXBwbHlGaWx0ZXJGaWVsZE5hbWUiLCJhcHBseUZpbHRlckZpZWxkTmFtZSIsIm1lcmdlRG9tYWluIiwidXBkYXRlZEZpbHRlciIsIm5ld0RhdGFzZXQiLCJncHUiLCJzZXRGaWx0ZXJHcHVNb2RlIiwiYXNzaWduR3B1Q2hhbm5lbCIsImxheWVySWREaWZmZXJlbmNlIiwieG9yIiwibGF5ZXJEYXRhSWRzIiwibGlkIiwibmV3RGF0YUlkcyIsInNldEZpbHRlclBsb3RVcGRhdGVyIiwiX3JlZjQiLCJuZXdQcm9wIiwicGlja18iLCJtZXJnZV8iLCJwbG90VHlwZSIsImNoYXJ0VHlwZSIsInlBeGlzIiwiUExPVF9UWVBFUyIsImxpbmVDaGFydCIsImhpc3RvZ3JhbSIsImFkZEZpbHRlclVwZGF0ZXIiLCJjcmVhdGVPclVwZGF0ZUZpbHRlclVwZGF0ZXIiLCJvcmlnaW5hbEluZGV4IiwiaW5kZXgiLCJsYXllckNvbG9yVUlDaGFuZ2VVcGRhdGVyIiwiX3JlZjUiLCJvbGRWaXhDb25maWciLCJ0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyIiwiaXNGaWx0ZXJBbmltYXRpb25Db25maWciLCJzZXRBbmltYXRpb25Db25maWdVcGRhdGVyIiwiaXNTaWRlRmlsdGVyIiwiYXBwbHlGaWx0ZXJDb25maWciLCJ0b2dnbGVMYXllckFuaW1hdGlvblVwZGF0ZXIiLCJ0b2dnbGVMYXllckFuaW1hdGlvbkNvbnRyb2xVcGRhdGVyIiwidXBkYXRlRmlsdGVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyIiwidXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIiLCJfcmVmNiIsInNldEZpbHRlclZpZXdVcGRhdGVyIiwic2hvdWxkUmVzZXRPdGhlckZpbHRlcnNWaWV3IiwidG9nZ2xlRmlsdGVyRmVhdHVyZVVwZGF0ZXIiLCJmZWF0dXJlVG9GaWx0ZXJWYWx1ZSIsInJlbW92ZUZpbHRlclVwZGF0ZXIiLCJfc3RhdGUkZmlsdGVycyRpZHgiLCJuZXdGaWx0ZXJzIiwibmV3RWRpdG9yIiwiZ2V0RmlsdGVySWRJbkZlYXR1cmUiLCJhZGRMYXllclVwZGF0ZXIiLCJuZXdMYXllckRhdGEiLCJjcmVhdGVMYXllckZyb21Db25maWciLCJ3YXJuIiwiX2FjdGlvbiRkYXRhc2V0SWQiLCJkZWZhdWx0RGF0YXNldCIsIkxheWVyIiwicmVtb3ZlTGF5ZXJVcGRhdGVyIiwiX3JlZjciLCJpc0Zpbml0ZSIsImxheWVyVG9SZW1vdmUiLCJmaWx0ZXJPdXRCeUlkIiwicmVtb3ZlRWxlbWVudEF0SW5kZXgiLCJyZW9yZGVyTGF5ZXJVcGRhdGVyIiwiX3JlZjgiLCJvcmRlciIsImR1cGxpY2F0ZUxheWVyVXBkYXRlciIsIl9yZWY5Iiwib3JpZ2luYWwiLCJvcmlnaW5hbExheWVyT3JkZXJJZHgiLCJuZXdMYWJlbCIsInBvc3RmaXgiLCJnZW5lcmF0ZUhhc2hJZCIsIkxBWUVSX0lEX0xFTkdUSCIsIm5ld0xheWVyT3JkZXIiLCJhcnJheUluc2VydCIsImFkZEVmZmVjdFVwZGF0ZXIiLCJfYWN0aW9uJGNvbmZpZyIsIkxJR0hUX0FORF9TSEFET1dfRUZGRUNUIiwiZWZmZWN0IiwibmV3RWZmZWN0IiwiY3JlYXRlRWZmZWN0Iiwic2V0UHJvcHMiLCJmaXhFZmZlY3RPcmRlciIsInJlbW92ZUVmZmVjdFVwZGF0ZXIiLCJfcmVmMTAiLCJlZmZlY3RUb1JlbW92ZSIsImVmZmVjdElkIiwicmVvcmRlckVmZmVjdFVwZGF0ZXIiLCJfcmVmMTEiLCJ1cGRhdGVFZmZlY3RVcGRhdGVyIiwiX3JlZjEyIiwiaWR4MiIsImVmZmVjdE9yZGVySWQiLCJuZXdFZmZlY3RzIiwicmVtb3ZlRGF0YXNldFVwZGF0ZXIiLCJkYXRhc2V0S2V5IiwiX3N0YXRlJGRhdGFzZXRzIiwibmV3RGF0YXNldHMiLCJsYXllcnNUb1JlbW92ZSIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJpbmRleE9mIiwicmVtb3ZlRGF0YXNldEZyb21JbnRlcmFjdGlvbkNvbmZpZyIsIl9yZWYxMyIsIl9pbnRlcmFjdGlvbkNvbmZpZyIsIl9jb25maWckZmllbGRzVG9TaG93IiwiZmllbGRzIiwidXBkYXRlTGF5ZXJCbGVuZGluZ1VwZGF0ZXIiLCJ1cGRhdGVPdmVybGF5QmxlbmRpbmdVcGRhdGVyIiwic2hvd0RhdGFzZXRUYWJsZVVwZGF0ZXIiLCJ1cGRhdGVUYWJsZUNvbG9yVXBkYXRlciIsInVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXIiLCJuZXdDb2xvciIsInJlc2V0TWFwQ29uZmlnVXBkYXRlciIsImluaXRpYWxTdGF0ZSIsInJlY2VpdmVNYXBDb25maWdVcGRhdGVyIiwiX3JlZjE0IiwiX3JlZjE0JHBheWxvYWQiLCJwYXlsb2FkIiwiX3JlZjE0JHBheWxvYWQkY29uZmlnIiwiX3JlZjE0JHBheWxvYWQkb3B0aW9uIiwib3B0aW9ucyIsInZpc1N0YXRlIiwia2VlcEV4aXN0aW5nQ29uZmlnIiwibWVyZ2VkU3RhdGUiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwibWVyZ2VyIiwiaXNWYWxpZE1lcmdlciIsImhhc1Byb3BzVG9NZXJnZSIsIm1lcmdlIiwiZ2V0UHJvcFZhbHVlVG9NZXJnZXIiLCJ0b01lcmdlUHJvcCIsImxheWVySG92ZXJVcGRhdGVyIiwiaW5mbyIsImludGVyYWN0aW9uQ29uZmlnQ2hhbmdlVXBkYXRlciIsImNvbnRyYWRpY3QiLCJrIiwibGF5ZXJDbGlja1VwZGF0ZXIiLCJwaW5uZWQiLCJjbG9uZURlZXAiLCJwaWNrZWQiLCJtYXBDbGlja1VwZGF0ZXIiLCJtb3VzZU1vdmVVcGRhdGVyIiwiX3JlZjE1IiwiZXZ0IiwicG9pbnQiLCJtb3VzZVBvc2l0aW9uIiwibG5nTGF0IiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIiwiY29tcHV0ZVNwbGl0TWFwTGF5ZXJzIiwiZHVwbGljYXRlIiwiY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgiLCJfcmVmMTYiLCJ1cGRhdGVWaXNEYXRhVXBkYXRlciIsInByZXZpb3VzU3RhdGUiLCJzZXRJc0xvYWRpbmdUYXNrIiwiQUNUSU9OX1RBU0siLCJzZXRMb2FkaW5nSW5kaWNhdG9yIiwiY2hhbmdlIiwid2l0aFRhc2siLCJjcmVhdGVEYXRhc2V0VGFza3MiLCJub3RpZmljYXRpb25UYXNrcyIsIl9yZWYxNyIsImRhdGFzZXRJbmRleCIsIl9yZWYxNyRpbmZvIiwicmVzdCIsInRhc2siLCJjcmVhdGVOZXdEYXRhRW50cnkiLCJhZGROb3RpZmljYXRpb24iLCJlcnJvck5vdGlmaWNhdGlvbiIsIm1lc3NhZ2UiLCJkYXRhc2V0c0FsbFNldHRsZWRUYXNrIiwiVGFzayIsImFsbFNldHRsZWQiLCJyZXN1bHRzIiwiY3JlYXRlTmV3RGF0YXNldFN1Y2Nlc3MiLCJhZGRUb01hcE9wdGlvbnMiLCJjcmVhdGVOZXdEYXRhc2V0U3VjY2Vzc1VwZGF0ZXIiLCJfYWN0aW9uJHBheWxvYWQiLCJuZXdEYXRhRW50cmllcyIsInN0YXR1cyIsImNvbnNvbGUiLCJyZWFzb24iLCJtZXJnZURhdGFzZXRzQnlPcmRlciIsImxheWVyTWVyZ2VycyIsIm0iLCJ3YWl0Rm9yTGF5ZXJEYXRhIiwiZGF0YXNldE1lcmdlcnMiLCJwb3N0TWVyZ2VyUGF5bG9hZCIsImFwcGx5TWVyZ2Vyc1VwZGF0ZXIiLCJtZXJnZVN0YXRlUmVzdWx0IiwibWVyZ2VTdGF0ZUZyb21NZXJnZXJzIiwiYWxsTWVyZ2VkIiwicG9zdE1lcmdlVXBkYXRlciIsImZEYXRhSWQiLCJkYXRhc2V0RmlsdGVyZWQiLCJkYXRhRW1wdHkiLCJuZXdMYXllcnMiLCJhdXRvQ3JlYXRlTGF5ZXJzIiwiYWRkRGVmYXVsdExheWVycyIsInRvb2x0aXBGaWVsZHMiLCJhdXRvQ3JlYXRlVG9vbHRpcHMiLCJhZGREZWZhdWx0VG9vbHRpcHMiLCJ1cGRhdGVkRGF0YXNldHMiLCJjZW50ZXJNYXAiLCJib3VuZHMiLCJmaW5kTWFwQm91bmRzIiwiZml0Qm91bmRzVGFzayIsImZpdE1hcEJvdW5kcyIsInJlbmFtZURhdGFzZXRVcGRhdGVyIiwiQUxMT1dFRF9VUERBVEVfREFUQVNFVF9QUk9QUyIsInZhbGlkYXRlRGF0YXNldFVwZGF0ZVByb3BzIiwidmFsaWRhdGVkUHJvcHMiLCJlbnRyaWVzIiwiYWNjIiwiZW50cnkiLCJfZW50cnkiLCJfc2xpY2VkVG9BcnJheTIiLCJpc1JnYkNvbG9yIiwiaXNQbGFpbk9iamVjdCIsImRlZXBtZXJnZSIsImV4aXN0aW5nIiwiY29weVRhYmxlQW5kVXBkYXRlIiwiX3N0YXRlJHNwbGl0TWFwcyRpbmRlIiwiaW5kZXhUb1JldHJpZXZlIiwibWFwTGF5ZXJzIiwibG9hZEZpbGVzVXBkYXRlciIsImZpbGVzIiwiX2FjdGlvbiRvbkZpbmlzaCIsIm9uRmluaXNoIiwibG9hZEZpbGVzU3VjY2VzcyIsImluaXRpYWxGaWxlTG9hZGluZ1Byb2dyZXNzIiwiZmlsZUNhY2hlIiwiZmlsZXNUb0xvYWQiLCJsb2FkTmV4dEZpbGVVcGRhdGVyIiwibG9hZEZpbGVTdGVwU3VjY2Vzc1VwZGF0ZXIiLCJmaWxlTmFtZSIsIl9zdGF0ZSRmaWxlTG9hZGluZyIsInN0YXRlV2l0aFByb2dyZXNzIiwidXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIiLCJwcm9ncmVzcyIsInBlcmNlbnQiLCJzdGF0ZVdpdGhDYWNoZSIsIkRFTEFZX1RBU0siLCJsb2FkTmV4dEZpbGUiLCJfZmlsZXNUb0xvYWQiLCJfdG9BcnJheTIiLCJmaWxlIiwicmVtYWluaW5nRmlsZXNUb0xvYWQiLCJtYWtlTG9hZEZpbGVUYXNrIiwiTE9BRF9GSUxFX1RBU0siLCJiaW1hcCIsImdlbiIsIm5leHRGaWxlQmF0Y2giLCJwcm9jZXNzRmlsZUNvbnRlbnQiLCJjb250ZW50IiwibG9hZEZpbGVzRXJyIiwicHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlciIsIl9hY3Rpb24kcGF5bG9hZDIiLCJQUk9DRVNTX0ZJTEVfREFUQSIsImxvYWRGaWxlU3RlcFN1Y2Nlc3MiLCJwYXJzZVByb2dyZXNzIiwicHJldlByb2dyZXNzIiwibmV4dEZpbGVCYXRjaFVwZGF0ZXIiLCJfcmVmMTgiLCJfYWNjdW11bGF0ZWQkZGF0YSIsIl9yZWYxOCRwYXlsb2FkIiwiYWNjdW11bGF0ZWQiLCJnZXRBcHBsaWNhdGlvbkNvbmZpZyIsInVzZUFycm93UHJvZ3Jlc3NpdmVMb2FkaW5nIiwiZW5kc1dpdGgiLCJkYXRhIiwiVU5XUkFQX1RBU0siLCJfcmVmMTkiLCJsb2FkRmlsZXNFcnJVcGRhdGVyIiwiX3JlZjIwIiwiX3N0YXRlJGZpbGVMb2FkaW5nMiIsImFwcGx5Q1BVRmlsdGVyVXBkYXRlciIsIl9yZWYyMSIsImRhdGFJZHMiLCJmaWx0ZXJEYXRhc2V0Q1BVIiwic2V0TWFwSW5mb1VwZGF0ZXIiLCJlbXB0eSIsImRlZmF1bHRMYXllcnMiLCJmb3VuZExheWVycyIsImZpbmREZWZhdWx0TGF5ZXIiLCJnZXRMYXllck9yZGVyRnJvbUxheWVycyIsImZpbmRGaWVsZHNUb1Nob3ciLCJtZXJnZWQiLCJfcmVmMjMiLCJmaXhlZERvbWFpbiIsIl9jYWxjdWxhdGVMYXllckRhdGE3IiwiX3N0YXRlJGZpbHRlcnMiLCJhbmltYXRhYmxlTGF5ZXJzIiwibGF5ZXJEb21haW5zIiwibWVyZ2VkRG9tYWluIiwibWVyZ2VUaW1lRG9tYWlucyIsImdldFRpbWVXaWRnZXRUaXRsZUZvcm1hdHRlciIsIm1lcmdlZFRpbWVTdGVwcyIsInNvcnQiLCJCQVNFX1NQRUVEIiwiRlBTIiwic3luY2VkRmlsdGVyIiwibmV3QW5pbWF0aW9uRG9tYWluIiwiaXNJblJhbmdlIiwic2V0RWRpdG9yTW9kZVVwZGF0ZXIiLCJfcmVmMjQiLCJzZXRGZWF0dXJlc1VwZGF0ZXIiLCJfcmVmMjUiLCJfbGFzdEZlYXR1cmUkcHJvcGVydGkiLCJfcmVmMjUkZmVhdHVyZXMiLCJsYXN0RmVhdHVyZSIsInByb3BlcnRpZXMiLCJpc0Nsb3NlZCIsIkVESVQiLCJmZWF0dXJlIiwiYmJveCIsImZlYXR1cmVWYWx1ZSIsImZpbHRlcklkeCIsImZpbCIsInNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIiLCJfcmVmMjYiLCJzZWxlY3Rpb25Db250ZXh0IiwiZGVsZXRlRmVhdHVyZVVwZGF0ZXIiLCJfcmVmMjciLCJzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyIiwibm9uZUZpbHRlckZlYXR1cmUiLCJfZmlsdGVyJGxheWVySWQiLCJpc0xheWVySW5jbHVkZWQiLCJnZW5lcmF0ZVBvbHlnb25GaWx0ZXIiLCJzb3J0VGFibGVDb2x1bW5VcGRhdGVyIiwiX3JlZjI4IiwiY29sdW1uIiwic29ydE1vZGUiLCJjdXJyZW50TW9kZSIsIlNPUlRfT1JERVIiLCJBU0NFTkRJTkciLCJzb3J0ZWQiLCJzb3J0RGF0YXNldEJ5Q29sdW1uIiwicGluVGFibGVDb2x1bW5VcGRhdGVyIiwiX3JlZjI5IiwicGluVGFibGVDb2x1bW5zIiwiY29weVRhYmxlQ29sdW1uVXBkYXRlciIsIl9yZWYzMCIsImZpZWxkSWR4IiwidGV4dCIsImRhdGFDb250YWluZXIiLCJyb3ciLCJwYXJzZUZpZWxkVmFsdWUiLCJ2YWx1ZUF0Iiwiam9pbiIsImNvcHkiLCJzZXRDb2x1bW5EaXNwbGF5Rm9ybWF0VXBkYXRlciIsIl9yZWYzMSIsImZvcm1hdHMiLCJkaXNwbGF5Rm9ybWF0IiwiX2xheWVyJGNvbmZpZyIsImNvbG9yRmllbGQiLCJ0b2dnbGVFZGl0b3JWaXNpYmlsaXR5VXBkYXRlciIsInNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdVcGRhdGVyIiwiX3JlZjMyIiwidXBkYXRlcyIsImNoZWNrVGltZUNvbmZpZ0FyZ3MiLCJhbGxvd2VkIiwic2V0TGF5ZXJBbmltYXRpb25UaW1lQ29uZmlnVXBkYXRlciIsIl9yZWYzMyIsImxheWVyRmlsdGVyZWRJdGVtc0NoYW5nZVVwZGF0ZXIiLCJfbGF5ZXIkZmlsdGVyZWRJdGVtQ28iLCJldmVudCIsImRlY2tnbExheWVySWQiLCJjb3VudCIsImZpbHRlcmVkSXRlbUNvdW50IiwiX25ld1N0YXRlJGFuaW1hdGlvbkNvIiwiX25ld1N0YXRlJGFuaW1hdGlvbkNvMiIsIl9hY3Rpb24kZW5hYmxlIiwiaW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycyIsImdldEludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMiLCJoYXNJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXIiLCJCb29sZWFuIiwibmV3RmlsdGVyRG9tYWluIiwiQU5JTUFUSU9OX1dJTkRPVyIsImludGVydmFsIiwiYWRqdXN0VGltZUZpbHRlckludGVydmFsIiwibmV3RmlsdGVyVmFsdWUiLCJzeW5jVGltZWxpbmVNb2RlIiwiU1lOQ19USU1FTElORV9NT0RFUyIsImVuZCIsInZhbGlkYXRlU3luY0FuaW1hdGlvbk1vZGUiLCJ0aW1lbGluZVZhbHVlIiwiZ2V0VGltZWxpbmVWYWx1ZUZyb21GaWx0ZXIiLCJzbmFwVG9NYXJrcyIsImZyZWUiLCJfZmlsdGVyJHN5bmNUaW1lbGluZU0iLCJuZXdNb2RlIiwic3RhcnQiLCJpbnRlcnZhbEluZGV4IiwiY3VycmVudEluZGV4IiwibWV0YSIsInRhcmdldFRpbWVJbnRlcnZhbCIsIm5ld0luZGV4IiwiVElNRV9JTlRFUlZBTFNfT1JERVJFRCIsImhleFRpbGVJbnRlcnZhbCIsIkxheWVyVG9GaWx0ZXJUaW1lSW50ZXJ2YWwiLCJnZXREZWZhdWx0VGltZUZvcm1hdCIsInVwZGF0ZWRQbG90VHlwZSIsInVwZGF0ZVRpbWVGaWx0ZXJQbG90VHlwZSIsImFkanVzdFZhbHVlVG9BbmltYXRpb25XaW5kb3ciLCJkZWZhdWx0UmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJkYXRhSWRUb1JlcGxhY2UiLCJfdmFsdWUkY29uZmlnIiwiX3ZhbHVlJGNvbmZpZzIiLCJyZXBsYWNlZCIsImlzT2JqZWN0IiwiZmluZENoaWxkRGF0YXNldElkcyIsIl92YWx1ZSRuZXdEYXRhc2V0IiwiY2hpbGREYXRhSWRzIiwibW92ZVZhbHVlVG9CZU1lcmdlZCIsInByb3BWYWx1ZXMiLCJfcmVmMzUiLCJzYXZlVW5tZXJnZWQiLCJzdGF0ZVJlbW92ZWQiLCJwcm9wVmFsdWUiLCJwIiwidG9CZU1lcmdlZCIsInJlcGxhY2VEYXRhc2V0QW5kRGVwcyIsImRhdGFJZFRvVXNlIiwiY29tcG9zZV8iLCJhcHBseV8iLCJyZXBsYWNlRGF0YXNldERlcHNJblN0YXRlIiwicHJlcGFyZVN0YXRlRm9yRGF0YXNldFJlcGxhY2UiLCJfbmV4dFN0YXRlJGxheWVyVG9CZU0iLCJzZXJpYWxpemVkU3RhdGUiLCJzZXJpYWxpemVWaXNTdGF0ZSIsInByZXNlcnZlTGF5ZXJPcmRlciIsInByZXNlcnZlRGF0YXNldE9yZGVyIiwiX3NlcmlhbGl6ZWRTdGF0ZSRzcGxpIiwiX3JlZjM2IiwiYWNjdVN0YXRlIiwiX3JlZjM3IiwicmVwbGFjZVBhcmVudERhdGFzZXRJZHMiLCJnZXRDaGlsZERhdGFzZXRJZHMiLCJwcmVzZXJ2ZU9yZGVyIiwidG9NZXJnZVByb3BzIiwic2F2ZWRQcm9wcyIsInJlcGxhY2VkU3RhdGUiLCJfcmVwbGFjZWRTdGF0ZSRtZXJnZXIiLCJtZXJnZXJPcHRpb25zIiwicmVwbGFjZWRJdGVtIiwicmVwbGFjZVByb3BWYWx1ZUluU3RhdGUiLCJpdGVtIiwiX3JlZjM4IiwiY2hpbGREYXRhSWQiXSwic291cmNlcyI6WyIuLi9zcmMvdmlzLXN0YXRlLXVwZGF0ZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCBiYm94IGZyb20gJ0B0dXJmL2Jib3gnO1xuaW1wb3J0IGNvcHkgZnJvbSAnY29weS10by1jbGlwYm9hcmQnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLmdldCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2guaXNlcXVhbCc7XG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gucGljayc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5pbXBvcnQgeG9yIGZyb20gJ2xvZGFzaC54b3InO1xuaW1wb3J0IFRhc2ssIHtkaXNhYmxlU3RhY2tDYXB0dXJpbmcsIHdpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbi8vIFRhc2tzXG5pbXBvcnQge1xuICBERUxBWV9UQVNLLFxuICBBQ1RJT05fVEFTSyxcbiAgTE9BRF9GSUxFX1RBU0ssXG4gIFBST0NFU1NfRklMRV9EQVRBLFxuICBVTldSQVBfVEFTS1xufSBmcm9tICdAa2VwbGVyLmdsL3Rhc2tzJztcbi8vIEFjdGlvbnNcbmltcG9ydCB7XG4gIGFkZE5vdGlmaWNhdGlvbixcbiAgQWN0aW9uVHlwZXMsXG4gIENyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzUGF5bG9hZCxcbiAgTWFwU3RhdGVBY3Rpb25zLFxuICBSZWNlaXZlTWFwQ29uZmlnUGF5bG9hZCxcbiAgVmlzU3RhdGVBY3Rpb25zLFxuICBhcHBseUxheWVyQ29uZmlnLFxuICBjcmVhdGVOZXdEYXRhc2V0U3VjY2VzcyxcbiAgbGF5ZXJDb25maWdDaGFuZ2UsXG4gIGxheWVyVHlwZUNoYW5nZSxcbiAgbGF5ZXJWaXNDb25maWdDaGFuZ2UsXG4gIGxheWVyVmlzdWFsQ2hhbm5lbENvbmZpZ0NoYW5nZSxcbiAgbG9hZEZpbGVTdGVwU3VjY2VzcyxcbiAgbG9hZEZpbGVzRXJyLFxuICBsb2FkRmlsZXNTdWNjZXNzLFxuICBsb2FkTmV4dEZpbGUsXG4gIG5leHRGaWxlQmF0Y2gsXG4gIHNldEZpbHRlcixcbiAgcHJvY2Vzc0ZpbGVDb250ZW50LFxuICBmaXRCb3VuZHMgYXMgZml0TWFwQm91bmRzLFxuICBzZXRMb2FkaW5nSW5kaWNhdG9yLFxuICB0b2dnbGVMYXllckZvck1hcCxcbiAgYXBwbHlGaWx0ZXJDb25maWdcbn0gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcblxuLy8gVXRpbHNcbmltcG9ydCB7XG4gIEZJTFRFUl9VUERBVEVSX1BST1BTLFxuICBhZGROZXdMYXllcnNUb1NwbGl0TWFwLFxuICBzbmFwVG9NYXJrcyxcbiAgYXBwbHlGaWx0ZXJGaWVsZE5hbWUsXG4gIGFwcGx5RmlsdGVyc1RvRGF0YXNldHMsXG4gIGFycmF5SW5zZXJ0LFxuICBjb21wdXRlU3BsaXRNYXBMYXllcnMsXG4gIGFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4sXG4gIGVycm9yTm90aWZpY2F0aW9uLFxuICBmZWF0dXJlVG9GaWx0ZXJWYWx1ZSxcbiAgZmlsdGVyRGF0YXNldENQVSxcbiAgZ2VuZXJhdGVQb2x5Z29uRmlsdGVyLFxuICBnZXREZWZhdWx0RmlsdGVyLFxuICBnZXRGaWx0ZXJJZEluRmVhdHVyZSxcbiAgZ2V0VGltZVdpZGdldFRpdGxlRm9ybWF0dGVyLFxuICBpc0luUmFuZ2UsXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1JnYkNvbG9yLFxuICBwYXJzZUZpZWxkVmFsdWUsXG4gIHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyxcbiAgc2V0LFxuICB1cGRhdGVGaWx0ZXJQbG90LFxuICByZW1vdmVGaWx0ZXJQbG90LFxuICBpc0xheWVyQW5pbWF0YWJsZSxcbiAgaXNTaWRlRmlsdGVyLFxuICBnZXRBcHBsaWNhdGlvbkNvbmZpZ1xufSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7Z2VuZXJhdGVIYXNoSWQsIHRvQXJyYXl9IGZyb20gJ0BrZXBsZXIuZ2wvY29tbW9uLXV0aWxzJztcbi8vIE1lcmdlcnNcbmltcG9ydCB7XG4gIEFOSU1BVElPTl9XSU5ET1csXG4gIEJBU0VfU1BFRUQsXG4gIENPTVBBUkVfVFlQRVMsXG4gIERFRkFVTFRfVEVYVF9MQUJFTCxcbiAgRURJVE9SX01PREVTLFxuICBGSUxURVJfVFlQRVMsXG4gIEZJTFRFUl9WSUVXX1RZUEVTLFxuICBGUFMsXG4gIExJR0hUX0FORF9TSEFET1dfRUZGRUNULFxuICBNQVhfREVGQVVMVF9UT09MVElQUyxcbiAgUExPVF9UWVBFUyxcbiAgU09SVF9PUkRFUixcbiAgU1lOQ19USU1FTElORV9NT0RFUyxcbiAgQ0hBTk5FTF9TQ0FMRVMsXG4gIFNDQUxFX1RZUEVTXG59IGZyb20gJ0BrZXBsZXIuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7TEFZRVJfSURfTEVOR1RILCBMYXllciwgTGF5ZXJDbGFzc2VzfSBmcm9tICdAa2VwbGVyLmdsL2xheWVycyc7XG5pbXBvcnQge1xuICBhcHBseV8sXG4gIGNvbXBvc2VfLFxuICBmaWx0ZXJPdXRCeUlkLFxuICBtZXJnZV8sXG4gIHBpY2tfLFxuICByZW1vdmVFbGVtZW50QXRJbmRleCxcbiAgc3dhcF9cbn0gZnJvbSAnLi9jb21wb3Nlci1oZWxwZXJzJztcbmltcG9ydCB7aXNWYWxpZE1lcmdlciwgbWVyZ2VTdGF0ZUZyb21NZXJnZXJzfSBmcm9tICcuL21lcmdlci1oYW5kbGVyJztcbmltcG9ydCB7XG4gIFZJU19TVEFURV9NRVJHRVJTLFxuICBjcmVhdGVMYXllckZyb21Db25maWcsXG4gIHBhcnNlTGF5ZXJDb25maWcsXG4gIHNlcmlhbGl6ZUZpbHRlcixcbiAgc2VyaWFsaXplTGF5ZXIsXG4gIHNlcmlhbGl6ZVZpc1N0YXRlLFxuICB2YWxpZGF0ZUxheWVyV2l0aERhdGFcbn0gZnJvbSAnLi92aXMtc3RhdGUtbWVyZ2VyJztcblxuaW1wb3J0IEtlcGxlckdMU2NoZW1hLCB7TWVyZ2VyLCBQb3N0TWVyZ2VyUGF5bG9hZCwgVmlzU3RhdGV9IGZyb20gJ0BrZXBsZXIuZ2wvc2NoZW1hcyc7XG5cbmltcG9ydCB7XG4gIEZpbHRlcixcbiAgSW50ZXJhY3Rpb25Db25maWcsXG4gIEFuaW1hdGlvbkNvbmZpZyxcbiAgRmlsdGVyQW5pbWF0aW9uQ29uZmlnLFxuICBFZGl0b3IsXG4gIEZpZWxkLFxuICBUaW1lUmFuZ2VGaWx0ZXJcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0xvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcblxuaW1wb3J0IHtcbiAgRGF0YXNldHMsXG4gIGFzc2lnbkdwdUNoYW5uZWwsXG4gIGNvcHlUYWJsZUFuZFVwZGF0ZSxcbiAgY3JlYXRlTmV3RGF0YUVudHJ5LFxuICBwaW5UYWJsZUNvbHVtbnMsXG4gIHNldEZpbHRlckdwdU1vZGUsXG4gIHNvcnREYXRhc2V0QnlDb2x1bW5cbn0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge2ZpbmRGaWVsZHNUb1Nob3d9IGZyb20gJy4vaW50ZXJhY3Rpb24tdXRpbHMnO1xuaW1wb3J0IHtjYWxjdWxhdGVMYXllckRhdGEsIGZpbmREZWZhdWx0TGF5ZXIsIGdldExheWVyT3JkZXJGcm9tTGF5ZXJzfSBmcm9tICcuL2xheWVyLXV0aWxzJztcbmltcG9ydCB7Z2V0UHJvcFZhbHVlVG9NZXJnZXIsIGhhc1Byb3BzVG9NZXJnZX0gZnJvbSAnLi9tZXJnZXItaGFuZGxlcic7XG5pbXBvcnQge21lcmdlRGF0YXNldHNCeU9yZGVyfSBmcm9tICcuL3Zpcy1zdGF0ZS1tZXJnZXInO1xuaW1wb3J0IHtcbiAgZml4RWZmZWN0T3JkZXIsXG4gIGdldEFuaW1hdGFibGVWaXNpYmxlTGF5ZXJzLFxuICBnZXRJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzLFxuICBtZXJnZVRpbWVEb21haW5zLFxuICBhZGp1c3RWYWx1ZVRvQW5pbWF0aW9uV2luZG93LFxuICB1cGRhdGVUaW1lRmlsdGVyUGxvdFR5cGUsXG4gIGdldERlZmF1bHRUaW1lRm9ybWF0LFxuICBMYXllclRvRmlsdGVyVGltZUludGVydmFsLFxuICBUSU1FX0lOVEVSVkFMU19PUkRFUkVELFxuICBtZXJnZUZpbHRlckRvbWFpbixcbiAgaW5pdEN1c3RvbVBhbGV0dGVCeUN1c3RvbVNjYWxlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVFZmZlY3R9IGZyb20gJ0BrZXBsZXIuZ2wvZWZmZWN0cyc7XG5pbXBvcnQge1BheWxvYWRBY3Rpb259IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuXG5pbXBvcnQge2ZpbmRNYXBCb3VuZHN9IGZyb20gJy4vZGF0YS11dGlscyc7XG5cbi8vIHJlYWN0LXBhbG1cbi8vIGRpc2FibGUgY2FwdHVyZSBleGNlcHRpb24gZm9yIHJlYWN0LXBhbG0gY2FsbCB0byB3aXRoVGFza1xuZGlzYWJsZVN0YWNrQ2FwdHVyaW5nKCk7XG5cbi8qKlxuICogVXBkYXRlcnMgZm9yIGB2aXNTdGF0ZWAgcmVkdWNlci4gQ2FuIGJlIHVzZWQgaW4geW91ciByb290IHJlZHVjZXIgdG8gZGlyZWN0bHkgbW9kaWZ5IGtlcGxlci5nbCdzIHN0YXRlLlxuICogUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyLCB7dmlzU3RhdGVVcGRhdGVyc30gZnJvbSAna2VwbGVyLmdsL3JlZHVjZXJzJztcbiAqIC8vIFJvb3QgUmVkdWNlclxuICogY29uc3QgcmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICogIGtlcGxlckdsOiBrZXBsZXJHbFJlZHVjZXIsXG4gKiAgYXBwOiBhcHBSZWR1Y2VyXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb21wb3NlZFJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICogIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAqICAgIGNhc2UgJ0NMSUNLX0JVVFRPTic6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgZm9vOiB7XG4gKiAgICAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbC5mb28sXG4gKiAgICAgICAgICAgICB2aXNTdGF0ZTogdmlzU3RhdGVVcGRhdGVycy5lbmxhcmdlRmlsdGVyVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgc3RhdGUua2VwbGVyR2wuZm9vLnZpc1N0YXRlLFxuICogICAgICAgICAgICAgICB7aWR4OiAwfVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgdmlzU3RhdGVVcGRhdGVycyA9IG51bGw7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEludGVyYWN0aW9uQ29uZmlnOiBJbnRlcmFjdGlvbkNvbmZpZyA9IHtcbiAgdG9vbHRpcDoge1xuICAgIGlkOiAndG9vbHRpcCcsXG4gICAgbGFiZWw6ICdpbnRlcmFjdGlvbnMudG9vbHRpcCcsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb25maWc6IHtcbiAgICAgIGZpZWxkc1RvU2hvdzoge30sXG4gICAgICBjb21wYXJlTW9kZTogZmFsc2UsXG4gICAgICBjb21wYXJlVHlwZTogQ09NUEFSRV9UWVBFUy5BQlNPTFVURVxuICAgIH1cbiAgfSxcbiAgZ2VvY29kZXI6IHtcbiAgICBpZDogJ2dlb2NvZGVyJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy5nZW9jb2RlcicsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcG9zaXRpb246IG51bGxcbiAgfSxcbiAgYnJ1c2g6IHtcbiAgICBpZDogJ2JydXNoJyxcbiAgICBsYWJlbDogJ2ludGVyYWN0aW9ucy5icnVzaCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgY29uZmlnOiB7XG4gICAgICAvLyBzaXplIGlzIGluIGttXG4gICAgICBzaXplOiAwLjVcbiAgICB9XG4gIH0sXG4gIGNvb3JkaW5hdGU6IHtcbiAgICBpZDogJ2Nvb3JkaW5hdGUnLFxuICAgIGxhYmVsOiAnaW50ZXJhY3Rpb25zLmNvb3JkaW5hdGUnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiBudWxsXG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FOSU1BVElPTl9DT05GSUc6IEFuaW1hdGlvbkNvbmZpZyA9IHtcbiAgZG9tYWluOiBudWxsLFxuICBjdXJyZW50VGltZTogbnVsbCxcbiAgc3BlZWQ6IDEsXG4gIGlzQW5pbWF0aW5nOiBmYWxzZSxcbiAgdGltZVN0ZXBzOiBudWxsLFxuICB0aW1lRm9ybWF0OiBudWxsLFxuICB0aW1lem9uZTogbnVsbCxcbiAgZGVmYXVsdFRpbWVGb3JtYXQ6IG51bGwsXG4gIGhpZGVDb250cm9sOiBmYWxzZSxcbiAgZHVyYXRpb246IG51bGxcbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VESVRPUjogRWRpdG9yID0ge1xuICBtb2RlOiBFRElUT1JfTU9ERVMuRFJBV19QT0xZR09OLFxuICBmZWF0dXJlczogW10sXG4gIHNlbGVjdGVkRmVhdHVyZTogbnVsbCxcbiAgdmlzaWJsZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGluaXRpYWwgYHZpc1N0YXRlYFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBjb25zdGFudFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9WSVNfU1RBVEU6IFZpc1N0YXRlID0ge1xuICAvLyBtYXAgaW5mb1xuICBtYXBJbmZvOiB7XG4gICAgdGl0bGU6ICcnLFxuICAgIGRlc2NyaXB0aW9uOiAnJ1xuICB9LFxuICAvLyBsYXllcnNcbiAgbGF5ZXJzOiBbXSxcbiAgbGF5ZXJEYXRhOiBbXSxcbiAgbGF5ZXJUb0JlTWVyZ2VkOiBbXSxcbiAgbGF5ZXJPcmRlcjogW10sXG5cbiAgLy8gZmlsdGVyc1xuICBmaWx0ZXJzOiBbXSxcbiAgZmlsdGVyVG9CZU1lcmdlZDogW10sXG5cbiAgLy8gYSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIGRhdGFzZXRcbiAgZGF0YXNldHM6IHt9LFxuICBlZGl0aW5nRGF0YXNldDogdW5kZWZpbmVkLFxuXG4gIC8vIGVmZmVjdHNcbiAgZWZmZWN0czogW10sXG4gIGVmZmVjdE9yZGVyOiBbXSxcblxuICBpbnRlcmFjdGlvbkNvbmZpZzogZGVmYXVsdEludGVyYWN0aW9uQ29uZmlnLFxuICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IHt9LFxuXG4gIGxheWVyQmxlbmRpbmc6ICdub3JtYWwnLFxuICBvdmVybGF5QmxlbmRpbmc6ICdub3JtYWwnLFxuICBob3ZlckluZm86IHVuZGVmaW5lZCxcbiAgY2xpY2tlZDogdW5kZWZpbmVkLFxuICBtb3VzZVBvczoge30sXG4gIG1heERlZmF1bHRUb29sdGlwczogTUFYX0RFRkFVTFRfVE9PTFRJUFMsXG5cbiAgLy8gdGhpcyBpcyB1c2VkIHdoZW4gdXNlciBzcGxpdCBtYXBzXG4gIHNwbGl0TWFwczogW1xuICAgIC8vIHRoaXMgd2lsbCBjb250YWluIGEgbGlzdCBvZiBvYmplY3RzIHRvXG4gICAgLy8gZGVzY3JpYmUgdGhlIHN0YXRlIG9mIGxheWVyIGF2YWlsYWJpbGl0eSBhbmQgdmlzaWJpbGl0eSBmb3IgZWFjaCBtYXBcbiAgICAvLyBbXG4gICAgLy8gICB7XG4gICAgLy8gICAgICBsYXllcnM6IHtsYXllcl9pZDogdHJ1ZSB8IGZhbHNlfVxuICAgIC8vICAgfVxuICAgIC8vIF1cbiAgXSxcbiAgc3BsaXRNYXBzVG9CZU1lcmdlZDogW10sXG4gIGlzTWVyZ2luZ0RhdGFzZXRzOiB7fSxcbiAgLy8gZGVmYXVsdHMgbGF5ZXIgY2xhc3Nlc1xuICBsYXllckNsYXNzZXM6IExheWVyQ2xhc3NlcyxcblxuICAvLyBkZWZhdWx0IGFuaW1hdGlvblxuICAvLyB0aW1lIGluIHVuaXggdGltZXN0YW1wIChtaWxsaXNlY29uZHMpICh0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggRXBvY2gpXG4gIGFuaW1hdGlvbkNvbmZpZzogREVGQVVMVF9BTklNQVRJT05fQ09ORklHLFxuXG4gIGVkaXRvcjogREVGQVVMVF9FRElUT1IsXG5cbiAgZmlsZUxvYWRpbmc6IGZhbHNlLFxuICBmaWxlTG9hZGluZ1Byb2dyZXNzOiB7fSxcblxuICBsb2FkZXJzOiBbXSxcbiAgbG9hZE9wdGlvbnM6IHt9LFxuXG4gIC8vIHZpc1N0YXRlTWVyZ2Vyc1xuICBtZXJnZXJzOiBWSVNfU1RBVEVfTUVSR0VSUyxcblxuICAvLyBrZXBsZXIgc2NoZW1hc1xuICBzY2hlbWE6IEtlcGxlckdMU2NoZW1hXG59O1xuXG50eXBlIFVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YVR5cGUgPSB7XG4gIGxheWVyczogTGF5ZXJbXTtcbiAgbGF5ZXJEYXRhOiBhbnlbXTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHN0YXRlIHdpdGggdXBkYXRlZCBsYXllciBhbmQgbGF5ZXJEYXRhXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhPFMgZXh0ZW5kcyBVcGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGFUeXBlPihcbiAgc3RhdGU6IFMsXG4gIHtsYXllckRhdGEsIGxheWVyLCBpZHh9OiB7bGF5ZXJEYXRhPzogYW55OyBsYXllcjogTGF5ZXI7IGlkeDogbnVtYmVyfVxuKTogUyB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKChseXIsIGkpID0+IChpID09PSBpZHggPyBsYXllciA6IGx5cikpLFxuICAgIGxheWVyRGF0YTogbGF5ZXJEYXRhXG4gICAgICA/IHN0YXRlLmxheWVyRGF0YS5tYXAoKGQsIGkpID0+IChpID09PSBpZHggPyBsYXllckRhdGEgOiBkKSlcbiAgICAgIDogc3RhdGUubGF5ZXJEYXRhXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMsIGxheWVyOiBMYXllcik6IFMge1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBsYXllci5jb25maWcuaXNWaXNpYmxlXG4gICAgICAgID8gYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgICAgICA6IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgIH07XG4gIH1cblxuICBpZiAobGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBvYmplY3RzIChvciBhcnJheXMpIGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIG9ubHkgdGhlXG4gKiBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBjaGFuZ2VkIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBwaWNrQ2hhbmdlZFByb3BzPFQ+KHByZXY6IFQsIG5leHQ6IFQpOiBQYXJ0aWFsPFQ+IHtcbiAgY29uc3QgY2hhbmdlZFByb3BzOiBQYXJ0aWFsPFQ+ID0ge307XG4gIGNvbnN0IHBpY2tQcm9wc09mID0gb2JqID0+IHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGFuZ2VkUHJvcHMsIGtleSkgJiZcbiAgICAgICAgIWlzRXF1YWwocHJldltrZXldLCBuZXh0W2tleV0pXG4gICAgICApIHtcbiAgICAgICAgY2hhbmdlZFByb3BzW2tleV0gPSBuZXh0W2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHBpY2tQcm9wc09mKHByZXYpO1xuICBwaWNrUHJvcHNPZihuZXh0KTtcbiAgcmV0dXJuIGNoYW5nZWRQcm9wcztcbn1cblxuY29uc3QgVklTVUFMX0NIQU5ORUxfUFJPUF9UWVBFUyA9IFsnZmllbGQnLCAnc2NhbGUnLCAnZG9tYWluJywgJ2FnZ3JlZ2F0aW9uJ107XG5cbi8qKlxuICogQXBwbHkgbGF5ZXIgY29uZmlnXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TGF5ZXJDb25maWdVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkFwcGx5TGF5ZXJDb25maWdVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllcklkLCBuZXdMYXllckNvbmZpZywgbGF5ZXJJbmRleH0gPSBhY3Rpb247XG4gIGNvbnN0IG5ld1BhcnNlZExheWVyID1cbiAgICAvLyB3aWxsIG1vdmUgdmlzdWFsQ2hhbm5lbHMgdG8gdGhlIGNvbmZpZyBwcm9wXG4gICAgcGFyc2VMYXllckNvbmZpZyhzdGF0ZS5zY2hlbWEsIG5ld0xheWVyQ29uZmlnKTtcbiAgY29uc3Qgb2xkTGF5ZXIgPSBzdGF0ZS5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IG9sZExheWVySWQpO1xuICBpZiAoIW9sZExheWVyIHx8ICFuZXdQYXJzZWRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAobGF5ZXJJbmRleCAhPT0gbnVsbCAmJiBsYXllckluZGV4ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUubGF5ZXJzW2xheWVySW5kZXhdICE9PSBvbGRMYXllcikge1xuICAgIC8vIGxheWVySW5kZXggaXMgcHJvdmlkZWQsIGJ1dCBpdCBkb2Vzbid0IG1hdGNoIHRoZSBvbGRMYXllclxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbbmV3UGFyc2VkTGF5ZXIuY29uZmlnLmRhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIGlzIHZhbGlkIGFuZCBjb252ZXJ0IGl0IHRvIExheWVyXG4gIGNvbnN0IG5ld0xheWVyID0gdmFsaWRhdGVMYXllcldpdGhEYXRhKGRhdGFzZXQsIG5ld1BhcnNlZExheWVyLCBzdGF0ZS5sYXllckNsYXNzZXMpO1xuICBpZiAoIW5ld0xheWVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgbGV0IG5leHRTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChuZXdMYXllci50eXBlICYmIG5ld0xheWVyLnR5cGUgIT09IG9sZExheWVyLnR5cGUpIHtcbiAgICBjb25zdCBvbGRMYXllckluZGV4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVySWQpO1xuICAgIGlmIChvbGRMYXllckluZGV4ID49IDApIHtcbiAgICAgIG5leHRTdGF0ZSA9IGxheWVyVHlwZUNoYW5nZVVwZGF0ZXIobmV4dFN0YXRlLCBsYXllclR5cGVDaGFuZ2Uob2xkTGF5ZXIsIG5ld0xheWVyLnR5cGUpKTtcbiAgICAgIC8vIGxheWVyVHlwZUNoYW5nZVVwZGF0ZXIgY2hhbmdlcyB0aGUgaWQgb2YgdGhlIGxheWVyLCBzbyB3ZSBuZWVkIHRvIG9idGFpbiB0aGUgbmV3IGlkXG4gICAgICAvLyBidXQgZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGxheWVyIHdhcyBub3QgcmVtb3ZlZFxuICAgICAgaWYgKG5leHRTdGF0ZS5sYXllcnMubGVuZ3RoID09PSBzdGF0ZS5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5ld0xheWVySWQgPSBuZXh0U3RhdGUubGF5ZXJzW29sZExheWVySW5kZXhdLmlkO1xuICAgICAgICBuZXh0U3RhdGUgPSBhcHBseUxheWVyQ29uZmlnVXBkYXRlcihcbiAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgYXBwbHlMYXllckNvbmZpZyhuZXdMYXllcklkLCB7Li4ubmV3TGF5ZXJDb25maWcsIGlkOiBuZXdMYXllcklkfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfVxuXG4gIC8vIHNlcmlhbGl6ZUxheWVyKCkgbWlnaHQgcmV0dXJuIG51bGwgaWYgdGhlIG9sZCBsYXllciBpcyBub3QgdmFsaWQsXG4gIC8vIHdlIHNob3VsZCBzdGlsbCBhcHBseSB0aGUgY2hhbmdlcyBpbiB0aGF0IGNhc2VcbiAgY29uc3Qgc2VyaWFsaXplZE9sZExheWVyID0gc2VyaWFsaXplTGF5ZXIob2xkTGF5ZXIsIHN0YXRlLnNjaGVtYSkgPz8ge2NvbmZpZzoge319O1xuICBjb25zdCBzZXJpYWxpemVkTmV3TGF5ZXIgPSBzZXJpYWxpemVMYXllcihuZXdMYXllciwgc3RhdGUuc2NoZW1hKTtcbiAgaWYgKCFzZXJpYWxpemVkTmV3TGF5ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCFpc0VxdWFsKHNlcmlhbGl6ZWRPbGRMYXllciwgc2VyaWFsaXplZE5ld0xheWVyKSkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSBwaWNrQ2hhbmdlZFByb3BzKHNlcmlhbGl6ZWRPbGRMYXllci5jb25maWcsIHNlcmlhbGl6ZWROZXdMYXllci5jb25maWcpO1xuXG4gICAgaWYgKCd2aXNDb25maWcnIGluIGNoYW5nZWQpIHtcbiAgICAgIGlmIChjaGFuZ2VkLnZpc0NvbmZpZykge1xuICAgICAgICBuZXh0U3RhdGUgPSBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgIGxheWVyVmlzQ29uZmlnQ2hhbmdlKG9sZExheWVyLCBjaGFuZ2VkLnZpc0NvbmZpZylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBjaGFuZ2VkLnZpc0NvbmZpZztcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhvbGRMYXllci52aXN1YWxDaGFubmVscykuZm9yRWFjaChjaGFubmVsTmFtZSA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gb2xkTGF5ZXIudmlzdWFsQ2hhbm5lbHNbY2hhbm5lbE5hbWVdO1xuICAgICAgY29uc3QgY2hhbm5lbFByb3BOYW1lcyA9IFZJU1VBTF9DSEFOTkVMX1BST1BfVFlQRVMubWFwKHByb3AgPT4gY2hhbm5lbFtwcm9wXSk7XG4gICAgICBpZiAoY2hhbm5lbFByb3BOYW1lcy5zb21lKHByb3AgPT4gcHJvcCBpbiBjaGFuZ2VkKSkge1xuICAgICAgICBuZXh0U3RhdGUgPSBsYXllclZpc3VhbENoYW5uZWxDaGFuZ2VVcGRhdGVyKFxuICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICBsYXllclZpc3VhbENoYW5uZWxDb25maWdDaGFuZ2UoXG4gICAgICAgICAgICBvbGRMYXllcixcbiAgICAgICAgICAgIHBpY2sobmV3TGF5ZXIuY29uZmlnLCBjaGFubmVsUHJvcE5hbWVzKSxcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgY2hhbm5lbFByb3BOYW1lcykge1xuICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VkW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlZCkubGVuZ3RoID4gMCkge1xuICAgICAgbmV4dFN0YXRlID0gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKFxuICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgIGxheWVyQ29uZmlnQ2hhbmdlKG9sZExheWVyLCBwaWNrKG5ld0xheWVyLmNvbmZpZywgT2JqZWN0LmtleXMoY2hhbmdlZCkpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVsYXllclZpc2liaWx0eShzdGF0ZTogVmlzU3RhdGUsIG5ld0xheWVyOiBMYXllciwgaXNWaXNpYmxlPzogYm9vbGVhbik6IFZpc1N0YXRlIHtcbiAgbGV0IG5ld1N0YXRlID0gdXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZShzdGF0ZSwgbmV3TGF5ZXIpO1xuICBjb25zdCBmaWx0ZXJJbmRleCA9IGZpbHRlclN5bmNlZFdpdGhUaW1lbGluZShzdGF0ZSk7XG4gIGlmIChpc0xheWVyQW5pbWF0YWJsZShuZXdMYXllcikgJiYgZmlsdGVySW5kZXggIT09IC0xKSB7XG4gICAgLy8gaWYgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgdmlzaWJsZSB3ZSBzeW5jIHdpdGggZmlsdGVyIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgb3RoZXIgYW5pbWF0YWJsZSBsYXllcnMgZXhpc3RzIGFuZCBhcmUgdmlzaWJsZVxuICAgIG5ld1N0YXRlID0gc3luY1RpbWVGaWx0ZXJXaXRoTGF5ZXJUaW1lbGluZVVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICAgIGlkeDogZmlsdGVySW5kZXgsXG4gICAgICBlbmFibGU6IGlzVmlzaWJsZSA/IGlzVmlzaWJsZSA6IGdldEFuaW1hdGFibGVWaXNpYmxlTGF5ZXJzKHN0YXRlLmxheWVycykubGVuZ3RoID4gMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYmFzZSBjb25maWc6IGRhdGFJZCwgbGFiZWwsIGNvbHVtbiwgaXNWaXNpYmxlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdDb25maWcpO1xuICBpZiAoXG4gICAgdHlwZW9mIGFjdGlvbi5uZXdDb25maWcuZGF0YUlkID09PSAnc3RyaW5nJyAmJlxuICAgIGFjdGlvbi5uZXdDb25maWcuZGF0YUlkICE9PSBvbGRMYXllci5jb25maWcuZGF0YUlkXG4gICkge1xuICAgIGNvbnN0IHtkYXRhSWQsIC4uLnJlc3RDb25maWd9ID0gYWN0aW9uLm5ld0NvbmZpZztcbiAgICBjb25zdCBzdGF0ZVdpdGhEYXRhSWQgPSBsYXllckRhdGFJZENoYW5nZVVwZGF0ZXIoc3RhdGUsIHtcbiAgICAgIG9sZExheWVyLFxuICAgICAgbmV3Q29uZmlnOiB7ZGF0YUlkfVxuICAgIH0pO1xuICAgIGNvbnN0IG5leHRMYXllciA9IHN0YXRlV2l0aERhdGFJZC5sYXllcnMuZmluZChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgICByZXR1cm4gbmV4dExheWVyICYmIE9iamVjdC5rZXlzKHJlc3RDb25maWcpLmxlbmd0aFxuICAgICAgPyBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGVXaXRoRGF0YUlkLCB7b2xkTGF5ZXI6IG5leHRMYXllciwgbmV3Q29uZmlnOiByZXN0Q29uZmlnfSlcbiAgICAgIDogc3RhdGVXaXRoRGF0YUlkO1xuICB9XG5cbiAgbGV0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoYWN0aW9uLm5ld0NvbmZpZyk7XG5cbiAgbGV0IGxheWVyRGF0YTtcblxuICBpZiAobmV3TGF5ZXIuc2hvdWxkQ2FsY3VsYXRlTGF5ZXJEYXRhKHByb3BzKSkge1xuICAgIGNvbnN0IG9sZExheWVyRGF0YSA9IHN0YXRlLmxheWVyRGF0YVtpZHhdO1xuXG4gICAgY29uc3QgdXBkYXRlTGF5ZXJEYXRhUmVzdWx0ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBzdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcbiAgICBuZXdMYXllciA9IHVwZGF0ZUxheWVyRGF0YVJlc3VsdC5sYXllcjtcbiAgICBsYXllckRhdGEgPSB1cGRhdGVMYXllckRhdGFSZXN1bHQubGF5ZXJEYXRhO1xuICB9XG5cbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmICgnaXNWaXNpYmxlJyBpbiBhY3Rpb24ubmV3Q29uZmlnKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVsYXllclZpc2liaWx0eShuZXdTdGF0ZSwgbmV3TGF5ZXIsIGFjdGlvbi5uZXdDb25maWcuaXNWaXNpYmxlKTtcbiAgfVxuXG4gIGlmICgnY29sdW1ucycgaW4gYWN0aW9uLm5ld0NvbmZpZyAmJiBuZXdMYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQpIHtcbiAgICAvLyBUT0RPOiBTaGFuLCBtYWtlIHRoZSBhbmltYXRpb24gY29uZmlnIGZ1bmN0aW9uIG1vcmUgcm9idXN0XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge1xuICAgIGxheWVyOiBuZXdMYXllcixcbiAgICBsYXllckRhdGEsXG4gICAgaWR4XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJBbmltYXRpb25DaGFuZ2VVcGRhdGVyPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMsIGFjdGlvbik6IFMge1xuICBjb25zdCB7b2xkTGF5ZXIsIHByb3AsIHZhbHVlfSA9IGFjdGlvbjtcbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcblxuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC4uLm9sZExheWVyLmNvbmZpZy5hbmltYXRpb24sXG4gICAgICBbcHJvcF06IHZhbHVlXG4gICAgfVxuICB9KTtcblxuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBzdGF0ZS5sYXllckRhdGFbaWR4XSk7XG5cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2xheWVyRGF0YSwgbGF5ZXIsIGlkeH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllcklkLCBpc1Zpc2libGUsIHNwbGl0TWFwSWRcbiAqIGhhbmRsZXMgdHdvIGNhc2VzOlxuICogMSkgdG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIGxvY2FsIFNwbGl0TWFwIGxheWVyICh2aXNTdGF0ZS5zcGxpdE1hcC5sYXllcnMpXG4gKiAyKSB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgZ2xvYmFsIGxheWVyICh2aXNTdGF0ZS5sYXllcnMpXG5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyVG9nZ2xlVmlzaWJpbGl0eVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJUb2dnbGVWaXNpYmlsaXR5VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7bGF5ZXJJZCwgaXNWaXNpYmxlLCBzcGxpdE1hcElkfSA9IGFjdGlvbjtcbiAgY29uc3QgbGF5ZXIgPSBzdGF0ZS5sYXllcnMuZmluZChkID0+IGQuaWQgPT09IGxheWVySWQpO1xuXG4gIGlmICghbGF5ZXIpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcblxuICBpZiAoc3BsaXRNYXBJZCkge1xuICAgIC8vIFtjYXNlIDFdOiB0b2dnbGUgbG9jYWwgbGF5ZXIgdmlzaWJpbGl0eSBmb3IgZWFjaCBTcGxpdE1hcFxuICAgIGNvbnN0IG1hcEluZGV4ID0gbmV3U3RhdGUuc3BsaXRNYXBzLmZpbmRJbmRleChzbSA9PiBzbS5pZCA9PT0gc3BsaXRNYXBJZCk7XG4gICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgLy8gMSkgaWYgdGhlIGxheWVyIGlzIGludmlzaWJsZSBnbG9iYWxseVxuICAgICAgLy8gLT4gc2V0IGdsb2JhbCB2aXNpYmlsaXR5IHRvIHRydWVcbiAgICAgIG5ld1N0YXRlID0gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKG5ld1N0YXRlLCBsYXllckNvbmZpZ0NoYW5nZShsYXllciwge2lzVmlzaWJsZTogdHJ1ZX0pKTtcblxuICAgICAgLy8gLT4gc2V0IGxvY2FsIHZpc2liaWxpdHkgdG8gdHJ1ZSBhbmQgdGhlIGxvY2FsIHZpc2liaWxpdGllcyBvZiBhbGwgb3RoZXIgU3BsaXRNYXBzIHRvIGZhbHNlXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgc3BsaXRNYXBzOiBuZXdTdGF0ZS5zcGxpdE1hcHMubWFwKHNtID0+XG4gICAgICAgICAgc20uaWQgIT09IHNwbGl0TWFwSWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLnNtLFxuICAgICAgICAgICAgICAgIGxheWVyczoge1xuICAgICAgICAgICAgICAgICAgLi4uc20ubGF5ZXJzLFxuICAgICAgICAgICAgICAgICAgW2xheWVySWRdOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgLi4uc20sXG4gICAgICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zbS5sYXllcnMsXG4gICAgICAgICAgICAgICAgICBbbGF5ZXJJZF06IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gMikgZWxzZSB3aGVuIHRoZSBsYXllciBpcyB2aXNpYmxlIGdsb2JhbGx5XG4gICAgcmV0dXJuIHRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlcihuZXdTdGF0ZSwgdG9nZ2xlTGF5ZXJGb3JNYXAobWFwSW5kZXgsIGxheWVySWQpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBbY2FzZSAyXTogdG9nZ2xlIGdsb2JhbCBsYXllciB2aXNpYmlsaXR5XG4gICAgY29uc3QgbmV3TGF5ZXIgPSBsYXllci51cGRhdGVMYXllckNvbmZpZyh7aXNWaXNpYmxlfSk7XG4gICAgY29uc3QgaWR4ID0gbmV3U3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGxheWVySWQpO1xuXG4gICAgbmV3U3RhdGUgPSB1cGRhdGVsYXllclZpc2liaWx0eShuZXdTdGF0ZSwgbmV3TGF5ZXIsIGlzVmlzaWJsZSk7XG4gICAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShuZXdTdGF0ZSwge1xuICAgICAgbGF5ZXI6IG5ld0xheWVyLFxuICAgICAgaWR4XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKiBAcmV0dXJucyBpbmRleCBvZiB0aGUgZmlsdGVyIHN5bmNlZCB0byB0aW1lbGluZSBvciAtMVxuICovXG5mdW5jdGlvbiBmaWx0ZXJTeW5jZWRXaXRoVGltZWxpbmUoc3RhdGU6IFZpc1N0YXRlKTogbnVtYmVyIHtcbiAgcmV0dXJuIHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gKGYgYXMgVGltZVJhbmdlRmlsdGVyKS5zeW5jZWRXaXRoTGF5ZXJUaW1lbGluZSk7XG59XG5cbi8qKlxuICogVXBkYXRlcyBpc1ZhbGlkIGZsYWcgb2YgYSBsYXllci5cbiAqIFVwZGF0ZXMgaXNWaXNpYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBpc1ZhbGlkLlxuICogVHJpZ2dlcnMgdXBkYXRlIG9mIGRhdGEgZm9yIHRoZSBsYXllciBpbiBvcmRlciB0byBnZXQgZXJyb3JzIGFnYWluIGR1cmluZyBuZXh0IHVwZGF0ZSBpdGVyYXRpb24uXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHJldHVybnMgbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclNldElzVmFsaWRVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyU2V0SXNWYWxpZFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBpc1ZhbGlkfSA9IGFjdGlvbjtcblxuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBsYXllclRvVXBkYXRlID0gc3RhdGUubGF5ZXJzW2lkeF07XG4gIGlmIChsYXllclRvVXBkYXRlKSB7XG4gICAgbGV0IG5ld0xheWVyO1xuICAgIGxldCBuZXdEYXRhID0gbnVsbDtcblxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAvLyBUcmlnZ2VyIGRhdGEgdXBkYXRlIGluIG9yZGVyIHRvIHNob3cgZXJyb3JzIGFnYWluIGlmIHByZXNlbnQuXG4gICAgICBjb25zdCB7bGF5ZXIsIGxheWVyRGF0YX0gPSBjYWxjdWxhdGVMYXllckRhdGEobGF5ZXJUb1VwZGF0ZSwgc3RhdGUsIHVuZGVmaW5lZCk7XG4gICAgICBuZXdMYXllciA9IGxheWVyO1xuICAgICAgbmV3RGF0YSA9IGxheWVyRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TGF5ZXIgPSBsYXllclRvVXBkYXRlLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBuZXdMYXllci5pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YShzdGF0ZSwge2lkeCwgbGF5ZXI6IG5ld0xheWVyLCBsYXllckRhdGE6IG5ld0RhdGF9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gYWRkT3JSZW1vdmVUZXh0TGFiZWxzKG5ld0ZpZWxkcywgdGV4dExhYmVsLCBkZWZhdWx0VGV4dExhYmVsID0gREVGQVVMVF9URVhUX0xBQkVMKSB7XG4gIGxldCBuZXdUZXh0TGFiZWwgPSB0ZXh0TGFiZWwuc2xpY2UoKTtcblxuICBjb25zdCBjdXJyZW50RmllbGRzID0gdGV4dExhYmVsLm1hcCh0bCA9PiB0bC5maWVsZCAmJiB0bC5maWVsZC5uYW1lKS5maWx0ZXIoZCA9PiBkKTtcblxuICBjb25zdCBhZGRGaWVsZHMgPSBuZXdGaWVsZHMuZmlsdGVyKGYgPT4gIWN1cnJlbnRGaWVsZHMuaW5jbHVkZXMoZi5uYW1lKSk7XG4gIGNvbnN0IGRlbGV0ZUZpZWxkcyA9IGN1cnJlbnRGaWVsZHMuZmlsdGVyKGYgPT4gIW5ld0ZpZWxkcy5maW5kKGZkID0+IGZkLm5hbWUgPT09IGYpKTtcblxuICAvLyBkZWxldGVcbiAgbmV3VGV4dExhYmVsID0gbmV3VGV4dExhYmVsLmZpbHRlcih0bCA9PiB0bC5maWVsZCAmJiAhZGVsZXRlRmllbGRzLmluY2x1ZGVzKHRsLmZpZWxkLm5hbWUpKTtcbiAgbmV3VGV4dExhYmVsID0gIW5ld1RleHRMYWJlbC5sZW5ndGggPyBbZGVmYXVsdFRleHRMYWJlbF0gOiBuZXdUZXh0TGFiZWw7XG5cbiAgLy8gYWRkXG4gIG5ld1RleHRMYWJlbCA9IFtcbiAgICAuLi5uZXdUZXh0TGFiZWwuZmlsdGVyKHRsID0+IHRsLmZpZWxkKSxcbiAgICAuLi5hZGRGaWVsZHMubWFwKGFmID0+ICh7XG4gICAgICAuLi5kZWZhdWx0VGV4dExhYmVsLFxuICAgICAgZmllbGQ6IGFmXG4gICAgfSkpXG4gIF07XG5cbiAgcmV0dXJuIG5ld1RleHRMYWJlbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVGV4dExhYmVsUHJvcEFuZFZhbHVlKGlkeCwgcHJvcCwgdmFsdWUsIHRleHRMYWJlbCkge1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0ZXh0TGFiZWxbaWR4XSwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGV4dExhYmVsO1xuICB9XG5cbiAgbGV0IG5ld1RleHRMYWJlbCA9IHRleHRMYWJlbC5zbGljZSgpO1xuXG4gIGlmIChwcm9wID09PSAnZmllbGQnICYmIHZhbHVlID09PSBudWxsICYmIHRleHRMYWJlbC5sZW5ndGggPiAxKSB7XG4gICAgLy8gcmVtb3ZlIGxhYmVsIHdoZW4gZmllbGQgdmFsdWUgaXMgc2V0IHRvIG51bGxcbiAgICBuZXdUZXh0TGFiZWwuc3BsaWNlKGlkeCwgMSk7XG4gIH0gZWxzZSBpZiAocHJvcCkge1xuICAgIG5ld1RleHRMYWJlbCA9IHRleHRMYWJlbC5tYXAoKHRsLCBpKSA9PiAoaSA9PT0gaWR4ID8gey4uLnRsLCBbcHJvcF06IHZhbHVlfSA6IHRsKSk7XG4gIH1cblxuICByZXR1cm4gbmV3VGV4dExhYmVsO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciBiYXNlIGNvbmZpZzogZGF0YUlkLCBsYWJlbCwgY29sdW1uLCBpc1Zpc2libGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcmV0dXJucyBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxheWVyVGV4dExhYmVsQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclRleHRMYWJlbENoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBpZHgsIHByb3AsIHZhbHVlfSA9IGFjdGlvbjtcbiAgY29uc3Qge3RleHRMYWJlbH0gPSBvbGRMYXllci5jb25maWc7XG5cbiAgLy8gd2hlbiBhZGRpbmcgYSBuZXcgZW1wdHkgdGV4dCBsYWJlbCxcbiAgLy8gcmVseSBvbiB0aGUgbGF5ZXIncyBkZWZhdWx0IGNvbmZpZywgb3IgdXNlIHRoZSBjb25zdGFudCBERUZBVUxUX1RFWFRfTEFCRUxcbiAgY29uc3QgZGVmYXVsdFRleHRMYWJlbCA9XG4gICAgb2xkTGF5ZXIuZ2V0RGVmYXVsdExheWVyQ29uZmlnKHtkYXRhSWQ6ICcnfSk/LnRleHRMYWJlbD8uWzBdID8/IERFRkFVTFRfVEVYVF9MQUJFTDtcblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG4gIGlmICghdGV4dExhYmVsW2lkeF0gJiYgaWR4ID09PSB0ZXh0TGFiZWwubGVuZ3RoKSB7XG4gICAgLy8gaWYgaWR4IGlzIHNldCB0byBsZW5ndGgsIGFkZCBlbXB0eSB0ZXh0IGxhYmVsXG4gICAgbmV3VGV4dExhYmVsID0gWy4uLnRleHRMYWJlbCwgZGVmYXVsdFRleHRMYWJlbF07XG4gIH1cblxuICBpZiAoaWR4ID09PSAnYWxsJyAmJiBwcm9wID09PSAnZmllbGRzJykge1xuICAgIG5ld1RleHRMYWJlbCA9IGFkZE9yUmVtb3ZlVGV4dExhYmVscyh2YWx1ZSwgdGV4dExhYmVsLCBkZWZhdWx0VGV4dExhYmVsKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdUZXh0TGFiZWwgPSB1cGRhdGVUZXh0TGFiZWxQcm9wQW5kVmFsdWUoaWR4LCBwcm9wLCB2YWx1ZSwgbmV3VGV4dExhYmVsKTtcbiAgfVxuICAvLyB1cGRhdGUgdGV4dCBsYWJlbCBwcm9wIGFuZCB2YWx1ZVxuICByZXR1cm4gbGF5ZXJDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7XG4gICAgb2xkTGF5ZXIsXG4gICAgbmV3Q29uZmlnOiB7dGV4dExhYmVsOiBuZXdUZXh0TGFiZWx9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4aXN0aW5nTGF5ZXJXaXRoRGF0YShkYXRhc2V0LCBsYXllckNsYXNzZXMsIGxheWVyLCBzY2hlbWEpIHtcbiAgY29uc3QgbG9hZGVkTGF5ZXIgPSBzZXJpYWxpemVMYXllcihsYXllciwgc2NoZW1hKTtcbiAgcmV0dXJuIGxvYWRlZExheWVyXG4gICAgPyB2YWxpZGF0ZUxheWVyV2l0aERhdGEoZGF0YXNldCwgbG9hZGVkTGF5ZXIsIGxheWVyQ2xhc3Nlcywge1xuICAgICAgICBhbGxvd0VtcHR5Q29sdW1uOiB0cnVlXG4gICAgICB9KVxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgY29uZmlnIGRhdGFJZFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIG5leHRTdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJEYXRhSWRDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjoge1xuICAgIG9sZExheWVyOiBMYXllcjtcbiAgICBuZXdDb25maWc6IHtcbiAgICAgIGRhdGFJZDogc3RyaW5nO1xuICAgIH07XG4gIH1cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdDb25maWd9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YUlkfSA9IG5ld0NvbmZpZztcblxuICBpZiAoIW9sZExheWVyIHx8ICFzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG5cbiAgbGV0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe2RhdGFJZH0pO1xuXG4gIC8vIHRoaXMgbWF5IGhhcHBlbiB3aGVuIGEgbGF5ZXIgaXMgbmV3ICh0eXBlOiBudWxsIGFuZCBubyBjb2x1bW5zKSBidXQgaXQncyBub3QgcmVhZHkgdG8gYmUgc2F2ZWRcbiAgaWYgKG5ld0xheWVyLmlzVmFsaWRUb1NhdmUoKSkge1xuICAgIGNvbnN0IHZhbGlkYXRlZCA9IHZhbGlkYXRlRXhpc3RpbmdMYXllcldpdGhEYXRhKFxuICAgICAgc3RhdGUuZGF0YXNldHNbZGF0YUlkXSxcbiAgICAgIHN0YXRlLmxheWVyQ2xhc3NlcyxcbiAgICAgIG5ld0xheWVyLFxuICAgICAgc3RhdGUuc2NoZW1hXG4gICAgKTtcbiAgICAvLyBpZiBjYW50IHZhbGlkYXRlIGl0IHdpdGggZGF0YSBjcmVhdGUgYSBuZXcgb25lXG4gICAgaWYgKCF2YWxpZGF0ZWQpIHtcbiAgICAgIGNvbnN0IG9sZExheWVyVHlwZSA9IG9sZExheWVyLnR5cGU7XG4gICAgICBpZiAob2xkTGF5ZXJUeXBlKSB7XG4gICAgICAgIG5ld0xheWVyID0gbmV3IHN0YXRlLmxheWVyQ2xhc3Nlc1tvbGRMYXllclR5cGVdKHtkYXRhSWQsIGlkOiBvbGRMYXllci5pZH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllciA9IHZhbGlkYXRlZDtcbiAgICB9XG4gIH1cblxuICBuZXdMYXllciA9IG5ld0xheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICBpc1Zpc2libGU6IG9sZExheWVyLmNvbmZpZy5pc1Zpc2libGUsXG4gICAgaXNDb25maWdBY3RpdmU6IHRydWVcbiAgfSk7XG5cbiAgbmV3TGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMpO1xuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCB1bmRlZmluZWQpO1xuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEluaXRpYWxMYXllckNvbmZpZyhsYXllciwgZGF0YXNldHMsIGxheWVyQ2xhc3Nlcyk6IExheWVyIHtcbiAgbGV0IG5ld0xheWVyID0gbGF5ZXI7XG4gIGlmICghT2JqZWN0LmtleXMoZGF0YXNldHMpLmxlbmd0aCkge1xuICAgIC8vIG5vIGRhdGEgaXMgbG9hZGVkXG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG4gIGlmICghbGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAgIC8vIHNldCBsYXllciBkYXRhSWRcbiAgICBuZXdMYXllciA9IGxheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHtkYXRhSWQ6IE9iamVjdC5rZXlzKGRhdGFzZXRzKVswXX0pO1xuICB9XG4gIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIGxheWVyO1xuICB9XG5cbiAgLy8gZmluZCBkZWZhdXQgbGF5ZXIgcHJvcHNcbiAgY29uc3QgcmVzdWx0ID1cbiAgICB0eXBlb2YgbGF5ZXJDbGFzc2VzW25ld0xheWVyLnR5cGVdLmZpbmREZWZhdWx0TGF5ZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBsYXllckNsYXNzZXNbbmV3TGF5ZXIudHlwZV0uZmluZERlZmF1bHRMYXllclByb3BzKGRhdGFzZXQsIFtdKVxuICAgICAgOiB7cHJvcHM6IFtdfTtcblxuICAvLyBhbiBhcnJheSBvZiBwb3NzaWJsZSBwcm9wcywgdXNlIDFzdCBvbmVcbiAgY29uc3QgcHJvcHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHQucHJvcHMgfHwgW107XG5cbiAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgIG5ld0xheWVyID0gbmV3IGxheWVyQ2xhc3Nlc1tsYXllci50eXBlXSh7XG4gICAgICAuLi5wcm9wc1swXSxcbiAgICAgIGxhYmVsOiBuZXdMYXllci5jb25maWcubGFiZWwsXG4gICAgICBkYXRhSWQ6IG5ld0xheWVyLmNvbmZpZy5kYXRhSWQsXG4gICAgICBpc0NvbmZpZ0FjdGl2ZTogbmV3TGF5ZXIuY29uZmlnLmlzQ29uZmlnQWN0aXZlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBuZXdMYXllci5zZXRJbml0aWFsTGF5ZXJDb25maWcgPT09ICdmdW5jdGlvbidcbiAgICA/IG5ld0xheWVyLnNldEluaXRpYWxMYXllckNvbmZpZyhkYXRhc2V0KVxuICAgIDogbmV3TGF5ZXI7XG59XG4vKipcbiAqIFVwZGF0ZSBsYXllciB0eXBlLiBQcmV2aWV3cyBsYXllciBjb25maWcgd2lsbCBiZSBjb3BpZWQgaWYgYXBwbGljYWJsZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxheWVyVHlwZUNoYW5nZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBvbGRJZCA9IG9sZExheWVyLmlkO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkSWQpO1xuXG4gIGlmICghc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgJHtuZXdUeXBlfSBpcyBub3QgYSB2YWxpZCBsYXllciB0eXBlYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdMYXllciA9IG5ldyBzdGF0ZS5sYXllckNsYXNzZXNbbmV3VHlwZV0oe1xuICAgIC8vIGtlZXAgb2xkIGxheWVyIGxhYmxlIGFuZCBpc0NvbmZpZ0FjdGl2ZVxuICAgIGxhYmVsOiBvbGRMYXllci5jb25maWcubGFiZWwsXG4gICAgaXNDb25maWdBY3RpdmU6IG9sZExheWVyLmNvbmZpZy5pc0NvbmZpZ0FjdGl2ZSxcbiAgICBkYXRhSWQ6IG9sZExheWVyLmNvbmZpZy5kYXRhSWRcbiAgfSk7XG5cbiAgaWYgKCFvbGRMYXllci50eXBlKSB7XG4gICAgLy8gaWYgc2V0dGluZyBsYXllciB0eXBlIG9uIGFuIGVtcHR5IGxheWVyXG4gICAgbmV3TGF5ZXIgPSBzZXRJbml0aWFsTGF5ZXJDb25maWcobmV3TGF5ZXIsIHN0YXRlLmRhdGFzZXRzLCBzdGF0ZS5sYXllckNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGdldCBhIG1pbnQgbGF5ZXIsIHdpdGggbmV3IGlkIGFuZCB0eXBlXG4gICAgLy8gYmVjYXVzZSBkZWNrLmdsIHVzZXMgaWQgdG8gbWF0Y2ggYmV0d2VlbiBuZXcgYW5kIG9sZCBsYXllci5cbiAgICAvLyBJZiB0eXBlIGhhcyBjaGFuZ2VkIGJ1dCBpZCBpcyB0aGUgc2FtZSwgaXQgd2lsbCBicmVha1xuXG4gICAgY29uc3QgZGVmYXVsdExheWVyUHJvcHMgPVxuICAgICAgdHlwZW9mIHN0YXRlLmxheWVyQ2xhc3Nlc1tuZXdUeXBlXS5maW5kRGVmYXVsdExheWVyUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBzdGF0ZS5sYXllckNsYXNzZXNbbmV3VHlwZV0uZmluZERlZmF1bHRMYXllclByb3BzKHN0YXRlLmRhdGFzZXRzW25ld0xheWVyLmNvbmZpZy5kYXRhSWRdKVxuICAgICAgICA6IG51bGw7XG5cbiAgICBuZXdMYXllci5hc3NpZ25Db25maWdUb0xheWVyKFxuICAgICAgb2xkTGF5ZXIuY29uZmlnLFxuICAgICAgb2xkTGF5ZXIudmlzQ29uZmlnU2V0dGluZ3MsXG4gICAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICAgIGRlZmF1bHRMYXllclByb3BzXG4gICAgKTtcbiAgICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihzdGF0ZS5kYXRhc2V0cyk7XG4gIH1cblxuICBjb25zdCB7Y2xpY2tlZCwgaG92ZXJJbmZvfSA9IHN0YXRlO1xuXG4gIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBvbGRMYXllci5pc0xheWVySG92ZXJlZChjbGlja2VkKSA/IHVuZGVmaW5lZCA6IGNsaWNrZWQsXG4gICAgaG92ZXJJbmZvOiBvbGRMYXllci5pc0xheWVySG92ZXJlZChob3ZlckluZm8pID8gdW5kZWZpbmVkIDogaG92ZXJJbmZvXG4gIH07XG5cbiAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKG5ld0xheWVyLCBuZXdTdGF0ZSk7XG4gIG5ld1N0YXRlID0gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKG5ld1N0YXRlLCB7bGF5ZXJEYXRhLCBsYXllciwgaWR4fSk7XG5cbiAgaWYgKGxheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCB8fCBvbGRMYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQpIHtcbiAgICBuZXdTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbihuZXdTdGF0ZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgc3BsaXRNYXAgbGF5ZXIgaWRcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBuZXdTdGF0ZS5zcGxpdE1hcHMubWFwKHNldHRpbmdzID0+IHtcbiAgICAgICAgY29uc3Qge1tvbGRJZF06IG9sZExheWVyTWFwLCAuLi5vdGhlckxheWVyc30gPSBzZXR0aW5ncy5sYXllcnM7XG4gICAgICAgIHJldHVybiBvbGRJZCBpbiBzZXR0aW5ncy5sYXllcnNcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgICAgIGxheWVyczoge1xuICAgICAgICAgICAgICAgIC4uLm90aGVyTGF5ZXJzLFxuICAgICAgICAgICAgICAgIFtsYXllci5pZF06IG9sZExheWVyTWFwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHNldHRpbmdzO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLy8gdXBkYXRlIGxheWVyT3JkZXIgd2l0aCBuZXcgaWRcbiAgbmV3U3RhdGUgPSB7XG4gICAgLi4ubmV3U3RhdGUsXG4gICAgbGF5ZXJPcmRlcjogbmV3U3RhdGUubGF5ZXJPcmRlci5tYXAobGF5ZXJJZCA9PlxuICAgICAgbGF5ZXJJZCA9PT0gb2xkTGF5ZXIuaWQgPyBuZXdMYXllci5pZCA6IGxheWVySWRcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciB2aXN1YWwgY2hhbm5lbFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllclZpc3VhbENoYW5uZWxDb25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnLCBuZXdWaXNDb25maWcsIGNoYW5uZWx9ID0gYWN0aW9uO1xuICBpZiAoIW9sZExheWVyLmNvbmZpZy5kYXRhSWQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbb2xkTGF5ZXIuY29uZmlnLmRhdGFJZF07XG5cbiAgY29uc3QgaWR4ID0gc3RhdGUubGF5ZXJzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IG9sZExheWVyLmlkKTtcbiAgbGV0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcobmV3Q29uZmlnKTtcbiAgaWYgKG5ld1Zpc0NvbmZpZykgbmV3TGF5ZXIgPSBuZXdMYXllci51cGRhdGVMYXllclZpc0NvbmZpZyhuZXdWaXNDb25maWcpO1xuXG4gIG5ld0xheWVyLnVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0LCBjaGFubmVsKTtcblxuICAvLyBjYWxsaW5nIHVwZGF0ZSBhbmltYXRpb24gZG9tYWluIGZpcnN0IHRvIG1lcmdlIGFsbCBsYXllciBhbmltYXRpb24gZG9tYWluXG4gIGxldCB1cGRhdGVkU3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4oc3RhdGUpO1xuXG4gIGNvbnN0IHZpc3VhbENoYW5uZWwgPSBvbGRMYXllci52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcbiAgaWYgKHZpc3VhbENoYW5uZWw/LmNoYW5uZWxTY2FsZVR5cGUgPT09IENIQU5ORUxfU0NBTEVTLmNvbG9yICYmIG5ld0NvbmZpZ1t2aXN1YWxDaGFubmVsLmZpZWxkXSkge1xuICAgIC8vIGlmIGNvbG9yIGZpZWxkIGNoYW5nZWQsIHNldCBjdXN0b21CcmVha3MgdG8gZmFsc2VcbiAgICBuZXdMYXllci51cGRhdGVMYXllckNvbG9yVUkodmlzdWFsQ2hhbm5lbC5yYW5nZSwge1xuICAgICAgY29sb3JSYW5nZUNvbmZpZzoge1xuICAgICAgICAuLi5uZXdMYXllci5jb25maWcuY29sb3JVSVt2aXN1YWxDaGFubmVsLnJhbmdlXS5jb2xvclJhbmdlQ29uZmlnLFxuICAgICAgICBjdXN0b21CcmVha3M6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB1cGRhdGVkU3RhdGUgPSB7XG4gICAgICAuLi51cGRhdGVkU3RhdGUsXG4gICAgICBsYXllcnM6IHVwZGF0ZWRTdGF0ZS5sYXllcnMubWFwKGwgPT4gKGwuaWQgPT09IG9sZExheWVyLmlkID8gbmV3TGF5ZXIgOiBsKSlcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gdXBkYXRlZFN0YXRlLmxheWVyRGF0YVtpZHhdO1xuICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHVwZGF0ZWRTdGF0ZSwgb2xkTGF5ZXJEYXRhKTtcblxuICBpZiAoXG4gICAgdmlzdWFsQ2hhbm5lbD8uY2hhbm5lbFNjYWxlVHlwZSA9PT0gQ0hBTk5FTF9TQ0FMRVMuY29sb3IgJiZcbiAgICBuZXdDb25maWdbdmlzdWFsQ2hhbm5lbD8uc2NhbGVdID09PSBTQ0FMRV9UWVBFUy5jdXN0b21PcmRpbmFsICYmXG4gICAgIW5ld1Zpc0NvbmZpZ1xuICApIHtcbiAgICAvLyB3aGVuIHN3aXRjaGluZyB0byBjdXN0b21PcmRpbmFsIHNjYWxlLCBjcmVhdGUgYSBjdXN0b21QYWxldHRlIGluIGNvbG9yVUkgd2l0aCB1cGRhdGVkIGNvbG9yRG9tYWluXG4gICAgY29uc3QgY3VzdG9tUGFsZXR0ZSA9IGluaXRDdXN0b21QYWxldHRlQnlDdXN0b21TY2FsZSh7XG4gICAgICBzY2FsZTogU0NBTEVfVFlQRVMuY3VzdG9tT3JkaW5hbCxcbiAgICAgIGZpZWxkOiBsYXllci5jb25maWdbdmlzdWFsQ2hhbm5lbC5maWVsZF0sXG4gICAgICBvcmRpbmFsRG9tYWluOiBsYXllci5jb25maWdbbGF5ZXIudmlzdWFsQ2hhbm5lbHNbY2hhbm5lbF0uZG9tYWluXSxcbiAgICAgIHJhbmdlOiBsYXllci5jb25maWcudmlzQ29uZmlnW3Zpc3VhbENoYW5uZWwucmFuZ2VdLFxuICAgICAgY29sb3JCcmVha3M6IG51bGxcbiAgICB9KTtcbiAgICAvLyB1cGRhdGUgY29sb3JSYW5nZSB3aXRoIG5ldyBjdXN0b21QYWxldHRlXG4gICAgbGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHZpc3VhbENoYW5uZWwucmFuZ2UsIHtcbiAgICAgIHNob3dDb2xvckNoYXJ0OiB0cnVlLFxuICAgICAgY29sb3JSYW5nZUNvbmZpZzoge1xuICAgICAgICAuLi5sYXllci5jb25maWcuY29sb3JVSVt2aXN1YWxDaGFubmVsLnJhbmdlXS5jb2xvclJhbmdlQ29uZmlnLFxuICAgICAgICBjdXN0b21CcmVha3M6IHRydWVcbiAgICAgIH0sXG4gICAgICBjdXN0b21QYWxldHRlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVN0YXRlV2l0aExheWVyQW5kRGF0YSh1cGRhdGVkU3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYHZpc0NvbmZpZ2BcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuTGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtvbGRMYXllcn0gPSBhY3Rpb247XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYWN0aW9uLm5ld1Zpc0NvbmZpZyk7XG5cbiAgY29uc3QgbmV3VmlzQ29uZmlnID0ge1xuICAgIC4uLm9sZExheWVyLmNvbmZpZy52aXNDb25maWcsXG4gICAgLi4uYWN0aW9uLm5ld1Zpc0NvbmZpZ1xuICB9O1xuXG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe3Zpc0NvbmZpZzogbmV3VmlzQ29uZmlnfSk7XG5cbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBvbGRMYXllckRhdGEpO1xuICAgIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllcjogbmV3TGF5ZXIsIGlkeH0pO1xufVxuXG4vKipcbiAqIFJlc2V0IGFuaW1hdGlvbiBjb25maWcgY3VycmVudCB0aW1lIHRvIGEgc3BlY2lmaWVkIHZhbHVlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICpcbiAqL1xuZXhwb3J0IGNvbnN0IHNldExheWVyQW5pbWF0aW9uVGltZVVwZGF0ZXIgPSA8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIHt2YWx1ZX06IFZpc1N0YXRlQWN0aW9ucy5TZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyQWN0aW9uXG4pOiBTID0+IHtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWU7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgIGN1cnJlbnRUaW1lXG4gICAgfVxuICB9O1xuICAvLyB1cGRhdGUgYW5pbWF0aW9uIGNvbmZpZyBmb3IgZWFjaCBsYXllclxuICByZXR1cm4gc3RhdGUubGF5ZXJzLnJlZHVjZSgoYWNjdSwgbCkgPT4ge1xuICAgIGlmIChsLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCAmJiBsLnR5cGUgIT09ICd0cmlwJykge1xuICAgICAgcmV0dXJuIGxheWVyQW5pbWF0aW9uQ2hhbmdlVXBkYXRlcihhY2N1LCB7b2xkTGF5ZXI6IGwsIHByb3A6ICdjdXJyZW50VGltZScsIGN1cnJlbnRUaW1lfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1O1xuICB9LCBuZXh0U3RhdGUpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZmlsdGVyIHByb3BlcnR5XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uVGltZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyQW5pbWF0aW9uVGltZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIoc3RhdGUsIGFjdGlvbik7XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBhbmltYXRpb24gd2luZG93XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uV2luZG93VXBkYXRlcjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAge2lkLCBhbmltYXRpb25XaW5kb3d9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyQW5pbWF0aW9uV2luZG93VXBkYXRlckFjdGlvblxuKTogUyB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmID0+IGYuaWQgPT09IGlkKTtcblxuICBpZiAoIWZpbHRlcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG5ld0ZpbHRlciA9IHtcbiAgICAuLi5maWx0ZXIsXG4gICAgYW5pbWF0aW9uV2luZG93XG4gIH07XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3dhcF88RmlsdGVyPihuZXdGaWx0ZXIpKHN0YXRlLmZpbHRlcnMpXG4gIH07XG5cbiAgY29uc3QgbmV3U3luY1RpbWVsaW5lTW9kZSA9IGdldFN5bmNBbmltYXRpb25Nb2RlKG5ld0ZpbHRlciBhcyBUaW1lUmFuZ2VGaWx0ZXIpO1xuXG4gIHJldHVybiBzZXRUaW1lRmlsdGVyVGltZWxpbmVNb2RlVXBkYXRlcihuZXdTdGF0ZSwge2lkLCBtb2RlOiBuZXdTeW5jVGltZWxpbmVNb2RlfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUZpbHRlckNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQXBwbHlGaWx0ZXJDb25maWdVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtmaWx0ZXJJZCwgbmV3RmlsdGVyfSA9IGFjdGlvbjtcbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGYgPT4gZi5pZCA9PT0gZmlsdGVySWQpO1xuICBpZiAoIW9sZEZpbHRlcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIFNlcmlhbGl6ZSB0aGUgZmlsdGVycyB0byBvbmx5IGNvbXBhcmUgdGhlIHNhdmVkIHByb3BlcnRpZXNcbiAgY29uc3Qgc2VyaWFsaXplZE9sZEZpbHRlciA9IHNlcmlhbGl6ZUZpbHRlcihvbGRGaWx0ZXIsIHN0YXRlLnNjaGVtYSkgPz8ge2NvbmZpZzoge319O1xuICBjb25zdCBzZXJpYWxpemVkTmV3RmlsdGVyID0gc2VyaWFsaXplRmlsdGVyKG5ld0ZpbHRlciwgc3RhdGUuc2NoZW1hKTtcbiAgaWYgKCFzZXJpYWxpemVkTmV3RmlsdGVyIHx8IGlzRXF1YWwoc2VyaWFsaXplZE9sZEZpbHRlciwgc2VyaWFsaXplZE5ld0ZpbHRlcikpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGNoYW5nZXMgdG8gdGhlIGZpbHRlciwgYXBwbHkgdGhlbVxuICBjb25zdCBjaGFuZ2VkID0gcGlja0NoYW5nZWRQcm9wcyhzZXJpYWxpemVkT2xkRmlsdGVyLCBzZXJpYWxpemVkTmV3RmlsdGVyKTtcbiAgZGVsZXRlIGNoYW5nZWRbJ2lkJ107IC8vIGlkIHNob3VsZCBub3QgYmUgY2hhbmdlZFxuXG4gIGNvbnN0IGZpbHRlckluZGV4ID0gc3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBmaWx0ZXJJZCk7XG4gIGlmIChmaWx0ZXJJbmRleCA8IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHNldEZpbHRlclVwZGF0ZXIoXG4gICAgc3RhdGUsXG4gICAgc2V0RmlsdGVyKGZpbHRlckluZGV4LCBPYmplY3Qua2V5cyhjaGFuZ2VkKSwgT2JqZWN0LnZhbHVlcyhjaGFuZ2VkKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZmlsdGVyIHByb3BlcnR5XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyVXBkYXRlcjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyVXBkYXRlckFjdGlvblxuKTogUyB7XG4gIGNvbnN0IHtpZHgsIHZhbHVlSW5kZXggPSAwfSA9IGFjdGlvbjtcbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuICBpZiAoIW9sZEZpbHRlcikge1xuICAgIENvbnNvbGUuZXJyb3IoYGZpbHRlcnMuJHtpZHh9IGlzIHVuZGVmaW5lZGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShhY3Rpb24ucHJvcCkgJiZcbiAgICAoIUFycmF5LmlzQXJyYXkoYWN0aW9uLnZhbHVlKSB8fCBhY3Rpb24ucHJvcC5sZW5ndGggIT09IGFjdGlvbi52YWx1ZS5sZW5ndGgpXG4gICkge1xuICAgIENvbnNvbGUuZXJyb3IoJ0V4cGVjdGluZyB2YWx1ZSB0byBiZSBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGgsIHNpbmNlIHByb3AgaXMgYW4gYXJyYXknKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgLy8gY29udmVydCBwcm9wIGFuZCB2YWx1ZSB0byBhcnJheVxuICBjb25zdCBwcm9wcyA9IHRvQXJyYXkoYWN0aW9uLnByb3ApO1xuICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGFjdGlvbi5wcm9wKSA/IHRvQXJyYXkoYWN0aW9uLnZhbHVlKSA6IFthY3Rpb24udmFsdWVdO1xuXG4gIGxldCBuZXdGaWx0ZXIgPSBvbGRGaWx0ZXI7XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGxldCBkYXRhc2V0SWRzVG9GaWx0ZXI6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgLy8gV2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IHBhc3NpbmcgaW4gbmFtZSBhcyBhbiBhcnJheSBpbnRvIF91cGRhdGVGaWx0ZXJQcm9wLCBzbyB3ZSBjYWxsIGl0IG11bHRpcGxlIHRpbWVzIHdpdGggZWFjaCBuYW1lXG4gICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZXJlIGFzIHRvIHdoYXQgc2hvdWxkIGJlIGFkZHJlc3NlZFxuICAgIGxldCByZXM7XG4gICAgaWYgKHByb3AgPT09ICduYW1lJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgcmVzID0gdmFsdWUucmVkdWNlKChhY2N1LCB2KSA9PiB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlRmlsdGVyUHJvcChhY2N1LCBuZXdGaWx0ZXIsIHByb3AsIHYsIHZhbHVlSW5kZXgpO1xuICAgICAgfSwgbmV3U3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBfdXBkYXRlRmlsdGVyUHJvcChuZXdTdGF0ZSwgbmV3RmlsdGVyLCBwcm9wLCB2YWx1ZSwgdmFsdWVJbmRleCk7XG4gICAgfVxuICAgIG5ld0ZpbHRlciA9IHJlcy5maWx0ZXI7XG4gICAgbmV3U3RhdGUgPSByZXMuc3RhdGU7XG4gICAgZGF0YXNldElkc1RvRmlsdGVyID0gZGF0YXNldElkc1RvRmlsdGVyLmNvbmNhdChyZXMuZGF0YXNldElkc1RvRmlsdGVyKTtcbiAgfVxuXG4gIGNvbnN0IGVubGFyZ2VkRmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGYgPT4gZi52aWV3ID09PSBGSUxURVJfVklFV19UWVBFUy5lbmxhcmdlZCk7XG5cbiAgaWYgKGVubGFyZ2VkRmlsdGVyICYmIGVubGFyZ2VkRmlsdGVyLmlkICE9PSBuZXdGaWx0ZXIuaWQpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgZW5sYXJnZWQgZmlsdGVyXG4gICAgbmV3RmlsdGVyLnZpZXcgPSBGSUxURVJfVklFV19UWVBFUy5zaWRlO1xuICB9XG5cbiAgLy8gc2F2ZSBuZXcgZmlsdGVycyB0byBuZXdTdGF0ZVxuICBuZXdTdGF0ZSA9IHNldChbJ2ZpbHRlcnMnLCBpZHhdLCBuZXdGaWx0ZXIsIG5ld1N0YXRlKTtcblxuICAvLyBmaWx0ZXIgZGF0YVxuICBjb25zdCBmaWx0ZXJlZERhdGFzZXRzID0gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyhcbiAgICB1bmlxKGRhdGFzZXRJZHNUb0ZpbHRlciksXG4gICAgbmV3U3RhdGUuZGF0YXNldHMsXG4gICAgbmV3U3RhdGUuZmlsdGVycyxcbiAgICBuZXdTdGF0ZS5sYXllcnNcbiAgKTtcblxuICBuZXdTdGF0ZSA9IHNldChbJ2RhdGFzZXRzJ10sIGZpbHRlcmVkRGF0YXNldHMsIG5ld1N0YXRlKTtcblxuICAvLyBuZWVkIHRvIHVwZGF0ZSBmaWx0ZXJQbG90IGFmdGVyIGZpbHRlciBEYXRhc2V0IGZvciBwbG90IHRvIHVwZGF0ZSBvbiBmaWx0ZXJlZCByZXN1bHRcbiAgY29uc3QgZmlsdGVyV2l0aFBMb3QgPSB1cGRhdGVGaWx0ZXJQbG90KG5ld1N0YXRlLmRhdGFzZXRzLCBuZXdTdGF0ZS5maWx0ZXJzW2lkeF0pO1xuXG4gIG5ld1N0YXRlID0gc2V0KFsnZmlsdGVycycsIGlkeF0sIGZpbHRlcldpdGhQTG90LCBuZXdTdGF0ZSk7XG5cbiAgLy8gZGF0YUlkIGlzIGFuIGFycmF5XG4gIC8vIHBhc3Mgb25seSB0aGUgZGF0YXNldCB3ZSBuZWVkIHRvIHVwZGF0ZVxuICBuZXdTdGF0ZSA9IHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShuZXdTdGF0ZSwgZGF0YXNldElkc1RvRmlsdGVyLCBuZXdGaWx0ZXIpO1xuXG4gIC8vIElmIHRpbWUgcmFuZ2UgZmlsdGVyIHZhbHVlIHdhcyB1cGRhdGVkLCBhZGp1c3QgYW5pbWF0aW9uIGNvbmZpZ1xuICBpZiAobmV3RmlsdGVyLnR5cGUgPT09IEZJTFRFUl9UWVBFUy50aW1lUmFuZ2UgJiYgcHJvcHMuaW5jbHVkZXMoJ3ZhbHVlJykpIHtcbiAgICBuZXdTdGF0ZSA9IGFkanVzdEFuaW1hdGlvbkNvbmZpZ1dpdGhGaWx0ZXIobmV3U3RhdGUsIGFjdGlvbi5pZHgpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG5mdW5jdGlvbiBfdXBkYXRlRmlsdGVyRGF0YUlkQXRWYWx1ZUluZGV4KGZpbHRlciwgdmFsdWVJbmRleCwgdmFsdWUsIGRhdGFzZXRzKSB7XG4gIGxldCBuZXdGaWx0ZXIgPSBmaWx0ZXI7XG4gIGlmIChmaWx0ZXIuZGF0YUlkW3ZhbHVlSW5kZXhdKSB7XG4gICAgLy8gaWYgZGF0YUlkIGFscmVhZHkgZXhpc3RcbiAgICBuZXdGaWx0ZXIgPSBfcmVtb3ZlRmlsdGVyRGF0YUlkQXRWYWx1ZUluZGV4KGZpbHRlciwgdmFsdWVJbmRleCwgZGF0YXNldHMpO1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5ld0ZpbHRlci5kYXRhSWQuc2xpY2UoKTtcbiAgICBuZXh0VmFsdWVbdmFsdWVJbmRleF0gPSB2YWx1ZTtcbiAgICBuZXdGaWx0ZXIgPSBzZXQoWydkYXRhSWQnXSwgbmV4dFZhbHVlLCBuZXdGaWx0ZXIpO1xuICB9XG4gIHJldHVybiBuZXdGaWx0ZXI7XG59XG5cbmZ1bmN0aW9uIF9yZW1vdmVGaWx0ZXJEYXRhSWRBdFZhbHVlSW5kZXgoZmlsdGVyLCB2YWx1ZUluZGV4LCBkYXRhc2V0cykge1xuICBjb25zdCBkYXRhSWQgPSBmaWx0ZXIuZGF0YUlkW3ZhbHVlSW5kZXhdO1xuXG4gIGlmIChmaWx0ZXIuZGF0YUlkLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZUluZGV4ID09PSAwKSB7XG4gICAgLy8gaWYgcmVtb3ZlIHRoZSBvbmx5IGRhdGFJZCwgY3JlYXRlIGFuIGVtcHR5IGZpbHRlciBpbnN0ZWFkO1xuICAgIHJldHVybiBnZXREZWZhdWx0RmlsdGVyKHtpZDogZmlsdGVyLmlkfSk7XG4gIH1cblxuICBpZiAoZGF0YUlkKSB7XG4gICAgZmlsdGVyID0gcmVtb3ZlRmlsdGVyUGxvdChmaWx0ZXIsIGRhdGFJZCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHByb3Agb2YgWydkYXRhSWQnLCAnbmFtZScsICdmaWVsZElkeCcsICdncHVDaGFubmVsJ10pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJbcHJvcF0pKSB7XG4gICAgICBjb25zdCBuZXh0VmFsID0gZmlsdGVyW3Byb3BdLnNsaWNlKCk7XG4gICAgICBuZXh0VmFsLnNwbGljZSh2YWx1ZUluZGV4LCAxKTtcbiAgICAgIGZpbHRlciA9IHNldChbcHJvcF0sIG5leHRWYWwsIGZpbHRlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2VGaWVsZERvbWFpbiBmb3IgdGhlIHJlbWFpbmluZyBmaWVsZHNcbiAgY29uc3QgZG9tYWluU3RlcHMgPSBtZXJnZUZpbHRlckRvbWFpbihmaWx0ZXIsIGRhdGFzZXRzKTtcblxuICBjb25zdCBuZXh0RmlsdGVyID0ge1xuICAgIC4uLmZpbHRlcixcbiAgICAvLyB2YWx1ZTogbmV4dFZhbHVlLFxuICAgIC4uLihkb21haW5TdGVwcyA/IHtkb21haW46IGRvbWFpblN0ZXBzPy5kb21haW4sIHN0ZXA6IGRvbWFpblN0ZXBzPy5zdGVwfSA6IHt9KVxuICB9O1xuXG4gIGNvbnN0IG5leHRWYWx1ZSA9IGFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4obmV4dEZpbHRlci52YWx1ZSwgbmV4dEZpbHRlcik7XG4gIHJldHVybiB7XG4gICAgLi4ubmV4dEZpbHRlcixcbiAgICB2YWx1ZTogbmV4dFZhbHVlXG4gIH07XG59XG5cbi8qKiAqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIHByb3BlcnR5IG9mIGEgZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVGaWx0ZXJQcm9wKHN0YXRlLCBmaWx0ZXIsIHByb3AsIHZhbHVlLCB2YWx1ZUluZGV4LCBkYXRhc2V0SWRzPykge1xuICBsZXQgZGF0YXNldElkc1RvRmlsdGVyOiBzdHJpbmdbXSA9IFtdO1xuICBzd2l0Y2ggKHByb3ApIHtcbiAgICAvLyBUT0RPOiBOZXh0IFBSIGZvciBVSSBpZiB3ZSB1cGRhdGUgZmlsdGVyRGF0YUlkLCB3ZSBuZWVkIHRvIGNvbnNpZGVyIHR3byBjYXNlczpcbiAgICAvLyAxLiBkYXRhSWQgaXMgZW1wdHk6IGNyZWF0ZSBhIGRlZmF1bHQgZmlsdGVyXG4gICAgLy8gMi4gQWRkIGEgbmV3IGRhdGFzZXQgaWRcbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLmRhdGFJZDoge1xuICAgICAgY29uc3Qgb2xkRGF0YUlkID0gWy4uLmZpbHRlci5kYXRhSWRdO1xuICAgICAgZmlsdGVyID0gX3VwZGF0ZUZpbHRlckRhdGFJZEF0VmFsdWVJbmRleChmaWx0ZXIsIHZhbHVlSW5kZXgsIHZhbHVlLCBzdGF0ZS5kYXRhc2V0cyk7XG4gICAgICBkYXRhc2V0SWRzVG9GaWx0ZXIgPSB1bmlxKFsuLi5vbGREYXRhSWQsIC4uLmZpbHRlci5kYXRhSWRdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLm5hbWU6IHtcbiAgICAgIC8vIHdlIGFyZSBzdXBwb3J0aW5nIHRoZSBjdXJyZW50IGZ1bmN0aW9uYWxpdHlcbiAgICAgIC8vIFRPRE86IE5leHQgUFIgZm9yIFVJIGZpbHRlciBuYW1lIHdpbGwgb25seSB1cGRhdGUgZmlsdGVyIG5hbWUgYnV0IGl0IHdvbid0IGhhdmUgc2lkZSBlZmZlY3RzXG4gICAgICAvLyB3ZSBhcmUgZ29ubmEgdXNlIHBhaXIgb2YgZGF0YXNldHMgYW5kIGZpZWxkSWR4IHRvIHVwZGF0ZSB0aGUgZmlsdGVyXG4gICAgICBjb25zdCBkYXRhc2V0SWQgPSBmaWx0ZXIuZGF0YUlkW3ZhbHVlSW5kZXhdO1xuICAgICAgY29uc3Qge2ZpbHRlcjogdXBkYXRlZEZpbHRlciwgZGF0YXNldDogbmV3RGF0YXNldH0gPSBhcHBseUZpbHRlckZpZWxkTmFtZShcbiAgICAgICAgZmlsdGVyLFxuICAgICAgICBzdGF0ZS5kYXRhc2V0cyxcbiAgICAgICAgZGF0YXNldElkLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVJbmRleCxcbiAgICAgICAge21lcmdlRG9tYWluOiB2YWx1ZUluZGV4ID4gMH1cbiAgICAgICk7XG4gICAgICBpZiAodXBkYXRlZEZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSB1cGRhdGVkRmlsdGVyO1xuICAgICAgICBpZiAoZmlsdGVyLmdwdSkge1xuICAgICAgICAgIGZpbHRlciA9IHNldEZpbHRlckdwdU1vZGUoZmlsdGVyLCBzdGF0ZS5maWx0ZXJzKTtcbiAgICAgICAgICBmaWx0ZXIgPSBhc3NpZ25HcHVDaGFubmVsKGZpbHRlciwgc3RhdGUuZmlsdGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBzZXQoWydkYXRhc2V0cycsIGRhdGFzZXRJZF0sIG5ld0RhdGFzZXQsIHN0YXRlKTtcbiAgICAgICAgLy8gcmVtb3ZlIGZpbHRlciBQbG90IGF0IGRhdGFzZXRJZCwgc28gaXQgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgZmlsdGVyID0gcmVtb3ZlRmlsdGVyUGxvdChmaWx0ZXIsIGRhdGFzZXRJZCk7XG5cbiAgICAgICAgZGF0YXNldElkc1RvRmlsdGVyID0gdXBkYXRlZEZpbHRlci5kYXRhSWQ7XG4gICAgICB9XG4gICAgICAvLyBvbmx5IGZpbHRlciB0aGUgY3VycmVudCBkYXRhc2V0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEZJTFRFUl9VUERBVEVSX1BST1BTLmxheWVySWQ6IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXBkYXRlIG9ubHkgZGF0YXNldElkL3MgaWYgd2UgaGF2ZSBhZGRlZC9yZW1vdmVkIGxheWVyc1xuICAgICAgLy8gLSBjaGVjayBmb3IgbGF5ZXJJZCBjaGFuZ2VzIChYT1Igd29ya3MgYmVjYXVzZSBvZiBzdHJpbmcgdmFsdWVzKVxuICAgICAgLy8gaWYgbm8gZGlmZmVyZW5jZXMgYmV0d2VlbiBsYXllcklkcywgZG9uJ3QgZG8gYW55IGZpbHRlcmluZ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgbGF5ZXJJZERpZmZlcmVuY2UgPSB4b3IodmFsdWUsIGZpbHRlci5sYXllcklkKTtcblxuICAgICAgY29uc3QgbGF5ZXJEYXRhSWRzID0gdW5pcTxzdHJpbmc+KFxuICAgICAgICBsYXllcklkRGlmZmVyZW5jZVxuICAgICAgICAgIC5tYXAobGlkID0+XG4gICAgICAgICAgICBnZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gbGlkKSxcbiAgICAgICAgICAgICAgWydjb25maWcnLCAnZGF0YUlkJ11cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbHRlcihkID0+IGQpIGFzIHN0cmluZ1tdXG4gICAgICApO1xuXG4gICAgICAvLyBvbmx5IGZpbHRlciBkYXRhc2V0c0lkc1xuICAgICAgZGF0YXNldElkc1RvRmlsdGVyID0gbGF5ZXJEYXRhSWRzO1xuXG4gICAgICAvLyBVcGRhdGUgbmV3RmlsdGVyIGRhdGFJZHNcbiAgICAgIGNvbnN0IG5ld0RhdGFJZHMgPSB1bmlxPHN0cmluZz4oXG4gICAgICAgIHZhbHVlXG4gICAgICAgICAgPy5tYXAobGlkID0+XG4gICAgICAgICAgICBnZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gbGlkKSxcbiAgICAgICAgICAgICAgWydjb25maWcnLCAnZGF0YUlkJ11cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbHRlcihkID0+IGQpIGFzIHN0cmluZ1tdXG4gICAgICApO1xuXG4gICAgICBmaWx0ZXIgPSB7XG4gICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgbGF5ZXJJZDogdmFsdWUsXG4gICAgICAgIGRhdGFJZDogbmV3RGF0YUlkc1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICBmaWx0ZXIgPSBzZXQoW3Byb3BdLCB2YWx1ZSwgZmlsdGVyKTtcbiAgICAgIGRhdGFzZXRJZHNUb0ZpbHRlciA9IFsuLi5maWx0ZXIuZGF0YUlkXTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtmaWx0ZXIsIGRhdGFzZXRJZHMsIGRhdGFzZXRJZHNUb0ZpbHRlciwgc3RhdGV9O1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFNldCB0aGUgcHJvcGVydHkgb2YgYSBmaWx0ZXIgcGxvdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEZpbHRlclBsb3RVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZHgsIG5ld1Byb3B9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmlsdGVyUGxvdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgaWYgKCFzdGF0ZS5maWx0ZXJzW2lkeF0pIHtcbiAgICBDb25zb2xlLmVycm9yKGBmaWx0ZXJzWyR7aWR4fV0gaXMgdW5kZWZpbmVkYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBuZXdGaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzW2lkeF07XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIG5ld1Byb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gJ3Bsb3RUeXBlJykge1xuICAgICAgbmV3RmlsdGVyID0gcGlja18oJ3Bsb3RUeXBlJykobWVyZ2VfKG5ld1Byb3AucGxvdFR5cGUpKShuZXdGaWx0ZXIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3lBeGlzJykge1xuICAgICAgY29uc3QgY2hhcnRUeXBlID0gbmV3UHJvcC55QXhpcyA/IFBMT1RfVFlQRVMubGluZUNoYXJ0IDogUExPVF9UWVBFUy5oaXN0b2dyYW07XG5cbiAgICAgIG5ld0ZpbHRlciA9IHBpY2tfKCdwbG90VHlwZScpKG1lcmdlXyh7dHlwZTogY2hhcnRUeXBlfSkpKG1lcmdlXyhuZXdQcm9wKShuZXdGaWx0ZXIpKTtcbiAgICB9XG4gIH1cblxuICBuZXdGaWx0ZXIgPSB1cGRhdGVGaWx0ZXJQbG90KHN0YXRlLmRhdGFzZXRzLCBuZXdGaWx0ZXIpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQWRkRmlsdGVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT5cbiAgIWFjdGlvbi5kYXRhSWRcbiAgICA/IHN0YXRlXG4gICAgOiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBmaWx0ZXJzOiBbLi4uc3RhdGUuZmlsdGVycywgZ2V0RGVmYXVsdEZpbHRlcih7ZGF0YUlkOiBhY3Rpb24uZGF0YUlkLCBpZDogYWN0aW9uLmlkfSldXG4gICAgICB9O1xuXG4vKipcbiAqIENyZWF0ZSBvciB1cGRhdGUgYSBmaWx0ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVPclVwZGF0ZUZpbHRlclVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuQ3JlYXRlT3JVcGRhdGVGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtpZCwgZGF0YUlkLCBmaWVsZCwgdmFsdWV9ID0gYWN0aW9uO1xuXG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCBvcmlnaW5hbEluZGV4ID0gbmV3U3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBpZCk7XG4gIGxldCBmaWx0ZXJJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gIGlmICghaWQgJiYgIWRhdGFJZCkge1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuICBpZiAob3JpZ2luYWxJbmRleCA8IDAgJiYgZGF0YUlkKSB7XG4gICAgbmV3U3RhdGUgPSBhZGRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7ZGF0YUlkfSk7XG4gICAgaWYgKG5ld1N0YXRlLmZpbHRlcnMubGVuZ3RoICE9PSBzdGF0ZS5maWx0ZXJzLmxlbmd0aCArIDEpIHtcbiAgICAgIC8vIE5vIG5ldyBmaWx0ZXIgd2FzIGFkZGVkXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgYXJlIGFzc3VtaW5nIHRoYXQgdGhlIGZpbHRlciB3YXMgYWRkZWQgYXQgdGhlIGVuZFxuICAgIGZpbHRlckluZGV4ID0gbmV3U3RhdGUuZmlsdGVycy5sZW5ndGggLSAxO1xuICAgIG5ld1N0YXRlLmZpbHRlcnNbZmlsdGVySW5kZXhdID0ge1xuICAgICAgLi4ubmV3U3RhdGUuZmlsdGVyc1tmaWx0ZXJJbmRleF0sXG4gICAgICAuLi4oaWQgPyB7aWR9IDogbnVsbClcbiAgICB9O1xuICB9XG5cbiAgLy8gTm8gbmVlZCB0byB1cGRhdGUgdGhpcyBpZiBpdCdzIGEgbmV3bHkgY3JlYXRlZCBmaWx0ZXJcbiAgLy8gRmlyc3Qgd2UgbWFrZSBzdXJlIGFsbCB0aGUgZGF0YUlkcyB0aGF0IGZpZWxkcyByZWZlciB0byBhcmUgdXBkYXRlZFxuICBpZiAob3JpZ2luYWxJbmRleCA+PSAwICYmIGRhdGFJZCkge1xuICAgIC8vIElmIHRoZSBkYXRhSWQgaXMgYW4gYXJyYXksIHdlIG5lZWQgdG8gdXBkYXRlIGVhY2ggb25lIGluZGl2aWR1YWxseSBhcyB0aGV5IG5lZWQgYSBjb3JyZWN0IHZhbHVlSW5kZXggcGFzc2VkXG4gICAgbmV3U3RhdGUgPSAoQXJyYXkuaXNBcnJheShkYXRhSWQpID8gZGF0YUlkIDogW2RhdGFJZF0pLnJlZHVjZSgoYWNjdSwgZCwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKGFjY3UsIHtcbiAgICAgICAgaWR4OiBmaWx0ZXJJbmRleCxcbiAgICAgICAgcHJvcDogJ2RhdGFJZCcsXG4gICAgICAgIHZhbHVlOiBkLFxuICAgICAgICB2YWx1ZUluZGV4OiBpbmRleFxuICAgICAgfSk7XG4gICAgfSwgbmV3U3RhdGUpO1xuICB9XG4gIC8vIFRoZW4gd2UgdXBkYXRlIHRoZSBmaWVsZHNcbiAgaWYgKGZpZWxkKSB7XG4gICAgLy8gSWYgdGhlIGZpZWxkIGlzIGFuIGFycmF5LCB3ZSBuZWVkIHRvIHVwZGF0ZSBlYWNoIGZpZWxkIGluZGl2aWR1YWxseSBhcyB0aGV5IG5lZWQgYSBjb3JyZWN0IHZhbHVlSW5kZXggcGFzc2VkXG4gICAgbmV3U3RhdGUgPSAoQXJyYXkuaXNBcnJheShmaWVsZCkgPyBmaWVsZCA6IFtmaWVsZF0pLnJlZHVjZSgoYWNjdSwgZiwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKGFjY3UsIHtcbiAgICAgICAgaWR4OiBmaWx0ZXJJbmRleCxcbiAgICAgICAgcHJvcDogJ25hbWUnLFxuICAgICAgICB2YWx1ZTogZixcbiAgICAgICAgdmFsdWVJbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH0sIG5ld1N0YXRlKTtcbiAgfVxuICAvLyBUaGVuIHdlIHVwZGF0ZSB0aGUgdmFsdWUgc2VwYXJhdGVseVxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5ld1N0YXRlID0gc2V0RmlsdGVyVXBkYXRlcihuZXdTdGF0ZSwge2lkeDogZmlsdGVySW5kZXgsIHByb3A6ICd2YWx1ZScsIHZhbHVlfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIFNldCBsYXllciBjb2xvciBwYWxldHRlIHVpIHN0YXRlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7b2xkTGF5ZXIsIHByb3AsIG5ld0NvbmZpZ306IFZpc1N0YXRlQWN0aW9ucy5MYXllckNvbG9yVUlDaGFuZ2VVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IG9sZFZpeENvbmZpZyA9IG9sZExheWVyLmNvbmZpZy52aXNDb25maWdbcHJvcF07XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHByb3AsIG5ld0NvbmZpZyk7XG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IG5ld0xheWVyLmNvbmZpZy52aXNDb25maWdbcHJvcF07XG4gIGlmIChvbGRWaXhDb25maWcgIT09IG5ld1Zpc0NvbmZpZykge1xuICAgIHJldHVybiBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIHtcbiAgICAgIG9sZExheWVyLFxuICAgICAgbmV3VmlzQ29uZmlnOiB7XG4gICAgICAgIFtwcm9wXTogbmV3VmlzQ29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IHN0YXRlLmxheWVycy5tYXAobCA9PiAobC5pZCA9PT0gb2xkTGF5ZXIuaWQgPyBuZXdMYXllciA6IGwpKVxuICB9O1xufTtcblxuLyoqXG4gKiBTdGFydCBhbmQgZW5kIGZpbHRlciBhbmltYXRpb25cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUZpbHRlckFuaW1hdGlvblVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT4gKGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgaXNBbmltYXRpbmc6ICFmLmlzQW5pbWF0aW5nfSA6IGYpKVxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbHRlckFuaW1hdGlvbkNvbmZpZyhjb25maWc6IEFuaW1hdGlvbkNvbmZpZyB8IEZpbHRlckFuaW1hdGlvbkNvbmZpZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gJ2RhdGFJZCcgaW4gY29uZmlnICYmICdhbmltYXRpb25XaW5kb3cnIGluIGNvbmZpZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEFuaW1hdGlvbkNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU2V0QW5pbWF0aW9uQ29uZmlnVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7Y29uZmlnfSA9IGFjdGlvbjtcbiAgaWYgKGlzRmlsdGVyQW5pbWF0aW9uQ29uZmlnKGNvbmZpZykpIHtcbiAgICAvLyBGaW5kIGZpbHRlciB1c2VkIGZvciBhbmltYXRpb25cbiAgICAvLyBBc3N1bWluZyB0aGVyZSdzIG9ubHkgb25lIGZpbHRlciB1c2VkIGZvciBhbmltYXRpb24sIHNlZSBzZXRGaWx0ZXJWaWV3VXBkYXRlclxuICAgIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmID0+ICFpc1NpZGVGaWx0ZXIoZikpO1xuICAgIGlmICghZmlsdGVyKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IG5ld0ZpbHRlciA9IHsuLi5maWx0ZXIsIC4uLmNvbmZpZ307XG4gICAgcmV0dXJuIGFwcGx5RmlsdGVyQ29uZmlnVXBkYXRlcihzdGF0ZSwgYXBwbHlGaWx0ZXJDb25maWcoZmlsdGVyLmlkLCBuZXdGaWx0ZXIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyQW5pbWF0aW9uVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlRvZ2dsZUxheWVyQW5pbWF0aW9uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICBpc0FuaW1hdGluZzogIXN0YXRlLmFuaW1hdGlvbkNvbmZpZy5pc0FuaW1hdGluZ1xuICB9XG59KTtcblxuLyoqXG4gKiBIaWRlIGFuZCBzaG93IGxheWVyIGFuaW1hdGlvbiBjb250cm9sXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlTGF5ZXJBbmltYXRpb25Db250cm9sVXBkYXRlciA9IChzdGF0ZTogVmlzU3RhdGUpOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgIGhpZGVDb250cm9sOiAhc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmhpZGVDb250cm9sXG4gIH1cbn0pO1xuXG4vKipcbiAqIENoYW5nZSBmaWx0ZXIgYW5pbWF0aW9uIHNwZWVkXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlRmlsdGVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKChmLCBpKSA9PiAoaSA9PT0gYWN0aW9uLmlkeCA/IHsuLi5mLCBzcGVlZDogYWN0aW9uLnNwZWVkfSA6IGYpKVxufSk7XG5cbi8qKlxuICogVXBkYXRlIGFuaW1hdGlvbiBzcGVlZCB3aXRoIHRoZSB2ZXJ0aWNhbCBzcGVlZCBzbGlkZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKlxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge3NwZWVkfTogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZUxheWVyQW5pbWF0aW9uU3BlZWRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgICBzcGVlZFxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogU2hvdyBsYXJnZXIgdGltZSBmaWx0ZXIgYXQgYm90dG9tIGZvciB0aW1lIHBsYXliYWNrIChhcHBseSB0byB0aW1lIGZpbHRlciBvbmx5KVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEZpbHRlclZpZXdVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlclZpZXdVcGRhdGVyQWN0aW9uXG4pID0+IHtcbiAgY29uc3Qge3ZpZXcsIGlkeH0gPSBhY3Rpb247XG4gIGNvbnN0IHNob3VsZFJlc2V0T3RoZXJGaWx0ZXJzVmlldyA9IHZpZXcgPT09IEZJTFRFUl9WSUVXX1RZUEVTLmVubGFyZ2VkO1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKChmLCBpKSA9PlxuICAgICAgaSA9PT0gaWR4XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uZixcbiAgICAgICAgICAgIHZpZXdcbiAgICAgICAgICB9XG4gICAgICAgIDogc2hvdWxkUmVzZXRPdGhlckZpbHRlcnNWaWV3XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uZixcbiAgICAgICAgICAgIHZpZXc6IEZJTFRFUl9WSUVXX1RZUEVTLnNpZGVcbiAgICAgICAgICB9XG4gICAgICAgIDogZlxuICAgIClcbiAgfTtcbn07XG5cbi8qKlxuICogVG9nZ2xlcyBmaWx0ZXIgZmVhdHVyZSB2aXNpYmlsaXR5XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlRmlsdGVyRmVhdHVyZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlRmlsdGVyRmVhdHVyZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3QgZmlsdGVyID0gc3RhdGUuZmlsdGVyc1thY3Rpb24uaWR4XTtcbiAgY29uc3QgaXNWaXNpYmxlID0gZ2V0KGZpbHRlciwgWyd2YWx1ZScsICdwcm9wZXJ0aWVzJywgJ2lzVmlzaWJsZSddKTtcblxuICBsZXQgbmV3U3RhdGUgPSBzZXRGaWx0ZXJVcGRhdGVyKHN0YXRlLCB7XG4gICAgaWR4OiBhY3Rpb24uaWR4LFxuICAgIHByb3A6ICdlbmFibGVkJyxcbiAgICB2YWx1ZTogIWlzVmlzaWJsZVxuICB9KTtcblxuICBuZXdTdGF0ZSA9IHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICBpZHg6IGFjdGlvbi5pZHgsXG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZmVhdHVyZVRvRmlsdGVyVmFsdWUoZmlsdGVyLnZhbHVlLCBmaWx0ZXIuaWQsIHtcbiAgICAgIGlzVmlzaWJsZTogIWlzVmlzaWJsZVxuICAgIH0pXG4gIH0pO1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRmlsdGVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtpZHh9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YUlkLCBpZH0gPSBzdGF0ZS5maWx0ZXJzW2lkeF07XG5cbiAgY29uc3QgbmV3RmlsdGVycyA9IFtcbiAgICAuLi5zdGF0ZS5maWx0ZXJzLnNsaWNlKDAsIGlkeCksXG4gICAgLi4uc3RhdGUuZmlsdGVycy5zbGljZShpZHggKyAxLCBzdGF0ZS5maWx0ZXJzLmxlbmd0aClcbiAgXTtcblxuICBjb25zdCBmaWx0ZXJlZERhdGFzZXRzID0gYXBwbHlGaWx0ZXJzVG9EYXRhc2V0cyhkYXRhSWQsIHN0YXRlLmRhdGFzZXRzLCBuZXdGaWx0ZXJzLCBzdGF0ZS5sYXllcnMpO1xuICBjb25zdCBuZXdFZGl0b3IgPVxuICAgIGdldEZpbHRlcklkSW5GZWF0dXJlKHN0YXRlLmVkaXRvci5zZWxlY3RlZEZlYXR1cmUpID09PSBpZFxuICAgICAgPyB7XG4gICAgICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICAgICAgICB9XG4gICAgICA6IHN0YXRlLmVkaXRvcjtcblxuICBsZXQgbmV3U3RhdGUgPSBzZXQoWydmaWx0ZXJzJ10sIG5ld0ZpbHRlcnMsIHN0YXRlKTtcbiAgbmV3U3RhdGUgPSBzZXQoWydkYXRhc2V0cyddLCBmaWx0ZXJlZERhdGFzZXRzLCBuZXdTdGF0ZSk7XG4gIG5ld1N0YXRlID0gc2V0KFsnZWRpdG9yJ10sIG5ld0VkaXRvciwgbmV3U3RhdGUpO1xuXG4gIHJldHVybiB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFJZCwgdW5kZWZpbmVkKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkTGF5ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkFkZExheWVyVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBsZXQgbmV3TGF5ZXI7XG4gIGxldCBuZXdMYXllckRhdGE7XG4gIGlmIChhY3Rpb24uY29uZmlnKSB7XG4gICAgbmV3TGF5ZXIgPSBjcmVhdGVMYXllckZyb21Db25maWcoc3RhdGUsIGFjdGlvbi5jb25maWcpO1xuICAgIGlmICghbmV3TGF5ZXIpIHtcbiAgICAgIENvbnNvbGUud2FybihcbiAgICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgbGF5ZXIgZnJvbSBjb25maWcsIGl0IHVzdWFsbHkgbWVhbnMgdGhlIGNvbmZpZyBpcyBub3QgYmUgaW4gY29ycmVjdCBmb3JtYXQnLFxuICAgICAgICBhY3Rpb24uY29uZmlnXG4gICAgICApO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUpO1xuICAgIG5ld0xheWVyID0gcmVzdWx0LmxheWVyO1xuICAgIG5ld0xheWVyRGF0YSA9IHJlc3VsdC5sYXllckRhdGE7XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGFuIGVtcHR5IGxheWVyIHdpdGggYSBzcGVjaWZpYyBkYXRhc2V0IG9yIGEgZGVmYXVsdCBvbmVcbiAgICBjb25zdCBkZWZhdWx0RGF0YXNldCA9IGFjdGlvbi5kYXRhc2V0SWQgPz8gT2JqZWN0LmtleXMoc3RhdGUuZGF0YXNldHMpWzBdO1xuICAgIG5ld0xheWVyID0gbmV3IExheWVyKHtcbiAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgIGlzQ29uZmlnQWN0aXZlOiB0cnVlLFxuICAgICAgZGF0YUlkOiBkZWZhdWx0RGF0YXNldFxuICAgIH0pO1xuICAgIG5ld0xheWVyRGF0YSA9IHt9O1xuICB9XG5cbiAgbGV0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogWy4uLnN0YXRlLmxheWVycywgbmV3TGF5ZXJdLFxuICAgIGxheWVyRGF0YTogWy4uLnN0YXRlLmxheWVyRGF0YSwgbmV3TGF5ZXJEYXRhXSxcbiAgICAvLyBhZGQgbmV3IGxheWVyIGF0IHRoZSB0b3BcbiAgICBsYXllck9yZGVyOiBbbmV3TGF5ZXIuaWQsIC4uLnN0YXRlLmxheWVyT3JkZXJdLFxuICAgIHNwbGl0TWFwczogYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIG5ld0xheWVyKVxuICB9O1xuXG4gIGlmIChuZXdMYXllci5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQpIHtcbiAgICBuZXdTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbihuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59O1xuXG4vKipcbiAqIHJlbW92ZSBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxheWVyVXBkYXRlcjxUIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogVCxcbiAge2lkfTogVmlzU3RhdGVBY3Rpb25zLlJlbW92ZUxheWVyVXBkYXRlckFjdGlvblxuKTogVCB7XG4gIGNvbnN0IGlkeCA9IE51bWJlci5pc0Zpbml0ZShpZClcbiAgICA/IC8vIHN1cHBvcnQgb2xkZXIgQVBJLCByZW1vdmUgbGF5ZXIgYnkgaWR4XG4gICAgICBOdW1iZXIoaWQpXG4gICAgOiBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gaWQpO1xuICBpZiAoaWR4IDwgMCB8fCBpZHggPj0gc3RhdGUubGF5ZXJzLmxlbmd0aCkge1xuICAgIC8vIGludmFsaWQgaW5kZXhcbiAgICBDb25zb2xlLndhcm4oYGNhbiBub3QgcmVtb3ZlIGxheWVyIHdpdGggaW52YWxpZCBpZHxpZHggJHtpZH1gKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7bGF5ZXJzLCBsYXllckRhdGEsIGxheWVyT3JkZXIsIGNsaWNrZWQsIGhvdmVySW5mb30gPSBzdGF0ZTtcbiAgY29uc3QgbGF5ZXJUb1JlbW92ZSA9IGxheWVyc1tpZHhdO1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IGZpbHRlck91dEJ5SWQobGF5ZXJUb1JlbW92ZS5pZCkobGF5ZXJzKSxcbiAgICBsYXllckRhdGE6IHJlbW92ZUVsZW1lbnRBdEluZGV4KGlkeCkobGF5ZXJEYXRhKSxcbiAgICBsYXllck9yZGVyOiBsYXllck9yZGVyLmZpbHRlcihsYXllcklkID0+IGxheWVySWQgIT09IGxheWVyVG9SZW1vdmUuaWQpLFxuICAgIGNsaWNrZWQ6IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoY2xpY2tlZCkgPyB1bmRlZmluZWQgOiBjbGlja2VkLFxuICAgIGhvdmVySW5mbzogbGF5ZXJUb1JlbW92ZS5pc0xheWVySG92ZXJlZChob3ZlckluZm8pID8gdW5kZWZpbmVkIDogaG92ZXJJbmZvLFxuICAgIHNwbGl0TWFwczogcmVtb3ZlTGF5ZXJGcm9tU3BsaXRNYXBzKHN0YXRlLnNwbGl0TWFwcywgbGF5ZXJUb1JlbW92ZSlcbiAgICAvLyBUT0RPOiB1cGRhdGUgZmlsdGVycywgY3JlYXRlIGhlbHBlciB0byByZW1vdmUgbGF5ZXIgZm9ybSBmaWx0ZXIgKHJlbW92ZSBsYXllcmlkIGFuZCBkYXRhaWQpIGlmIG1hcHBlZFxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVBbmltYXRpb25Eb21haW4obmV3U3RhdGUpO1xufVxuXG4vKipcbiAqIFJlb3JkZXIgbGF5ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW9yZGVyTGF5ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtvcmRlcn06IFZpc1N0YXRlQWN0aW9ucy5SZW9yZGVyTGF5ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbGF5ZXJPcmRlcjogb3JkZXJcbn0pO1xuXG4vKipcbiAqIGR1cGxpY2F0ZSBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGR1cGxpY2F0ZUxheWVyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7aWR9OiBWaXNTdGF0ZUFjdGlvbnMuRHVwbGljYXRlTGF5ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IGlkeCA9IE51bWJlci5pc0Zpbml0ZShpZClcbiAgICA/IC8vIHN1cHBvcnQgb2xkZXIgQVBJLCByZW1vdmUgbGF5ZXIgYnkgaWR4XG4gICAgICBOdW1iZXIoaWQpXG4gICAgOiBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gaWQpO1xuICBpZiAoaWR4IDwgMCB8fCAhc3RhdGUubGF5ZXJzW2lkeF0pIHtcbiAgICBDb25zb2xlLndhcm4oYGxheWVyICR7aWR4fSBub3QgZm91bmQgaW4gbGF5ZXJPcmRlcmApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHtsYXllcnN9ID0gc3RhdGU7XG4gIGNvbnN0IG9yaWdpbmFsID0gbGF5ZXJzW2lkeF07XG5cbiAgY29uc3Qgb3JpZ2luYWxMYXllck9yZGVySWR4ID0gc3RhdGUubGF5ZXJPcmRlci5maW5kSW5kZXgobGlkID0+IGxpZCA9PT0gb3JpZ2luYWwuaWQpO1xuICBsZXQgbmV3TGFiZWwgPSBgQ29weSBvZiAke29yaWdpbmFsLmNvbmZpZy5sYWJlbH1gO1xuICBsZXQgcG9zdGZpeCA9IDA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgd2hpbGUgKGxheWVycy5maW5kKGwgPT4gbC5jb25maWcubGFiZWwgPT09IG5ld0xhYmVsKSkge1xuICAgIG5ld0xhYmVsID0gYENvcHkgb2YgJHtvcmlnaW5hbC5jb25maWcubGFiZWx9ICR7Kytwb3N0Zml4fWA7XG4gIH1cblxuICAvLyBjb2xsZWN0IGxheWVyIGNvbmZpZyBmcm9tIG9yaWdpbmFsXG4gIGNvbnN0IGxvYWRlZExheWVyID0gc2VyaWFsaXplTGF5ZXIob3JpZ2luYWwsIHN0YXRlLnNjaGVtYSk7XG5cbiAgLy8gYXNzaWduIG5ldyBpZCBhbmQgbGFiZWwgdG8gY29waWVkIGxheWVyXG4gIGlmICghbG9hZGVkTGF5ZXI/LmNvbmZpZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsb2FkZWRMYXllci5jb25maWcubGFiZWwgPSBuZXdMYWJlbDtcbiAgbG9hZGVkTGF5ZXIuaWQgPSBnZW5lcmF0ZUhhc2hJZChMQVlFUl9JRF9MRU5HVEgpO1xuXG4gIC8vIGFkZCBsYXllciB0byBzdGF0ZVxuICBsZXQgbmV4dFN0YXRlID0gYWRkTGF5ZXJVcGRhdGVyKHN0YXRlLCB7Y29uZmlnOiBsb2FkZWRMYXllcn0pO1xuICAvLyByZXRyaWV2ZSBuZXdseSBjcmVhdGVkIGxheWVyXG4gIGNvbnN0IG5ld0xheWVyID0gbmV4dFN0YXRlLmxheWVyc1tuZXh0U3RhdGUubGF5ZXJzLmxlbmd0aCAtIDFdO1xuICAvLyB1cGRhdGUgbGF5ZXIgb3JkZXIgd2l0aCBuZXdMeWFlci5pZFxuICBjb25zdCBuZXdMYXllck9yZGVyID0gYXJyYXlJbnNlcnQoXG4gICAgbmV4dFN0YXRlLmxheWVyT3JkZXIuc2xpY2UoMSwgbmV4dFN0YXRlLmxheWVyT3JkZXIubGVuZ3RoKSxcbiAgICBvcmlnaW5hbExheWVyT3JkZXJJZHgsXG4gICAgbmV3TGF5ZXIuaWRcbiAgKTtcblxuICBuZXh0U3RhdGUgPSByZW9yZGVyTGF5ZXJVcGRhdGVyKG5leHRTdGF0ZSwge29yZGVyOiBuZXdMYXllck9yZGVyfSk7XG5cbiAgcmV0dXJuIHVwZGF0ZUFuaW1hdGlvbkRvbWFpbihuZXh0U3RhdGUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBuZXcgZWZmZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5BZGRFZmZlY3RVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGlmIChcbiAgICBhY3Rpb24uY29uZmlnPy50eXBlID09PSBMSUdIVF9BTkRfU0hBRE9XX0VGRkVDVC50eXBlICYmXG4gICAgc3RhdGUuZWZmZWN0cy5zb21lKGVmZmVjdCA9PiBlZmZlY3QudHlwZSA9PT0gTElHSFRfQU5EX1NIQURPV19FRkZFQ1QudHlwZSlcbiAgKSB7XG4gICAgQ29uc29sZS53YXJuKGBDYW4ndCBhZGQgbW9yZSB0aGFuIG9uZSAke0xJR0hUX0FORF9TSEFET1dfRUZGRUNULm5hbWV9IGVmZmVjdGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG5ld0VmZmVjdCA9IGNyZWF0ZUVmZmVjdChhY3Rpb24uY29uZmlnKTtcblxuICAvLyBjb2xsYXBzZSBjb25maWd1cmF0b3JzIGZvciBvdGhlciBlZmZlY3RzXG4gIHN0YXRlLmVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LnNldFByb3BzKHtpc0NvbmZpZ0FjdGl2ZTogZmFsc2V9KSk7XG5cbiAgY29uc3QgZWZmZWN0cyA9IFsuLi5zdGF0ZS5lZmZlY3RzLCBuZXdFZmZlY3RdO1xuICBjb25zdCBlZmZlY3RPcmRlciA9IGZpeEVmZmVjdE9yZGVyKGVmZmVjdHMsIFtuZXdFZmZlY3QuaWQsIC4uLnN0YXRlLmVmZmVjdE9yZGVyXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZmZlY3RzLFxuICAgIGVmZmVjdE9yZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIHJlbW92ZSBlZmZlY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFZmZlY3RVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZH06IFZpc1N0YXRlQWN0aW9ucy5SZW1vdmVFZmZlY3RVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IGlkeCA9IHN0YXRlLmVmZmVjdHMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gaWQpO1xuICBpZiAoaWR4IDwgMCB8fCBpZHggPj0gc3RhdGUuZWZmZWN0cy5sZW5ndGgpIHtcbiAgICBDb25zb2xlLndhcm4oYGNhbiBub3QgcmVtb3ZlIGVmZmVjdCB3aXRoIGludmFsaWQgaWQgJHtpZH1gKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB7ZWZmZWN0cywgZWZmZWN0T3JkZXJ9ID0gc3RhdGU7XG4gIGNvbnN0IGVmZmVjdFRvUmVtb3ZlID0gZWZmZWN0c1tpZHhdO1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZml4ZWQgaW4gdHNcbiAgICBlZmZlY3RzOiBmaWx0ZXJPdXRCeUlkKGVmZmVjdFRvUmVtb3ZlLmlkKShlZmZlY3RzKSxcbiAgICBlZmZlY3RPcmRlcjogZWZmZWN0T3JkZXIuZmlsdGVyKGVmZmVjdElkID0+IGVmZmVjdElkICE9PSBlZmZlY3RUb1JlbW92ZS5pZClcbiAgfTtcbn07XG5cbi8qKlxuICogUmVvcmRlciBlZmZlY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW9yZGVyRWZmZWN0VXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7b3JkZXJ9OiBWaXNTdGF0ZUFjdGlvbnMuUmVvcmRlckVmZmVjdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBlZmZlY3RPcmRlcjogZml4RWZmZWN0T3JkZXIoc3RhdGUuZWZmZWN0cywgWy4uLm9yZGVyXSlcbn0pO1xuXG4vKipcbiAqIFVwZGF0ZSBlZmZlY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVFZmZlY3RVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtpZCwgcHJvcHN9OiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlRWZmZWN0VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBpZHggPSBzdGF0ZS5lZmZlY3RzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IGlkKTtcbiAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IHN0YXRlLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgQ29uc29sZS53YXJuKGBjYW4gbm90IHVwZGF0ZSBlZmZlY3Qgd2l0aCBpbnZhbGlkIGlkICR7aWR9YCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgbGV0IGVmZmVjdE9yZGVyID0gc3RhdGUuZWZmZWN0T3JkZXI7XG4gIGlmIChwcm9wcy5pZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmlkICE9PSBpZCkge1xuICAgIGNvbnN0IGlkeDIgPSBzdGF0ZS5lZmZlY3RzLmZpbmRJbmRleChsID0+IGwuaWQgPT09IHByb3BzLmlkKTtcbiAgICBpZiAoaWR4MiA+PSAwKSB7XG4gICAgICBDb25zb2xlLndhcm4oYGNhbiBub3QgdXBkYXRlIGVmZmVjdCB3aXRoIGV4aXN0aW5nIGVmZmVjdCBpZCAke2lkfWApO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGVmZmVjdE9yZGVyID0gZWZmZWN0T3JkZXIubWFwKGVmZmVjdE9yZGVySWQgPT5cbiAgICAgIGVmZmVjdE9yZGVySWQgPT09IGlkID8gKHByb3BzLmlkIGFzIHN0cmluZykgOiBlZmZlY3RPcmRlcklkXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG5ld0VmZmVjdHMgPSBbLi4uc3RhdGUuZWZmZWN0c107XG4gIG5ld0VmZmVjdHNbaWR4XS5zZXRQcm9wcyhwcm9wcyk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBlZmZlY3RzOiBuZXdFZmZlY3RzLFxuICAgIGVmZmVjdE9yZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGRhdGFzZXQgYW5kIGFsbCBsYXllcnMsIGZpbHRlcnMsIHRvb2x0aXAgY29uZmlncyB0aGF0IGJhc2VkIG9uIGl0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRGF0YXNldFVwZGF0ZXI8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlJlbW92ZURhdGFzZXRVcGRhdGVyQWN0aW9uXG4pOiBUIHtcbiAgLy8gZXh0cmFjdCBkYXRhc2V0IGtleVxuICBjb25zdCB7ZGF0YUlkOiBkYXRhc2V0S2V5fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFzZXRzfSA9IHN0YXRlO1xuXG4gIC8vIGNoZWNrIGlmIGRhdGFzZXQgaXMgcHJlc2VudFxuICBpZiAoIWRhdGFzZXRzW2RhdGFzZXRLZXldKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGxheWVycyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZGF0YXNldHM6IHtbZGF0YXNldEtleV06IGRhdGFzZXQsIC4uLm5ld0RhdGFzZXRzfVxuICB9ID0gc3RhdGU7XG5cbiAgY29uc3QgbGF5ZXJzVG9SZW1vdmUgPSBsYXllcnMuZmlsdGVyKGwgPT4gbC5jb25maWcuZGF0YUlkID09PSBkYXRhc2V0S2V5KS5tYXAobCA9PiBsLmlkKTtcblxuICAvLyByZW1vdmUgbGF5ZXJzIGFuZCBkYXRhc2V0c1xuICBsZXQgbmV3U3RhdGUgPSBsYXllcnNUb1JlbW92ZS5yZWR1Y2UoKGFjY3UsIGlkKSA9PiByZW1vdmVMYXllclVwZGF0ZXIoYWNjdSwge2lkfSksIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBkYXRhc2V0czogbmV3RGF0YXNldHNcbiAgfSk7XG5cbiAgLy8gdXBkYXRlIGZpbHRlcnNcbiAgY29uc3QgZmlsdGVyczogRmlsdGVyW10gPSBbXTtcbiAgZm9yIChjb25zdCBmaWx0ZXIgb2YgbmV3U3RhdGUuZmlsdGVycykge1xuICAgIGNvbnN0IHZhbHVlSW5kZXggPSBmaWx0ZXIuZGF0YUlkLmluZGV4T2YoZGF0YXNldEtleSk7XG4gICAgaWYgKHZhbHVlSW5kZXggPj0gMCAmJiBmaWx0ZXIuZGF0YUlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIG9ubHkgcmVtb3ZlIG9uZSBzeW5jZWQgZGF0YXNldCBmcm9tIHRoZSBmaWx0ZXJcbiAgICAgIGZpbHRlcnMucHVzaChfcmVtb3ZlRmlsdGVyRGF0YUlkQXRWYWx1ZUluZGV4KGZpbHRlciwgdmFsdWVJbmRleCwgZGF0YXNldHMpKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlSW5kZXggPCAwKSB7XG4gICAgICAvLyBsZWF2ZSB0aGUgZmlsdGVyIGFzIGlzXG4gICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICB9XG4gIH1cblxuICBuZXdTdGF0ZSA9IHsuLi5uZXdTdGF0ZSwgZmlsdGVyc307XG5cbiAgcmV0dXJuIHJlbW92ZURhdGFzZXRGcm9tSW50ZXJhY3Rpb25Db25maWcobmV3U3RhdGUsIHtkYXRhSWQ6IGRhdGFzZXRLZXl9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRGF0YXNldEZyb21JbnRlcmFjdGlvbkNvbmZpZyhzdGF0ZSwge2RhdGFJZH0pIHtcbiAgbGV0IHtpbnRlcmFjdGlvbkNvbmZpZ30gPSBzdGF0ZTtcbiAgY29uc3Qge3Rvb2x0aXB9ID0gaW50ZXJhY3Rpb25Db25maWc7XG4gIGlmICh0b29sdGlwKSB7XG4gICAgY29uc3Qge2NvbmZpZ30gPSB0b29sdGlwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCB7W2RhdGFJZF06IGZpZWxkcywgLi4uZmllbGRzVG9TaG93fSA9IGNvbmZpZy5maWVsZHNUb1Nob3c7XG4gICAgaW50ZXJhY3Rpb25Db25maWcgPSB7XG4gICAgICAuLi5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgIHRvb2x0aXA6IHsuLi50b29sdGlwLCBjb25maWc6IHsuLi5jb25maWcsIGZpZWxkc1RvU2hvd319XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7Li4uc3RhdGUsIGludGVyYWN0aW9uQ29uZmlnfTtcbn1cbi8qKlxuICogdXBkYXRlIGxheWVyIGJsZW5kaW5nIG1vZGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVMYXllckJsZW5kaW5nVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVMYXllckJsZW5kaW5nVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGxheWVyQmxlbmRpbmc6IGFjdGlvbi5tb2RlXG59KTtcblxuLyoqXG4gKiB1cGRhdGUgb3ZlcmxheSBibGVuZGluZyBtb2RlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlT3ZlcmxheUJsZW5kaW5nVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVPdmVybGF5QmxlbmRpbmdVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgb3ZlcmxheUJsZW5kaW5nOiBhY3Rpb24ubW9kZVxufSk7XG5cbi8qKlxuICogRGlzcGxheSBkYXRhc2V0IHRhYmxlIGluIGEgbW9kYWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93RGF0YXNldFRhYmxlVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TaG93RGF0YXNldFRhYmxlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRpbmdEYXRhc2V0OiBhY3Rpb24uZGF0YUlkXG4gIH07XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gY29sb3IgZm9yIGRhdGFzZXRzIGFuZCBsYXllcnNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVUYWJsZUNvbG9yVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5VcGRhdGVEYXRhc2V0Q29sb3JVcGRhdGVyXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIHJldHVybiB1cGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyKHN0YXRlLCB7ZGF0YUlkOiBhY3Rpb24uZGF0YUlkLCBwcm9wczoge2NvbG9yOiBhY3Rpb24ubmV3Q29sb3J9fSk7XG59O1xuXG4vKipcbiAqIHJlc2V0IHZpc1N0YXRlIHRvIGluaXRpYWwgU3RhdGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZXNldE1hcENvbmZpZ1VwZGF0ZXIgPSAoc3RhdGU6IFZpc1N0YXRlKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uSU5JVElBTF9WSVNfU1RBVEUsXG4gIC4uLnN0YXRlLmluaXRpYWxTdGF0ZSxcbiAgaW5pdGlhbFN0YXRlOiBzdGF0ZS5pbml0aWFsU3RhdGVcbn0pO1xuXG4vKipcbiAqIFByb3BhZ2F0ZSBgdmlzU3RhdGVgIHJlZHVjZXIgd2l0aCBhIG5ldyBjb25maWd1cmF0aW9uLiBDdXJyZW50IGNvbmZpZyB3aWxsIGJlIG92ZXJyaWRlLlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlY2VpdmVNYXBDb25maWdVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtcbiAgICBwYXlsb2FkOiB7Y29uZmlnID0ge30sIG9wdGlvbnMgPSB7fX1cbiAgfToge1xuICAgIHR5cGU/OiB0eXBlb2YgQWN0aW9uVHlwZXMuUkVDRUlWRV9NQVBfQ09ORklHO1xuICAgIHBheWxvYWQ6IFJlY2VpdmVNYXBDb25maWdQYXlsb2FkO1xuICB9XG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGlmICghY29uZmlnLnZpc1N0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge2tlZXBFeGlzdGluZ0NvbmZpZ30gPSBvcHRpb25zO1xuXG4gIC8vIHJlc2V0IGNvbmZpZyBpZiBrZWVwRXhpc3RpbmdDb25maWcgaXMgZmFsc3lcbiAgbGV0IG1lcmdlZFN0YXRlID0gIWtlZXBFeGlzdGluZ0NvbmZpZyA/IHJlc2V0TWFwQ29uZmlnVXBkYXRlcihzdGF0ZSkgOiBzdGF0ZTtcbiAgZm9yIChjb25zdCBtZXJnZXIgb2Ygc3RhdGUubWVyZ2Vycykge1xuICAgIGlmIChpc1ZhbGlkTWVyZ2VyKG1lcmdlcikgJiYgaGFzUHJvcHNUb01lcmdlKGNvbmZpZy52aXNTdGF0ZSwgbWVyZ2VyLnByb3ApKSB7XG4gICAgICBtZXJnZWRTdGF0ZSA9IG1lcmdlci5tZXJnZShcbiAgICAgICAgbWVyZ2VkU3RhdGUsXG4gICAgICAgIGdldFByb3BWYWx1ZVRvTWVyZ2VyKGNvbmZpZy52aXNTdGF0ZSwgbWVyZ2VyLnByb3AsIG1lcmdlci50b01lcmdlUHJvcCksXG4gICAgICAgIC8vIGZyb21Db25maWdcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkU3RhdGU7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbGF5ZXIgaG92ZXIgZXZlbnQgd2l0aCBob3ZlcmVkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxheWVySG92ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLk9uTGF5ZXJIb3ZlclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+ICh7XG4gIC4uLnN0YXRlLFxuICBob3ZlckluZm86IHtcbiAgICAvLyBkZWNrLmdsIGluZm8gaXMgbXV0YWJsZVxuICAgIC4uLmFjdGlvbi5pbmZvLFxuICAgIC4uLihOdW1iZXIuaXNGaW5pdGUoYWN0aW9uLm1hcEluZGV4KSA/IHttYXBJbmRleDogYWN0aW9uLm1hcEluZGV4fSA6IHt9KVxuICB9XG59KTtcblxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFVwZGF0ZSBgaW50ZXJhY3Rpb25Db25maWdgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkludGVyYWN0aW9uQ29uZmlnQ2hhbmdlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCB7Y29uZmlnfSA9IGFjdGlvbjtcblxuICBjb25zdCBpbnRlcmFjdGlvbkNvbmZpZyA9IHtcbiAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAuLi57W2NvbmZpZy5pZF06IGNvbmZpZ31cbiAgfTtcblxuICAvLyBEb24ndCBlbmFibGUgdG9vbHRpcCBhbmQgYnJ1c2ggYXQgdGhlIHNhbWUgdGltZVxuICAvLyBidXQgY29vcmRpbmF0ZXMgY2FuIGJlIHNob3duIGF0IGFsbCB0aW1lXG4gIGNvbnN0IGNvbnRyYWRpY3QgPSBbJ2JydXNoJywgJ3Rvb2x0aXAnXTtcblxuICBpZiAoXG4gICAgY29udHJhZGljdC5pbmNsdWRlcyhjb25maWcuaWQpICYmXG4gICAgY29uZmlnLmVuYWJsZWQgJiZcbiAgICAhc3RhdGUuaW50ZXJhY3Rpb25Db25maWdbY29uZmlnLmlkXS5lbmFibGVkXG4gICkge1xuICAgIC8vIG9ubHkgZW5hYmxlIG9uZSBpbnRlcmFjdGlvbiBhdCBhIHRpbWVcbiAgICBjb250cmFkaWN0LmZvckVhY2goayA9PiB7XG4gICAgICBpZiAoayAhPT0gY29uZmlnLmlkKSB7XG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnW2tdID0gey4uLmludGVyYWN0aW9uQ29uZmlnW2tdLCBlbmFibGVkOiBmYWxzZX07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZ1xuICB9O1xuXG4gIGlmIChjb25maWcuaWQgPT09ICdnZW9jb2RlcicgJiYgIWNvbmZpZy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHJlbW92ZURhdGFzZXRVcGRhdGVyKG5ld1N0YXRlLCB7ZGF0YUlkOiAnZ2VvY29kZXJfZGF0YXNldCd9KTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGxheWVyIGNsaWNrIGV2ZW50IHdpdGggY2xpY2tlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllckNsaWNrVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5PbkxheWVyQ2xpY2tVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbW91c2VQb3M6IHN0YXRlLmludGVyYWN0aW9uQ29uZmlnLmNvb3JkaW5hdGUuZW5hYmxlZFxuICAgID8ge1xuICAgICAgICAuLi5zdGF0ZS5tb3VzZVBvcyxcbiAgICAgICAgcGlubmVkOiBzdGF0ZS5tb3VzZVBvcy5waW5uZWQgPyBudWxsIDogY2xvbmVEZWVwKHN0YXRlLm1vdXNlUG9zKVxuICAgICAgfVxuICAgIDogc3RhdGUubW91c2VQb3MsXG4gIGNsaWNrZWQ6IGFjdGlvbi5pbmZvICYmIGFjdGlvbi5pbmZvLnBpY2tlZCA/IGFjdGlvbi5pbmZvIDogbnVsbFxufSk7XG5cbi8qKlxuICogVHJpZ2dlciBtYXAgY2xpY2sgZXZlbnQsIHVuc2VsZWN0IGNsaWNrZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbWFwQ2xpY2tVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuT25NYXBDbGlja1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBudWxsXG4gIH07XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIG1vdmUgZXZlbnRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZU1vdmVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtldnR9OiBWaXNTdGF0ZUFjdGlvbnMuT25Nb3VzZU1vdmVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGlmIChPYmplY3QudmFsdWVzKHN0YXRlLmludGVyYWN0aW9uQ29uZmlnKS5zb21lKGNvbmZpZyA9PiBjb25maWcuZW5hYmxlZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBtb3VzZVBvczoge1xuICAgICAgICAuLi5zdGF0ZS5tb3VzZVBvcyxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZXZ0LnBvaW50KSA/IHttb3VzZVBvc2l0aW9uOiBbLi4uZXZ0LnBvaW50XX0gOiB7fSksXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KGV2dC5sbmdMYXQpID8ge2Nvb3JkaW5hdGU6IFsuLi5ldnQubG5nTGF0XX0gOiB7fSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgYSBsYXllciBmb3IgYSBzcGxpdCBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVTcGxpdE1hcFVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PlxuICBzdGF0ZS5zcGxpdE1hcHMgJiYgc3RhdGUuc3BsaXRNYXBzLmxlbmd0aCA9PT0gMFxuICAgID8ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIHVzZSBhbiBhcnJheSB0byBzdG9yZSBzdGF0ZSBmb3IgYSBzaW5nbGUgbWFwIGFzIHdlbGxcbiAgICAgICAgLy8gaWYgY3VycmVudCBtYXBzIGxlbmd0aCBpcyBlcXVhbCB0byAwIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGFib3V0IHRvIHNwbGl0IHRoZSB2aWV3XG4gICAgICAgIHNwbGl0TWFwczogY29tcHV0ZVNwbGl0TWFwTGF5ZXJzKHN0YXRlLmxheWVycywge2R1cGxpY2F0ZTogZmFsc2V9KVxuICAgICAgfVxuICAgIDogY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgoc3RhdGUsIGFjdGlvbik7XG5cbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgYSBsYXllciBpbiBhIHNwbGl0IG1hcFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7bWFwSW5kZXgsIGxheWVySWR9OiBWaXNTdGF0ZUFjdGlvbnMuVG9nZ2xlTGF5ZXJGb3JNYXBVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIGNvbnN0IHtzcGxpdE1hcHN9ID0gc3RhdGU7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzcGxpdE1hcHM6IHNwbGl0TWFwcy5tYXAoKHNtLCBpKSA9PlxuICAgICAgaSA9PT0gbWFwSW5kZXhcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5zcGxpdE1hcHNbaV0sXG4gICAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgICAgLi4uc3BsaXRNYXBzW2ldLmxheWVycyxcbiAgICAgICAgICAgICAgLy8gaWYgbGF5ZXJJZCBub3QgaW4gbGF5ZXJzLCBzZXQgaXQgdG8gdmlzaWJsZVxuICAgICAgICAgICAgICBbbGF5ZXJJZF06ICFzcGxpdE1hcHNbaV0ubGF5ZXJzW2xheWVySWRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICA6IHNtXG4gICAgKVxuICB9O1xufTtcblxuLyoqXG4gKiBBZGQgbmV3IGRhdGFzZXQgdG8gYHZpc1N0YXRlYCwgd2l0aCBvcHRpb24gdG8gbG9hZCBhIG1hcCBjb25maWcgYWxvbmcgd2l0aCB0aGUgZGF0YXNldHNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgY29uc3QgdXBkYXRlVmlzRGF0YVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuVXBkYXRlVmlzRGF0YVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgLy8gZGF0YXNldHMgY2FuIGJlIGEgc2luZ2xlIGRhdGEgZW50cmllcyBvciBhbiBhcnJheSBvZiBtdWx0aXBsZSBkYXRhIGVudHJpZXNcbiAgY29uc3Qge2NvbmZpZywgb3B0aW9uc30gPSBhY3Rpb247XG5cbiAgLy8gYXBwbHkgY29uZmlnIGlmIHBhc3NlZCBmcm9tIGFjdGlvblxuICAvLyBUT0RPOiB3ZSBkb24ndCBoYW5kbGUgYXN5bmMgbWVyZ2VycyBoZXJlIHlldFxuICBjb25zdCBwcmV2aW91c1N0YXRlID0gY29uZmlnXG4gICAgPyByZWNlaXZlTWFwQ29uZmlnVXBkYXRlcihzdGF0ZSwge1xuICAgICAgICBwYXlsb2FkOiB7Y29uZmlnLCBvcHRpb25zfVxuICAgICAgfSlcbiAgICA6IHN0YXRlO1xuXG4gIC8vIGluZGljYXRlIHRoYXQgc29tZXRoaW5nIGlzIGluIHByb2dyZXNzXG4gIGNvbnN0IHNldElzTG9hZGluZ1Rhc2sgPSBBQ1RJT05fVEFTSygpLm1hcCgoKSA9PiB7XG4gICAgcmV0dXJuIHNldExvYWRpbmdJbmRpY2F0b3Ioe2NoYW5nZTogMX0pO1xuICB9KTtcbiAgY29uc3QgdXBkYXRlZFN0YXRlID0gd2l0aFRhc2socHJldmlvdXNTdGF0ZSwgc2V0SXNMb2FkaW5nVGFzayk7XG5cbiAgY29uc3QgZGF0YXNldHMgPSB0b0FycmF5KGFjdGlvbi5kYXRhc2V0cyk7XG5cbiAgY29uc3QgY3JlYXRlRGF0YXNldFRhc2tzOiBUYXNrW10gPSBbXTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uVGFza3M6IFRhc2tbXSA9IFtdO1xuXG4gIGRhdGFzZXRzLmZvckVhY2goKHtpbmZvID0ge30sIC4uLnJlc3R9LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICBjb25zdCB0YXNrID0gY3JlYXRlTmV3RGF0YUVudHJ5KHtpbmZvLCAuLi5yZXN0fSwgc3RhdGUuZGF0YXNldHMpO1xuICAgIGlmICh0YXNrKSB7XG4gICAgICBjcmVhdGVEYXRhc2V0VGFza3MucHVzaCh0YXNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm90aWZpY2F0aW9uVGFza3MucHVzaChcbiAgICAgICAgQUNUSU9OX1RBU0soKS5tYXAoKCkgPT5cbiAgICAgICAgICBhZGROb3RpZmljYXRpb24oXG4gICAgICAgICAgICBlcnJvck5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IGRhdGFzZXQgZHVlIHRvIGRhdGEgdmVyaWZpY2F0aW9uIGVycm9yc2AsXG4gICAgICAgICAgICAgIGlkOiBgZGF0YXNldC1mYWlsZWQtJHtkYXRhc2V0SW5kZXh9YFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBkYXRhc2V0c0FsbFNldHRsZWRUYXNrID0gY3JlYXRlRGF0YXNldFRhc2tzLmxlbmd0aFxuICAgID8gVGFzay5hbGxTZXR0bGVkKGNyZWF0ZURhdGFzZXRUYXNrcykubWFwKHJlc3VsdHMgPT5cbiAgICAgICAgY3JlYXRlTmV3RGF0YXNldFN1Y2Nlc3Moe3Jlc3VsdHMsIGFkZFRvTWFwT3B0aW9uczogb3B0aW9uc30pXG4gICAgICApXG4gICAgOiBudWxsO1xuXG4gIHJldHVybiB3aXRoVGFzayh1cGRhdGVkU3RhdGUsIFtcbiAgICAuLi4oZGF0YXNldHNBbGxTZXR0bGVkVGFzayA/IFtkYXRhc2V0c0FsbFNldHRsZWRUYXNrXSA6IFtdKSxcbiAgICAuLi5ub3RpZmljYXRpb25UYXNrc1xuICBdKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVOZXdEYXRhc2V0U3VjY2Vzc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPENyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzUGF5bG9hZD5cbik6IFZpc1N0YXRlID0+IHtcbiAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZU5ld0RhdGFzZXRTdWNjZXNzVXBkYXRlcicsIGFjdGlvbi5wYXlsb2FkKTtcbiAgY29uc3Qge3Jlc3VsdHMsIGFkZFRvTWFwT3B0aW9uc30gPSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgbmV3RGF0YUVudHJpZXMgPSByZXN1bHRzLnJlZHVjZSgoYWNjdSwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHsuLi5hY2N1LCBbZGF0YXNldC5pZF06IGRhdGFzZXR9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgY3JlYXRlIGRhdGFzZXQgZXJyb3JcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdjcmVhdGVOZXdEYXRhc2V0U3VjY2Vzc1VwZGF0ZXI6IGZhaWxlZCcsXG4gICAgICAgIHJlc3VsdC5yZWFzb24gfHwgKHJlc3VsdCBhcyBhbnkpLnZhbHVlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfVxuICB9LCB7fSBhcyBEYXRhc2V0cyk7XG4gIC8vIHNhdmUgbmV3IGRhdGFzZXQgZW50cnkgdG8gc3RhdGVcbiAgY29uc3QgbWVyZ2VkU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgZGF0YXNldHM6IG1lcmdlRGF0YXNldHNCeU9yZGVyKHN0YXRlLCBuZXdEYXRhRW50cmllcylcbiAgfTtcblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIGNvbmZpZyB0byBiZSBtZXJnZWRcbiAgY29uc3QgbGF5ZXJNZXJnZXJzID0gc3RhdGUubWVyZ2Vycy5maWx0ZXIobSA9PiBtLndhaXRGb3JMYXllckRhdGEpO1xuICBjb25zdCBkYXRhc2V0TWVyZ2VycyA9IHN0YXRlLm1lcmdlcnMuZmlsdGVyKG0gPT4gIWxheWVyTWVyZ2Vycy5pbmNsdWRlcyhtKSk7XG5cbiAgY29uc3QgbmV3RGF0YUlkcyA9IE9iamVjdC5rZXlzKG5ld0RhdGFFbnRyaWVzKTtcbiAgY29uc3QgcG9zdE1lcmdlclBheWxvYWQgPSB7XG4gICAgbmV3RGF0YUlkcyxcbiAgICBvcHRpb25zOiBhZGRUb01hcE9wdGlvbnMsXG4gICAgbGF5ZXJNZXJnZXJzXG4gIH07XG5cbiAgY29uc3QgdXBkYXRlZFN0YXRlID0gYXBwbHlNZXJnZXJzVXBkYXRlcihtZXJnZWRTdGF0ZSwge1xuICAgIG1lcmdlcnM6IGRhdGFzZXRNZXJnZXJzLFxuICAgIHBvc3RNZXJnZXJQYXlsb2FkXG4gIH0pO1xuXG4gIC8vIHJlc29sdmUgYWN0aXZlIGxvYWRpbmcgaW5pdGlhdGVkIGJ5IHVwZGF0ZVZpc0RhdGFVcGRhdGVyXG4gIGNvbnN0IHNldElzTG9hZGluZ1Rhc2sgPSBBQ1RJT05fVEFTSygpLm1hcCgoKSA9PiB7XG4gICAgcmV0dXJuIHNldExvYWRpbmdJbmRpY2F0b3Ioe2NoYW5nZTogLTF9KTtcbiAgfSk7XG4gIHJldHVybiB3aXRoVGFzayh1cGRhdGVkU3RhdGUsIHNldElzTG9hZGluZ1Rhc2spO1xufTtcblxuLyoqXG4gKiBBZGQgbmV3IGRhdGFzZXQgdG8gYHZpc1N0YXRlYCwgd2l0aCBvcHRpb24gdG8gbG9hZCBhIG1hcCBjb25maWcgYWxvbmcgd2l0aCB0aGUgZGF0YXNldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWVyZ2Vyc1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiB7XG4gICAgbWVyZ2VyczogTWVyZ2VyPGFueT5bXTtcbiAgICBwb3N0TWVyZ2VyUGF5bG9hZDogUG9zdE1lcmdlclBheWxvYWQ7XG4gIH1cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge21lcmdlcnMsIHBvc3RNZXJnZXJQYXlsb2FkfSA9IGFjdGlvbjtcblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIGNvbmZpZyB0byBiZSBtZXJnZWRcbiAgY29uc3QgbWVyZ2VTdGF0ZVJlc3VsdCA9IG1lcmdlU3RhdGVGcm9tTWVyZ2VycyhcbiAgICBzdGF0ZSxcbiAgICB7XG4gICAgICAuLi5JTklUSUFMX1ZJU19TVEFURSxcbiAgICAgIC4uLnN0YXRlLmluaXRpYWxTdGF0ZVxuICAgIH0sXG4gICAgbWVyZ2VycyxcbiAgICAvLyBuZXdEYXRhSWRzLFxuICAgIHBvc3RNZXJnZXJQYXlsb2FkXG4gICk7XG5cbiAgLy8gaWYgYWxsIG1lcmdlZCwga2lja3VwIHBvc3QgbWVyZ2UgcHJvY2Vzc1xuICAvLyBpZiBub3Qgd2FpdFxuICByZXR1cm4gbWVyZ2VTdGF0ZVJlc3VsdC5hbGxNZXJnZWRcbiAgICA/IHBvc3RNZXJnZVVwZGF0ZXIobWVyZ2VTdGF0ZVJlc3VsdC5tZXJnZWRTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQpXG4gICAgOiBtZXJnZVN0YXRlUmVzdWx0Lm1lcmdlZFN0YXRlO1xufVxuXG4vKipcbiAqIEFkZCBuZXcgZGF0YXNldCB0byBgdmlzU3RhdGVgLCB3aXRoIG9wdGlvbiB0byBsb2FkIGEgbWFwIGNvbmZpZyBhbG9uZyB3aXRoIHRoZSBkYXRhc2V0c1xuICovXG5mdW5jdGlvbiBwb3N0TWVyZ2VVcGRhdGVyKG1lcmdlZFN0YXRlOiBWaXNTdGF0ZSwgcG9zdE1lcmdlclBheWxvYWQ6IFBvc3RNZXJnZXJQYXlsb2FkKTogVmlzU3RhdGUge1xuICBjb25zdCB7bmV3RGF0YUlkcywgb3B0aW9ucywgbGF5ZXJNZXJnZXJzfSA9IHBvc3RNZXJnZXJQYXlsb2FkO1xuICBjb25zdCBuZXdGaWx0ZXJzID0gbWVyZ2VkU3RhdGUuZmlsdGVycy5maWx0ZXIoZiA9PlxuICAgIGYuZGF0YUlkLmZpbmQoZkRhdGFJZCA9PiBuZXdEYXRhSWRzLmluY2x1ZGVzKGZEYXRhSWQpKVxuICApO1xuICBjb25zdCBkYXRhc2V0RmlsdGVyZWQ6IHN0cmluZ1tdID0gdW5pcShcbiAgICBuZXdGaWx0ZXJzLnJlZHVjZSgoYWNjdSwgZikgPT4gWy4uLmFjY3UsIC4uLmYuZGF0YUlkXSwgW10gYXMgc3RyaW5nW10pXG4gICk7XG4gIGNvbnN0IGRhdGFFbXB0eSA9IG5ld0RhdGFJZHMubGVuZ3RoIDwgMTtcblxuICBsZXQgbmV3TGF5ZXJzID0gIWRhdGFFbXB0eVxuICAgID8gbWVyZ2VkU3RhdGUubGF5ZXJzLmZpbHRlcihsID0+IGwuY29uZmlnLmRhdGFJZCAmJiBuZXdEYXRhSWRzLmluY2x1ZGVzKGwuY29uZmlnLmRhdGFJZCkpXG4gICAgOiBbXTtcblxuICBjb25zdCBuZXdEYXRhRW50cmllcyA9IG5ld0RhdGFJZHMucmVkdWNlKFxuICAgIChhY2N1LCBpZCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbaWRdOiBtZXJnZWRTdGF0ZS5kYXRhc2V0c1tpZF1cbiAgICB9KSxcbiAgICB7fVxuICApO1xuXG4gIGlmICghbmV3TGF5ZXJzLmxlbmd0aCAmJiAob3B0aW9ucyB8fCB7fSkuYXV0b0NyZWF0ZUxheWVycyAhPT0gZmFsc2UpIHtcbiAgICAvLyBubyBsYXllciBtZXJnZWQsIGZpbmQgZGVmYXVsdHNcbiAgICBjb25zdCByZXN1bHQgPSBhZGREZWZhdWx0TGF5ZXJzKG1lcmdlZFN0YXRlLCBuZXdEYXRhRW50cmllcyk7XG4gICAgbWVyZ2VkU3RhdGUgPSByZXN1bHQuc3RhdGU7XG4gICAgbmV3TGF5ZXJzID0gcmVzdWx0Lm5ld0xheWVycztcbiAgfVxuXG4gIGlmIChtZXJnZWRTdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgbWFwIGlzIHNwbGl0LCBhZGQgbmV3IGxheWVycyB0byBzcGxpdE1hcHNcbiAgICBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgJiYgbmV3RGF0YUlkcy5pbmNsdWRlcyhsLmNvbmZpZy5kYXRhSWQpXG4gICAgKTtcbiAgICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAgIC4uLm1lcmdlZFN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBhZGROZXdMYXllcnNUb1NwbGl0TWFwKG1lcmdlZFN0YXRlLnNwbGl0TWFwcywgbmV3TGF5ZXJzKVxuICAgIH07XG4gIH1cblxuICAvLyBpZiBubyB0b29sdGlwcyBtZXJnZWQgYWRkIGRlZmF1bHQgdG9vbHRpcHNcbiAgbmV3RGF0YUlkcy5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IG1lcmdlZFN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdO1xuICAgIC8vIGxvYWRpbmcgZGF0YXNldDogYXV0b0NyZWF0ZVRvb2x0aXBzIGlzIGZhbHNlIGFuZCB3ZSBkb24ndCB3YW50IHRvIHJ1biBhZGREZWZhdWx0VG9vbHRpcHMgd2hlbiB0b29sdGlwRmllbGRzIGlzIGVtcHR5XG4gICAgaWYgKFxuICAgICAgb3B0aW9ucz8uYXV0b0NyZWF0ZVRvb2x0aXBzICE9PSBmYWxzZSAmJlxuICAgICAgKCFBcnJheS5pc0FycmF5KHRvb2x0aXBGaWVsZHMpIHx8ICF0b29sdGlwRmllbGRzLmxlbmd0aClcbiAgICApIHtcbiAgICAgIC8vIGFkZGluZyBkYXRhc2V0OiBhdXRvQ3JlYXRlVG9vbHRpcHMgaXMgdHJ1ZVxuICAgICAgbWVyZ2VkU3RhdGUgPSBhZGREZWZhdWx0VG9vbHRpcHMobWVyZ2VkU3RhdGUsIG5ld0RhdGFFbnRyaWVzW2RhdGFJZF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdXBkYXRlZERhdGFzZXRzID0gZGF0YUVtcHR5XG4gICAgPyBPYmplY3Qua2V5cyhtZXJnZWRTdGF0ZS5kYXRhc2V0cylcbiAgICA6IHVuaXEoT2JqZWN0LmtleXMobmV3RGF0YUVudHJpZXMpLmNvbmNhdChkYXRhc2V0RmlsdGVyZWQpKTtcblxuICBsZXQgdXBkYXRlZFN0YXRlID0gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKG1lcmdlZFN0YXRlLCB1cGRhdGVkRGF0YXNldHMsIHVuZGVmaW5lZCk7XG5cbiAgLy8gcmVnaXN0ZXIgbGF5ZXIgYW5pbWF0aW9uIGRvbWFpbixcbiAgLy8gbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgbGF5ZXIgZGF0YSBpcyBjYWxjdWxhdGVkXG4gIHVwZGF0ZWRTdGF0ZSA9IHVwZGF0ZUFuaW1hdGlvbkRvbWFpbih1cGRhdGVkU3RhdGUpO1xuXG4gIC8vIHRyeSB0byBwcm9jZXNzIGxheWVyTWVyZ2VycyBhZnRlciBkYXRhc2V0K2RhdGFzZXRNZXJnZXJzXG4gIHVwZGF0ZWRTdGF0ZSA9XG4gICAgbGF5ZXJNZXJnZXJzICYmIGxheWVyTWVyZ2Vycy5sZW5ndGggPiAwXG4gICAgICA/IGFwcGx5TWVyZ2Vyc1VwZGF0ZXIodXBkYXRlZFN0YXRlLCB7XG4gICAgICAgICAgbWVyZ2VyczogbGF5ZXJNZXJnZXJzLFxuICAgICAgICAgIHBvc3RNZXJnZXJQYXlsb2FkOiB7Li4ucG9zdE1lcmdlclBheWxvYWQsIGxheWVyTWVyZ2VyczogW119XG4gICAgICAgIH0pXG4gICAgICA6IHVwZGF0ZWRTdGF0ZTtcblxuICAvLyBjZW50ZXIgdGhlIG1hcCBvbmNlIHRoZSBkYXRhc2V0IGlzIGNyZWF0ZWRcbiAgaWYgKG5ld0xheWVycy5sZW5ndGggJiYgKG9wdGlvbnMgfHwge30pLmNlbnRlck1hcCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbmRNYXBCb3VuZHMobmV3TGF5ZXJzKTtcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICBjb25zdCBmaXRCb3VuZHNUYXNrID0gQUNUSU9OX1RBU0soKS5tYXAoKCkgPT4ge1xuICAgICAgICByZXR1cm4gZml0TWFwQm91bmRzKGJvdW5kcyk7XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZWRTdGF0ZSA9IHdpdGhUYXNrKHVwZGF0ZWRTdGF0ZSwgZml0Qm91bmRzVGFzayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWRTdGF0ZTtcbn1cblxuLyoqXG4gKiBSZW5hbWUgYW4gZXhpc3RpbmcgZGF0YXNldCBpbiBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lRGF0YXNldFVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuUmVuYW1lRGF0YXNldFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgcmV0dXJuIHVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXIoc3RhdGUsIHtkYXRhSWQ6IGFjdGlvbi5kYXRhSWQsIHByb3BzOiB7bGFiZWw6IGFjdGlvbi5sYWJlbH19KTtcbn1cblxuY29uc3QgQUxMT1dFRF9VUERBVEVfREFUQVNFVF9QUk9QUyA9IFsnbGFiZWwnLCAnY29sb3InLCAnbWV0YWRhdGEnXTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgcHJvcGVydGllcyBiZWZvcmUgdXBkYXRpbmcgdGhlIGRhdGFzZXQuXG4gKiBNYWtlcyBzdXJlIGVhY2ggcHJvcGVydHkgaXMgaW4gdGhlIGFsbG93ZWQgbGlzdFxuICogTWFrZXMgc3VyZSBjb2xvciB2YWx1ZSBpcyBSR0JcbiAqIFBlcmZvcm1zIGRlZXAgbWVyZ2Ugd2hlbiB1cGRhdGluZyBtZXRhZGF0YVxuICovXG5jb25zdCB2YWxpZGF0ZURhdGFzZXRVcGRhdGVQcm9wcyA9IChwcm9wcywgZGF0YXNldCkgPT4ge1xuICBjb25zdCB2YWxpZGF0ZWRQcm9wcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICAvLyBpcyBpdCBhbGxvd2VkID9cbiAgICBpZiAoIUFMTE9XRURfVVBEQVRFX0RBVEFTRVRfUFJPUFMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBhcmUgYWRkaW5nIGEgY29sb3IgYnV0IGl0IGlzIG5vdCBSR0Igd2UgZG9uJ3QgYWNjZXB0IHRoZSB2YWx1ZVxuICAgIC8vIGluIHRoZSBmdXR1cmUgYXMgd2UgYWRkIG1vcmUgcHJvcHMgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzIGlmIGludG8gYSBzd2l0Y2hcbiAgICBpZiAoa2V5ID09PSAnY29sb3InICYmICFpc1JnYkNvbG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICAvLyBkbyB3ZSBuZWVkIGRlZXAgbWVyZ2UgP1xuICAgIHJldHVybiB7Li4uYWNjLCBba2V5XTogaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBkZWVwbWVyZ2UoZGF0YXNldFtrZXldIHx8IHt9LCB2YWx1ZSkgOiB2YWx1ZX07XG4gIH0sIHt9KTtcblxuICByZXR1cm4gdmFsaWRhdGVkUHJvcHM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBEYXRhc2V0IHByb3BzIChsYWJlbCwgY29sb3IsIG1ldGEpLiBEbyBub3QgdXNlIHRvIHVwZGF0ZSBkYXRhIG9yIGFueSByZWxhdGVkIHByb3BlcnRpZXNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEYXRhc2V0UHJvcHNVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLlVwZGF0ZURhdGFzZXRQcm9wc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qge2RhdGFJZCwgcHJvcHN9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG4gIGNvbnN0IGV4aXN0aW5nID0gZGF0YXNldHNbZGF0YUlkXTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRQcm9wcyA9IHZhbGlkYXRlRGF0YXNldFVwZGF0ZVByb3BzKHByb3BzLCBleGlzdGluZyk7XG4gICAgLy8gIHZhbGlkYXRlIHByb3BzOiBqdXN0IGNvbG9yIGZvciBub3dcbiAgICAvLyAgd2Ugb25seSBhbGxvdyBsYWJlbCwgY29sb3IgYW5kIG1ldGEgdG8gYmUgdXBkYXRlZFxuICAgIC8vIGNvbnN0IG5ld1RhYmxlID0gY29weVRhYmxlQW5kVXBkYXRlKGV4aXN0aW5nLCB2YWxpZGF0ZWRQcm9wcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZGF0YXNldHM6IHtcbiAgICAgICAgLi4uZGF0YXNldHMsXG4gICAgICAgIFtkYXRhSWRdOiBjb3B5VGFibGVBbmRVcGRhdGUoZXhpc3RpbmcsIHZhbGlkYXRlZFByb3BzKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogV2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBzcGVjaWZpYyBtYXAgY2xvc2luZyBpY29uXG4gKiB0aGUgYXBwbGljYXRpb24gd2lsbCBjbG9zZSB0aGUgc2VsZWN0ZWQgbWFwXG4gKiBhbmQgd2lsbCBtZXJnZSB0aGUgcmVtYWluaW5nIG9uZSB3aXRoIHRoZSBnbG9iYWwgc3RhdGVcbiAqIFRPRE86IGkgdGhpbmsgaW4gdGhlIGZ1dHVyZSB0aGlzIGFjdGlvbiBzaG91bGQgYmUgY2FsbGVkIG1lcmdlIG1hcCBsYXllcnMgd2l0aCBnbG9iYWwgc2V0dGluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVNwZWNpZmljTWFwQXRJbmRleDxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuVG9nZ2xlU3BsaXRNYXBVcGRhdGVyQWN0aW9uXG4pOiBTIHtcbiAgLy8gcmV0cmlldmUgbGF5ZXJzIG1ldGEgZGF0YSBmcm9tIHRoZSByZW1haW5pbmcgbWFwIHRoYXQgd2UgbmVlZCB0byBrZWVwXG4gIGNvbnN0IGluZGV4VG9SZXRyaWV2ZSA9IDEgLSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgbWFwTGF5ZXJzID0gc3RhdGUuc3BsaXRNYXBzW2luZGV4VG9SZXRyaWV2ZV0/LmxheWVycztcbiAgY29uc3Qge2xheWVyc30gPSBzdGF0ZTtcblxuICAvLyB1cGRhdGUgbGF5ZXIgdmlzaWJpbGl0eVxuICBjb25zdCBuZXdMYXllcnMgPSBsYXllcnMubWFwKGxheWVyID0+XG4gICAgbWFwTGF5ZXJzICYmICFtYXBMYXllcnNbbGF5ZXIuaWRdICYmIGxheWVyLmNvbmZpZy5pc1Zpc2libGVcbiAgICAgID8gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAgIC8vIGlmIGxheWVyLmlkIGlzIG5vdCBpbiBtYXBMYXllcnMsIGl0IHNob3VsZCBiZSBpblZpc2libGVcbiAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICA6IGxheWVyXG4gICk7XG5cbiAgLy8gZGVsZXRlIG1hcFxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIHNwbGl0TWFwczogW11cbiAgfTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGZpbGUgbG9hZGluZyBkaXNwYXRjaCBgYWRkRGF0YVRvTWFwYCBpZiBzdWNjZWVkLCBvciBgbG9hZEZpbGVzRXJyYCBpZiBmYWlsZWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZXNVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlc1VwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgY29uc3Qge2ZpbGVzLCBvbkZpbmlzaCA9IGxvYWRGaWxlc1N1Y2Nlc3N9ID0gYWN0aW9uO1xuICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGZpbGVMb2FkaW5nUHJvZ3Jlc3MgPSBBcnJheS5mcm9tKGZpbGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGYsIGkpID0+IG1lcmdlXyhpbml0aWFsRmlsZUxvYWRpbmdQcm9ncmVzcyhmLCBpKSkoYWNjdSksXG4gICAge31cbiAgKTtcblxuICBjb25zdCBmaWxlTG9hZGluZyA9IHtcbiAgICBmaWxlQ2FjaGU6IFtdLFxuICAgIGZpbGVzVG9Mb2FkOiBmaWxlcyxcbiAgICBvbkZpbmlzaFxuICB9O1xuXG4gIGNvbnN0IG5leHRTdGF0ZSA9IG1lcmdlXyh7ZmlsZUxvYWRpbmdQcm9ncmVzcywgZmlsZUxvYWRpbmd9KShzdGF0ZSk7XG5cbiAgcmV0dXJuIGxvYWROZXh0RmlsZVVwZGF0ZXIobmV4dFN0YXRlKTtcbn07XG5cbi8qKlxuICogU3VjZXNzZnVsbHkgbG9hZGVkIG9uZSBmaWxlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IG9uZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGaWxlU3RlcFN1Y2Nlc3NVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlU3RlcFN1Y2Nlc3NBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgaWYgKCFzdGF0ZS5maWxlTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmlsZU5hbWUsIGZpbGVDYWNoZX0gPSBhY3Rpb247XG4gIGNvbnN0IHtmaWxlc1RvTG9hZCwgb25GaW5pc2h9ID0gc3RhdGUuZmlsZUxvYWRpbmc7XG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIoc3RhdGUsIHtcbiAgICBmaWxlTmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDEsIG1lc3NhZ2U6ICdEb25lJ31cbiAgfSk7XG5cbiAgLy8gc2F2ZSBwcm9jZXNzZWQgZmlsZSB0byBmaWxlQ2FjaGVcbiAgY29uc3Qgc3RhdGVXaXRoQ2FjaGUgPSBwaWNrXygnZmlsZUxvYWRpbmcnKShtZXJnZV8oe2ZpbGVDYWNoZX0pKShzdGF0ZVdpdGhQcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIHN0YXRlV2l0aENhY2hlLFxuICAgIERFTEFZX1RBU0soMjAwKS5tYXAoZmlsZXNUb0xvYWQubGVuZ3RoID8gbG9hZE5leHRGaWxlIDogKCkgPT4gb25GaW5pc2goZmlsZUNhY2hlKSlcbiAgKTtcbn1cblxuLy8gd2l0aFRhc2s8VD4oc3RhdGU6IFQsIHRhc2s6IGFueSk6IFRcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWROZXh0RmlsZVVwZGF0ZXIoc3RhdGU6IFZpc1N0YXRlKTogVmlzU3RhdGUge1xuICBpZiAoIXN0YXRlLmZpbGVMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHtmaWxlc1RvTG9hZH0gPSBzdGF0ZS5maWxlTG9hZGluZztcbiAgY29uc3QgW2ZpbGUsIC4uLnJlbWFpbmluZ0ZpbGVzVG9Mb2FkXSA9IGZpbGVzVG9Mb2FkO1xuXG4gIC8vIHNhdmUgZmlsZXNUb0xvYWQgdG8gc3RhdGVcbiAgY29uc3QgbmV4dFN0YXRlID0gcGlja18oJ2ZpbGVMb2FkaW5nJykobWVyZ2VfKHtmaWxlc1RvTG9hZDogcmVtYWluaW5nRmlsZXNUb0xvYWR9KSkoc3RhdGUpO1xuXG4gIGNvbnN0IHN0YXRlV2l0aFByb2dyZXNzID0gdXBkYXRlRmlsZUxvYWRpbmdQcm9ncmVzc1VwZGF0ZXIobmV4dFN0YXRlLCB7XG4gICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICBwcm9ncmVzczoge3BlcmNlbnQ6IDAsIG1lc3NhZ2U6ICdsb2FkaW5nLi4uJ31cbiAgfSk7XG5cbiAgY29uc3Qge2xvYWRlcnMsIGxvYWRPcHRpb25zfSA9IHN0YXRlO1xuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgbWFrZUxvYWRGaWxlVGFzayhcbiAgICAgIGZpbGUsXG4gICAgICBuZXh0U3RhdGUuZmlsZUxvYWRpbmcgJiYgbmV4dFN0YXRlLmZpbGVMb2FkaW5nLmZpbGVDYWNoZSxcbiAgICAgIGxvYWRlcnMsXG4gICAgICBsb2FkT3B0aW9uc1xuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMb2FkRmlsZVRhc2soZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzOiBMb2FkZXJbXSA9IFtdLCBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBMT0FEX0ZJTEVfVEFTSyh7ZmlsZSwgZmlsZUNhY2hlLCBsb2FkZXJzLCBsb2FkT3B0aW9uc30pLmJpbWFwKFxuICAgIC8vIHByZXR0aWVyIGlnbm9yZVxuICAgIC8vIHN1Y2Nlc3NcbiAgICBnZW4gPT5cbiAgICAgIG5leHRGaWxlQmF0Y2goe1xuICAgICAgICBnZW4sXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgIG9uRmluaXNoOiByZXN1bHQgPT5cbiAgICAgICAgICBwcm9jZXNzRmlsZUNvbnRlbnQoe1xuICAgICAgICAgICAgY29udGVudDogcmVzdWx0LFxuICAgICAgICAgICAgZmlsZUNhY2hlXG4gICAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgLy8gZXJyb3JcbiAgICBlcnIgPT4gbG9hZEZpbGVzRXJyKGZpbGUubmFtZSwgZXJyKVxuICApO1xufVxuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDb250ZW50VXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Qcm9jZXNzRmlsZUNvbnRlbnRVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtjb250ZW50LCBmaWxlQ2FjaGV9ID0gYWN0aW9uLnBheWxvYWQ7XG5cbiAgY29uc3Qgc3RhdGVXaXRoUHJvZ3Jlc3MgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiB7cGVyY2VudDogMSwgbWVzc2FnZTogJ3Byb2Nlc3NpbmcuLi4nfVxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soXG4gICAgc3RhdGVXaXRoUHJvZ3Jlc3MsXG4gICAgUFJPQ0VTU19GSUxFX0RBVEEoe2NvbnRlbnQsIGZpbGVDYWNoZX0pLmJpbWFwKFxuICAgICAgcmVzdWx0ID0+IGxvYWRGaWxlU3RlcFN1Y2Nlc3Moe2ZpbGVOYW1lOiBjb250ZW50LmZpbGVOYW1lLCBmaWxlQ2FjaGU6IHJlc3VsdH0pLFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0Vycihjb250ZW50LmZpbGVOYW1lLCBlcnIpXG4gICAgKVxuICApO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9ncmVzcyhwcmV2UHJvZ3Jlc3MgPSB7fSwgcHJvZ3Jlc3MpIHtcbiAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gcmVjZWl2aW5nIHF1ZXJ5IG1ldGFkYXRhIG9yIG90aGVyIGNhc2VzIHdlIGRvbid0XG4gIC8vIGhhdmUgYW4gdXBkYXRlIGZvciB0aGUgdXNlci5cbiAgaWYgKCFwcm9ncmVzcyB8fCAhcHJvZ3Jlc3MucGVyY2VudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGVyY2VudDogcHJvZ3Jlc3MucGVyY2VudFxuICB9O1xufVxuXG4vKipcbiAqIGdldHMgY2FsbGVkIHdpdGggcGF5bG9hZCA9IEFzeW5jR2VuZXJhdG9yPD8/Pz5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0RmlsZUJhdGNoVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7XG4gICAgcGF5bG9hZDoge2dlbiwgZmlsZU5hbWUsIHByb2dyZXNzLCBhY2N1bXVsYXRlZCwgb25GaW5pc2h9XG4gIH06IFZpc1N0YXRlQWN0aW9ucy5OZXh0RmlsZUJhdGNoVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICBjb25zdCBzdGF0ZVdpdGhQcm9ncmVzcyA9IHVwZGF0ZUZpbGVMb2FkaW5nUHJvZ3Jlc3NVcGRhdGVyKHN0YXRlLCB7XG4gICAgZmlsZU5hbWUsXG4gICAgcHJvZ3Jlc3M6IHBhcnNlUHJvZ3Jlc3Moc3RhdGUuZmlsZUxvYWRpbmdQcm9ncmVzc1tmaWxlTmFtZV0sIHByb2dyZXNzKVxuICB9KTtcblxuICByZXR1cm4gd2l0aFRhc2soc3RhdGVXaXRoUHJvZ3Jlc3MsIFtcbiAgICAuLi4oZ2V0QXBwbGljYXRpb25Db25maWcoKS51c2VBcnJvd1Byb2dyZXNzaXZlTG9hZGluZyAmJlxuICAgIGZpbGVOYW1lLmVuZHNXaXRoKCdhcnJvdycpICYmXG4gICAgYWNjdW11bGF0ZWQ/LmRhdGE/Lmxlbmd0aCA+IDBcbiAgICAgID8gW1xuICAgICAgICAgIFBST0NFU1NfRklMRV9EQVRBKHtjb250ZW50OiBhY2N1bXVsYXRlZCwgZmlsZUNhY2hlOiBbXX0pLmJpbWFwKFxuICAgICAgICAgICAgcmVzdWx0ID0+IGxvYWRGaWxlc1N1Y2Nlc3MocmVzdWx0KSxcbiAgICAgICAgICAgIGVyciA9PiBsb2FkRmlsZXNFcnIoZmlsZU5hbWUsIGVycilcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIDogW10pLFxuICAgIFVOV1JBUF9UQVNLKGdlbi5uZXh0KCkpLmJpbWFwKFxuICAgICAgKHt2YWx1ZSwgZG9uZX0pID0+IHtcbiAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICA/IG9uRmluaXNoKGFjY3VtdWxhdGVkKVxuICAgICAgICAgIDogbmV4dEZpbGVCYXRjaCh7XG4gICAgICAgICAgICAgIGdlbixcbiAgICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICAgIHByb2dyZXNzOiB2YWx1ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWQ6IHZhbHVlLFxuICAgICAgICAgICAgICBvbkZpbmlzaFxuICAgICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IGxvYWRGaWxlc0VycihmaWxlTmFtZSwgZXJyKVxuICAgIClcbiAgXSk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgbG9hZGluZyBmaWxlIGVycm9yXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGVzRXJyVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZXJyb3IsIGZpbGVOYW1lfTogVmlzU3RhdGVBY3Rpb25zLkxvYWRGaWxlc0VyclVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlID0+IHtcbiAgLy8gdXBkYXRlIHVpIHdpdGggZXJyb3IgbWVzc2FnZVxuICBDb25zb2xlLndhcm4oZXJyb3IpO1xuICBpZiAoIXN0YXRlLmZpbGVMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHtmaWxlc1RvTG9hZCwgb25GaW5pc2gsIGZpbGVDYWNoZX0gPSBzdGF0ZS5maWxlTG9hZGluZztcblxuICBjb25zdCBuZXh0U3RhdGUgPSB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge1xuICAgIGZpbGVOYW1lLFxuICAgIHByb2dyZXNzOiB7ZXJyb3J9XG4gIH0pO1xuXG4gIC8vIGtpY2sgb2ZmIG5leHQgZmlsZSBvciBmaW5pc2hcbiAgcmV0dXJuIHdpdGhUYXNrKFxuICAgIG5leHRTdGF0ZSxcbiAgICBERUxBWV9UQVNLKDIwMCkubWFwKGZpbGVzVG9Mb2FkLmxlbmd0aCA/IGxvYWROZXh0RmlsZSA6ICgpID0+IG9uRmluaXNoKGZpbGVDYWNoZSkpXG4gICk7XG59O1xuXG4vKipcbiAqIFdoZW4gc2VsZWN0IGRhdGFzZXQgZm9yIGV4cG9ydCwgYXBwbHkgY3B1IGZpbHRlciB0byBzZWxlY3RlZCBkYXRhc2V0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYXBwbHlDUFVGaWx0ZXJVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWR9OiBWaXNTdGF0ZUFjdGlvbnMuQXBwbHlDUFVGaWx0ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiB7XG4gIC8vIGFwcGx5IGNwdUZpbHRlclxuICBjb25zdCBkYXRhSWRzID0gdG9BcnJheShkYXRhSWQpO1xuXG4gIHJldHVybiBkYXRhSWRzLnJlZHVjZSgoYWNjdSwgaWQpID0+IGZpbHRlckRhdGFzZXRDUFUoYWNjdSwgaWQpLCBzdGF0ZSk7XG59O1xuXG4vKipcbiAqIFVzZXIgaW5wdXQgdG8gdXBkYXRlIHRoZSBpbmZvIG9mIHRoZSBtYXBcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRNYXBJbmZvVXBkYXRlciA9IChcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5TZXRNYXBJbmZvVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1hcEluZm86IHtcbiAgICAuLi5zdGF0ZS5tYXBJbmZvLFxuICAgIC4uLmFjdGlvbi5pbmZvXG4gIH1cbn0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdXBkYXRlIEFsbCBsYXllciBkb21haW4gYW5kIGxheWVyIGRhdGEgb2Ygc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRMYXllcnMoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgZGF0YXNldHM6IERhdGFzZXRzXG4pOiB7c3RhdGU6IFZpc1N0YXRlOyBuZXdMYXllcnM6IExheWVyW119IHtcbiAgY29uc3QgZW1wdHk6IExheWVyW10gPSBbXTtcbiAgY29uc3QgZGVmYXVsdExheWVycyA9IE9iamVjdC52YWx1ZXMoZGF0YXNldHMpLnJlZHVjZSgoYWNjdTogTGF5ZXJbXSwgZGF0YXNldCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kTGF5ZXJzID0gZmluZERlZmF1bHRMYXllcihkYXRhc2V0LCBzdGF0ZS5sYXllckNsYXNzZXMpO1xuICAgIHJldHVybiBmb3VuZExheWVycyAmJiBmb3VuZExheWVycy5sZW5ndGggPyBhY2N1LmNvbmNhdChmb3VuZExheWVycykgOiBhY2N1O1xuICB9LCBlbXB0eSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBsYXllcnM6IFsuLi5zdGF0ZS5sYXllcnMsIC4uLmRlZmF1bHRMYXllcnNdLFxuICAgICAgbGF5ZXJPcmRlcjogW1xuICAgICAgICAvLyBwdXQgbmV3IGxheWVycyBvbiB0b3Agb2Ygb2xkIG9uZXMgaW4gcmV2ZXJzZVxuICAgICAgICAuLi5nZXRMYXllck9yZGVyRnJvbUxheWVycyhkZWZhdWx0TGF5ZXJzKSxcbiAgICAgICAgLi4uc3RhdGUubGF5ZXJPcmRlclxuICAgICAgXVxuICAgIH0sXG4gICAgbmV3TGF5ZXJzOiBkZWZhdWx0TGF5ZXJzXG4gIH07XG59XG5cbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZGVmYXVsdCB0b29sdGlwc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YXNldFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWZhdWx0VG9vbHRpcHMoc3RhdGUsIGRhdGFzZXQpIHtcbiAgY29uc3QgdG9vbHRpcEZpZWxkcyA9IGZpbmRGaWVsZHNUb1Nob3coe1xuICAgIC4uLmRhdGFzZXQsXG4gICAgbWF4RGVmYXVsdFRvb2x0aXBzOiBzdGF0ZS5tYXhEZWZhdWx0VG9vbHRpcHNcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5maWVsZHNUb1Nob3csXG4gICAgLi4udG9vbHRpcEZpZWxkc1xuICB9O1xuXG4gIHJldHVybiBzZXQoWydpbnRlcmFjdGlvbkNvbmZpZycsICd0b29sdGlwJywgJ2NvbmZpZycsICdmaWVsZHNUb1Nob3cnXSwgbWVyZ2VkLCBzdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsRmlsZUxvYWRpbmdQcm9ncmVzcyhmaWxlLCBpbmRleCkge1xuICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZSB8fCBgVW50aXRsZWQgRmlsZSAke2luZGV4fWA7XG4gIHJldHVybiB7XG4gICAgW2ZpbGVOYW1lXToge1xuICAgICAgLy8gcGVyY2VudCBvZiBjdXJyZW50IGZpbGVcbiAgICAgIHBlcmNlbnQ6IDAsXG4gICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWxlTG9hZGluZ1Byb2dyZXNzVXBkYXRlcihzdGF0ZSwge2ZpbGVOYW1lLCBwcm9ncmVzc30pIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICByZXR1cm4gcGlja18oJ2ZpbGVMb2FkaW5nUHJvZ3Jlc3MnKShwaWNrXyhmaWxlTmFtZSkobWVyZ2VfKHByb2dyZXNzKSkpKHN0YXRlKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBsYXllciBkb21haW5zIGZvciBhbiBhcnJheSBvZiBkYXRhc2V0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBkYXRhSWQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1cGRhdGVkRmlsdGVyPzogRmlsdGVyXG4pOiBTIHtcbiAgY29uc3QgZGF0YUlkcyA9IHR5cGVvZiBkYXRhSWQgPT09ICdzdHJpbmcnID8gW2RhdGFJZF0gOiBkYXRhSWQ7XG4gIGNvbnN0IG5ld0xheWVyczogTGF5ZXJbXSA9IFtdO1xuICBjb25zdCBuZXdMYXllckRhdGE6IGFueVtdID0gW107XG5cbiAgc3RhdGUubGF5ZXJzLmZvckVhY2goKG9sZExheWVyLCBpKSA9PiB7XG4gICAgaWYgKG9sZExheWVyLmNvbmZpZy5kYXRhSWQgJiYgZGF0YUlkcy5pbmNsdWRlcyhvbGRMYXllci5jb25maWcuZGF0YUlkKSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZWNhbGN1bGF0ZSBsYXllciBkb21haW4gaWYgZmlsdGVyIGhhcyBmaXhlZCBkb21haW5cbiAgICAgIGNvbnN0IG5ld0xheWVyID1cbiAgICAgICAgdXBkYXRlZEZpbHRlciAmJiB1cGRhdGVkRmlsdGVyLmZpeGVkRG9tYWluXG4gICAgICAgICAgPyBvbGRMYXllclxuICAgICAgICAgIDogb2xkTGF5ZXIudXBkYXRlTGF5ZXJEb21haW4oc3RhdGUuZGF0YXNldHMsIHVwZGF0ZWRGaWx0ZXIpO1xuXG4gICAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEobmV3TGF5ZXIsIHN0YXRlLCBzdGF0ZS5sYXllckRhdGFbaV0pO1xuXG4gICAgICBuZXdMYXllcnMucHVzaChsYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChsYXllckRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMYXllcnMucHVzaChvbGRMYXllcik7XG4gICAgICBuZXdMYXllckRhdGEucHVzaChzdGF0ZS5sYXllckRhdGFbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBuZXdMYXllcnMsXG4gICAgbGF5ZXJEYXRhOiBuZXdMYXllckRhdGFcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25Eb21haW48UyBleHRlbmRzIFZpc1N0YXRlPihzdGF0ZTogUyk6IFMge1xuICAvLyBtZXJnZSBhbGwgYW5pbWF0YWJsZSBsYXllciBkb21haW4gYW5kIHVwZGF0ZSBnbG9iYWwgY29uZmlnXG4gIGNvbnN0IGFuaW1hdGFibGVMYXllcnMgPSBnZXRBbmltYXRhYmxlVmlzaWJsZUxheWVycyhzdGF0ZS5sYXllcnMpO1xuXG4gIGlmICghYW5pbWF0YWJsZUxheWVycy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIGlzQW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgdGltZVN0ZXBzOiBudWxsLFxuICAgICAgICBkZWZhdWx0VGltZUZvcm1hdDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zdCBsYXllckRvbWFpbnMgPSBhbmltYXRhYmxlTGF5ZXJzLm1hcChsID0+IGwuY29uZmlnLmFuaW1hdGlvbi5kb21haW4gfHwgW10pO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG1lcmdlZERvbWFpbiA9IG1lcmdlVGltZURvbWFpbnMobGF5ZXJEb21haW5zKTtcbiAgY29uc3QgZGVmYXVsdFRpbWVGb3JtYXQgPSBnZXRUaW1lV2lkZ2V0VGl0bGVGb3JtYXR0ZXIobWVyZ2VkRG9tYWluKTtcblxuICAvLyBtZXJnZSB0aW1lU3RlcHNcbiAgbGV0IG1lcmdlZFRpbWVTdGVwczogbnVtYmVyW10gfCBudWxsID0gdW5pcTxudW1iZXI+KFxuICAgIGFuaW1hdGFibGVMYXllcnMucmVkdWNlKChhY2N1LCBsYXllcikgPT4ge1xuICAgICAgYWNjdS5wdXNoKC4uLihsYXllci5jb25maWcuYW5pbWF0aW9uLnRpbWVTdGVwcyB8fCBbXSkpO1xuICAgICAgcmV0dXJuIGFjY3U7XG4gICAgfSwgW10pXG4gICkuc29ydCgpO1xuXG4gIG1lcmdlZFRpbWVTdGVwcyA9IG1lcmdlZFRpbWVTdGVwcy5sZW5ndGggPyBtZXJnZWRUaW1lU3RlcHMgOiBudWxsO1xuXG4gIC8vIFRPRE86IGJldHRlciBoYW5kbGluZyBvZiBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICBjb25zdCBkdXJhdGlvbiA9IG1lcmdlZFRpbWVTdGVwc1xuICAgID8gKEJBU0VfU1BFRUQgKiAoMTAwMCAvIEZQUykpIC8gbWVyZ2VkVGltZVN0ZXBzLmxlbmd0aCAvIChzdGF0ZS5hbmltYXRpb25Db25maWcuc3BlZWQgfHwgMSlcbiAgICA6IG51bGw7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgZG9tYWluOiBtZXJnZWREb21haW4sXG4gICAgICBkZWZhdWx0VGltZUZvcm1hdCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZVN0ZXBzOiBtZXJnZWRUaW1lU3RlcHNcbiAgICB9XG4gIH07XG5cbiAgLy8gcmVzZXQgY3VycmVudFRpbWUgYmFzZWQgb24gbmV3IGRvbWFpblxuICBjb25zdCBzeW5jZWRGaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzPy5maW5kKGYgPT4gKGYgYXMgVGltZVJhbmdlRmlsdGVyKS5zeW5jZWRXaXRoTGF5ZXJUaW1lbGluZSkgYXNcbiAgICB8IFRpbWVSYW5nZUZpbHRlclxuICAgIHwgdW5kZWZpbmVkO1xuXG4gIC8vIGlmIHN5bmNlZCBmaWx0ZXIgZXhpc3Qgd2VlIG5lZWQgdG8gbWVyZ2UgYW5pbWF0aW9uQ29uZmlnIGFuZCBmaWx0ZXIgZG9tYWluc1xuICAvLyBhbmQgdmFsaWRhdGUgdGhlIGN1cnJlbnQgdGltZSBhZ2FpbnN0IHRoZSBuZXcgbWVyZ2VkIGRvbWFpblxuICBjb25zdCBuZXdBbmltYXRpb25Eb21haW4gPSBzeW5jZWRGaWx0ZXJcbiAgICA/IG1lcmdlVGltZURvbWFpbnMoW21lcmdlZERvbWFpbiwgc3luY2VkRmlsdGVyLmRvbWFpbl0pXG4gICAgOiBtZXJnZWREb21haW47XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gaXNJblJhbmdlKHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZSwgbmV3QW5pbWF0aW9uRG9tYWluKVxuICAgID8gc3RhdGUuYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lXG4gICAgOiBuZXdBbmltYXRpb25Eb21haW5bMF07XG5cbiAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGF0ZS5hbmltYXRpb25Db25maWcuY3VycmVudFRpbWUpIHtcbiAgICAvLyBpZiBjdXJyZW50VGltZSBjaGFuZ2VkLCBuZWVkIHRvIGNhbGwgYW5pbWF0aW9uVGltZVVwZGF0ZXIgdG8gcmUgY2FsbCBmb3JtYXRMYXllckRhdGFcbiAgICByZXR1cm4gc2V0TGF5ZXJBbmltYXRpb25UaW1lVXBkYXRlcihuZXh0U3RhdGUsIHt2YWx1ZTogY3VycmVudFRpbWV9KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzdGF0dXMgb2YgdGhlIGVkaXRvclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEVkaXRvck1vZGVVcGRhdGVyID0gKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHttb2RlfTogVmlzU3RhdGVBY3Rpb25zLlNldEVkaXRvck1vZGVVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgZWRpdG9yOiB7XG4gICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgIG1vZGUsXG4gICAgc2VsZWN0ZWRGZWF0dXJlOiBudWxsXG4gIH1cbn0pO1xuXG4vLyBjb25zdCBmZWF0dXJlVG9GaWx0ZXJWYWx1ZSA9IChmZWF0dXJlKSA9PiAoey4uLmZlYXR1cmUsIGlkOiBmZWF0dXJlLmlkfSk7XG4vKipcbiAqIFVwZGF0ZSBlZGl0b3IgZmVhdHVyZXNcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGZWF0dXJlc1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmVzID0gW119OiBWaXNTdGF0ZUFjdGlvbnMuU2V0RmVhdHVyZXNVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGxhc3RGZWF0dXJlID0gZmVhdHVyZXMubGVuZ3RoICYmIGZlYXR1cmVzW2ZlYXR1cmVzLmxlbmd0aCAtIDFdO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgLy8gb25seSBzYXZlIG5vbmUgZmlsdGVyIGZlYXR1cmVzIHRvIGVkaXRvclxuICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLmZpbHRlcihmID0+ICFnZXRGaWx0ZXJJZEluRmVhdHVyZShmKSksXG4gICAgICBtb2RlOiBsYXN0RmVhdHVyZSAmJiBsYXN0RmVhdHVyZS5wcm9wZXJ0aWVzPy5pc0Nsb3NlZCA/IEVESVRPUl9NT0RFUy5FRElUIDogc3RhdGUuZWRpdG9yLm1vZGVcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgZXhpc3RpbmcgZmVhdHVyZVxuICBjb25zdCB7c2VsZWN0ZWRGZWF0dXJlfSA9IHN0YXRlLmVkaXRvcjtcblxuICAvLyBJZiBubyBmZWF0dXJlIGlzIHNlbGVjdGVkIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHNpbmNlIG5vIG9wZXJhdGlvbnNcbiAgaWYgKCFzZWxlY3RlZEZlYXR1cmUpIHtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBUT0RPOiBjaGVjayBpZiB0aGUgZmVhdHVyZSBoYXMgY2hhbmdlZFxuICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuZmluZChmID0+IGYuaWQgPT09IHNlbGVjdGVkRmVhdHVyZS5pZCk7XG5cbiAgLy8gaWYgZmVhdHVyZSBpcyBwYXJ0IG9mIGEgZmlsdGVyXG4gIGNvbnN0IGZpbHRlcklkID0gZmVhdHVyZSAmJiBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKTtcbiAgaWYgKGZpbHRlcklkICYmIGZlYXR1cmUpIHtcbiAgICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gICAgaWYgKGZlYXR1cmUucHJvcGVydGllcykgZmVhdHVyZS5wcm9wZXJ0aWVzLmJib3ggPSBiYm94KGZlYXR1cmUpO1xuICAgIGNvbnN0IGZlYXR1cmVWYWx1ZSA9IGZlYXR1cmVUb0ZpbHRlclZhbHVlKGZlYXR1cmUsIGZpbHRlcklkKTtcbiAgICBjb25zdCBmaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmaWwgPT4gZmlsLmlkID09PSBmaWx0ZXJJZCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBzZXRGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICBpZHg6IGZpbHRlcklkeCxcbiAgICAgIHByb3A6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogZmVhdHVyZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNlbGVjdGVkIGZlYXR1cmVcbiAqIEBtZW1iZXJvZiB1aVN0YXRlVXBkYXRlcnNcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFNlbGVjdGVkRmVhdHVyZVVwZGF0ZXIgPSAoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmUsIHNlbGVjdGlvbkNvbnRleHR9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0U2VsZWN0ZWRGZWF0dXJlVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUgPT4ge1xuICAvLyBhZGQgYmJveCBmb3IgcG9seWdvbiBmaWx0ZXIgdG8gc3BlZWQgdXAgZmlsdGVyaW5nXG4gIGlmIChmZWF0dXJlICYmIGZlYXR1cmUucHJvcGVydGllcykgZmVhdHVyZS5wcm9wZXJ0aWVzLmJib3ggPSBiYm94KGZlYXR1cmUpO1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgc2VsZWN0aW9uQ29udGV4dFxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGV4aXN0aW5nIGZlYXR1cmUgZnJvbSBmaWx0ZXJzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlRmVhdHVyZVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2ZlYXR1cmV9OiBWaXNTdGF0ZUFjdGlvbnMuRGVsZXRlRmVhdHVyZVVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgaWYgKCFmZWF0dXJlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdG9yOiB7XG4gICAgICAuLi5zdGF0ZS5lZGl0b3IsXG4gICAgICBzZWxlY3RlZEZlYXR1cmU6IG51bGxcbiAgICB9XG4gIH07XG5cbiAgaWYgKGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpKSB7XG4gICAgY29uc3QgZmlsdGVySWR4ID0gbmV3U3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBnZXRGaWx0ZXJJZEluRmVhdHVyZShmZWF0dXJlKSk7XG5cbiAgICByZXR1cm4gZmlsdGVySWR4ID4gLTEgPyByZW1vdmVGaWx0ZXJVcGRhdGVyKG5ld1N0YXRlLCB7aWR4OiBmaWx0ZXJJZHh9KSA6IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gbW9kaWZ5IGVkaXRvciBvYmplY3RcbiAgY29uc3QgbmV3RWRpdG9yID0ge1xuICAgIC4uLnN0YXRlLmVkaXRvcixcbiAgICBmZWF0dXJlczogc3RhdGUuZWRpdG9yLmZlYXR1cmVzLmZpbHRlcihmID0+IGYuaWQgIT09IGZlYXR1cmUuaWQpLFxuICAgIHNlbGVjdGVkRmVhdHVyZTogbnVsbFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdG9yOiBuZXdFZGl0b3JcbiAgfTtcbn1cblxuLyoqXG4gKiBUb2dnbGUgZmVhdHVyZSBhcyBsYXllciBmaWx0ZXJcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHBheWxvYWQ6IFZpc1N0YXRlQWN0aW9ucy5TZXRQb2x5Z29uRmlsdGVyTGF5ZXJVcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IHtsYXllciwgZmVhdHVyZX0gPSBwYXlsb2FkO1xuICBjb25zdCBmaWx0ZXJJZCA9IGdldEZpbHRlcklkSW5GZWF0dXJlKGZlYXR1cmUpO1xuXG4gIC8vIGxldCBuZXdGaWx0ZXIgPSBudWxsO1xuICBsZXQgZmlsdGVySWR4O1xuICBsZXQgbmV3TGF5ZXJJZCA9IFtsYXllci5pZF07XG4gIGxldCBuZXdTdGF0ZSA9IHN0YXRlO1xuICAvLyBJZiBwb2x5Z29uIGZpbHRlciBhbHJlYWR5IGV4aXN0cywgd2UgbmVlZCB0byBmaW5kIG91dCBpZiB0aGUgY3VycmVudCBsYXllciBpcyBhbHJlYWR5IGluY2x1ZGVkXG4gIGlmIChmaWx0ZXJJZCkge1xuICAgIGZpbHRlcklkeCA9IHN0YXRlLmZpbHRlcnMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZmlsdGVySWQpO1xuXG4gICAgaWYgKCFzdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0pIHtcbiAgICAgIC8vIHdoYXQgaWYgZmlsdGVyIGRvZXNuJ3QgZXhpc3Q/Li4uIG5vdCBwb3NzaWJsZS5cbiAgICAgIC8vIGJlY2F1c2UgZmVhdHVyZXMgaW4gdGhlIGVkaXRvciBpcyBwYXNzZWQgaW4gZnJvbSBmaWx0ZXJzIGFuZCBlZGl0b3JzLlxuICAgICAgLy8gYnV0IHdlIHdpbGwgbW92ZSB0aGlzIGZlYXR1cmUgYmFjayB0byBlZGl0b3IganVzdCBpbiBjYXNlXG4gICAgICBjb25zdCBub25lRmlsdGVyRmVhdHVyZSA9IHtcbiAgICAgICAgLi4uZmVhdHVyZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIC4uLmZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgICBmaWx0ZXJJZDogbnVsbFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZWRpdG9yOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgICAgIGZlYXR1cmVzOiBbLi4uc3RhdGUuZWRpdG9yLmZlYXR1cmVzLCBub25lRmlsdGVyRmVhdHVyZV0sXG4gICAgICAgICAgc2VsZWN0ZWRGZWF0dXJlOiBub25lRmlsdGVyRmVhdHVyZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXIgPSBzdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF07XG4gICAgY29uc3Qge2xheWVySWQgPSBbXX0gPSBmaWx0ZXI7XG4gICAgY29uc3QgaXNMYXllckluY2x1ZGVkID0gbGF5ZXJJZC5pbmNsdWRlcyhsYXllci5pZCk7XG5cbiAgICBuZXdMYXllcklkID0gaXNMYXllckluY2x1ZGVkXG4gICAgICA/IC8vIGlmIGxheWVyIGlzIGluY2x1ZGVkLCByZW1vdmUgaXRcbiAgICAgICAgbGF5ZXJJZC5maWx0ZXIobCA9PiBsICE9PSBsYXllci5pZClcbiAgICAgIDogWy4uLmxheWVySWQsIGxheWVyLmlkXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB3ZSBoYXZlbid0IGNyZWF0ZSB0aGUgcG9seWdvbiBmaWx0ZXIsIGNyZWF0ZSBpdFxuICAgIGNvbnN0IG5ld0ZpbHRlciA9IGdlbmVyYXRlUG9seWdvbkZpbHRlcihbXSwgZmVhdHVyZSk7XG4gICAgZmlsdGVySWR4ID0gc3RhdGUuZmlsdGVycy5sZW5ndGg7XG5cbiAgICAvLyBhZGQgZmVhdHVyZSwgcmVtb3ZlIGZlYXR1cmUgZnJvbSBlaWR0b3JcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsdGVyczogWy4uLnN0YXRlLmZpbHRlcnMsIG5ld0ZpbHRlcl0sXG4gICAgICBlZGl0b3I6IHtcbiAgICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgICBmZWF0dXJlczogc3RhdGUuZWRpdG9yLmZlYXR1cmVzLmZpbHRlcihmID0+IGYuaWQgIT09IGZlYXR1cmUuaWQpLFxuICAgICAgICBzZWxlY3RlZEZlYXR1cmU6IG5ld0ZpbHRlci52YWx1ZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2V0RmlsdGVyVXBkYXRlcihuZXdTdGF0ZSwge1xuICAgIGlkeDogZmlsdGVySWR4LFxuICAgIHByb3A6ICdsYXllcklkJyxcbiAgICB2YWx1ZTogbmV3TGF5ZXJJZFxuICB9KTtcbn1cblxuLyoqXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydFRhYmxlQ29sdW1uVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBjb2x1bW4sIG1vZGV9OiBWaXNTdGF0ZUFjdGlvbnMuU29ydFRhYmxlQ29sdW1uVXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICBjb25zdCBkYXRhc2V0ID0gc3RhdGUuZGF0YXNldHNbZGF0YUlkXTtcbiAgaWYgKCFkYXRhc2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGxldCBzb3J0TW9kZSA9IG1vZGU7XG4gIGlmICghc29ydE1vZGUpIHtcbiAgICBjb25zdCBjdXJyZW50TW9kZSA9IGdldChkYXRhc2V0LCBbJ3NvcnRDb2x1bW4nLCBjb2x1bW5dKTtcbiAgICAvLyBAdHMtaWdub3JlIC0gc2hvdWxkIGJlIGZpeGFibGUgaW4gYSBUUyBmaWxlXG4gICAgc29ydE1vZGUgPSBjdXJyZW50TW9kZVxuICAgICAgPyBPYmplY3Qua2V5cyhTT1JUX09SREVSKS5maW5kKG0gPT4gbSAhPT0gY3VycmVudE1vZGUpXG4gICAgICA6IFNPUlRfT1JERVIuQVNDRU5ESU5HO1xuICB9XG5cbiAgY29uc3Qgc29ydGVkID0gc29ydERhdGFzZXRCeUNvbHVtbihkYXRhc2V0LCBjb2x1bW4sIHNvcnRNb2RlKTtcbiAgcmV0dXJuIHNldChbJ2RhdGFzZXRzJywgZGF0YUlkXSwgc29ydGVkLCBzdGF0ZSk7XG59XG5cbi8qKlxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpblRhYmxlQ29sdW1uVXBkYXRlcihcbiAgc3RhdGU6IFZpc1N0YXRlLFxuICB7ZGF0YUlkLCBjb2x1bW59OiBWaXNTdGF0ZUFjdGlvbnMuUGluVGFibGVDb2x1bW5VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgbmV3RGF0YXNldCA9IHBpblRhYmxlQ29sdW1ucyhkYXRhc2V0LCBjb2x1bW4pO1xuXG4gIHJldHVybiBzZXQoWydkYXRhc2V0cycsIGRhdGFJZF0sIG5ld0RhdGFzZXQsIHN0YXRlKTtcbn1cblxuLyoqXG4gKiBDb3B5IGNvbHVtbiBjb250ZW50IGFzIHN0cmluZ3NcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5VGFibGVDb2x1bW5VcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWQsIGNvbHVtbn06IFZpc1N0YXRlQWN0aW9ucy5Db3B5VGFibGVDb2x1bW5VcGRhdGVyQWN0aW9uXG4pOiBWaXNTdGF0ZSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdO1xuICBpZiAoIWRhdGFzZXQpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgZmllbGRJZHggPSBkYXRhc2V0LmZpZWxkcy5maW5kSW5kZXgoZiA9PiBmLm5hbWUgPT09IGNvbHVtbik7XG4gIGlmIChmaWVsZElkeCA8IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3Qge3R5cGV9ID0gZGF0YXNldC5maWVsZHNbZmllbGRJZHhdO1xuICBjb25zdCB0ZXh0ID0gZGF0YXNldC5kYXRhQ29udGFpbmVyXG4gICAgLm1hcChyb3cgPT4gcGFyc2VGaWVsZFZhbHVlKHJvdy52YWx1ZUF0KGZpZWxkSWR4KSwgdHlwZSksIHRydWUpXG4gICAgLmpvaW4oJ1xcbicpO1xuXG4gIGNvcHkodGV4dCk7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFNldCBkaXNwbGF5IGZvcm1hdCBmcm9tIGNvbHVtbnMgZnJvbSB1c2VyIHNlbGVjdGlvblxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbHVtbkRpc3BsYXlGb3JtYXRVcGRhdGVyKFxuICBzdGF0ZTogVmlzU3RhdGUsXG4gIHtkYXRhSWQsIGZvcm1hdHN9OiBWaXNTdGF0ZUFjdGlvbnMuU2V0Q29sdW1uRGlzcGxheUZvcm1hdFVwZGF0ZXJBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG4gIGlmICghZGF0YXNldCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBsZXQgbmV3RmllbGRzID0gZGF0YXNldC5maWVsZHM7XG4gIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICBjb25zdCBmaWVsZElkeCA9IGRhdGFzZXQuZmllbGRzLmZpbmRJbmRleChmID0+IGYubmFtZSA9PT0gY29sdW1uKTtcbiAgICBpZiAoZmllbGRJZHggPj0gMCkge1xuICAgICAgY29uc3QgZGlzcGxheUZvcm1hdCA9IGZvcm1hdHNbY29sdW1uXTtcbiAgICAgIGNvbnN0IGZpZWxkID0gbmV3RmllbGRzW2ZpZWxkSWR4XTtcbiAgICAgIG5ld0ZpZWxkcyA9IHN3YXBfKG1lcmdlXyh7ZGlzcGxheUZvcm1hdH0pKGZpZWxkKSBhcyB7aWQ6IHN0cmluZ30pKFxuICAgICAgICBuZXdGaWVsZHMgYXMge2lkOiBzdHJpbmd9W11cbiAgICAgICkgYXMgRmllbGRbXTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG5ld0RhdGFzZXQgPSBjb3B5VGFibGVBbmRVcGRhdGUoZGF0YXNldCwge2ZpZWxkczogbmV3RmllbGRzIGFzIEZpZWxkW119KTtcbiAgbGV0IG5ld1N0YXRlID0gcGlja18oJ2RhdGFzZXRzJykobWVyZ2VfKHtbZGF0YUlkXTogbmV3RGF0YXNldH0pKShzdGF0ZSk7XG5cbiAgLy8gdXBkYXRlIGNvbG9yRmllbGQgZGlzcGxheUZvcm1hdFxuICBuZXdTdGF0ZSA9IHtcbiAgICAuLi5uZXdTdGF0ZSxcbiAgICBsYXllcnM6IG5ld1N0YXRlLmxheWVycy5tYXAobGF5ZXIgPT5cbiAgICAgIGxheWVyLmNvbmZpZz8uY29sb3JGaWVsZD8ubmFtZSAmJiBsYXllci5jb25maWcuY29sb3JGaWVsZC5uYW1lIGluIGZvcm1hdHNcbiAgICAgICAgPyBsYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgICAgICAgICBjb2xvckZpZWxkOiB7XG4gICAgICAgICAgICAgIC4uLmxheWVyLmNvbmZpZy5jb2xvckZpZWxkLFxuICAgICAgICAgICAgICBkaXNwbGF5Rm9ybWF0OiBmb3JtYXRzW2xheWVyLmNvbmZpZy5jb2xvckZpZWxkLm5hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBsYXllclxuICAgIClcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGVkaXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlRWRpdG9yVmlzaWJpbGl0eVVwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5Ub2dnbGVFZGl0b3JWaXNpYmlsaXR5VXBkYXRlckFjdGlvblxuKTogVmlzU3RhdGUge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGVkaXRvcjoge1xuICAgICAgLi4uc3RhdGUuZWRpdG9yLFxuICAgICAgdmlzaWJsZTogIXN0YXRlLmVkaXRvci52aXNpYmxlXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsdGVyQW5pbWF0aW9uVGltZUNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2lkeCwgY29uZmlnfTogVmlzU3RhdGVBY3Rpb25zLlNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWdBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgY29uc3Qgb2xkRmlsdGVyID0gc3RhdGUuZmlsdGVyc1tpZHhdO1xuICBpZiAoIW9sZEZpbHRlcikge1xuICAgIENvbnNvbGUuZXJyb3IoYGZpbHRlcnMuJHtpZHh9IGlzIHVuZGVmaW5lZGApO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAob2xkRmlsdGVyLnR5cGUgIT09IEZJTFRFUl9UWVBFUy50aW1lUmFuZ2UpIHtcbiAgICBDb25zb2xlLmVycm9yKFxuICAgICAgYHNldEZpbHRlckFuaW1hdGlvblRpbWVDb25maWcgY2FuIG9ubHkgYmUgY2FsbGVkIHRvIHVwZGF0ZSBhIHRpbWUgZmlsdGVyLiBjaGVjayBmaWx0ZXIudHlwZSA9PT0gJ3RpbWVSYW5nZSdgXG4gICAgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB1cGRhdGVzID0gY2hlY2tUaW1lQ29uZmlnQXJncyhjb25maWcpO1xuXG4gIHJldHVybiBwaWNrXygnZmlsdGVycycpKHN3YXBfKG1lcmdlXyh1cGRhdGVzKShvbGRGaWx0ZXIpKSkoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaGVja1RpbWVDb25maWdBcmdzKGNvbmZpZykge1xuICBjb25zdCBhbGxvd2VkID0gWyd0aW1lRm9ybWF0JywgJ3RpbWV6b25lJ107XG4gIHJldHVybiBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZSgoYWNjdSwgcHJvcCkgPT4ge1xuICAgIGlmICghYWxsb3dlZC5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgQ29uc29sZS5lcnJvcihcbiAgICAgICAgYHNldExheWVyQW5pbWF0aW9uVGltZUNvbmZpZyB0YWtlcyB0aW1lRm9ybWF0IGFuZC9vciB0aW1lem9uZSBhcyBvcHRpb25zLCBmb3VuZCAke3Byb3B9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH1cblxuICAgIC8vIGhlcmUgd2UgYXJlIE5PVCBjaGVja2luZyBpZiB0aW1lem9uZSBvciB0aW1lRm9ybWF0IGlucHV0IGlzIHZhbGlkXG4gICAgYWNjdVtwcm9wXSA9IGNvbmZpZ1twcm9wXTtcbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBlZGl0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExheWVyQW5pbWF0aW9uVGltZUNvbmZpZ1VwZGF0ZXIoXG4gIHN0YXRlOiBWaXNTdGF0ZSxcbiAge2NvbmZpZ306IFZpc1N0YXRlQWN0aW9ucy5TZXRMYXllckFuaW1hdGlvblRpbWVDb25maWdBY3Rpb25cbik6IFZpc1N0YXRlIHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgdXBkYXRlcyA9IGNoZWNrVGltZUNvbmZpZ0FyZ3MoY29uZmlnKTtcbiAgcmV0dXJuIHBpY2tfKCdhbmltYXRpb25Db25maWcnKShtZXJnZV8odXBkYXRlcykpKHN0YXRlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZWRpdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllckZpbHRlcmVkSXRlbXNDaGFuZ2VVcGRhdGVyPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oXG4gIHN0YXRlOiBTLFxuICBhY3Rpb246IFZpc1N0YXRlQWN0aW9ucy5MYXllckZpbHRlcmVkSXRlbXNDaGFuZ2VBY3Rpb25cbik6IFMge1xuICBjb25zdCB7ZXZlbnQsIGxheWVyfSA9IGFjdGlvbjtcbiAgY29uc3Qge2lkOiBkZWNrZ2xMYXllcklkLCBjb3VudH0gPSBldmVudDtcbiAgaWYgKCFsYXllcikge1xuICAgIENvbnNvbGUud2FybihgbGF5ZXJGaWx0ZXJlZEl0ZW1zIGxheWVyIGRvZXNudCBleGlzdHNgKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKGxheWVyLmZpbHRlcmVkSXRlbUNvdW50Py5bZGVja2dsTGF5ZXJJZF0gPT09IGNvdW50KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgbGF5ZXIuZmlsdGVyZWRJdGVtQ291bnQgPSB7XG4gICAgLi4ubGF5ZXIuZmlsdGVyZWRJdGVtQ291bnQsXG4gICAgW2RlY2tnbExheWVySWRdOiBjb3VudFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzd2FwXyhsYXllcikoc3RhdGUubGF5ZXJzKVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbmV4cG9ydCBmdW5jdGlvbiBzeW5jVGltZUZpbHRlcldpdGhMYXllclRpbWVsaW5lVXBkYXRlcjxTIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogUyxcbiAgYWN0aW9uOiBWaXNTdGF0ZUFjdGlvbnMuU3luY1RpbWVGaWx0ZXJXaXRoTGF5ZXJUaW1lbGluZUFjdGlvblxuKTogUyB7XG4gIGNvbnN0IHtpZHg6IGZpbHRlcklkeCwgZW5hYmxlID0gZmFsc2V9ID0gYWN0aW9uO1xuXG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSBhcyBUaW1lUmFuZ2VGaWx0ZXI7XG5cbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGxldCBuZXdGaWx0ZXIgPSBmaWx0ZXI7XG5cbiAgLy8gaWYgd2UgZW5hYmxlIHN5bmMgd2UgYXJlIGdvaW5nIHRvIG1lcmdlIGZpbHRlciBhbmQgYW5pbWF0aW9uQ29uZmlnIGRvbWFpbnMgYW5kIHN0b3JlIGludG8gZmlsdGVyLmRvbWFpblxuICBpZiAoZW5hYmxlKSB7XG4gICAgY29uc3QgYW5pbWF0YWJsZUxheWVycyA9IGdldEFuaW1hdGFibGVWaXNpYmxlTGF5ZXJzKG5ld1N0YXRlLmxheWVycyk7XG4gICAgLy8gaWYgbm8gYW5pbWF0YWJsZUxheWVycyBhcmUgcHJlc2VudCB3ZSBzaW1wbHkgcmV0dXJuXG4gICAgaWYgKCFhbmltYXRhYmxlTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMgPSBnZXRJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzKGFuaW1hdGFibGVMYXllcnMpO1xuICAgIGNvbnN0IGhhc0ludGVydmFsQmFzZWRBbmltYXRpb25MYXllciA9IEJvb2xlYW4oaW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycy5sZW5ndGgpO1xuXG4gICAgY29uc3QgbmV3RmlsdGVyRG9tYWluID0gbWVyZ2VUaW1lRG9tYWlucyhbZmlsdGVyLmRvbWFpbiwgbmV3U3RhdGUuYW5pbWF0aW9uQ29uZmlnLmRvbWFpbl0pO1xuXG4gICAgLy8gd2Ugb25seSB1cGRhdGUgYW5pbWF0aW9uV2luZG93IGlmIHdlIGhhdmUgaW50ZXJ2YWwgYmFzZWQgYW5pbWF0aW9uIGxheWVycyB3aXRoIGRlZmluZWQgaW50ZXJ2YWxzIGFuZCB0aGUgY3VycmVudCBmaWx0ZXIgYW5pbWF0aW9uIHdpbmRvdyBpcyBub3QgaW50ZXJ2YWxcbiAgICBpZiAoaGFzSW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVyKSB7XG4gICAgICBpZiAoZmlsdGVyLmFuaW1hdGlvbldpbmRvdyAhPT0gQU5JTUFUSU9OX1dJTkRPVy5pbnRlcnZhbCkge1xuICAgICAgICBuZXdTdGF0ZSA9IHNldEZpbHRlckFuaW1hdGlvbldpbmRvd1VwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICAgICAgICBpZDogZmlsdGVyLmlkLFxuICAgICAgICAgIGFuaW1hdGlvbldpbmRvdzogQU5JTUFUSU9OX1dJTkRPVy5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbmV3RmlsdGVyID0gbmV3U3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdIGFzIFRpbWVSYW5nZUZpbHRlcjtcblxuICAgICAgLy8gYWRqdXN0IHRpbWUgZmlsdGVyIGludGVydmFsXG4gICAgICBuZXdGaWx0ZXIgPSBhZGp1c3RUaW1lRmlsdGVySW50ZXJ2YWwobmV3U3RhdGUsIG5ld0ZpbHRlcik7XG5cbiAgICAgIC8vIHJlcGxhY2UgZmlsdGVyIGluIHN0YXRlIHdpdGggbmV3RmlsdGVyXG4gICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIGZpbHRlcnM6IHN3YXBfPEZpbHRlcj4obmV3RmlsdGVyKShuZXdTdGF0ZS5maWx0ZXJzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBuZXdGaWx0ZXIgPSBuZXdTdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0gYXMgVGltZVJhbmdlRmlsdGVyO1xuXG4gICAgLy8gYWRqdXN0IHZhbHVlIGJhc2VkIG9uIG5ldyBkb21haW5cbiAgICBjb25zdCBuZXdGaWx0ZXJWYWx1ZSA9IGFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4oXG4gICAgICBuZXdGaWx0ZXIuYW5pbWF0aW9uV2luZG93ID09PSBBTklNQVRJT05fV0lORE9XLmludGVydmFsXG4gICAgICAgID8gW25ld0ZpbHRlckRvbWFpblswXSwgbmV3RmlsdGVyRG9tYWluWzBdXVxuICAgICAgICA6IG5ld0ZpbHRlckRvbWFpbixcbiAgICAgIHsuLi5uZXdGaWx0ZXIsIGRvbWFpbjogbmV3RmlsdGVyRG9tYWlufVxuICAgICk7XG5cbiAgICBuZXdTdGF0ZSA9IHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICAgIGlkeDogZmlsdGVySWR4LFxuICAgICAgcHJvcDogJ3ZhbHVlJyxcbiAgICAgIHZhbHVlOiBuZXdGaWx0ZXJWYWx1ZVxuICAgIH0pO1xuXG4gICAgbmV3RmlsdGVyID0ge1xuICAgICAgLi4uKG5ld1N0YXRlLmZpbHRlcnNbZmlsdGVySWR4XSBhcyBUaW1lUmFuZ2VGaWx0ZXIpLFxuICAgICAgc3luY2VkV2l0aExheWVyVGltZWxpbmU6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gcmVwbGFjZSBmaWx0ZXIgaW4gc3RhdGUgd2l0aCBuZXdGaWx0ZXJcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgZmlsdGVyczogc3dhcF88RmlsdGVyPihuZXdGaWx0ZXIpKG5ld1N0YXRlLmZpbHRlcnMpXG4gICAgfTtcblxuICAgIG5ld1N0YXRlID0gc2V0VGltZUZpbHRlclRpbWVsaW5lTW9kZVVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICAgIGlkOiBuZXdGaWx0ZXIuaWQsXG4gICAgICBtb2RlOiBnZXRTeW5jQW5pbWF0aW9uTW9kZShuZXdGaWx0ZXIpXG4gICAgfSk7XG5cbiAgICBuZXdGaWx0ZXIgPSBuZXdTdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0gYXMgVGltZVJhbmdlRmlsdGVyO1xuXG4gICAgLy8gc2V0IHRoZSBhbmltYXRpb24gY29uZmlnIHZhbHVlIHRvIG1hdGNoIGZpbHRlciB2YWx1ZVxuICAgIHJldHVybiBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgICB2YWx1ZTogbmV3RmlsdGVyLnZhbHVlW25ld0ZpbHRlci5zeW5jVGltZWxpbmVNb2RlXVxuICAgIH0pO1xuICB9XG5cbiAgLy8gc2V0IGRvbWFpbiBhbmQgc3RlcFxuICBuZXdGaWx0ZXIgPSB7XG4gICAgLi4uZmlsdGVyLFxuICAgIHN5bmNlZFdpdGhMYXllclRpbWVsaW5lOiBmYWxzZVxuICB9O1xuXG4gIC8vIHJlcGxhY2UgZmlsdGVyIGluIHN0YXRlIHdpdGggbmV3RmlsdGVyXG4gIG5ld1N0YXRlID0ge1xuICAgIC4uLm5ld1N0YXRlLFxuICAgIGZpbHRlcnM6IHN3YXBfPEZpbHRlcj4obmV3RmlsdGVyKShuZXdTdGF0ZS5maWx0ZXJzKVxuICB9O1xuXG4gIC8vIHJlc2V0IHN5bmMgdGltZWxpbmUgbW9kZVxuICBuZXdTdGF0ZSA9IHNldFRpbWVGaWx0ZXJUaW1lbGluZU1vZGVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWQ6IG5ld0ZpbHRlci5pZCxcbiAgICBtb2RlOiBTWU5DX1RJTUVMSU5FX01PREVTLmVuZFxuICB9KTtcblxuICBuZXdGaWx0ZXIgPSBuZXdTdGF0ZS5maWx0ZXJzW2ZpbHRlcklkeF0gYXMgVGltZVJhbmdlRmlsdGVyO1xuXG4gIC8vIHJlc2V0IGZpbHRlciB2YWx1ZVxuICBjb25zdCBuZXdGaWx0ZXJWYWx1ZSA9IGFkanVzdFZhbHVlVG9GaWx0ZXJEb21haW4obmV3RmlsdGVyLmRvbWFpbiwgbmV3RmlsdGVyKTtcblxuICBuZXdTdGF0ZSA9IHNldEZpbHRlclVwZGF0ZXIobmV3U3RhdGUsIHtcbiAgICBpZHg6IGZpbHRlcklkeCxcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIHZhbHVlOiBuZXdGaWx0ZXJWYWx1ZVxuICB9KTtcblxuICBuZXdTdGF0ZSA9IHNldFRpbWVGaWx0ZXJUaW1lbGluZU1vZGVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgaWQ6IG5ld0ZpbHRlci5pZCxcbiAgICBtb2RlOiBnZXRTeW5jQW5pbWF0aW9uTW9kZShuZXdGaWx0ZXIpXG4gIH0pO1xuXG4gIC8vIHJlc2V0IGFuaW1hdGlvbiBjb25maWcgY3VycmVudCB0aW1lIHRvXG4gIHJldHVybiBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyKG5ld1N0YXRlLCB7XG4gICAgdmFsdWU6IG5ld1N0YXRlLmFuaW1hdGlvbkNvbmZpZy5kb21haW4/LlswXSA/PyBudWxsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VGltZUZpbHRlclRpbWVsaW5lTW9kZVVwZGF0ZXI8UyBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFMsXG4gIGFjdGlvbjogVmlzU3RhdGVBY3Rpb25zLnNldFRpbWVGaWx0ZXJTeW5jVGltZWxpbmVNb2RlQWN0aW9uXG4pIHtcbiAgY29uc3Qge2lkOiBmaWx0ZXJJZCwgbW9kZTogc3luY1RpbWVsaW5lTW9kZX0gPSBhY3Rpb247XG5cbiAgY29uc3QgZmlsdGVySWR4ID0gc3RhdGUuZmlsdGVycy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBmaWx0ZXJJZCk7XG4gIGlmIChmaWx0ZXJJZHggPT09IC0xKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgZmlsdGVyID0gc3RhdGUuZmlsdGVyc1tmaWx0ZXJJZHhdIGFzIFRpbWVSYW5nZUZpbHRlcjtcblxuICBpZiAoIXZhbGlkYXRlU3luY0FuaW1hdGlvbk1vZGUoZmlsdGVyLCBzeW5jVGltZWxpbmVNb2RlKSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IG5ld0ZpbHRlciA9IHtcbiAgICAuLi5maWx0ZXIsXG4gICAgc3luY1RpbWVsaW5lTW9kZVxuICB9O1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGZpbHRlcnM6IHN3YXBfPEZpbHRlcj4obmV3RmlsdGVyKShzdGF0ZS5maWx0ZXJzKVxuICB9O1xuXG4gIHJldHVybiBhZGp1c3RBbmltYXRpb25Db25maWdXaXRoRmlsdGVyKG5ld1N0YXRlLCBmaWx0ZXJJZHgpO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RBbmltYXRpb25Db25maWdXaXRoRmlsdGVyPFMgZXh0ZW5kcyBWaXNTdGF0ZT4oc3RhdGU6IFMsIGZpbHRlcklkeDogbnVtYmVyKTogUyB7XG4gIGNvbnN0IGZpbHRlciA9IHN0YXRlLmZpbHRlcnNbZmlsdGVySWR4XTtcbiAgaWYgKChmaWx0ZXIgYXMgVGltZVJhbmdlRmlsdGVyKS5zeW5jZWRXaXRoTGF5ZXJUaW1lbGluZSkge1xuICAgIGNvbnN0IHRpbWVsaW5lVmFsdWUgPSBnZXRUaW1lbGluZVZhbHVlRnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuYW5pbWF0aW9uQ29uZmlnLnRpbWVTdGVwc1xuICAgICAgPyBzbmFwVG9NYXJrcyh0aW1lbGluZVZhbHVlLCBzdGF0ZS5hbmltYXRpb25Db25maWcudGltZVN0ZXBzKVxuICAgICAgOiB0aW1lbGluZVZhbHVlO1xuICAgIHJldHVybiBzZXRMYXllckFuaW1hdGlvblRpbWVVcGRhdGVyKHN0YXRlLCB7dmFsdWV9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVsaW5lVmFsdWVGcm9tRmlsdGVyKGZpbHRlcikge1xuICByZXR1cm4gZmlsdGVyLnZhbHVlW2ZpbHRlci5zeW5jVGltZWxpbmVNb2RlXTtcbn1cblxuZnVuY3Rpb24gZ2V0U3luY0FuaW1hdGlvbk1vZGUoZmlsdGVyOiBUaW1lUmFuZ2VGaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5hbmltYXRpb25XaW5kb3cgPT09IEFOSU1BVElPTl9XSU5ET1cuZnJlZSkge1xuICAgIHJldHVybiBmaWx0ZXIuc3luY1RpbWVsaW5lTW9kZSA/PyBTWU5DX1RJTUVMSU5FX01PREVTLmVuZDtcbiAgfVxuXG4gIHJldHVybiBTWU5DX1RJTUVMSU5FX01PREVTLmVuZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTeW5jQW5pbWF0aW9uTW9kZShmaWx0ZXI6IFRpbWVSYW5nZUZpbHRlciwgbmV3TW9kZTogbnVtYmVyKSB7XG4gIHJldHVybiAhKFxuICAgIGZpbHRlci5hbmltYXRpb25XaW5kb3cgIT09IEFOSU1BVElPTl9XSU5ET1cuZnJlZSAmJiBuZXdNb2RlID09PSBTWU5DX1RJTUVMSU5FX01PREVTLnN0YXJ0XG4gICk7XG59XG5cbmZ1bmN0aW9uIGFkanVzdFRpbWVGaWx0ZXJJbnRlcnZhbChzdGF0ZSwgZmlsdGVyKSB7XG4gIGNvbnN0IGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMgPSBnZXRJbnRlcnZhbEJhc2VkQW5pbWF0aW9uTGF5ZXJzKHN0YXRlLmxheWVycyk7XG5cbiAgbGV0IGludGVydmFsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgaWYgKGludGVydmFsQmFzZWRBbmltYXRpb25MYXllcnMubGVuZ3RoID4gMCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpbnRlcnZhbEluZGV4ID0gaW50ZXJ2YWxCYXNlZEFuaW1hdGlvbkxheWVycy5yZWR1Y2UoKGN1cnJlbnRJbmRleCwgbCkgPT4ge1xuICAgICAgaWYgKGwubWV0YS50YXJnZXRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSBUSU1FX0lOVEVSVkFMU19PUkRFUkVELmZpbmRJbmRleChpID0+IGkgPT09IGwubWV0YS50YXJnZXRUaW1lSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gbmV3SW5kZXggPiAtMSAmJiBuZXdJbmRleCA8IGN1cnJlbnRJbmRleCA/IG5ld0luZGV4IDogY3VycmVudEluZGV4O1xuICAgICAgfVxuICAgIH0sIFRJTUVfSU5URVJWQUxTX09SREVSRUQubGVuZ3RoIC0gMSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGhleFRpbGVJbnRlcnZhbCA9IFRJTUVfSU5URVJWQUxTX09SREVSRURbaW50ZXJ2YWxJbmRleF07XG4gICAgaW50ZXJ2YWwgPSBMYXllclRvRmlsdGVyVGltZUludGVydmFsW2hleFRpbGVJbnRlcnZhbF07XG4gIH1cblxuICBpZiAoIWludGVydmFsKSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIC8vIGFkanVzdCBmaWx0ZXJcbiAgY29uc3QgdGltZUZvcm1hdCA9IGdldERlZmF1bHRUaW1lRm9ybWF0KGludGVydmFsKTtcbiAgY29uc3QgdXBkYXRlZFBsb3RUeXBlID0gey4uLmZpbHRlci5wbG90VHlwZSwgaW50ZXJ2YWwsIHRpbWVGb3JtYXR9O1xuICBjb25zdCBuZXdGaWx0ZXIgPSB1cGRhdGVUaW1lRmlsdGVyUGxvdFR5cGUoZmlsdGVyLCB1cGRhdGVkUGxvdFR5cGUsIHN0YXRlLmRhdGFzZXRzKTtcbiAgcmV0dXJuIGFkanVzdFZhbHVlVG9BbmltYXRpb25XaW5kb3coc3RhdGUsIG5ld0ZpbHRlcik7XG59XG5cbi8vIEZpbmQgZGF0YUlkIGZyb20gYSBzYXZlZCB2aXNTdGF0ZSBwcm9wZXJ0eTpcbi8vIGxheWVycywgZmlsdGVycywgaW50ZXJhY3Rpb25zLCBsYXllckJsZW5kaW5nLCBvdmVybGF5QmxlbmRpbmcsIHNwbGl0TWFwcywgYW5pbWF0aW9uQ29uZmlnLCBlZGl0b3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGRhdGFJZFxuZnVuY3Rpb24gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHZhbHVlOiBhbnksIGRhdGFJZDogc3RyaW5nLCBkYXRhSWRUb1JlcGxhY2U6IHN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBmb3IgbGF5ZXJzLCBmaWx0ZXJzLCBjYWxsIGRlZmF1bHRSZXBsYWNlUGFyZW50RGF0YXNldElkcyBvbiBlYWNoIGl0ZW0gaW4gYXJyYXlcbiAgICBjb25zdCByZXBsYWNlZCA9IHZhbHVlXG4gICAgICAubWFwKHYgPT4gZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHYsIGRhdGFJZCwgZGF0YUlkVG9SZXBsYWNlKSlcbiAgICAgIC5maWx0ZXIoZCA9PiBkKTtcbiAgICByZXR1cm4gcmVwbGFjZWQubGVuZ3RoID8gcmVwbGFjZWQgOiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuZGF0YUlkID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5kYXRhSWQgPT09IGRhdGFJZCkge1xuICAgIC8vIG90aGVyc1xuICAgIHJldHVybiB7XG4gICAgICAuLi52YWx1ZSxcbiAgICAgIGRhdGFJZDogZGF0YUlkVG9SZXBsYWNlXG4gICAgfTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGFJZCkgJiYgdmFsdWUuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkpIHtcbiAgICAvLyBmaWx0ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBkYXRhSWQ6IHZhbHVlLmRhdGFJZC5tYXAoZCA9PiAoZCA9PT0gZGF0YUlkID8gZGF0YUlkVG9SZXBsYWNlIDogZCkpXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5jb25maWc/LmRhdGFJZCAmJiB2YWx1ZS5jb25maWc/LmRhdGFJZCA9PT0gZGF0YUlkKSB7XG4gICAgLy8gbGF5ZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4udmFsdWUuY29uZmlnLFxuICAgICAgICBkYXRhSWQ6IGRhdGFJZFRvUmVwbGFjZVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgZGF0YUlkKSkge1xuICAgIC8vIGZvciB2YWx1ZSBzYXZlZCBhcyB7W2RhdGFJZF06IHsuLi59fVxuICAgIHJldHVybiB7W2RhdGFJZFRvUmVwbGFjZV06IHZhbHVlW2RhdGFJZF19O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEZpbmQgZGF0YXNldElkcyBkZXJpdmVkIGEgc2F2ZWQgdmlzU3RhdGUgUHJvcGVydHk7XG5mdW5jdGlvbiBmaW5kQ2hpbGREYXRhc2V0SWRzKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIGZvciBsYXllcnMsIGZpbHRlcnMsIGNhbGwgZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzIG9uIGVhY2ggaXRlbSBpbiBhcnJheVxuICAgIGNvbnN0IGNoaWxkRGF0YUlkcyA9IHZhbHVlLm1hcChmaW5kQ2hpbGREYXRhc2V0SWRzKS5maWx0ZXIoZCA9PiBkKTtcbiAgICByZXR1cm4gY2hpbGREYXRhSWRzLmxlbmd0aCA/IGNoaWxkRGF0YUlkcyA6IG51bGw7XG4gIH1cblxuICAvLyBjaGlsZCBkYXRhIGlkIHVzdWFsbHkgc3RvcmVzIGluIHRoZSBkZXJpdmVkIGRhdGFzZXQgaW5mb1xuICByZXR1cm4gdmFsdWU/Lm5ld0RhdGFzZXQ/LmluZm8uaWQgfHwgbnVsbDtcbn1cblxuLy8gbW92ZWQgdW5tZXJnZWQgbGF5ZXJzLCBmaWx0ZXJzLCBpbnRlcmFjdGlvbnNcbmZ1bmN0aW9uIG1vdmVWYWx1ZVRvQmVNZXJnZWQoc3RhdGUsIHByb3BWYWx1ZXMsIHtwcm9wLCB0b01lcmdlUHJvcCwgc2F2ZVVubWVyZ2VkfSkge1xuICAvLyByZW1vdmUgcHJvcCB2YWx1ZSBmcm9tIHN0YXRlXG4gIC8vIFRPRE86IHNob3VsZCB3ZSBhZGQgcmVtb3ZlIHVwZGF0ZXIgdG8gbWVyZ2VyIGFzIHdlbGw/XG4gIGlmICghcHJvcFZhbHVlcykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVJlbW92ZWQgPVxuICAgIHByb3AgPT09ICdsYXllcnMnXG4gICAgICA/IHByb3BWYWx1ZXMucmVkdWNlKChhY2N1LCBwcm9wVmFsdWUpID0+IHJlbW92ZUxheWVyVXBkYXRlcihhY2N1LCB7aWQ6IHByb3BWYWx1ZS5pZH0pLCBzdGF0ZSlcbiAgICAgIDogQXJyYXkuaXNBcnJheShzdGF0ZVtwcm9wXSlcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIFtwcm9wXTogc3RhdGVbcHJvcF0uZmlsdGVyKHAgPT4gIXByb3BWYWx1ZXMuZmluZChwcm9wVmFsdWUgPT4gcC5pZCA9PT0gcHJvcFZhbHVlLmlkKSlcbiAgICAgICAgfVxuICAgICAgOiAvLyBpZiBub3QgYXJyYXksIHdlIHdvbid0IHJlbW92ZSBpdCwgcmVtb3ZlIGRhdGFzZXQgc2hvdWxkIGhhbmRsZSBpdFxuICAgICAgICBzdGF0ZTtcblxuICAvLyBtb3ZlIHRvIHN0YXRlVG9CZU1lcmdlZFxuICBjb25zdCB0b0JlTWVyZ2VkID0ge1xuICAgIFt0b01lcmdlUHJvcF06IHNhdmVVbm1lcmdlZFxuICAgICAgPyAvLyBjYWxsIG1lcmdlIHNhdmVVbm1lcmdlZCBtZXRob2RcbiAgICAgICAgc2F2ZVVubWVyZ2VkKHN0YXRlUmVtb3ZlZCwgcHJvcFZhbHVlcylcbiAgICAgIDogLy8gaWYgdG9NZXJnZVByb3AgaXMgYXJhYXksIGFwcGVuZCB0byBpdFxuICAgICAgQXJyYXkuaXNBcnJheShzdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdKVxuICAgICAgPyBbLi4uc3RhdGVSZW1vdmVkW3RvTWVyZ2VQcm9wXSwgLi4ucHJvcFZhbHVlc11cbiAgICAgIDogLy8gc2F2ZSBwcm9wVmFsdWVzIHRvIHRvTWVyZ2VcbiAgICAgIGlzT2JqZWN0KHN0YXRlUmVtb3ZlZFt0b01lcmdlUHJvcF0pXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5zdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdLFxuICAgICAgICAgIC4uLnByb3BWYWx1ZXNcbiAgICAgICAgfVxuICAgICAgOiBzdGF0ZVJlbW92ZWRbdG9NZXJnZVByb3BdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZVJlbW92ZWQsXG4gICAgLi4udG9CZU1lcmdlZFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRGF0YXNldEFuZERlcHM8VCBleHRlbmRzIFZpc1N0YXRlPihcbiAgc3RhdGU6IFQsXG4gIGRhdGFJZDogc3RyaW5nLFxuICBkYXRhSWRUb1VzZTogc3RyaW5nXG4pOiBUIHtcbiAgcmV0dXJuIGNvbXBvc2VfPFQ+KFtcbiAgICBhcHBseV8ocmVwbGFjZURhdGFzZXREZXBzSW5TdGF0ZSwge2RhdGFJZCwgZGF0YUlkVG9Vc2V9KSxcbiAgICBhcHBseV8ocmVtb3ZlRGF0YXNldFVwZGF0ZXIsIHtkYXRhSWR9KVxuICBdKShzdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlU3RhdGVGb3JEYXRhc2V0UmVwbGFjZTxUIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogVCxcbiAgZGF0YUlkOiBzdHJpbmcsXG4gIGRhdGFJZFRvVXNlOiBzdHJpbmdcbik6IFQge1xuICBjb25zdCBzZXJpYWxpemVkU3RhdGUgPSBzZXJpYWxpemVWaXNTdGF0ZShzdGF0ZSwgc3RhdGUuc2NoZW1hKTtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVwbGFjZURhdGFzZXRBbmREZXBzKHN0YXRlLCBkYXRhSWQsIGRhdGFJZFRvVXNlKTtcbiAgLy8gbWFrZSBhIGNvcHkgb2YgbGF5ZXJPcmRlciwgYmVjYXVzZSBsYXllciBpZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBpdCBieSBjYWxsaW5nIHJlbW92ZUxheWVyVXBkYXRlclxuICBjb25zdCBwcmVzZXJ2ZUxheWVyT3JkZXIgPSBbLi4uc3RhdGUubGF5ZXJPcmRlcl07XG5cbiAgLy8gcHJlc2VydmUgZGF0YXNldCBvcmRlclxuICBuZXh0U3RhdGUucHJlc2VydmVEYXRhc2V0T3JkZXIgPSBPYmplY3Qua2V5cyhzdGF0ZS5kYXRhc2V0cykubWFwKGQgPT5cbiAgICBkID09PSBkYXRhSWQgPyBkYXRhSWRUb1VzZSA6IGRcbiAgKTtcblxuICAvLyBwcmVzZXJ2ZUxheWVyT3JkZXJcbiAgaWYgKG5leHRTdGF0ZS5sYXllclRvQmVNZXJnZWQ/Lmxlbmd0aCkge1xuICAgIC8vIGNvcHkgc3BsaXQgbWFwcyB0byBiZSBtZXJnZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZXNldCBpbiByZW1vdmUgbGF5ZXJcbiAgICBuZXh0U3RhdGUuc3BsaXRNYXBzVG9CZU1lcmdlZCA9IHNlcmlhbGl6ZWRTdGF0ZT8uc3BsaXRNYXBzID8/IFtdO1xuICAgIG5leHRTdGF0ZS5sYXllck9yZGVyID0gWy4uLnByZXNlcnZlTGF5ZXJPcmRlcl07XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZURhdGFzZXREZXBzSW5TdGF0ZTxUIGV4dGVuZHMgVmlzU3RhdGU+KFxuICBzdGF0ZTogVCxcbiAge2RhdGFJZCwgZGF0YUlkVG9Vc2V9OiB7ZGF0YUlkOiBzdHJpbmc7IGRhdGFJZFRvVXNlOiBzdHJpbmd9XG4pOiBUIHtcbiAgY29uc3Qgc2VyaWFsaXplZFN0YXRlID0gc2VyaWFsaXplVmlzU3RhdGUoc3RhdGUsIHN0YXRlLnNjaGVtYSk7XG5cbiAgY29uc3QgbmV4dFN0YXRlID0gc3RhdGUubWVyZ2Vycy5yZWR1Y2UoXG4gICAgKFxuICAgICAgYWNjdVN0YXRlLFxuICAgICAge3Byb3AsIHRvTWVyZ2VQcm9wLCByZXBsYWNlUGFyZW50RGF0YXNldElkcywgZ2V0Q2hpbGREYXRhc2V0SWRzLCBzYXZlVW5tZXJnZWQsIHByZXNlcnZlT3JkZXJ9XG4gICAgKSA9PiB7XG4gICAgICAvLyBnZXQgZGF0YXNldCBpZHMgdGhhdCBhcmUgZGVwZW5kcyBvbiB0aGlzIGRhdGFzZXRcbiAgICAgIGNvbnN0IHByb3BzID0gdG9BcnJheShwcm9wKTtcbiAgICAgIGNvbnN0IHRvTWVyZ2VQcm9wcyA9IHRvQXJyYXkodG9NZXJnZVByb3ApO1xuICAgICAgY29uc3Qgc2F2ZWRQcm9wcyA9IHNlcmlhbGl6ZWRTdGF0ZSA/IHByb3BzLm1hcChwID0+IHNlcmlhbGl6ZWRTdGF0ZVtwXSkgOiBbXTtcblxuICAgICAgbGV0IHJlcGxhY2VkU3RhdGUgPSBhY2N1U3RhdGU7XG4gICAgICBzYXZlZFByb3BzLmZvckVhY2goKHByb3BWYWx1ZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZXJPcHRpb25zID0ge1xuICAgICAgICAgIHByb3A6IHByb3BzW2ldLFxuICAgICAgICAgIHRvTWVyZ2VQcm9wOiB0b01lcmdlUHJvcHNbaV0sXG4gICAgICAgICAgZ2V0Q2hpbGREYXRhc2V0SWRzLFxuICAgICAgICAgIHNhdmVVbm1lcmdlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcGxhY2VkSXRlbSA9XG4gICAgICAgICAgcmVwbGFjZVBhcmVudERhdGFzZXRJZHM/Lihwcm9wVmFsdWUsIGRhdGFJZCwgZGF0YUlkVG9Vc2UpIHx8XG4gICAgICAgICAgZGVmYXVsdFJlcGxhY2VQYXJlbnREYXRhc2V0SWRzKHByb3BWYWx1ZSwgZGF0YUlkLCBkYXRhSWRUb1VzZSk7XG4gICAgICAgIHJlcGxhY2VkU3RhdGUgPSByZXBsYWNlZEl0ZW1cbiAgICAgICAgICA/IHJlcGxhY2VQcm9wVmFsdWVJblN0YXRlKHJlcGxhY2VkU3RhdGUsIHJlcGxhY2VkSXRlbSwgbWVyZ2VyT3B0aW9ucylcbiAgICAgICAgICA6IHJlcGxhY2VkU3RhdGU7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1lcmdlck9wdGlvbnMudG9NZXJnZVByb3AgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHJlcGxhY2VkU3RhdGVbbWVyZ2VyT3B0aW9ucy50b01lcmdlUHJvcF0/Lmxlbmd0aCAmJlxuICAgICAgICAgIHByZXNlcnZlT3JkZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVwbGFjZWRTdGF0ZVtwcmVzZXJ2ZU9yZGVyXSA9IHByb3BWYWx1ZS5tYXAoaXRlbSA9PiBpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXBsYWNlZFN0YXRlO1xuICAgIH0sXG4gICAgc3RhdGVcbiAgKTtcblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlUHJvcFZhbHVlSW5TdGF0ZShcbiAgc3RhdGUsXG4gIHJlcGxhY2VkSXRlbSxcbiAge3Byb3AsIHRvTWVyZ2VQcm9wLCBnZXRDaGlsZERhdGFzZXRJZHMsIHNhdmVVbm1lcmdlZH1cbikge1xuICAvLyBwcm9wIGlzIGRlcGVuZHMgb24gdGhlIGRhdGFzZXQgdG8gYmUgcmVwbGFjZWRcbiAgLy8gcmVtb3ZlIHByb3AgZnJvbSBzdGF0ZSwgYW5kIG1vdmUgaXQgdG8gdG9CZU1lcmdlZFxuICBsZXQgbmV4dFN0YXRlID0gbW92ZVZhbHVlVG9CZU1lcmdlZChzdGF0ZSwgcmVwbGFjZWRJdGVtLCB7cHJvcCwgdG9NZXJnZVByb3AsIHNhdmVVbm1lcmdlZH0pO1xuICBjb25zdCBjaGlsZERhdGFJZHMgPSBnZXRDaGlsZERhdGFzZXRJZHM/LihyZXBsYWNlZEl0ZW0pIHx8IGZpbmRDaGlsZERhdGFzZXRJZHMocmVwbGFjZWRJdGVtKTtcblxuICBpZiAoY2hpbGREYXRhSWRzKSB7XG4gICAgbmV4dFN0YXRlID0gdG9BcnJheShjaGlsZERhdGFJZHMpLnJlZHVjZSgoYWNjdSwgY2hpbGREYXRhSWQpID0+IHtcbiAgICAgIC8vIHNob3VsZG4ndCBuZWVkIHRvIGNoYW5nZSBjaGlsZCBkYXRhc2V0IGlkLFxuICAgICAgLy8gYnV0IHN0aWxsIG5lZWQgdG8gbW92ZSBvdXQgb2Ygc3RhdGUgYW5kIG1lcmdlIGJhY2sgaW5cbiAgICAgIHJldHVybiByZXBsYWNlRGF0YXNldEFuZERlcHMoYWNjdSwgY2hpbGREYXRhSWQsIGNoaWxkRGF0YUlkKTtcbiAgICB9LCBuZXh0U3RhdGUpO1xuICB9XG4gIHJldHVybiBuZXh0U3RhdGU7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0Es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