import { MapState, UiState, AddDataToMapPayload } from '@kepler.gl/types';
import { MapStyle } from './map-style-updaters';
import { ProviderState } from './provider-state-updaters';
import { loadFilesSuccessUpdaterAction, MapStyleChangeUpdaterAction, LayerTypeChangeUpdaterAction, ToggleSplitMapUpdaterAction, ReplaceDataInMapPayload } from '@kepler.gl/actions';
import { VisState } from '@kepler.gl/schemas';
export declare type KeplerGlState = {
    visState: VisState;
    mapState: MapState;
    mapStyle: MapStyle;
    uiState: UiState;
    providerState: ProviderState;
};
export declare const isValidConfig: (config: any) => unknown;
export declare const defaultAddDataToMapOptions: {
    centerMap: boolean;
    keepExistingConfig: boolean;
    autoCreateLayers: boolean;
    autoCreateTooltips: boolean;
};
/**
 * Combine data and full configuration update in a single action
 *
 * @memberof combinedUpdaters
 * @param {Object} state kepler.gl instance state, containing all subreducer state
 * @param {Object} action
 * @param {Object} action.payload `{datasets, options, config}`
 * @param action.payload.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param [action.payload.options] option object `{centerMap: true}`
 * @param [action.payload.config] map config
 * @param [action.payload.info] map info contains title and description
 * @returns nextState
 *
 * @typedef {Object} Dataset
 * @property info -info of a dataset
 * @property info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @property info.label - A display name of this dataset
 * @property data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @property data.fields - ***required** Array of fields,
 * @property data.fields.name - ***required** Name of the field,
 * @property data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 *
 * @public
 */
export declare const addDataToMapUpdater: (state: KeplerGlState, { payload }: {
    payload: AddDataToMapPayload;
}) => KeplerGlState;
export declare const loadFilesSuccessUpdater: (state: KeplerGlState, action: loadFilesSuccessUpdaterAction) => KeplerGlState;
export declare const addDataToMapComposed: (state: KeplerGlState, { payload }: {
    payload: AddDataToMapPayload;
}) => KeplerGlState;
/**
 * Updater that changes the map style by calling mapStyleChangeUpdater on visState.
 * In addition to that, it does the following:
 *
 *   1. Update map overlay blending mode in accordance with the colorMode of the
 *      base map, but only if it's not in the `normal` mode.
 *
 *   2. Update all the layers which have the `darkBaseMapEnabled` config setting
 *      adjusting it in accordance with the colorMode of the base map.
 *
 */
export declare const combinedMapStyleChangeUpdater: (state: KeplerGlState, action: MapStyleChangeUpdaterAction) => KeplerGlState;
/**
 * Updater that changes the layer type by calling `layerTypeChangeUpdater` on visState.
 * In addition to that, if the new layer type has the `darkBaseMapEnabled` config
 * setting, we adjust it in accordance with the colorMode of the base map.s
 */
export declare const combinedLayerTypeChangeUpdater: (state: KeplerGlState, action: LayerTypeChangeUpdaterAction) => KeplerGlState;
/**
 * Make mapLegend active when toggleSplitMap action is called
 */
export declare const toggleSplitMapUpdater: (state: KeplerGlState, action: ToggleSplitMapUpdaterAction) => KeplerGlState;
/**
 * Updater replace a dataset in state
 */
export declare const replaceDataInMapUpdater: (state: KeplerGlState, { payload }: {
    payload: ReplaceDataInMapPayload;
}) => KeplerGlState;
