"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBoundsUpdater = exports.INITIAL_MAP_STATE = void 0;
exports.getMapDimForSplitMap = getMapDimForSplitMap;
exports.pickViewportPropsFromMapState = pickViewportPropsFromMapState;
exports.updateMapUpdater = exports.toggleSplitMapViewportUpdater = exports.toggleSplitMapUpdater = exports.togglePerspectiveUpdater = exports.resetMapConfigUpdater = exports.receiveMapConfigUpdater = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _geoViewport = _interopRequireDefault(require("@mapbox/geo-viewport"));
var _booleanWithin = _interopRequireDefault(require("@turf/boolean-within"));
var _bboxPolygon = _interopRequireDefault(require("@turf/bbox-polygon"));
var _webMercator = require("@math.gl/web-mercator");
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _lodash = _interopRequireDefault(require("lodash.pick"));
var _utils = require("@kepler.gl/utils");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Updaters for `mapState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to close side panel
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapState: mapStateUpdaters.fitBoundsUpdater(
 *               mapState, {payload: [127.34, 31.09, 127.56, 31.59]]}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-ignore
var mapStateUpdaters = null;
/* eslint-enable @typescript-eslint/no-unused-vars */
/**
 * Default initial `mapState`
 * @memberof mapStateUpdaters
 * @constant
 * @property pitch Default: `0`
 * @property bearing Default: `0`
 * @property latitude Default: `37.75043`
 * @property longitude Default: `-122.34679`
 * @property zoom Default: `9`
 * @property dragRotate Default: `false`
 * @property width Default: `800`
 * @property height Default: `800`
 * @property minZoom: `undefined`,
 * @property maxZoom: `undefined`,
 * @property maxBounds: `undefined`,
 * @property isSplit: `false`,
 * @property isViewportSynced: `true`,
 * @property isZoomLocked: `false`,
 * @property splitMapViewports: `[]`
 * @public
 */
var INITIAL_MAP_STATE = exports.INITIAL_MAP_STATE = {
  pitch: 0,
  bearing: 0,
  latitude: 37.75043,
  longitude: -122.34679,
  zoom: 9,
  dragRotate: false,
  width: 800,
  height: 800,
  minZoom: undefined,
  maxZoom: undefined,
  maxBounds: undefined,
  isSplit: false,
  isViewportSynced: true,
  isZoomLocked: false,
  splitMapViewports: []
};

/* Updaters */
/**
 * Update map viewport
 * @memberof mapStateUpdaters
 * @public
 */
var updateMapUpdater = exports.updateMapUpdater = function updateMapUpdater(state, action) {
  var _action$payload = action.payload,
    inputViewport = _action$payload.viewport,
    _action$payload$mapIn = _action$payload.mapIndex,
    mapIndex = _action$payload$mapIn === void 0 ? 0 : _action$payload$mapIn;
  var viewport = (0, _utils.validateViewPort)(inputViewport);
  if (state.isViewportSynced) {
    // The `updateViewport` function is typed as (Viewport, Viewport) -> Viewport but here the
    // expected typing is (MapState, Viewport) -> MapState.
    // this could be a potential bug as we treat Viewport and MapState as equal seemingly
    // @ts-expect-error Type 'Viewport' is missing the following properties from type 'MapState': isSplit, isViewportSynced, isZoomLocked, splitMapViewports
    return updateViewport(state, viewport);
  }
  var otherViewportMapIndex = -1;
  var splitMapViewports = state.splitMapViewports.map(function (currentViewport, i) {
    if (i === mapIndex) {
      // update the matching viewport with the newViewport info in the action payload
      return updateViewport(currentViewport, viewport);
    }
    otherViewportMapIndex = i;
    // make no changes to the other viewport (yet)
    return currentViewport;
  });

  // make conditional updates to the other viewport not matching this payload's `mapIndex`
  if (Number.isFinite(otherViewportMapIndex) && otherViewportMapIndex > -1) {
    // width and height are a special case and are always updated
    splitMapViewports[otherViewportMapIndex] = _objectSpread(_objectSpread({}, splitMapViewports[otherViewportMapIndex]), {}, {
      width: splitMapViewports[mapIndex].width,
      height: splitMapViewports[mapIndex].height
    });
    if (state.isZoomLocked) {
      // update the other viewport with the new zoom from the split viewport that was updated with this payload's `mapIndex`
      splitMapViewports[otherViewportMapIndex] = _objectSpread(_objectSpread({}, splitMapViewports[otherViewportMapIndex]), {}, {
        zoom: splitMapViewports[mapIndex].zoom
      });
    }
  }
  return _objectSpread(_objectSpread(_objectSpread({}, state), splitMapViewports[mapIndex]), {}, {
    // update the mapState with the new array of split viewports
    splitMapViewports: splitMapViewports
  });
};

/**
 * Fit map viewport to bounds
 * @memberof mapStateUpdaters
 * @public
 */
var fitBoundsUpdater = exports.fitBoundsUpdater = function fitBoundsUpdater(state, action) {
  var centerAndZoom = (0, _utils.getCenterAndZoomFromBounds)(action.payload, {
    width: state.width,
    height: state.height
  });
  if (!centerAndZoom) {
    // bounds is invalid
    return state;
  }
  var newState = _objectSpread(_objectSpread({}, state), {}, {
    latitude: centerAndZoom.center[1],
    longitude: centerAndZoom.center[0]
  }, Number.isFinite(centerAndZoom.zoom) ? {
    zoom: centerAndZoom.zoom
  } : {});

  // if fitting to bounds while split and unsynced
  // copy the new latitude, longitude, and zoom values to each split viewport
  if (newState.splitMapViewports.length) {
    newState.splitMapViewports = newState.splitMapViewports.map(function (currentViewport) {
      return _objectSpread(_objectSpread({}, currentViewport), {}, {
        latitude: newState.latitude,
        longitude: newState.longitude,
        zoom: newState.zoom
      });
    });
  }
  return newState;
};

/**
 * Toggle between 3d and 2d map.
 * @memberof mapStateUpdaters
 * @public
 */
var togglePerspectiveUpdater = exports.togglePerspectiveUpdater = function togglePerspectiveUpdater(state) {
  var newState = _objectSpread(_objectSpread(_objectSpread({}, state), {
    pitch: state.dragRotate ? 0 : 50,
    bearing: state.dragRotate ? 0 : 24
  }), {}, {
    dragRotate: !state.dragRotate
  });

  // if toggling 3d and 2d while split and unsynced
  // copy the new pitch, bearing, and dragRotate values to each split viewport
  if (newState.splitMapViewports.length) {
    newState.splitMapViewports = newState.splitMapViewports.map(function (currentViewport) {
      return _objectSpread(_objectSpread({}, currentViewport), {}, {
        pitch: newState.pitch,
        bearing: newState.bearing,
        dragRotate: newState.dragRotate
      });
    });
  }
  return newState;
};

/**
 * reset mapState to initial State
 * @memberof mapStateUpdaters
 * @public
 */
var resetMapConfigUpdater = exports.resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_MAP_STATE), state.initialState), {}, {
    initialState: state.initialState
  });
};

// consider case where you have a split map and user wants to reset
/**
 * Update `mapState` to propagate a new config
 * @memberof mapStateUpdaters
 * @public
 */
var receiveMapConfigUpdater = exports.receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref) {
  var _ref$payload = _ref.payload,
    _ref$payload$config = _ref$payload.config,
    config = _ref$payload$config === void 0 ? {} : _ref$payload$config,
    _ref$payload$options = _ref$payload.options,
    options = _ref$payload$options === void 0 ? {} : _ref$payload$options,
    _ref$payload$bounds = _ref$payload.bounds,
    bounds = _ref$payload$bounds === void 0 ? null : _ref$payload$bounds;
  /**
   * @type {Partial<MapState>}
   */
  var mapState = (config || {}).mapState || {};
  // merged received mapState with previous state
  // state also may include properties that are new to an existing, saved project's mapState

  var mergedState = (0, _deepmerge["default"])(state, mapState, {
    // note: deepmerge by default will merge arrays by concatenating them
    // but we need to overwrite destination arrays with source arrays, if present
    // https://github.com/TehShrike/deepmerge#arraymerge-example-overwrite-target-array
    arrayMerge: function arrayMerge(_destinationArray, sourceArray) {
      return sourceArray;
    }
  });

  // if center map
  // center map will override mapState config
  if (options.centerMap && bounds) {
    mergedState = fitBoundsUpdater(mergedState, {
      payload: bounds
    });
  }

  // make sure we validate map state before we merge
  mergedState = (0, _utils.validateViewPort)(mergedState);
  return _objectSpread(_objectSpread({}, mergedState), getMapDimForSplitMap(mergedState.isSplit, state));
};

/**
 * Toggle between one or split maps
 * @memberof mapStateUpdaters
 * @public
 */
var toggleSplitMapUpdater = exports.toggleSplitMapUpdater = function toggleSplitMapUpdater(state) {
  return _objectSpread(_objectSpread(_objectSpread({}, state), getMapDimForSplitMap(!state.isSplit, state)), {}, {
    isSplit: !state.isSplit
  }, !state.isSplit === false ? {
    // if toggling to no longer split (single mode) then reset a few properties
    isViewportSynced: true,
    isZoomLocked: false,
    splitMapViewports: []
  } : {});
};

/**
 * Toggle between locked and unlocked split viewports
 * @memberof mapStateUpdaters
 * @public
 */
var toggleSplitMapViewportUpdater = exports.toggleSplitMapViewportUpdater = function toggleSplitMapViewportUpdater(state, action) {
  // new map state immediately gets the new, optional payload values for isViewportSynced and/or isZoomLocked
  var newMapState = _objectSpread(_objectSpread({}, state), action.payload || {});
  if (newMapState.isViewportSynced) {
    // switching from unsynced to synced viewports
    newMapState.splitMapViewports = [];
  } else {
    // switching from synced to unsynced viewports
    // or already in unsynced mode and toggling locked zoom

    if (state.isZoomLocked && !newMapState.isZoomLocked) {
      // switching off locked zoom while unsynced
      // don't copy the mapStates to left and right viewports because there will be zoom "jumping"
      return newMapState;
    }
    if (!state.isZoomLocked && newMapState.isZoomLocked) {
      // switching on locked zoom while unsynced
      // only copy zoom viewport property from the most recently interacted-with viewport to the other
      // TODO: do we want to check for a match a different way, such as a combo of `latitude` and `longitude`?
      var lastUpdatedViewportIndex = newMapState.splitMapViewports.findIndex(function (v) {
        return newMapState.zoom === v.zoom;
      });
      var splitMapViewports = newMapState.splitMapViewports.map(function (currentViewport, i) {
        if (i === lastUpdatedViewportIndex) {
          // no zoom to modify here
          return currentViewport;
        }
        // the other viewport gets the most recently interacted-with viewport's zoom
        // WHY? the viewport the user was last interacting with will set zoom across the board for smooth UX
        return _objectSpread(_objectSpread({}, currentViewport), {}, {
          zoom: newMapState.splitMapViewports[lastUpdatedViewportIndex].zoom
        });
      });
      newMapState.splitMapViewports = splitMapViewports;
      return newMapState;
    }

    // if current viewport is synced, and we are unsyncing it
    // or already in unsynced mode and NOT toggling locked zoom
    // make a fresh copy of the current viewport object, assign it to splitMapViewports[]
    // pickViewportPropsFromMapState is called twice to avoid memory allocation conflicts
    var leftViewport = pickViewportPropsFromMapState(newMapState);
    var rightViewport = pickViewportPropsFromMapState(newMapState);
    newMapState.splitMapViewports = [leftViewport, rightViewport];
  }

  // return new state
  return newMapState;
};

// Helpers
function getMapDimForSplitMap(isSplit, state) {
  // cases:
  // 1. state split: true - isSplit: true
  // do nothing
  // 2. state split: false - isSplit: false
  // do nothing
  if (state.isSplit === isSplit) {
    return {};
  }
  var width = state.isSplit && !isSplit ?
  // 3. state split: true - isSplit: false
  // double width
  state.width * 2 :
  // 4. state split: false - isSplit: true
  // split width
  state.width / 2;
  return {
    width: width
  };
}
function updateViewportBasedOnBounds(state, newMapState) {
  // Get the new viewport bounds
  var viewportBounds = _geoViewport["default"].bounds([newMapState.longitude, newMapState.latitude], newMapState.zoom, [newMapState.width, newMapState.height], _utils.MAPBOX_TILE_SIZE);
  // Generate turf Polygon from bounds for comparison
  var viewportBoundsPolygon = (0, _bboxPolygon["default"])(viewportBounds);
  // @ts-ignore
  var newStateMaxBounds = newMapState.maxBounds;
  // @ts-ignore
  var maxBoundsPolygon = (0, _bboxPolygon["default"])(newStateMaxBounds);

  // If maxBounds has changed reset the viewport to snap to bounds
  var hasMaxBoundsChanged = !state.maxBounds || !state.maxBounds.every(function (val, idx) {
    return val === newStateMaxBounds[idx];
  });
  if (hasMaxBoundsChanged) {
    // Check if the newMapState viewport is within maxBounds
    if (!(0, _booleanWithin["default"])(viewportBoundsPolygon, maxBoundsPolygon)) {
      var _fitBounds = (0, _webMercator.fitBounds)({
          width: newMapState.width,
          height: newMapState.width,
          bounds: [[newStateMaxBounds[0], newStateMaxBounds[1]], [newStateMaxBounds[2], newStateMaxBounds[3]]]
        }),
        latitude = _fitBounds.latitude,
        longitude = _fitBounds.longitude,
        zoom = _fitBounds.zoom;
      newMapState = _objectSpread(_objectSpread({}, newMapState), {}, {
        latitude: latitude,
        longitude: longitude
      }, Number.isFinite(zoom) ? {
        zoom: zoom
      } : {});
    }
    return newMapState;
  }

  // Check if the newMapState viewport is within maxBounds
  if (!(0, _booleanWithin["default"])(viewportBoundsPolygon, maxBoundsPolygon)) {
    newMapState = _objectSpread(_objectSpread({}, newMapState), {}, {
      longitude: state.longitude,
      latitude: state.latitude,
      zoom: state.zoom
    });
  }
  return newMapState;
}
function pickViewportPropsFromMapState(state) {
  return (0, _lodash["default"])(state, ['width', 'height', 'zoom', 'pitch', 'bearing', 'latitude', 'longitude', 'dragRotate', 'minZoom', 'maxZoom', 'maxBounds']);
}

/** Select items from object whose value is not undefined */
var definedProps = function definedProps(obj) {
  return Object.entries(obj).reduce(function (accu, _ref2) {
    var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
      k = _ref3[0],
      v = _ref3[1];
    return _objectSpread(_objectSpread({}, accu), v !== undefined ? (0, _defineProperty2["default"])({}, k, v) : {});
  }, {});
};
function updateViewport(originalViewport, viewportUpdates) {
  var newViewport = _objectSpread(_objectSpread({}, originalViewport), definedProps(viewportUpdates) || {});

  // Make sure zoom level doesn't go bellow minZoom if defined
  if (newViewport.minZoom && newViewport.zoom && newViewport.zoom < newViewport.minZoom) {
    newViewport.zoom = newViewport.minZoom;
  }
  // Make sure zoom level doesn't go above maxZoom if defined
  if (newViewport.maxZoom && newViewport.zoom && newViewport.zoom > newViewport.maxZoom) {
    newViewport.zoom = newViewport.maxZoom;
  }
  // Limit viewport update based on maxBounds
  if (newViewport.maxBounds && (0, _utils.validateBounds)(newViewport.maxBounds)) {
    // @ts-expect-error Type 'Viewport' is missing the following properties from type 'MapState': isSplit, isViewportSynced, isZoomLocked, splitMapViewports
    newViewport = updateViewportBasedOnBounds(originalViewport, newViewport);
  }
  return newViewport;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2VvVmlld3BvcnQiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9ib29sZWFuV2l0aGluIiwiX2Jib3hQb2x5Z29uIiwiX3dlYk1lcmNhdG9yIiwiX2RlZXBtZXJnZSIsIl9sb2Rhc2giLCJfdXRpbHMiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm1hcFN0YXRlVXBkYXRlcnMiLCJJTklUSUFMX01BUF9TVEFURSIsImV4cG9ydHMiLCJwaXRjaCIsImJlYXJpbmciLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJkcmFnUm90YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJtaW5ab29tIiwidW5kZWZpbmVkIiwibWF4Wm9vbSIsIm1heEJvdW5kcyIsImlzU3BsaXQiLCJpc1ZpZXdwb3J0U3luY2VkIiwiaXNab29tTG9ja2VkIiwic3BsaXRNYXBWaWV3cG9ydHMiLCJ1cGRhdGVNYXBVcGRhdGVyIiwic3RhdGUiLCJhY3Rpb24iLCJfYWN0aW9uJHBheWxvYWQiLCJwYXlsb2FkIiwiaW5wdXRWaWV3cG9ydCIsInZpZXdwb3J0IiwiX2FjdGlvbiRwYXlsb2FkJG1hcEluIiwibWFwSW5kZXgiLCJ2YWxpZGF0ZVZpZXdQb3J0IiwidXBkYXRlVmlld3BvcnQiLCJvdGhlclZpZXdwb3J0TWFwSW5kZXgiLCJtYXAiLCJjdXJyZW50Vmlld3BvcnQiLCJpIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaXRCb3VuZHNVcGRhdGVyIiwiY2VudGVyQW5kWm9vbSIsImdldENlbnRlckFuZFpvb21Gcm9tQm91bmRzIiwibmV3U3RhdGUiLCJjZW50ZXIiLCJ0b2dnbGVQZXJzcGVjdGl2ZVVwZGF0ZXIiLCJyZXNldE1hcENvbmZpZ1VwZGF0ZXIiLCJpbml0aWFsU3RhdGUiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsIl9yZWYiLCJfcmVmJHBheWxvYWQiLCJfcmVmJHBheWxvYWQkY29uZmlnIiwiY29uZmlnIiwiX3JlZiRwYXlsb2FkJG9wdGlvbnMiLCJvcHRpb25zIiwiX3JlZiRwYXlsb2FkJGJvdW5kcyIsImJvdW5kcyIsIm1hcFN0YXRlIiwibWVyZ2VkU3RhdGUiLCJkZWVwbWVyZ2UiLCJhcnJheU1lcmdlIiwiX2Rlc3RpbmF0aW9uQXJyYXkiLCJzb3VyY2VBcnJheSIsImNlbnRlck1hcCIsImdldE1hcERpbUZvclNwbGl0TWFwIiwidG9nZ2xlU3BsaXRNYXBVcGRhdGVyIiwidG9nZ2xlU3BsaXRNYXBWaWV3cG9ydFVwZGF0ZXIiLCJuZXdNYXBTdGF0ZSIsImxhc3RVcGRhdGVkVmlld3BvcnRJbmRleCIsImZpbmRJbmRleCIsInYiLCJsZWZ0Vmlld3BvcnQiLCJwaWNrVmlld3BvcnRQcm9wc0Zyb21NYXBTdGF0ZSIsInJpZ2h0Vmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydEJhc2VkT25Cb3VuZHMiLCJ2aWV3cG9ydEJvdW5kcyIsImdlb1ZpZXdwb3J0IiwiTUFQQk9YX1RJTEVfU0laRSIsInZpZXdwb3J0Qm91bmRzUG9seWdvbiIsImJib3hQb2x5Z29uIiwibmV3U3RhdGVNYXhCb3VuZHMiLCJtYXhCb3VuZHNQb2x5Z29uIiwiaGFzTWF4Qm91bmRzQ2hhbmdlZCIsImV2ZXJ5IiwidmFsIiwiaWR4IiwiYm9vbGVhbldpdGhpbiIsIl9maXRCb3VuZHMiLCJmaXRCb3VuZHMiLCJwaWNrIiwiZGVmaW5lZFByb3BzIiwib2JqIiwiZW50cmllcyIsInJlZHVjZSIsImFjY3UiLCJfcmVmMiIsIl9yZWYzIiwiX3NsaWNlZFRvQXJyYXkyIiwiayIsIm9yaWdpbmFsVmlld3BvcnQiLCJ2aWV3cG9ydFVwZGF0ZXMiLCJuZXdWaWV3cG9ydCIsInZhbGlkYXRlQm91bmRzIl0sInNvdXJjZXMiOlsiLi4vc3JjL21hcC1zdGF0ZS11cGRhdGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgZ2VvVmlld3BvcnQgZnJvbSAnQG1hcGJveC9nZW8tdmlld3BvcnQnO1xuaW1wb3J0IGJvb2xlYW5XaXRoaW4gZnJvbSAnQHR1cmYvYm9vbGVhbi13aXRoaW4nO1xuaW1wb3J0IGJib3hQb2x5Z29uIGZyb20gJ0B0dXJmL2Jib3gtcG9seWdvbic7XG5pbXBvcnQge2ZpdEJvdW5kc30gZnJvbSAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yJztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC5waWNrJztcblxuaW1wb3J0IHtcbiAgZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMsXG4gIHZhbGlkYXRlQm91bmRzLFxuICBNQVBCT1hfVElMRV9TSVpFLFxuICB2YWxpZGF0ZVZpZXdQb3J0XG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtNYXBTdGF0ZUFjdGlvbnMsIFJlY2VpdmVNYXBDb25maWdQYXlsb2FkLCBBY3Rpb25UeXBlc30gZnJvbSAnQGtlcGxlci5nbC9hY3Rpb25zJztcbmltcG9ydCB7TWFwU3RhdGUsIEJvdW5kcywgVmlld3BvcnR9IGZyb20gJ0BrZXBsZXIuZ2wvdHlwZXMnO1xuXG4vKipcbiAqIFVwZGF0ZXJzIGZvciBgbWFwU3RhdGVgIHJlZHVjZXIuIENhbiBiZSB1c2VkIGluIHlvdXIgcm9vdCByZWR1Y2VyIHRvIGRpcmVjdGx5IG1vZGlmeSBrZXBsZXIuZ2wncyBzdGF0ZS5cbiAqIFJlYWQgbW9yZSBhYm91dCBbVXNpbmcgdXBkYXRlcnNdKC4uL2FkdmFuY2VkLXVzYWdlL3VzaW5nLXVwZGF0ZXJzLm1kKVxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyLCB7bWFwU3RhdGVVcGRhdGVyc30gZnJvbSAna2VwbGVyLmdsL3JlZHVjZXJzJztcbiAqIC8vIFJvb3QgUmVkdWNlclxuICogY29uc3QgcmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICogIGtlcGxlckdsOiBrZXBsZXJHbFJlZHVjZXIsXG4gKiAgYXBwOiBhcHBSZWR1Y2VyXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb21wb3NlZFJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICogIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAqICAgIC8vIGNsaWNrIGJ1dHRvbiB0byBjbG9zZSBzaWRlIHBhbmVsXG4gKiAgICBjYXNlICdDTElDS19CVVRUT04nOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIGZvbzoge1xuICogICAgICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wuZm9vLFxuICogICAgICAgICAgICAgbWFwU3RhdGU6IG1hcFN0YXRlVXBkYXRlcnMuZml0Qm91bmRzVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgbWFwU3RhdGUsIHtwYXlsb2FkOiBbMTI3LjM0LCAzMS4wOSwgMTI3LjU2LCAzMS41OV1dfVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBtYXBTdGF0ZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vKipcbiAqIERlZmF1bHQgaW5pdGlhbCBgbWFwU3RhdGVgXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkgcGl0Y2ggRGVmYXVsdDogYDBgXG4gKiBAcHJvcGVydHkgYmVhcmluZyBEZWZhdWx0OiBgMGBcbiAqIEBwcm9wZXJ0eSBsYXRpdHVkZSBEZWZhdWx0OiBgMzcuNzUwNDNgXG4gKiBAcHJvcGVydHkgbG9uZ2l0dWRlIERlZmF1bHQ6IGAtMTIyLjM0Njc5YFxuICogQHByb3BlcnR5IHpvb20gRGVmYXVsdDogYDlgXG4gKiBAcHJvcGVydHkgZHJhZ1JvdGF0ZSBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcHJvcGVydHkgd2lkdGggRGVmYXVsdDogYDgwMGBcbiAqIEBwcm9wZXJ0eSBoZWlnaHQgRGVmYXVsdDogYDgwMGBcbiAqIEBwcm9wZXJ0eSBtaW5ab29tOiBgdW5kZWZpbmVkYCxcbiAqIEBwcm9wZXJ0eSBtYXhab29tOiBgdW5kZWZpbmVkYCxcbiAqIEBwcm9wZXJ0eSBtYXhCb3VuZHM6IGB1bmRlZmluZWRgLFxuICogQHByb3BlcnR5IGlzU3BsaXQ6IGBmYWxzZWAsXG4gKiBAcHJvcGVydHkgaXNWaWV3cG9ydFN5bmNlZDogYHRydWVgLFxuICogQHByb3BlcnR5IGlzWm9vbUxvY2tlZDogYGZhbHNlYCxcbiAqIEBwcm9wZXJ0eSBzcGxpdE1hcFZpZXdwb3J0czogYFtdYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgSU5JVElBTF9NQVBfU1RBVEU6IE1hcFN0YXRlID0ge1xuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgbGF0aXR1ZGU6IDM3Ljc1MDQzLFxuICBsb25naXR1ZGU6IC0xMjIuMzQ2NzksXG4gIHpvb206IDksXG4gIGRyYWdSb3RhdGU6IGZhbHNlLFxuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDgwMCxcbiAgbWluWm9vbTogdW5kZWZpbmVkLFxuICBtYXhab29tOiB1bmRlZmluZWQsXG4gIG1heEJvdW5kczogdW5kZWZpbmVkLFxuICBpc1NwbGl0OiBmYWxzZSxcbiAgaXNWaWV3cG9ydFN5bmNlZDogdHJ1ZSxcbiAgaXNab29tTG9ja2VkOiBmYWxzZSxcbiAgc3BsaXRNYXBWaWV3cG9ydHM6IFtdXG59O1xuXG4vKiBVcGRhdGVycyAqL1xuLyoqXG4gKiBVcGRhdGUgbWFwIHZpZXdwb3J0XG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdXBkYXRlTWFwVXBkYXRlciA9IChcbiAgc3RhdGU6IE1hcFN0YXRlLFxuICBhY3Rpb246IE1hcFN0YXRlQWN0aW9ucy5VcGRhdGVNYXBVcGRhdGVyQWN0aW9uXG4pOiBNYXBTdGF0ZSA9PiB7XG4gIGNvbnN0IHt2aWV3cG9ydDogaW5wdXRWaWV3cG9ydCwgbWFwSW5kZXggPSAwfSA9IGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCB2aWV3cG9ydCA9IHZhbGlkYXRlVmlld1BvcnQoaW5wdXRWaWV3cG9ydCk7XG5cbiAgaWYgKHN0YXRlLmlzVmlld3BvcnRTeW5jZWQpIHtcbiAgICAvLyBUaGUgYHVwZGF0ZVZpZXdwb3J0YCBmdW5jdGlvbiBpcyB0eXBlZCBhcyAoVmlld3BvcnQsIFZpZXdwb3J0KSAtPiBWaWV3cG9ydCBidXQgaGVyZSB0aGVcbiAgICAvLyBleHBlY3RlZCB0eXBpbmcgaXMgKE1hcFN0YXRlLCBWaWV3cG9ydCkgLT4gTWFwU3RhdGUuXG4gICAgLy8gdGhpcyBjb3VsZCBiZSBhIHBvdGVudGlhbCBidWcgYXMgd2UgdHJlYXQgVmlld3BvcnQgYW5kIE1hcFN0YXRlIGFzIGVxdWFsIHNlZW1pbmdseVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHlwZSAnVmlld3BvcnQnIGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGZyb20gdHlwZSAnTWFwU3RhdGUnOiBpc1NwbGl0LCBpc1ZpZXdwb3J0U3luY2VkLCBpc1pvb21Mb2NrZWQsIHNwbGl0TWFwVmlld3BvcnRzXG4gICAgcmV0dXJuIHVwZGF0ZVZpZXdwb3J0KHN0YXRlLCB2aWV3cG9ydCk7XG4gIH1cblxuICBsZXQgb3RoZXJWaWV3cG9ydE1hcEluZGV4ID0gLTE7XG4gIGNvbnN0IHNwbGl0TWFwVmlld3BvcnRzID0gc3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMubWFwKChjdXJyZW50Vmlld3BvcnQsIGkpID0+IHtcbiAgICBpZiAoaSA9PT0gbWFwSW5kZXgpIHtcbiAgICAgIC8vIHVwZGF0ZSB0aGUgbWF0Y2hpbmcgdmlld3BvcnQgd2l0aCB0aGUgbmV3Vmlld3BvcnQgaW5mbyBpbiB0aGUgYWN0aW9uIHBheWxvYWRcbiAgICAgIHJldHVybiB1cGRhdGVWaWV3cG9ydChjdXJyZW50Vmlld3BvcnQsIHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICBvdGhlclZpZXdwb3J0TWFwSW5kZXggPSBpO1xuICAgIC8vIG1ha2Ugbm8gY2hhbmdlcyB0byB0aGUgb3RoZXIgdmlld3BvcnQgKHlldClcbiAgICByZXR1cm4gY3VycmVudFZpZXdwb3J0O1xuICB9KTtcblxuICAvLyBtYWtlIGNvbmRpdGlvbmFsIHVwZGF0ZXMgdG8gdGhlIG90aGVyIHZpZXdwb3J0IG5vdCBtYXRjaGluZyB0aGlzIHBheWxvYWQncyBgbWFwSW5kZXhgXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUob3RoZXJWaWV3cG9ydE1hcEluZGV4KSAmJiBvdGhlclZpZXdwb3J0TWFwSW5kZXggPiAtMSkge1xuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGEgc3BlY2lhbCBjYXNlIGFuZCBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICBzcGxpdE1hcFZpZXdwb3J0c1tvdGhlclZpZXdwb3J0TWFwSW5kZXhdID0ge1xuICAgICAgLi4uc3BsaXRNYXBWaWV3cG9ydHNbb3RoZXJWaWV3cG9ydE1hcEluZGV4XSxcbiAgICAgIHdpZHRoOiBzcGxpdE1hcFZpZXdwb3J0c1ttYXBJbmRleF0ud2lkdGgsXG4gICAgICBoZWlnaHQ6IHNwbGl0TWFwVmlld3BvcnRzW21hcEluZGV4XS5oZWlnaHRcbiAgICB9O1xuXG4gICAgaWYgKHN0YXRlLmlzWm9vbUxvY2tlZCkge1xuICAgICAgLy8gdXBkYXRlIHRoZSBvdGhlciB2aWV3cG9ydCB3aXRoIHRoZSBuZXcgem9vbSBmcm9tIHRoZSBzcGxpdCB2aWV3cG9ydCB0aGF0IHdhcyB1cGRhdGVkIHdpdGggdGhpcyBwYXlsb2FkJ3MgYG1hcEluZGV4YFxuICAgICAgc3BsaXRNYXBWaWV3cG9ydHNbb3RoZXJWaWV3cG9ydE1hcEluZGV4XSA9IHtcbiAgICAgICAgLi4uc3BsaXRNYXBWaWV3cG9ydHNbb3RoZXJWaWV3cG9ydE1hcEluZGV4XSxcbiAgICAgICAgem9vbTogc3BsaXRNYXBWaWV3cG9ydHNbbWFwSW5kZXhdLnpvb21cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyB1cGRhdGUgdGhlIHRvcC1sZXZlbCBtYXBTdGF0ZSB2aWV3cG9ydCB3aXRoIHRoZSBtb3N0IHJlY2VudGx5IGludGVyYWN0ZWQtd2l0aCBzcGxpdCB2aWV3cG9ydFxuICAgIC8vIFdIWT8gdGhpcyBhdm9pZHMgem9vbSBhbmQgYm91bmRzIFwianVtcGluZ1wiIGR1ZSB0byBhIFwic3RhbGVcIiB0b3AtbGV2ZWwgbWFwU3RhdGUgdmlld3BvcnQgd2hlbjpcbiAgICAvLyAgMS4gdG9nZ2xpbmcgb2ZmIHRoZSB1bnN5bmNlZCB2aWV3cG9ydHMgbW9kZSB0byBzd2l0Y2ggdG8gdGhlIHN5bmNlZCB2aWV3cG9ydHMgbW9kZVxuICAgIC8vICAyLiB0b2dnbGluZyBvbiB0aGUgem9vbSBsb2NrIGR1cmluZyBhbiB1bnN5bmNlZCB2aWV3cG9ydHMgbW9kZVxuICAgIC4uLnN0YXRlLFxuICAgIC4uLnNwbGl0TWFwVmlld3BvcnRzW21hcEluZGV4XSxcbiAgICAvLyB1cGRhdGUgdGhlIG1hcFN0YXRlIHdpdGggdGhlIG5ldyBhcnJheSBvZiBzcGxpdCB2aWV3cG9ydHNcbiAgICBzcGxpdE1hcFZpZXdwb3J0c1xuICB9O1xufTtcblxuLyoqXG4gKiBGaXQgbWFwIHZpZXdwb3J0IHRvIGJvdW5kc1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGZpdEJvdW5kc1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdGF0ZSxcbiAgYWN0aW9uOiBNYXBTdGF0ZUFjdGlvbnMuRml0Qm91bmRzVXBkYXRlckFjdGlvblxuKTogTWFwU3RhdGUgPT4ge1xuICBjb25zdCBjZW50ZXJBbmRab29tID0gZ2V0Q2VudGVyQW5kWm9vbUZyb21Cb3VuZHMoYWN0aW9uLnBheWxvYWQsIHtcbiAgICB3aWR0aDogc3RhdGUud2lkdGgsXG4gICAgaGVpZ2h0OiBzdGF0ZS5oZWlnaHRcbiAgfSk7XG4gIGlmICghY2VudGVyQW5kWm9vbSkge1xuICAgIC8vIGJvdW5kcyBpcyBpbnZhbGlkXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF0aXR1ZGU6IGNlbnRlckFuZFpvb20uY2VudGVyWzFdLFxuICAgIGxvbmdpdHVkZTogY2VudGVyQW5kWm9vbS5jZW50ZXJbMF0sXG4gICAgLy8gRm9yIG1hcmdpbmFsIG9yIGludmFsaWQgYm91bmRzLCB6b29tIG1heSBiZSBOYU4uIE1ha2Ugc3VyZSB0byBwcm92aWRlIGEgdmFsaWQgdmFsdWUgaW4gb3JkZXJcbiAgICAvLyB0byBhdm9pZCBjb3JydXB0IHN0YXRlIGFuZCBwb3RlbnRpYWwgY3Jhc2hlcyBhcyB6b29tIGlzIGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyXG4gICAgLi4uKE51bWJlci5pc0Zpbml0ZShjZW50ZXJBbmRab29tLnpvb20pID8ge3pvb206IGNlbnRlckFuZFpvb20uem9vbX0gOiB7fSlcbiAgfTtcblxuICAvLyBpZiBmaXR0aW5nIHRvIGJvdW5kcyB3aGlsZSBzcGxpdCBhbmQgdW5zeW5jZWRcbiAgLy8gY29weSB0aGUgbmV3IGxhdGl0dWRlLCBsb25naXR1ZGUsIGFuZCB6b29tIHZhbHVlcyB0byBlYWNoIHNwbGl0IHZpZXdwb3J0XG4gIGlmIChuZXdTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cyA9IG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzLm1hcChjdXJyZW50Vmlld3BvcnQgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRWaWV3cG9ydCxcbiAgICAgIGxhdGl0dWRlOiBuZXdTdGF0ZS5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogbmV3U3RhdGUubG9uZ2l0dWRlLFxuICAgICAgem9vbTogbmV3U3RhdGUuem9vbVxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIGJldHdlZW4gM2QgYW5kIDJkIG1hcC5cbiAqIEBtZW1iZXJvZiBtYXBTdGF0ZVVwZGF0ZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVQZXJzcGVjdGl2ZVVwZGF0ZXIgPSAoc3RhdGU6IE1hcFN0YXRlKTogTWFwU3RhdGUgPT4ge1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICAuLi57XG4gICAgICBwaXRjaDogc3RhdGUuZHJhZ1JvdGF0ZSA/IDAgOiA1MCxcbiAgICAgIGJlYXJpbmc6IHN0YXRlLmRyYWdSb3RhdGUgPyAwIDogMjRcbiAgICB9LFxuICAgIGRyYWdSb3RhdGU6ICFzdGF0ZS5kcmFnUm90YXRlXG4gIH07XG5cbiAgLy8gaWYgdG9nZ2xpbmcgM2QgYW5kIDJkIHdoaWxlIHNwbGl0IGFuZCB1bnN5bmNlZFxuICAvLyBjb3B5IHRoZSBuZXcgcGl0Y2gsIGJlYXJpbmcsIGFuZCBkcmFnUm90YXRlIHZhbHVlcyB0byBlYWNoIHNwbGl0IHZpZXdwb3J0XG4gIGlmIChuZXdTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cyA9IG5ld1N0YXRlLnNwbGl0TWFwVmlld3BvcnRzLm1hcChjdXJyZW50Vmlld3BvcnQgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRWaWV3cG9ydCxcbiAgICAgIHBpdGNoOiBuZXdTdGF0ZS5waXRjaCxcbiAgICAgIGJlYXJpbmc6IG5ld1N0YXRlLmJlYXJpbmcsXG4gICAgICBkcmFnUm90YXRlOiBuZXdTdGF0ZS5kcmFnUm90YXRlXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiByZXNldCBtYXBTdGF0ZSB0byBpbml0aWFsIFN0YXRlXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVzZXRNYXBDb25maWdVcGRhdGVyID0gKHN0YXRlOiBNYXBTdGF0ZSk6IE1hcFN0YXRlID0+ICh7XG4gIC4uLklOSVRJQUxfTUFQX1NUQVRFLFxuICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gIGluaXRpYWxTdGF0ZTogc3RhdGUuaW5pdGlhbFN0YXRlXG59KTtcblxuLy8gY29uc2lkZXIgY2FzZSB3aGVyZSB5b3UgaGF2ZSBhIHNwbGl0IG1hcCBhbmQgdXNlciB3YW50cyB0byByZXNldFxuLyoqXG4gKiBVcGRhdGUgYG1hcFN0YXRlYCB0byBwcm9wYWdhdGUgYSBuZXcgY29uZmlnXG4gKiBAbWVtYmVyb2YgbWFwU3RhdGVVcGRhdGVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlOiBNYXBTdGF0ZSxcbiAge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBwYXlsb2FkOiB7Y29uZmlnID0ge30sIG9wdGlvbnMgPSB7fSwgYm91bmRzID0gbnVsbH1cbiAgfToge1xuICAgIHR5cGU/OiB0eXBlb2YgQWN0aW9uVHlwZXMuUkVDRUlWRV9NQVBfQ09ORklHO1xuICAgIHBheWxvYWQ6IFJlY2VpdmVNYXBDb25maWdQYXlsb2FkO1xuICB9XG4pOiBNYXBTdGF0ZSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UGFydGlhbDxNYXBTdGF0ZT59XG4gICAqL1xuICBjb25zdCBtYXBTdGF0ZSA9IChjb25maWcgfHwge30pLm1hcFN0YXRlIHx8IHt9O1xuICAvLyBtZXJnZWQgcmVjZWl2ZWQgbWFwU3RhdGUgd2l0aCBwcmV2aW91cyBzdGF0ZVxuICAvLyBzdGF0ZSBhbHNvIG1heSBpbmNsdWRlIHByb3BlcnRpZXMgdGhhdCBhcmUgbmV3IHRvIGFuIGV4aXN0aW5nLCBzYXZlZCBwcm9qZWN0J3MgbWFwU3RhdGVcblxuICBsZXQgbWVyZ2VkU3RhdGUgPSBkZWVwbWVyZ2U8TWFwU3RhdGU+KHN0YXRlLCBtYXBTdGF0ZSwge1xuICAgIC8vIG5vdGU6IGRlZXBtZXJnZSBieSBkZWZhdWx0IHdpbGwgbWVyZ2UgYXJyYXlzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlbVxuICAgIC8vIGJ1dCB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBkZXN0aW5hdGlvbiBhcnJheXMgd2l0aCBzb3VyY2UgYXJyYXlzLCBpZiBwcmVzZW50XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1RlaFNocmlrZS9kZWVwbWVyZ2UjYXJyYXltZXJnZS1leGFtcGxlLW92ZXJ3cml0ZS10YXJnZXQtYXJyYXlcbiAgICBhcnJheU1lcmdlOiAoX2Rlc3RpbmF0aW9uQXJyYXksIHNvdXJjZUFycmF5KSA9PiBzb3VyY2VBcnJheVxuICB9KTtcblxuICAvLyBpZiBjZW50ZXIgbWFwXG4gIC8vIGNlbnRlciBtYXAgd2lsbCBvdmVycmlkZSBtYXBTdGF0ZSBjb25maWdcbiAgaWYgKG9wdGlvbnMuY2VudGVyTWFwICYmIGJvdW5kcykge1xuICAgIG1lcmdlZFN0YXRlID0gZml0Qm91bmRzVXBkYXRlcihtZXJnZWRTdGF0ZSwge1xuICAgICAgcGF5bG9hZDogYm91bmRzXG4gICAgfSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdmFsaWRhdGUgbWFwIHN0YXRlIGJlZm9yZSB3ZSBtZXJnZVxuICBtZXJnZWRTdGF0ZSA9IHZhbGlkYXRlVmlld1BvcnQobWVyZ2VkU3RhdGUpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubWVyZ2VkU3RhdGUsXG4gICAgLy8gdXBkYXRlIHdpZHRoIGlmIGBpc1NwbGl0YCBoYXMgY2hhbmdlZFxuICAgIC4uLmdldE1hcERpbUZvclNwbGl0TWFwKG1lcmdlZFN0YXRlLmlzU3BsaXQsIHN0YXRlKVxuICB9O1xufTtcblxuLyoqXG4gKiBUb2dnbGUgYmV0d2VlbiBvbmUgb3Igc3BsaXQgbWFwc1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVXBkYXRlciA9IChzdGF0ZTogTWFwU3RhdGUpOiBNYXBTdGF0ZSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgLi4uZ2V0TWFwRGltRm9yU3BsaXRNYXAoIXN0YXRlLmlzU3BsaXQsIHN0YXRlKSxcbiAgaXNTcGxpdDogIXN0YXRlLmlzU3BsaXQsXG4gIC4uLighc3RhdGUuaXNTcGxpdCA9PT0gZmFsc2VcbiAgICA/IHtcbiAgICAgICAgLy8gaWYgdG9nZ2xpbmcgdG8gbm8gbG9uZ2VyIHNwbGl0IChzaW5nbGUgbW9kZSkgdGhlbiByZXNldCBhIGZldyBwcm9wZXJ0aWVzXG4gICAgICAgIGlzVmlld3BvcnRTeW5jZWQ6IHRydWUsXG4gICAgICAgIGlzWm9vbUxvY2tlZDogZmFsc2UsXG4gICAgICAgIHNwbGl0TWFwVmlld3BvcnRzOiBbXVxuICAgICAgfVxuICAgIDoge30pXG59KTtcblxuLyoqXG4gKiBUb2dnbGUgYmV0d2VlbiBsb2NrZWQgYW5kIHVubG9ja2VkIHNwbGl0IHZpZXdwb3J0c1xuICogQG1lbWJlcm9mIG1hcFN0YXRlVXBkYXRlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZVNwbGl0TWFwVmlld3BvcnRVcGRhdGVyID0gKFxuICBzdGF0ZTogTWFwU3RhdGUsXG4gIGFjdGlvbjogTWFwU3RhdGVBY3Rpb25zLlRvZ2dsZVNwbGl0TWFwVmlld3BvcnRVcGRhdGVyQWN0aW9uXG4pID0+IHtcbiAgLy8gbmV3IG1hcCBzdGF0ZSBpbW1lZGlhdGVseSBnZXRzIHRoZSBuZXcsIG9wdGlvbmFsIHBheWxvYWQgdmFsdWVzIGZvciBpc1ZpZXdwb3J0U3luY2VkIGFuZC9vciBpc1pvb21Mb2NrZWRcbiAgY29uc3QgbmV3TWFwU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgLi4uKGFjdGlvbi5wYXlsb2FkIHx8IHt9KVxuICB9O1xuXG4gIGlmIChuZXdNYXBTdGF0ZS5pc1ZpZXdwb3J0U3luY2VkKSB7XG4gICAgLy8gc3dpdGNoaW5nIGZyb20gdW5zeW5jZWQgdG8gc3luY2VkIHZpZXdwb3J0c1xuICAgIG5ld01hcFN0YXRlLnNwbGl0TWFwVmlld3BvcnRzID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gc3dpdGNoaW5nIGZyb20gc3luY2VkIHRvIHVuc3luY2VkIHZpZXdwb3J0c1xuICAgIC8vIG9yIGFscmVhZHkgaW4gdW5zeW5jZWQgbW9kZSBhbmQgdG9nZ2xpbmcgbG9ja2VkIHpvb21cblxuICAgIGlmIChzdGF0ZS5pc1pvb21Mb2NrZWQgJiYgIW5ld01hcFN0YXRlLmlzWm9vbUxvY2tlZCkge1xuICAgICAgLy8gc3dpdGNoaW5nIG9mZiBsb2NrZWQgem9vbSB3aGlsZSB1bnN5bmNlZFxuICAgICAgLy8gZG9uJ3QgY29weSB0aGUgbWFwU3RhdGVzIHRvIGxlZnQgYW5kIHJpZ2h0IHZpZXdwb3J0cyBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgem9vbSBcImp1bXBpbmdcIlxuICAgICAgcmV0dXJuIG5ld01hcFN0YXRlO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUuaXNab29tTG9ja2VkICYmIG5ld01hcFN0YXRlLmlzWm9vbUxvY2tlZCkge1xuICAgICAgLy8gc3dpdGNoaW5nIG9uIGxvY2tlZCB6b29tIHdoaWxlIHVuc3luY2VkXG4gICAgICAvLyBvbmx5IGNvcHkgem9vbSB2aWV3cG9ydCBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IGludGVyYWN0ZWQtd2l0aCB2aWV3cG9ydCB0byB0aGUgb3RoZXJcbiAgICAgIC8vIFRPRE86IGRvIHdlIHdhbnQgdG8gY2hlY2sgZm9yIGEgbWF0Y2ggYSBkaWZmZXJlbnQgd2F5LCBzdWNoIGFzIGEgY29tYm8gb2YgYGxhdGl0dWRlYCBhbmQgYGxvbmdpdHVkZWA/XG4gICAgICBjb25zdCBsYXN0VXBkYXRlZFZpZXdwb3J0SW5kZXggPSBuZXdNYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cy5maW5kSW5kZXgoXG4gICAgICAgIHYgPT4gbmV3TWFwU3RhdGUuem9vbSA9PT0gdi56b29tXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzcGxpdE1hcFZpZXdwb3J0cyA9IG5ld01hcFN0YXRlLnNwbGl0TWFwVmlld3BvcnRzLm1hcCgoY3VycmVudFZpZXdwb3J0LCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSBsYXN0VXBkYXRlZFZpZXdwb3J0SW5kZXgpIHtcbiAgICAgICAgICAvLyBubyB6b29tIHRvIG1vZGlmeSBoZXJlXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWaWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgb3RoZXIgdmlld3BvcnQgZ2V0cyB0aGUgbW9zdCByZWNlbnRseSBpbnRlcmFjdGVkLXdpdGggdmlld3BvcnQncyB6b29tXG4gICAgICAgIC8vIFdIWT8gdGhlIHZpZXdwb3J0IHRoZSB1c2VyIHdhcyBsYXN0IGludGVyYWN0aW5nIHdpdGggd2lsbCBzZXQgem9vbSBhY3Jvc3MgdGhlIGJvYXJkIGZvciBzbW9vdGggVVhcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jdXJyZW50Vmlld3BvcnQsXG4gICAgICAgICAgem9vbTogbmV3TWFwU3RhdGUuc3BsaXRNYXBWaWV3cG9ydHNbbGFzdFVwZGF0ZWRWaWV3cG9ydEluZGV4XS56b29tXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgbmV3TWFwU3RhdGUuc3BsaXRNYXBWaWV3cG9ydHMgPSBzcGxpdE1hcFZpZXdwb3J0cztcblxuICAgICAgcmV0dXJuIG5ld01hcFN0YXRlO1xuICAgIH1cblxuICAgIC8vIGlmIGN1cnJlbnQgdmlld3BvcnQgaXMgc3luY2VkLCBhbmQgd2UgYXJlIHVuc3luY2luZyBpdFxuICAgIC8vIG9yIGFscmVhZHkgaW4gdW5zeW5jZWQgbW9kZSBhbmQgTk9UIHRvZ2dsaW5nIGxvY2tlZCB6b29tXG4gICAgLy8gbWFrZSBhIGZyZXNoIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgb2JqZWN0LCBhc3NpZ24gaXQgdG8gc3BsaXRNYXBWaWV3cG9ydHNbXVxuICAgIC8vIHBpY2tWaWV3cG9ydFByb3BzRnJvbU1hcFN0YXRlIGlzIGNhbGxlZCB0d2ljZSB0byBhdm9pZCBtZW1vcnkgYWxsb2NhdGlvbiBjb25mbGljdHNcbiAgICBjb25zdCBsZWZ0Vmlld3BvcnQgPSBwaWNrVmlld3BvcnRQcm9wc0Zyb21NYXBTdGF0ZShuZXdNYXBTdGF0ZSk7XG4gICAgY29uc3QgcmlnaHRWaWV3cG9ydCA9IHBpY2tWaWV3cG9ydFByb3BzRnJvbU1hcFN0YXRlKG5ld01hcFN0YXRlKTtcbiAgICBuZXdNYXBTdGF0ZS5zcGxpdE1hcFZpZXdwb3J0cyA9IFtsZWZ0Vmlld3BvcnQsIHJpZ2h0Vmlld3BvcnRdO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5ldyBzdGF0ZVxuICByZXR1cm4gbmV3TWFwU3RhdGU7XG59O1xuXG4vLyBIZWxwZXJzXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFwRGltRm9yU3BsaXRNYXAoaXNTcGxpdCwgc3RhdGUpIHtcbiAgLy8gY2FzZXM6XG4gIC8vIDEuIHN0YXRlIHNwbGl0OiB0cnVlIC0gaXNTcGxpdDogdHJ1ZVxuICAvLyBkbyBub3RoaW5nXG4gIC8vIDIuIHN0YXRlIHNwbGl0OiBmYWxzZSAtIGlzU3BsaXQ6IGZhbHNlXG4gIC8vIGRvIG5vdGhpbmdcbiAgaWYgKHN0YXRlLmlzU3BsaXQgPT09IGlzU3BsaXQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCB3aWR0aCA9XG4gICAgc3RhdGUuaXNTcGxpdCAmJiAhaXNTcGxpdFxuICAgICAgPyAvLyAzLiBzdGF0ZSBzcGxpdDogdHJ1ZSAtIGlzU3BsaXQ6IGZhbHNlXG4gICAgICAgIC8vIGRvdWJsZSB3aWR0aFxuICAgICAgICBzdGF0ZS53aWR0aCAqIDJcbiAgICAgIDogLy8gNC4gc3RhdGUgc3BsaXQ6IGZhbHNlIC0gaXNTcGxpdDogdHJ1ZVxuICAgICAgICAvLyBzcGxpdCB3aWR0aFxuICAgICAgICBzdGF0ZS53aWR0aCAvIDI7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVWaWV3cG9ydEJhc2VkT25Cb3VuZHMoc3RhdGU6IE1hcFN0YXRlLCBuZXdNYXBTdGF0ZTogTWFwU3RhdGUpIHtcbiAgLy8gR2V0IHRoZSBuZXcgdmlld3BvcnQgYm91bmRzXG4gIGNvbnN0IHZpZXdwb3J0Qm91bmRzID0gZ2VvVmlld3BvcnQuYm91bmRzKFxuICAgIFtuZXdNYXBTdGF0ZS5sb25naXR1ZGUsIG5ld01hcFN0YXRlLmxhdGl0dWRlXSxcbiAgICBuZXdNYXBTdGF0ZS56b29tLFxuICAgIFtuZXdNYXBTdGF0ZS53aWR0aCwgbmV3TWFwU3RhdGUuaGVpZ2h0XSxcbiAgICBNQVBCT1hfVElMRV9TSVpFXG4gICk7XG4gIC8vIEdlbmVyYXRlIHR1cmYgUG9seWdvbiBmcm9tIGJvdW5kcyBmb3IgY29tcGFyaXNvblxuICBjb25zdCB2aWV3cG9ydEJvdW5kc1BvbHlnb24gPSBiYm94UG9seWdvbih2aWV3cG9ydEJvdW5kcyk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgbmV3U3RhdGVNYXhCb3VuZHM6IEJvdW5kcyA9IG5ld01hcFN0YXRlLm1heEJvdW5kcztcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBtYXhCb3VuZHNQb2x5Z29uID0gYmJveFBvbHlnb24obmV3U3RhdGVNYXhCb3VuZHMpO1xuXG4gIC8vIElmIG1heEJvdW5kcyBoYXMgY2hhbmdlZCByZXNldCB0aGUgdmlld3BvcnQgdG8gc25hcCB0byBib3VuZHNcbiAgY29uc3QgaGFzTWF4Qm91bmRzQ2hhbmdlZCA9XG4gICAgIXN0YXRlLm1heEJvdW5kcyB8fCAhc3RhdGUubWF4Qm91bmRzLmV2ZXJ5KCh2YWwsIGlkeCkgPT4gdmFsID09PSBuZXdTdGF0ZU1heEJvdW5kc1tpZHhdKTtcbiAgaWYgKGhhc01heEJvdW5kc0NoYW5nZWQpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgbmV3TWFwU3RhdGUgdmlld3BvcnQgaXMgd2l0aGluIG1heEJvdW5kc1xuICAgIGlmICghYm9vbGVhbldpdGhpbih2aWV3cG9ydEJvdW5kc1BvbHlnb24sIG1heEJvdW5kc1BvbHlnb24pKSB7XG4gICAgICBjb25zdCB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbX0gPSBmaXRCb3VuZHMoe1xuICAgICAgICB3aWR0aDogbmV3TWFwU3RhdGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogbmV3TWFwU3RhdGUud2lkdGgsXG4gICAgICAgIGJvdW5kczogW1xuICAgICAgICAgIFtuZXdTdGF0ZU1heEJvdW5kc1swXSwgbmV3U3RhdGVNYXhCb3VuZHNbMV1dLFxuICAgICAgICAgIFtuZXdTdGF0ZU1heEJvdW5kc1syXSwgbmV3U3RhdGVNYXhCb3VuZHNbM11dXG4gICAgICAgIF1cbiAgICAgIH0pO1xuXG4gICAgICBuZXdNYXBTdGF0ZSA9IHtcbiAgICAgICAgLi4ubmV3TWFwU3RhdGUsXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIC8vIEZvciBtYXJnaW5hbCBvciBpbnZhbGlkIGJvdW5kcywgem9vbSBtYXkgYmUgTmFOLiBNYWtlIHN1cmUgdG8gcHJvdmlkZSBhIHZhbGlkIHZhbHVlIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIGF2b2lkIGNvcnJ1cHQgc3RhdGUgYW5kIHBvdGVudGlhbCBjcmFzaGVzIGFzIHpvb20gaXMgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXJcbiAgICAgICAgLi4uKE51bWJlci5pc0Zpbml0ZSh6b29tKSA/IHt6b29tfSA6IHt9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcFN0YXRlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIG5ld01hcFN0YXRlIHZpZXdwb3J0IGlzIHdpdGhpbiBtYXhCb3VuZHNcbiAgaWYgKCFib29sZWFuV2l0aGluKHZpZXdwb3J0Qm91bmRzUG9seWdvbiwgbWF4Qm91bmRzUG9seWdvbikpIHtcbiAgICBuZXdNYXBTdGF0ZSA9IHtcbiAgICAgIC4uLm5ld01hcFN0YXRlLFxuICAgICAgbG9uZ2l0dWRlOiBzdGF0ZS5sb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZTogc3RhdGUubGF0aXR1ZGUsXG4gICAgICB6b29tOiBzdGF0ZS56b29tXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBuZXdNYXBTdGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tWaWV3cG9ydFByb3BzRnJvbU1hcFN0YXRlKHN0YXRlOiBNYXBTdGF0ZSk6IFZpZXdwb3J0IHtcbiAgcmV0dXJuIHBpY2soc3RhdGUsIFtcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICd6b29tJyxcbiAgICAncGl0Y2gnLFxuICAgICdiZWFyaW5nJyxcbiAgICAnbGF0aXR1ZGUnLFxuICAgICdsb25naXR1ZGUnLFxuICAgICdkcmFnUm90YXRlJyxcbiAgICAnbWluWm9vbScsXG4gICAgJ21heFpvb20nLFxuICAgICdtYXhCb3VuZHMnXG4gIF0pO1xufVxuXG4vKiogU2VsZWN0IGl0ZW1zIGZyb20gb2JqZWN0IHdob3NlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgKi9cbmNvbnN0IGRlZmluZWRQcm9wcyA9IG9iaiA9PlxuICBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZShcbiAgICAoYWNjdSwgW2ssIHZdKSA9PiAoey4uLmFjY3UsIC4uLih2ICE9PSB1bmRlZmluZWQgPyB7W2tdOiB2fSA6IHt9KX0pLFxuICAgIHt9XG4gICk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0KG9yaWdpbmFsVmlld3BvcnQ6IFZpZXdwb3J0LCB2aWV3cG9ydFVwZGF0ZXM6IFZpZXdwb3J0KTogVmlld3BvcnQge1xuICBsZXQgbmV3Vmlld3BvcnQgPSB7XG4gICAgLi4ub3JpZ2luYWxWaWV3cG9ydCxcbiAgICAuLi4oZGVmaW5lZFByb3BzKHZpZXdwb3J0VXBkYXRlcykgfHwge30pXG4gIH07XG5cbiAgLy8gTWFrZSBzdXJlIHpvb20gbGV2ZWwgZG9lc24ndCBnbyBiZWxsb3cgbWluWm9vbSBpZiBkZWZpbmVkXG4gIGlmIChuZXdWaWV3cG9ydC5taW5ab29tICYmIG5ld1ZpZXdwb3J0Lnpvb20gJiYgbmV3Vmlld3BvcnQuem9vbSA8IG5ld1ZpZXdwb3J0Lm1pblpvb20pIHtcbiAgICBuZXdWaWV3cG9ydC56b29tID0gbmV3Vmlld3BvcnQubWluWm9vbTtcbiAgfVxuICAvLyBNYWtlIHN1cmUgem9vbSBsZXZlbCBkb2Vzbid0IGdvIGFib3ZlIG1heFpvb20gaWYgZGVmaW5lZFxuICBpZiAobmV3Vmlld3BvcnQubWF4Wm9vbSAmJiBuZXdWaWV3cG9ydC56b29tICYmIG5ld1ZpZXdwb3J0Lnpvb20gPiBuZXdWaWV3cG9ydC5tYXhab29tKSB7XG4gICAgbmV3Vmlld3BvcnQuem9vbSA9IG5ld1ZpZXdwb3J0Lm1heFpvb207XG4gIH1cbiAgLy8gTGltaXQgdmlld3BvcnQgdXBkYXRlIGJhc2VkIG9uIG1heEJvdW5kc1xuICBpZiAobmV3Vmlld3BvcnQubWF4Qm91bmRzICYmIHZhbGlkYXRlQm91bmRzKG5ld1ZpZXdwb3J0Lm1heEJvdW5kcykpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFR5cGUgJ1ZpZXdwb3J0JyBpcyBtaXNzaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBmcm9tIHR5cGUgJ01hcFN0YXRlJzogaXNTcGxpdCwgaXNWaWV3cG9ydFN5bmNlZCwgaXNab29tTG9ja2VkLCBzcGxpdE1hcFZpZXdwb3J0c1xuICAgIG5ld1ZpZXdwb3J0ID0gdXBkYXRlVmlld3BvcnRCYXNlZE9uQm91bmRzKG9yaWdpbmFsVmlld3BvcnQsIG5ld1ZpZXdwb3J0KTtcbiAgfVxuXG4gIHJldHVybiBuZXdWaWV3cG9ydDtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR0EsSUFBQUEsWUFBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsY0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUUsWUFBQSxHQUFBSCxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUcsWUFBQSxHQUFBSCxPQUFBO0FBQ0EsSUFBQUksVUFBQSxHQUFBTCxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUssT0FBQSxHQUFBTixzQkFBQSxDQUFBQyxPQUFBO0FBRUEsSUFBQU0sTUFBQSxHQUFBTixPQUFBO0FBSzBCLFNBQUFPLFFBQUFDLENBQUEsRUFBQUMsQ0FBQSxRQUFBQyxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsSUFBQSxDQUFBSixDQUFBLE9BQUFHLE1BQUEsQ0FBQUUscUJBQUEsUUFBQUMsQ0FBQSxHQUFBSCxNQUFBLENBQUFFLHFCQUFBLENBQUFMLENBQUEsR0FBQUMsQ0FBQSxLQUFBSyxDQUFBLEdBQUFBLENBQUEsQ0FBQUMsTUFBQSxXQUFBTixDQUFBLFdBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQVIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFRLFVBQUEsT0FBQVAsQ0FBQSxDQUFBUSxJQUFBLENBQUFDLEtBQUEsQ0FBQVQsQ0FBQSxFQUFBSSxDQUFBLFlBQUFKLENBQUE7QUFBQSxTQUFBVSxjQUFBWixDQUFBLGFBQUFDLENBQUEsTUFBQUEsQ0FBQSxHQUFBWSxTQUFBLENBQUFDLE1BQUEsRUFBQWIsQ0FBQSxVQUFBQyxDQUFBLFdBQUFXLFNBQUEs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