import { Layer } from '@kepler.gl/layers';
import { VisState, VisStateMergers, KeplerGLSchemaClass } from '@kepler.gl/schemas';
import { ParsedLayer, ParsedVisState, SavedInteractionConfig, TooltipInfo, SavedEditor, ParsedConfig, Filter, Effect as EffectType, ParsedEffect, LayerColumns, LayerColumn, ParsedFilter } from '@kepler.gl/types';
import { KeplerTable, Datasets } from '@kepler.gl/table';
/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 */
export declare function mergeFilters<S extends VisState>(state: S, filtersToMerge: NonNullable<ParsedConfig['visState']>['filters'], fromConfig?: boolean): S;
export declare function replaceFilterDatasetIds(savedFilter: Filter[], dataId: string, dataIdToUse: string): Filter[] | null;
export declare function isSavedLayerConfigV1(layerConfig: any): boolean;
export declare function parseLayerConfig(schema: KeplerGLSchemaClass, layerConfig: any): ParsedLayer | undefined;
export declare function createLayerFromConfig(state: VisState, layerConfig: any): Layer | null;
/**
 * Get loaded filter from state
 */
export declare function serializeFilter(newFilter: Filter, schema: KeplerGLSchemaClass): ParsedFilter | undefined;
/**
 * Get loaded layer from state
 */
export declare function serializeLayer(newLayer: Layer, schema: KeplerGLSchemaClass): ParsedLayer | undefined;
/**
 * Get loaded effect from state
 */
export declare function serializeEffect(newEffect: EffectType, schema: KeplerGLSchemaClass): ParsedEffect | undefined;
/**
 * Get vis state config
 */
export declare function serializeVisState(visState: Partial<VisState>, schema: KeplerGLSchemaClass): ParsedVisState | undefined;
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 */
export declare function mergeLayers<S extends VisState>(state: S, layersToMerge?: NonNullable<ParsedConfig['visState']>['layers'], fromConfig?: boolean): S;
export declare function insertLayerAtRightOrder(currentLayers: any, layersToInsert: any, currentOrder: any, preservedOrder?: string[]): {
    newLayers: any;
    newLayerOrder: any;
};
/**
 * Merge interactions with saved config
 *
 */
export declare function mergeInteractions<S extends VisState>(state: S, interactionToBeMerged: Partial<SavedInteractionConfig> | undefined): S;
/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */
export declare function mergeSplitMaps<S extends VisState>(state: S, splitMaps?: NonNullable<ParsedConfig['visState']>['splitMaps']): S;
/**
 * Merge effects with saved config
 */
export declare function mergeEffects<S extends VisState>(state: S, effects: NonNullable<ParsedConfig['visState']>['effects'], fromConfig?: boolean): S;
/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param state
 * @param tooltipConfig
 * @return - {mergedTooltip: {}, unmergedTooltip: {}}
 */
export declare function mergeInteractionTooltipConfig(state: VisState, tooltipConfig?: Pick<TooltipInfo['config'], 'fieldsToShow'> | null): {
    mergedTooltip: {
        [key: string]: import("@kepler.gl/types").TooltipField[];
    };
    unmergedTooltip: {
        [key: string]: import("@kepler.gl/types").TooltipField[];
    };
};
/**
 * Merge layerBlending with saved
 *
 */
export declare function mergeLayerBlending<S extends VisState>(state: S, layerBlending: NonNullable<ParsedConfig['visState']>['layerBlending']): S;
/**
 * Merge overlayBlending with saved
 */
export declare function mergeOverlayBlending<S extends VisState>(state: S, overlayBlending: NonNullable<ParsedConfig['visState']>['overlayBlending']): S;
/**
 * Merge animation config
 */
export declare function mergeAnimationConfig<S extends VisState>(state: S, animation: NonNullable<ParsedConfig['visState']>['animationConfig']): S;
/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param fields
 * @param savedCols
 * @param emptyCols
 * @param options
 * @return - validated columns or null
 */
export declare function validateSavedLayerColumns(fields: KeplerTable['fields'], savedCols: {
    [key: string]: string;
} | undefined, emptyCols: LayerColumns, options?: {
    throwOnError?: boolean;
}): LayerColumns | null;
/**
 * Validate layer column
 */
export declare function validateColumn(column: LayerColumn & {
    validator?: typeof validateColumn;
}, columns: LayerColumns, allFields: KeplerTable['fields']): boolean;
/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @param {Object} options
 * @return {Object} - validated textlabel
 */
export declare function validateSavedTextLabel(fields: any, [layerTextLabel]: [any], savedTextLabel: any, options?: {
    throwOnError?: boolean;
}): {}[];
/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 */
export declare function validateSavedVisualChannels(fields: KeplerTable['fields'], newLayer: Layer, savedLayer: ParsedLayer, options?: {
    throwOnError?: boolean;
}): null | Layer;
declare type ValidateLayerOption = {
    allowEmptyColumn?: boolean;
    throwOnError?: boolean;
};
export declare function validateLayersByDatasets(datasets: Datasets, layerClasses: VisState['layerClasses'], layers?: NonNullable<ParsedConfig['visState']>['layers'], options?: ValidateLayerOption): {
    validated: Layer[];
    failed: ParsedLayer[];
};
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
export declare function validateLayerWithData(dataset: KeplerTable, savedLayer: ParsedLayer, layerClasses: VisState['layerClasses'], options?: ValidateLayerOption): Layer | null;
export declare function mergeEditor<S extends VisState>(state: S, savedEditor: SavedEditor): S;
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 */
export declare function mergeDatasetsByOrder(state: VisState, newDataEntries: Datasets): Datasets;
export declare const VIS_STATE_MERGERS: VisStateMergers<any>;
export {};
