import * as arrow from 'apache-arrow';
import * as ga from '@geoarrow/geoarrow-js';
export declare type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;
export declare function findGeometryColumnIndex(schema: arrow.Schema, extensionName: string, geometryColumnName?: string | null): number | null;
/**
 * Returns `true` if the input is a reference to a column in the table
 */
export declare function isColumnReference(input: any): input is string;
/**
 * Convert geoarrow Struct coordinates to FixedSizeList coords
 *
 * The GeoArrow spec allows for either separated or interleaved coords, but at
 * this time deck.gl only supports interleaved.
 */
export declare function convertStructToFixedSizeList(coords: arrow.Data<arrow.FixedSizeList<arrow.Float64>> | arrow.Data<arrow.Struct<{
    x: arrow.Float64;
    y: arrow.Float64;
}>>): arrow.Data<arrow.FixedSizeList<arrow.Float64>>;
declare type AssignAccessorProps = {
    /** The object on which to assign the resolved accesor */
    props: Record<string, any>;
    /** The name of the prop to set */
    propName: string;
    /** The user-supplied input to the layer. Must either be a scalar value or a reference to a column in the table. */
    propInput: any;
    /** Numeric index in the table */
    chunkIdx: number;
    /** a map from the geometry index to the coord offsets for that geometry. */
    geomCoordOffsets?: Int32Array | null;
    /** Absolute offset of the batch in the table/vector. Added to the sampling index. */
    batchOffset?: number;
};
/**
 * Resolve accessor and assign to props object
 *
 * This is useful as a helper function because a scalar prop is set at the top
 * level while a vectorized prop is set inside data.attributes
 *
 */
export declare function assignAccessor(args: AssignAccessorProps): void;
/**
 * Expand an array from "one element per geometry" to "one element per coordinate"
 *
 * @param input: the input array to expand
 * @param size : the number of nested elements in the input array per geometry. So for example, for RGB data this would be 3, for RGBA this would be 4. For radius, this would be 1.
 * @param geomOffsets : an offsets array mapping from the geometry to the coordinate indexes. So in the case of a LineStringArray, this is retrieved directly from the GeoArrow storage. In the case of a PolygonArray, this comes from the resolved indexes that need to be given to the SolidPolygonLayer anyways.
 * @param numPositions : end position in geomOffsets, as geomOffsets can potentially contain preallocated zeroes in the end of the buffer.
 *
 * @return  {TypedArray} values expanded to be per-coordinate
 */
export declare function expandArrayToCoords<T extends TypedArray>(input: T, size: number, geomOffsets: Int32Array, numPositions?: number): T;
/**
 * Get a geometry vector with the specified extension type name from the table.
 */
export declare function getGeometryVector(table: arrow.Table, geoarrowTypeName: string): arrow.Vector | null;
export declare function getListNestingLevels(data: arrow.Data): number;
export declare function getMultiLineStringResolvedOffsets(data: ga.data.MultiLineStringData): Int32Array;
export declare function getPolygonResolvedOffsets(data: ga.data.PolygonData): Int32Array;
export declare function getMultiPolygonResolvedOffsets(data: ga.data.MultiPolygonData): Int32Array;
/**
 * Invert offsets so that lookup can go in the opposite direction
 */
export declare function invertOffsets(offsets: Int32Array): Uint8Array | Uint16Array | Uint32Array;
export declare function extractAccessorsFromProps(props: Record<string, any>, excludeKeys: string[]): [Record<string, any>, Record<string, any>];
export {};
