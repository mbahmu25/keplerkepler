import { AggregatedBin, ColorMap, ColorRange, HexColor, KeplerLayer as Layer, MapState, VisualChannel, VisualChannelDomain, RGBColor, RGBAColor, ColorUI, Field } from '@kepler.gl/types';
import { DataContainerInterface } from './data-container-interface';
export declare type ColorBreak = {
    data: HexColor;
    label: string;
    range: number[];
    inputs: number[];
};
export declare type ColorBreakOrdinal = {
    data: HexColor;
    label: string | number | string[] | number[] | null;
};
export declare type D3ScaleFunction = Record<string, any> & ((x: any) => any);
declare type FilterProps = any;
declare type KeplerTable = any;
export declare type LabelFormat = (n: number, type?: string) => string;
declare type dataValueAccessor = <T>(param: T) => T;
declare type dataContainerValueAccessor = (d: {
    index: number;
}, dc: DataContainerInterface) => any;
declare type sort = (a: any, b: any) => any;
/**
 * return quantile domain for an array of data
 */
export declare function getQuantileDomain(data: any[], valueAccessor?: dataValueAccessor, sortFunc?: sort): number[];
/**
 * return ordinal domain for a data container
 */
export declare function getOrdinalDomain(dataContainer: DataContainerInterface, valueAccessor: dataContainerValueAccessor): string[];
/**
 * return linear domain for an array of data
 */
export declare function getLinearDomain(data: number[], valueAccessor?: dataValueAccessor): [number, number];
/**
 * return linear domain for an array of data. A log scale domain cannot contain 0
 */
export declare function getLogDomain(data: any[], valueAccessor: dataValueAccessor): [number, number];
export declare type DomainStops = {
    stops: number[];
    z: number[];
};
/**
 * whether field domain is stops
 */
export declare function isDomainStops(domain: unknown): domain is DomainStops;
export declare type DomainQuantiles = {
    quantiles: number[];
    z: number[];
};
/**
 * whether field domain is quantiles
 */
export declare function isDomainQuantile(domain: any): domain is DomainQuantiles;
/**
 * get the domain at zoom
 */
export declare function getThresholdsFromQuantiles(quantiles: number[], buckets: number): (number | undefined)[];
/**
 * get the domain at zoom
 */
export declare function getDomainStepsbyZoom(domain: any[], steps: number[], z: number): any;
/**
 * Get d3 scale function
 */
export declare function getScaleFunction(scale: string, range: any[] | IterableIterator<any>, domain: (number | undefined)[] | string[] | IterableIterator<any>, fixed?: boolean): D3ScaleFunction;
/**
 * Get linear / quant scale color breaks
 */
export declare function getQuantLegends(scale: D3ScaleFunction, labelFormat: LabelFormat): ColorBreak[];
/**
 * Get ordinal color scale legends
 */
export declare function getOrdinalLegends(scale: D3ScaleFunction): ColorBreakOrdinal[];
export declare function getQuantLabelFormat(domain: any, fieldType: any): (d: any) => any;
/**
 * Get legends for scale
 */
export declare function getLegendOfScale({ scale, scaleType, labelFormat, fieldType }: {
    scale?: D3ScaleFunction | null;
    scaleType: string;
    labelFormat?: LabelFormat;
    fieldType: string | null | undefined;
}): ColorBreak[] | ColorBreakOrdinal[];
/**
 * Get color scale function
 */
export declare function getLayerColorScale({ range, domain, scaleType, layer }: {
    range: ColorRange | null | undefined;
    domain: VisualChannelDomain;
    scaleType: string;
    layer: Layer;
    isFixed?: boolean;
}): D3ScaleFunction | null;
/**
 * Convert colorRange.colorMap into color breaks UI input
 */
export declare function initializeLayerColorMap(layer: Layer, visualChannel: VisualChannel): ColorMap;
/**
 * Get visual chanel scale function if it's based on zoom
 */
export declare function getVisualChannelScaleByZoom({ scale, layer, mapState }: {
    scale: D3ScaleFunction | null;
    layer: Layer;
    mapState?: MapState;
}): D3ScaleFunction | null;
/**
 * Get categorical colorMap from colors and domain (unique values)
 */
export declare function getCategoricalColorMap(colors: string[], domain: (string | number | string[] | number[] | null)[]): any;
/**
 * Get categorical colorBreaks from colorMap
 */
export declare function colorMapToCategoricalColorBreaks(colorMap?: ColorMap | null): ColorBreakOrdinal[] | null;
/**
 * create categorical colorMap from colorBreaks
 */
export declare function colorBreaksToCategoricalColorMap(colorBreaks: ColorBreakOrdinal[]): ColorMap;
/**
 * Convert color breaks UI input into colorRange.colorMap
 */
export declare function colorBreaksToColorMap(colorBreaks: ColorBreak[] | ColorBreakOrdinal[]): ColorMap;
/**
 * Convert colorRange.colorMap into color breaks UI input
 */
export declare function colorMapToColorBreaks(colorMap?: ColorMap | null): ColorBreak[] | null;
/**
 * Whether color breaks is for numeric field
 */
export declare function isNumericColorBreaks(colorBreaks: unknown): colorBreaks is ColorBreak[];
export declare function getHistogramDomain({ aggregatedBins, columnStats, dataset, fieldValueAccessor }: {
    aggregatedBins?: AggregatedBin[];
    columnStats?: FilterProps['columnStats'];
    dataset?: KeplerTable;
    fieldValueAccessor: (idx: unknown) => number;
}): any[];
export declare function resetCategoricalColorMapByIndex(colorMap: ColorMap, index: number): any;
/**
 * select rest categorical values for a colorMap by its index
 */
export declare function selectRestCategoricalColorMapByIndex(colorMap: ColorMap | null, index: number, uniqueValues?: number[] | string[]): ColorMap | undefined | null;
/**
 * remove a categorical value from a colorMap by its index
 */
export declare function removeCategoricalValueFromColorMap(colorMap: ColorMap | null | undefined, item: number | string, index: number): ColorMap | null | undefined;
/**
 * add categorical values (from multisel dropdown) to a colorMap by its index
 */
export declare function addCategoricalValuesToColorMap(colorMap: ColorMap, items: (string | number)[], index: number): ColorMap;
/**
 * get a color scale func for categorical (custom ordinal) scale
 */
export declare function getCategoricalColorScale(colorDomain: number[] | string[], colorRange: ColorRange, useRgb?: boolean): (categoryValue: string | number) => RGBColor | RGBAColor;
/**
 * initialize customPalette by custom scale or customOrdinal scale
 */
export declare function initCustomPaletteByCustomScale({ scale, field, ordinalDomain, range, colorBreaks }: {
    scale: string;
    field: Field;
    ordinalDomain?: number[] | string[];
    range: ColorRange;
    colorBreaks: ColorBreakOrdinal[] | null;
}): ColorUI['customPalette'];
export {};
