"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.MAX_CACHE_SIZE_MOBILE = exports.DEFAULT_STROKE_WIDTH = exports.DEFAULT_HIGHLIGHT_STROKE_COLOR = exports.DEFAULT_HIGHLIGHT_FILL_COLOR = void 0;
exports.tileLayerBoundsLayer = tileLayerBoundsLayer;
exports.vectorTileVisConfigs = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typed = require("@deck.gl/layers/typed");
var _mvt = require("@loaders.gl/mvt");
var _pmtiles = require("@loaders.gl/pmtiles");
var _constants = _interopRequireDefault(require("@luma.gl/constants"));
var _commonUtils = require("@kepler.gl/common-utils");
var _constants2 = require("@kepler.gl/constants");
var _table = require("@kepler.gl/table");
var _mvtLayer = require("./mvt-layer");
var _vectorTileIcon = _interopRequireDefault(require("./vector-tile-icon"));
var _baseLayer = _interopRequireDefault(require("../base-layer"));
var _abstractTileLayer = _interopRequireWildcard(require("./abstract-tile-layer"));
var _tileDataset = _interopRequireDefault(require("./common-tile/tile-dataset"));
var _tileUtils = require("./common-tile/tile-utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, e, r, o) { var p = (0, _get2["default"])((0, _getPrototypeOf2["default"])(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var DEFAULT_HIGHLIGHT_FILL_COLOR = exports.DEFAULT_HIGHLIGHT_FILL_COLOR = [252, 242, 26, 150];
var DEFAULT_HIGHLIGHT_STROKE_COLOR = exports.DEFAULT_HIGHLIGHT_STROKE_COLOR = [252, 242, 26, 255];
var MAX_CACHE_SIZE_MOBILE = exports.MAX_CACHE_SIZE_MOBILE = 1; // Minimize caching, visible tiles will always be loaded
var DEFAULT_STROKE_WIDTH = exports.DEFAULT_STROKE_WIDTH = 1;

/**
 * Type for transformRequest returned parameters.
 */

// This type *seems* to be what loaders.gl currently returns for tile content.
// Apparently this might be different depending on the loaders version, and for...
// reasons we use two different versions of loaders right now.
// TODO: The Features[] version should not be needed when we update to a newer
// version of Deck.gl and use only one version of loaders

var vectorTileVisConfigs = exports.vectorTileVisConfigs = _objectSpread(_objectSpread({}, _abstractTileLayer.commonTileVisConfigs), {}, {
  stroked: _objectSpread(_objectSpread({}, _constants2.LAYER_VIS_CONFIGS.stroked), {}, {
    defaultValue: false
  }),
  // TODO figure out why strokeColorScale can't be const
  strokeColorScale: 'strokeColorScale',
  strokeColorRange: 'strokeColorRange',
  sizeRange: 'strokeWidthRange',
  strokeWidth: _objectSpread(_objectSpread({}, _constants2.LAYER_VIS_CONFIGS.thickness), {}, {
    property: 'strokeWidth',
    defaultValue: 0.5,
    allowCustomValue: false
  }),
  radiusScale: 'radiusScale',
  radiusRange: _objectSpread(_objectSpread({}, _constants2.LAYER_VIS_CONFIGS.radiusRange), {}, {
    type: 'number',
    defaultValue: [0, 1],
    isRanged: true,
    range: [0, 1],
    step: 0.01
  })
});
function tileLayerBoundsLayer(id, props) {
  var bounds = props.bounds;
  if ((bounds === null || bounds === void 0 ? void 0 : bounds.length) !== 4) return [];
  var data = [{
    path: [[bounds[0], bounds[1]], [bounds[2], bounds[1]], [bounds[2], bounds[3]], [bounds[0], bounds[3]], [bounds[0], bounds[1]]]
  }];
  var layer = new _typed.PathLayer({
    id: "".concat(id, "-vector-tile-bounds"),
    data: data,
    getPath: function getPath(d) {
      return d.path;
    },
    getColor: [128, 128, 128, 255],
    getWidth: 1,
    widthUnits: 'pixels',
    pickable: false
  });
  return [layer];
}
var VectorTileLayer = exports["default"] = /*#__PURE__*/function (_AbstractTileLayer) {
  function VectorTileLayer(props) {
    var _this;
    (0, _classCallCheck2["default"])(this, VectorTileLayer);
    _this = _callSuper(this, VectorTileLayer, [props]);
    (0, _defineProperty2["default"])(_this, "meta", {});
    _this.registerVisConfig(vectorTileVisConfigs);
    _this.tileDataset = _this.initTileDataset();
    return _this;
  }
  (0, _inherits2["default"])(VectorTileLayer, _AbstractTileLayer);
  return (0, _createClass2["default"])(VectorTileLayer, [{
    key: "initTileDataset",
    value: function initTileDataset() {
      return new _tileDataset["default"]({
        getTileId: function getTileId(tile) {
          return tile.id;
        },
        getIterable: function getIterable(tile) {
          if (tile.content) {
            return tile.content.shape === 'geojson-table' ? tile.content.features : tile.content;
          }
          return [];
        },
        getRowCount: function getRowCount(features) {
          return features.length;
        },
        getRowValue: this.accessRowValue
      });
    }
  }, {
    key: "type",
    get: function get() {
      return _constants2.LAYER_TYPES.vectorTile;
    }
  }, {
    key: "name",
    get: function get() {
      return 'Vector Tile';
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _vectorTileIcon["default"];
    }
  }, {
    key: "supportedDatasetTypes",
    get: function get() {
      return [_constants2.DatasetType.VECTOR_TILE];
    }
  }, {
    key: "visualChannels",
    get: function get() {
      var visualChannels = _superPropGet(VectorTileLayer, "visualChannels", this, 1);
      return _objectSpread(_objectSpread({}, visualChannels), {}, {
        strokeColor: {
          property: 'strokeColor',
          field: 'strokeColorField',
          scale: 'strokeColorScale',
          domain: 'strokeColorDomain',
          range: 'strokeColorRange',
          key: 'strokeColor',
          channelScaleType: _constants2.CHANNEL_SCALES.color,
          accessor: 'getLineColor',
          condition: function condition(config) {
            return config.visConfig.stroked;
          },
          nullValue: visualChannels.color.nullValue,
          getAttributeValue: function getAttributeValue(config) {
            return config.visConfig.strokeColor || config.color;
          }
        },
        size: {
          property: 'stroke',
          field: 'sizeField',
          scale: 'sizeScale',
          domain: 'sizeDomain',
          range: 'sizeRange',
          key: 'size',
          channelScaleType: _constants2.CHANNEL_SCALES.size,
          nullValue: 0,
          accessor: 'getLineWidth',
          condition: function condition(config) {
            return config.visConfig.stroked;
          },
          getAttributeValue: function getAttributeValue(config) {
            return config.visConfig.strokeWidth || DEFAULT_STROKE_WIDTH;
          }
        },
        radius: {
          property: 'radius',
          field: 'radiusField',
          scale: 'radiusScale',
          domain: 'radiusDomain',
          range: 'radiusRange',
          key: 'radius',
          channelScaleType: _constants2.CHANNEL_SCALES.size,
          nullValue: 0,
          getAttributeValue: function getAttributeValue(config) {
            return config.visConfig.radius || config.radius;
          },
          accessor: 'getPointRadius',
          defaultValue: function defaultValue(config) {
            return config.radius;
          }
        }
      });
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      var defaultLayerConfig = _superPropGet(VectorTileLayer, "getDefaultLayerConfig", this, 3)([props]);
      return _objectSpread(_objectSpread({}, defaultLayerConfig), {}, {
        colorScale: _constants2.SCALE_TYPES.quantize,
        strokeColorField: null,
        strokeColorDomain: [0, 1],
        strokeColorScale: _constants2.SCALE_TYPES.quantile,
        colorUI: _objectSpread(_objectSpread({}, defaultLayerConfig.colorUI), {}, {
          // @ts-expect-error LayerConfig
          strokeColorRange: _constants2.DEFAULT_COLOR_UI
        }),
        radiusField: null,
        radiusDomain: [0, 1],
        radiusScale: _constants2.SCALE_TYPES.linear
      });
    }
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer, fields) {
      return fields.map(function (f) {
        var _object$properties$f$, _object$properties;
        return (_object$properties$f$ = (_object$properties = object.properties) === null || _object$properties === void 0 ? void 0 : _object$properties[f.name]) !== null && _object$properties$f$ !== void 0 ? _object$properties$f$ : null;
      });
    }
  }, {
    key: "calculateLayerDomain",
    value: function calculateLayerDomain(dataset, visualChannel) {
      var _field$filterProps, _field$filterProps2, _field$filterProps3;
      var defaultDomain = [0, 1];
      var field = this.config[visualChannel.field];
      var scale = this.config[visualChannel.scale];
      if (!field) {
        // if colorField or sizeField were set back to null
        return defaultDomain;
      }
      if (scale === _constants2.SCALE_TYPES.quantile && (0, _tileUtils.isDomainQuantiles)(field === null || field === void 0 || (_field$filterProps = field.filterProps) === null || _field$filterProps === void 0 ? void 0 : _field$filterProps.domainQuantiles)) {
        return field.filterProps.domainQuantiles;
      }
      if ((0, _tileUtils.isDomainStops)(field === null || field === void 0 || (_field$filterProps2 = field.filterProps) === null || _field$filterProps2 === void 0 ? void 0 : _field$filterProps2.domainStops)) {
        return field.filterProps.domainStops;
      } else if (Array.isArray(field === null || field === void 0 || (_field$filterProps3 = field.filterProps) === null || _field$filterProps3 === void 0 ? void 0 : _field$filterProps3.domain)) {
        return field.filterProps.domain;
      }
      return defaultDomain;
    }
  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channelKey) {
      var _field$filterProps4;
      var options = _baseLayer["default"].prototype.getScaleOptions.call(this, channelKey);
      var channel = this.visualChannels.strokeColor;
      var field = this.config[channel.field];
      if (!((0, _tileUtils.isDomainQuantiles)(field === null || field === void 0 || (_field$filterProps4 = field.filterProps) === null || _field$filterProps4 === void 0 ? void 0 : _field$filterProps4.domainQuantiles) || this.config.visConfig.dynamicColor ||
      // If we've set the scale to quantile, we need to include it - there's a loading
      // period in which the visConfig isn't set yet, but if we don't return the right
      // scale type we lose it
      this.config.colorScale === _constants2.SCALE_TYPES.quantile)) {
        options = options.filter(function (scale) {
          return scale !== _constants2.SCALE_TYPES.quantile;
        });
      }
      return options;
    }
  }, {
    key: "accessRowValue",
    value: function accessRowValue(field, indexKey) {
      // if is indexed field
      if ((0, _tileUtils.isIndexedField)(field) && indexKey !== null) {
        var _field$indexBy;
        var fieldName = indexKey && (field === null || field === void 0 || (_field$indexBy = field.indexBy) === null || _field$indexBy === void 0 ? void 0 : _field$indexBy.mappedValue[indexKey]);
        if (fieldName) {
          return function (f, datum) {
            if (datum.properties) {
              return datum.properties[fieldName];
            }
            // TODO debug this with indexed tiled dataset
            return datum[fieldName];
          };
        }
      }

      // default
      return function (f, datum) {
        if (f && datum.properties) {
          return datum.properties[f.name];
        }
        // support picking & highlighting
        return f ? datum[f.fieldIdx] : null;
      };
    }
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataset, datasets) {
      if (dataset.type !== _constants2.DatasetType.VECTOR_TILE) {
        return;
      }
      var datasetMeta = dataset.metadata;
      this.updateMeta({
        datasetId: dataset.id,
        datasets: datasets,
        bounds: datasetMeta.bounds
      });
    }
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData, animationConfig) {
      var dataId = this.config.dataId;
      if (!(0, _commonUtils.notNullorUndefined)(dataId)) {
        return {
          tileSource: null
        };
      }
      var dataset = datasets[dataId];
      var tilesetDataUrl;
      var tileSource = null;
      if ((dataset === null || dataset === void 0 ? void 0 : dataset.type) === _constants2.DatasetType.VECTOR_TILE) {
        var datasetMetadata = dataset.metadata;
        var remoteTileFormat = datasetMetadata === null || datasetMetadata === void 0 ? void 0 : datasetMetadata.remoteTileFormat;
        if (remoteTileFormat === _constants2.RemoteTileFormat.MVT) {
          var _datasetMetadata$tile;
          var transformFetch = /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(input, init) {
              var requestData;
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    requestData = {
                      url: input,
                      searchParams: new URLSearchParams(),
                      options: init !== null && init !== void 0 ? init : {}
                    };
                    return _context.abrupt("return", fetch(requestData.url, requestData.options));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function transformFetch(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          tilesetDataUrl = datasetMetadata === null || datasetMetadata === void 0 ? void 0 : datasetMetadata.tilesetDataUrl;
          tileSource = tilesetDataUrl ? _mvt.MVTSource.createDataSource(decodeURIComponent(tilesetDataUrl), {
            mvt: {
              metadataUrl: (_datasetMetadata$tile = datasetMetadata === null || datasetMetadata === void 0 ? void 0 : datasetMetadata.tilesetMetadataUrl) !== null && _datasetMetadata$tile !== void 0 ? _datasetMetadata$tile : null,
              loadOptions: {
                fetch: transformFetch
              }
            }
          }) : null;
        } else if (remoteTileFormat === _constants2.RemoteTileFormat.PMTILES) {
          // TODO: to render image pmtiles need to use TileLayer and BitmapLayer (https://github.com/visgl/loaders.gl/blob/master/examples/website/tiles/components/tile-source-layer.ts)
          tilesetDataUrl = datasetMetadata === null || datasetMetadata === void 0 ? void 0 : datasetMetadata.tilesetDataUrl;
          tileSource = tilesetDataUrl ? _pmtiles.PMTilesSource.createDataSource(tilesetDataUrl, {}) : null;
        }
      }
      return _objectSpread(_objectSpread({}, _superPropGet(VectorTileLayer, "formatLayerData", this, 3)([datasets, oldLayerData, animationConfig])), {}, {
        tilesetDataUrl: typeof tilesetDataUrl === 'string' ? (0, _table.getTileUrl)(tilesetDataUrl) : null,
        tileSource: tileSource
      });
    }
  }, {
    key: "hasHoveredObject",
    value: function hasHoveredObject(objectInfo) {
      if (_superPropGet(VectorTileLayer, "hasHoveredObject", this, 3)([objectInfo])) {
        var _objectInfo$tile;
        var features = objectInfo === null || objectInfo === void 0 || (_objectInfo$tile = objectInfo.tile) === null || _objectInfo$tile === void 0 || (_objectInfo$tile = _objectInfo$tile.content) === null || _objectInfo$tile === void 0 ? void 0 : _objectInfo$tile.features;
        return features[objectInfo.index];
      }
      return null;
    }
  }, {
    key: "renderSubLayers",
    value: function renderSubLayers(props) {
      var _data, _data2;
      var data = props.data;
      data = ((_data = data) === null || _data === void 0 ? void 0 : _data.shape) === 'geojson-table' ? data.features : data;
      if (!((_data2 = data) !== null && _data2 !== void 0 && _data2.length)) {
        return [];
      }
      var tile = props.tile;
      var zoom = tile.index.z;
      return new _typed.GeoJsonLayer(_objectSpread(_objectSpread({}, props), {}, {
        data: data,
        getFillColor: props.getFillColorByZoom ? props.getFillColor(zoom) : props.getFillColor,
        getElevation: props.getElevationByZoom ? props.getElevation(zoom) : props.getElevation,
        // radius for points
        pointRadiusScale: props.pointRadiusScale,
        // props.getPointRadiusScaleByZoom(zoom),
        pointRadiusUnits: props.pointRadiusUnits,
        getPointRadius: props.getPointRadius,
        // For some reason tile Layer reset autoHighlight to false
        pickable: true,
        autoHighlight: true,
        stroked: props.stroked,
        // wrapLongitude: true causes missing side polygon when extrude is enabled
        wrapLongitude: false
      }));
    }

    // generate a deck layer
  }, {
    key: "renderLayer",
    value: function renderLayer(opts) {
      var mapState = opts.mapState,
        data = opts.data,
        animationConfig = opts.animationConfig,
        gpuFilter = opts.gpuFilter,
        objectHovered = opts.objectHovered,
        layerCallbacks = opts.layerCallbacks;
      var _this$config = this.config,
        animation = _this$config.animation,
        visConfig = _this$config.visConfig;
      this.setLayerDomain = layerCallbacks.onSetLayerDomain;
      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);
      var eleZoomFactor = this.getElevationZoomFactor(mapState);
      var transitions = this.config.visConfig.transition ? {
        getFillColor: {
          duration: animationConfig.duration
        },
        getElevation: {
          duration: animationConfig.duration
        }
      } : undefined;
      var colorField = this.config.colorField;
      var heightField = this.config.heightField;
      var strokeColorField = this.config.strokeColorField;
      var sizeField = this.config.sizeField;
      var radiusField = this.config.radiusField;
      if (data.tileSource) {
        var _data$tileSource, _objectHovered$source;
        var hoveredObject = this.hasHoveredObject(objectHovered);
        var layers = [new _mvtLayer.MVTLayer(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), data), {}, {
          onViewportLoad: this.onViewportLoad,
          data: data.tilesetDataUrl,
          getTileData: (_data$tileSource = data.tileSource) === null || _data$tileSource === void 0 ? void 0 : _data$tileSource.getTileData,
          tileSource: data.tileSource,
          getFilterValue: this.getGpuFilterValueAccessor(opts),
          filterRange: gpuFilter.filterRange,
          lineWidthUnits: 'pixels',
          binary: false,
          elevationScale: visConfig.elevationScale * eleZoomFactor,
          extruded: visConfig.enable3d,
          stroked: visConfig.stroked,
          // TODO: this is hard coded, design a UI to allow user assigned unique property id
          // uniqueIdProperty: 'ufid',
          renderSubLayers: this.renderSubLayers,
          // when radiusUnits is meter
          getPointRadiusScaleByZoom: (0, _tileUtils.getPropertyByZoom)(visConfig.radiusByZoom, visConfig.radius),
          pointRadiusUnits: visConfig.radiusUnits ? 'pixels' : 'meters',
          pointRadiusScale: radiusField ? visConfig.radius : 1,
          pointRadiusMinPixels: 1,
          autoHighlight: true,
          highlightColor: DEFAULT_HIGHLIGHT_FILL_COLOR,
          pickable: true,
          transitions: transitions,
          updateTriggers: {
            getFilterValue: _objectSpread(_objectSpread({}, gpuFilter.filterValueUpdateTriggers), {}, {
              currentTime: animation.enabled ? animationConfig.currentTime : null
            }),
            getFillColor: {
              color: this.config.color,
              colorField: this.config.colorField,
              colorScale: this.config.colorScale,
              colorDomain: this.config.colorDomain,
              colorRange: visConfig.colorRange,
              currentTime: (0, _tileUtils.isIndexedField)(colorField) ? animationConfig.currentTime : null
            },
            getElevation: {
              heightField: this.config.heightField,
              heightScaleType: this.config.heightScale,
              heightRange: visConfig.heightRange,
              currentTime: (0, _tileUtils.isIndexedField)(heightField) ? animationConfig.currentTime : null
            },
            getLineColor: {
              strokeColor: visConfig.strokeColor,
              strokeColorField: this.config.strokeColorField,
              // @ts-expect-error prop not in LayerConfig
              strokeColorScale: this.config.strokeColorScale,
              // @ts-expect-error prop not in LayerConfig
              strokeColorDomain: this.config.strokeColorDomain,
              // FIXME: Strip out empty arrays from individual color map steps, and replace with `null`, otherwise the layer may show the incorrect color.
              // So far it seems that it uses the previous color chosen in the palette rather than the currently chosen color for the specific custom ordinal value when there are "sparse" color maps.
              // In other words, a color map with "holes" of colors with unassigned field values, which may have been assigned in the past.
              // For example "abc" was green, stored as `["abc"]`. Then "abc" was reassigned to the red color map step, stored as `["abc"]`. Now the green color map step's stored value is `[]`, and the layer will incorrectly still render "abc" in green.
              // Quick patch example:
              // strokeColorRange: visConfig?.strokeColorRange?.colorMap?.map(cm =>
              //   cm[0]?.length === 0 ? [null, cm[1]] : cm
              // ),
              // Note: for regular scales the colorMap in the above patch is undefined and breaks strokeColorRange update trigger.
              strokeColorRange: visConfig.strokeColorRange,
              currentTime: (0, _tileUtils.isIndexedField)(strokeColorField) ? animationConfig.currentTime : null
            },
            getLineWidth: {
              sizeRange: visConfig.sizeRange,
              strokeWidth: visConfig.strokeWidth,
              sizeField: this.config.sizeField,
              sizeScale: this.config.sizeScale,
              sizeDomain: this.config.sizeDomain,
              currentTime: (0, _tileUtils.isIndexedField)(sizeField) ? animationConfig.currentTime : null
            },
            getPointRadius: {
              radius: visConfig.radius,
              radiusField: this.config.radiusField,
              radiusScale: this.config.radiusScale,
              radiusDomain: this.config.radiusDomain,
              radiusRange: this.config.radiusRange,
              currentTime: (0, _tileUtils.isIndexedField)(radiusField) ? animationConfig.currentTime : null
            }
          },
          _subLayerProps: {
            'polygons-stroke': {
              opacity: visConfig.strokeOpacity
            },
            'polygons-fill': {
              parameters: {
                cullFace: _constants["default"].BACK
              }
            }
          },
          loadOptions: {
            mvt: (0, _table.getLoaderOptions)().mvt
          }
        }))].concat((0, _toConsumableArray2["default"])(hoveredObject ? [new _typed.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread({}, (_objectHovered$source = objectHovered.sourceLayer) === null || _objectHovered$source === void 0 ? void 0 : _objectHovered$source.props), this.getDefaultHoverLayerProps()), {}, {
          visible: true,
          wrapLongitude: false,
          data: [hoveredObject],
          getLineColor: DEFAULT_HIGHLIGHT_STROKE_COLOR,
          getFillColor: DEFAULT_HIGHLIGHT_FILL_COLOR,
          getLineWidth: visConfig.strokeWidth + 1,
          lineWidthUnits: 'pixels',
          stroked: true,
          filled: true
        }))] : []));
        return layers;
      }
      return [];
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(dataset) {
      if (dataset.type !== _constants2.DatasetType.VECTOR_TILE) {
        return {
          props: []
        };
      }
      return _superPropGet(VectorTileLayer, "findDefaultLayerProps", this, 2)([dataset]);
    }
  }]);
}(_abstractTileLayer["default"]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfdHlwZWQiLCJyZXF1aXJlIiwiX212dCIsIl9wbXRpbGVzIiwiX2NvbnN0YW50cyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY29tbW9uVXRpbHMiLCJfY29uc3RhbnRzMiIsIl90YWJsZSIsIl9tdnRMYXllciIsIl92ZWN0b3JUaWxlSWNvbiIsIl9iYXNlTGF5ZXIiLCJfYWJzdHJhY3RUaWxlTGF5ZXIiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl90aWxlRGF0YXNldCIsIl90aWxlVXRpbHMiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfY2FsbFN1cGVyIiwibyIsIl9nZXRQcm90b3R5cGVPZjIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImNvbnN0cnVjdG9yIiwiYXBwbHkiLCJCb29sZWFuIiwicHJvdG90eXBlIiwidmFsdWVPZiIsIl9zdXBlclByb3BHZXQiLCJwIiwiX2dldDIiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImVudW1lcmFibGUiLCJwdXNoIiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJERUZBVUxUX0hJR0hMSUdIVF9GSUxMX0NPTE9SIiwiZXhwb3J0cyIsIkRFRkFVTFRfSElHSExJR0hUX1NUUk9LRV9DT0xPUiIsIk1BWF9DQUNIRV9TSVpFX01PQklMRSIsIkRFRkFVTFRfU1RST0tFX1dJRFRIIiwidmVjdG9yVGlsZVZpc0NvbmZpZ3MiLCJjb21tb25UaWxlVmlzQ29uZmlncyIsInN0cm9rZWQiLCJMQVlFUl9WSVNfQ09ORklHUyIsImRlZmF1bHRWYWx1ZSIsInN0cm9rZUNvbG9yU2NhbGUiLCJzdHJva2VDb2xvclJhbmdlIiwic2l6ZVJhbmdlIiwic3Ryb2tlV2lkdGgiLCJ0aGlja25lc3MiLCJwcm9wZXJ0eSIsImFsbG93Q3VzdG9tVmFsdWUiLCJyYWRpdXNTY2FsZSIsInJhZGl1c1JhbmdlIiwidHlwZSIsImlzUmFuZ2VkIiwicmFuZ2UiLCJzdGVwIiwidGlsZUxheWVyQm91bmRzTGF5ZXIiLCJpZCIsInByb3BzIiwiYm91bmRzIiwiZGF0YSIsInBhdGgiLCJsYXllciIsIlBhdGhMYXllciIsImNvbmNhdCIsImdldFBhdGgiLCJkIiwiZ2V0Q29sb3IiLCJnZXRXaWR0aCIsIndpZHRoVW5pdHMiLCJwaWNrYWJsZSIsIlZlY3RvclRpbGVMYXllciIsIl9BYnN0cmFjdFRpbGVMYXllciIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrMiIsInJlZ2lzdGVyVmlzQ29uZmlnIiwidGlsZURhdGFzZXQiLCJpbml0VGlsZURhdGFzZXQiLCJfaW5oZXJpdHMyIiwiX2NyZWF0ZUNsYXNzMiIsImtleSIsInZhbHVlIiwiVGlsZURhdGFzZXQiLCJnZXRUaWxlSWQiLCJ0aWxlIiwiZ2V0SXRlcmFibGUiLCJjb250ZW50Iiwic2hhcGUiLCJmZWF0dXJlcyIsImdldFJvd0NvdW50IiwiZ2V0Um93VmFsdWUiLCJhY2Nlc3NSb3dWYWx1ZSIsIkxBWUVSX1RZUEVTIiwidmVjdG9yVGlsZSIsIlZlY3RvclRpbGVJY29uIiwiRGF0YXNldFR5cGUiLCJWRUNUT1JfVElMRSIsInZpc3VhbENoYW5uZWxzIiwic3Ryb2tlQ29sb3IiLCJmaWVsZCIsInNjYWxlIiwiZG9tYWluIiwiY2hhbm5lbFNjYWxlVHlwZSIsIkNIQU5ORUxfU0NBTEVTIiwiY29sb3IiLCJhY2Nlc3NvciIsImNvbmRpdGlvbiIsImNvbmZpZyIsInZpc0NvbmZpZyIsIm51bGxWYWx1ZSIsImdldEF0dHJpYnV0ZVZhbHVlIiwic2l6ZSIsInJhZGl1cyIsImdldERlZmF1bHRMYXllckNvbmZpZyIsImRlZmF1bHRMYXllckNvbmZpZyIsImNvbG9yU2NhbGUiLCJTQ0FMRV9UWVBFUyIsInF1YW50aXplIiwic3Ryb2tlQ29sb3JGaWVsZCIsInN0cm9rZUNvbG9yRG9tYWluIiwicXVhbnRpbGUiLCJjb2xvclVJIiwiREVGQVVMVF9DT0xPUl9VSSIsInJhZGl1c0ZpZWxkIiwicmFkaXVzRG9tYWluIiwibGluZWFyIiwiZ2V0SG92ZXJEYXRhIiwib2JqZWN0IiwiZGF0YUNvbnRhaW5lciIsImZpZWxkcyIsIm1hcCIsImYiLCJfb2JqZWN0JHByb3BlcnRpZXMkZiQiLCJfb2JqZWN0JHByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwibmFtZSIsImNhbGN1bGF0ZUxheWVyRG9tYWluIiwiZGF0YXNldCIsInZpc3VhbENoYW5uZWwiLCJfZmllbGQkZmlsdGVyUHJvcHMiLCJfZmllbGQkZmlsdGVyUHJvcHMyIiwiX2ZpZWxkJGZpbHRlclByb3BzMyIsImRlZmF1bHREb21haW4iLCJpc0RvbWFpblF1YW50aWxlcyIsImZpbHRlclByb3BzIiwiZG9tYWluUXVhbnRpbGVzIiwiaXNEb21haW5TdG9wcyIsImRvbWFpblN0b3BzIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0U2NhbGVPcHRpb25zIiwiY2hhbm5lbEtleSIsIl9maWVsZCRmaWx0ZXJQcm9wczQiLCJvcHRpb25zIiwiS2VwbGVyTGF5ZXIiLCJjaGFubmVsIiwiZHluYW1pY0NvbG9yIiwiaW5kZXhLZXkiLCJpc0luZGV4ZWRGaWVsZCIsIl9maWVsZCRpbmRleEJ5IiwiZmllbGROYW1lIiwiaW5kZXhCeSIsIm1hcHBlZFZhbHVlIiwiZGF0dW0iLCJmaWVsZElkeCIsInVwZGF0ZUxheWVyTWV0YSIsImRhdGFzZXRzIiwiZGF0YXNldE1ldGEiLCJtZXRhZGF0YSIsInVwZGF0ZU1ldGEiLCJkYXRhc2V0SWQiLCJmb3JtYXRMYXllckRhdGEiLCJvbGRMYXllckRhdGEiLCJhbmltYXRpb25Db25maWciLCJkYXRhSWQiLCJub3ROdWxsb3JVbmRlZmluZWQiLCJ0aWxlU291cmNlIiwidGlsZXNldERhdGFVcmwiLCJkYXRhc2V0TWV0YWRhdGEiLCJyZW1vdGVUaWxlRm9ybWF0IiwiUmVtb3RlVGlsZUZvcm1hdCIsIk1WVCIsIl9kYXRhc2V0TWV0YWRhdGEkdGlsZSIsInRyYW5zZm9ybUZldGNoIiwiX3JlZiIsIl9hc3luY1RvR2VuZXJhdG9yMiIsIl9yZWdlbmVyYXRvciIsIm1hcmsiLCJfY2FsbGVlIiwiaW5wdXQiLCJpbml0IiwicmVxdWVzdERhdGEiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwidXJsIiwic2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYWJydXB0IiwiZmV0Y2giLCJzdG9wIiwiX3giLCJfeDIiLCJNVlRTb3VyY2UiLCJjcmVhdGVEYXRhU291cmNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibXZ0IiwibWV0YWRhdGFVcmwiLCJ0aWxlc2V0TWV0YWRhdGFVcmwiLCJsb2FkT3B0aW9ucyIsIlBNVElMRVMiLCJQTVRpbGVzU291cmNlIiwiZ2V0VGlsZVVybCIsImhhc0hvdmVyZWRPYmplY3QiLCJvYmplY3RJbmZvIiwiX29iamVjdEluZm8kdGlsZSIsImluZGV4IiwicmVuZGVyU3ViTGF5ZXJzIiwiX2RhdGEiLCJfZGF0YTIiLCJ6b29tIiwieiIsIkdlb0pzb25MYXllciIsImdldEZpbGxDb2xvciIsImdldEZpbGxDb2xvckJ5Wm9vbSIsImdldEVsZXZhdGlvbiIsImdldEVsZXZhdGlvbkJ5Wm9vbSIsInBvaW50UmFkaXVzU2NhbGUiLCJwb2ludFJhZGl1c1VuaXRzIiwiZ2V0UG9pbnRSYWRpdXMiLCJhdXRvSGlnaGxpZ2h0Iiwid3JhcExvbmdpdHVkZSIsInJlbmRlckxheWVyIiwib3B0cyIsIm1hcFN0YXRlIiwiZ3B1RmlsdGVyIiwib2JqZWN0SG92ZXJlZCIsImxheWVyQ2FsbGJhY2tzIiwiX3RoaXMkY29uZmlnIiwiYW5pbWF0aW9uIiwic2V0TGF5ZXJEb21haW4iLCJvblNldExheWVyRG9tYWluIiwiZGVmYXVsdExheWVyUHJvcHMiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJlbGVab29tRmFjdG9yIiwiZ2V0RWxldmF0aW9uWm9vbUZhY3RvciIsInRyYW5zaXRpb25zIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwidW5kZWZpbmVkIiwiY29sb3JGaWVsZCIsImhlaWdodEZpZWxkIiwic2l6ZUZpZWxkIiwiX2RhdGEkdGlsZVNvdXJjZSIsIl9vYmplY3RIb3ZlcmVkJHNvdXJjZSIsImhvdmVyZWRPYmplY3QiLCJsYXllcnMiLCJDdXN0b21NVlRMYXllciIsIm9uVmlld3BvcnRMb2FkIiwiZ2V0VGlsZURhdGEiLCJnZXRGaWx0ZXJWYWx1ZSIsImdldEdwdUZpbHRlclZhbHVlQWNjZXNzb3IiLCJmaWx0ZXJSYW5nZSIsImxpbmVXaWR0aFVuaXRzIiwiYmluYXJ5IiwiZWxldmF0aW9uU2NhbGUiLCJleHRydWRlZCIsImVuYWJsZTNkIiwiZ2V0UG9pbnRSYWRpdXNTY2FsZUJ5Wm9vbSIsImdldFByb3BlcnR5Qnlab29tIiwicmFkaXVzQnlab29tIiwicmFkaXVzVW5pdHMiLCJwb2ludFJhZGl1c01pblBpeGVscyIsImhpZ2hsaWdodENvbG9yIiwidXBkYXRlVHJpZ2dlcnMiLCJmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzIiwiY3VycmVudFRpbWUiLCJlbmFibGVkIiwiY29sb3JEb21haW4iLCJjb2xvclJhbmdlIiwiaGVpZ2h0U2NhbGVUeXBlIiwiaGVpZ2h0U2NhbGUiLCJoZWlnaHRSYW5nZSIsImdldExpbmVDb2xvciIsImdldExpbmVXaWR0aCIsInNpemVTY2FsZSIsInNpemVEb21haW4iLCJfc3ViTGF5ZXJQcm9wcyIsIm9wYWNpdHkiLCJzdHJva2VPcGFjaXR5IiwicGFyYW1ldGVycyIsImN1bGxGYWNlIiwiR0wiLCJCQUNLIiwiZ2V0TG9hZGVyT3B0aW9ucyIsIl90b0NvbnN1bWFibGVBcnJheTIiLCJzb3VyY2VMYXllciIsImdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMiLCJ2aXNpYmxlIiwiZmlsbGVkIiwiZmluZERlZmF1bHRMYXllclByb3BzIiwiQWJzdHJhY3RUaWxlTGF5ZXIiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdmVjdG9yLXRpbGUvdmVjdG9yLXRpbGUtbGF5ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuaW1wb3J0IHtGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZX0gZnJvbSAnZ2VvanNvbic7XG5cbmltcG9ydCB7TGF5ZXIgYXMgRGVja0xheWVyfSBmcm9tICdAZGVjay5nbC9jb3JlL3R5cGVkJztcbmltcG9ydCB7X1RpbGUyREhlYWRlciBhcyBUaWxlMkRIZWFkZXJ9IGZyb20gJ0BkZWNrLmdsL2dlby1sYXllcnMvdHlwZWQnO1xuaW1wb3J0IHtHZW9Kc29uTGF5ZXIsIFBhdGhMYXllcn0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzL3R5cGVkJztcbmltcG9ydCB7TVZUU291cmNlLCBNVlRUaWxlU291cmNlfSBmcm9tICdAbG9hZGVycy5nbC9tdnQnO1xuaW1wb3J0IHtQTVRpbGVzU291cmNlLCBQTVRpbGVzVGlsZVNvdXJjZX0gZnJvbSAnQGxvYWRlcnMuZ2wvcG10aWxlcyc7XG5pbXBvcnQgR0wgZnJvbSAnQGx1bWEuZ2wvY29uc3RhbnRzJztcblxuaW1wb3J0IHtub3ROdWxsb3JVbmRlZmluZWR9IGZyb20gJ0BrZXBsZXIuZ2wvY29tbW9uLXV0aWxzJztcbmltcG9ydCB7XG4gIERhdGFzZXRUeXBlLFxuICBMQVlFUl9UWVBFUyxcbiAgUmVtb3RlVGlsZUZvcm1hdCxcbiAgVmVjdG9yVGlsZURhdGFzZXRNZXRhZGF0YSxcbiAgU0NBTEVfVFlQRVMsXG4gIENIQU5ORUxfU0NBTEVTLFxuICBERUZBVUxUX0NPTE9SX1VJLFxuICBMQVlFUl9WSVNfQ09ORklHU1xufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBnZXRUaWxlVXJsLFxuICBnZXRMb2FkZXJPcHRpb25zLFxuICBLZXBsZXJUYWJsZSBhcyBLZXBsZXJEYXRhc2V0LFxuICBEYXRhc2V0cyBhcyBLZXBsZXJEYXRhc2V0cyxcbiAgR3B1RmlsdGVyLFxuICBWZWN0b3JUaWxlTWV0YWRhdGFcbn0gZnJvbSAnQGtlcGxlci5nbC90YWJsZSc7XG5pbXBvcnQge1xuICBBbmltYXRpb25Db25maWcsXG4gIEZpZWxkIGFzIEtlcGxlckZpZWxkLFxuICBMYXllckNvbG9yQ29uZmlnLFxuICBMYXllckhlaWdodENvbmZpZyxcbiAgTWVyZ2UsXG4gIE1hcFN0YXRlLFxuICBCaW5kZWRMYXllckNhbGxiYWNrcyxcbiAgVmlzQ29uZmlnUmFuZ2UsXG4gIFZpc0NvbmZpZ051bWJlcixcbiAgRG9tYWluU3RvcHNcbn0gZnJvbSAnQGtlcGxlci5nbC90eXBlcyc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2V9IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5pbXBvcnQge01WVExheWVyIGFzIEN1c3RvbU1WVExheWVyfSBmcm9tICcuL212dC1sYXllcic7XG5pbXBvcnQgVmVjdG9yVGlsZUljb24gZnJvbSAnLi92ZWN0b3ItdGlsZS1pY29uJztcbmltcG9ydCB7XG4gIGRlZmF1bHQgYXMgS2VwbGVyTGF5ZXIsXG4gIExheWVyQmFzZUNvbmZpZyxcbiAgTGF5ZXJCYXNlQ29uZmlnUGFydGlhbCxcbiAgVmlzdWFsQ2hhbm5lbCxcbiAgVmlzdWFsQ2hhbm5lbERvbWFpbixcbiAgVmlzdWFsQ2hhbm5lbEZpZWxkXG59IGZyb20gJy4uL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IHtGaW5kRGVmYXVsdExheWVyUHJvcHNSZXR1cm5WYWx1ZX0gZnJvbSAnLi4vbGF5ZXItdXRpbHMnO1xuXG5pbXBvcnQgQWJzdHJhY3RUaWxlTGF5ZXIsIHtcbiAgTGF5ZXJEYXRhIGFzIENvbW1vbkxheWVyRGF0YSxcbiAgY29tbW9uVGlsZVZpc0NvbmZpZ3MsXG4gIEFic3RyYWN0VGlsZUxheWVyQ29uZmlnLFxuICBBYnN0cmFjdFRpbGVMYXllclZpc0NvbmZpZ1NldHRpbmdzXG59IGZyb20gJy4vYWJzdHJhY3QtdGlsZS1sYXllcic7XG5pbXBvcnQgVGlsZURhdGFzZXQgZnJvbSAnLi9jb21tb24tdGlsZS90aWxlLWRhdGFzZXQnO1xuaW1wb3J0IHtcbiAgaXNEb21haW5TdG9wcyxcbiAgaXNEb21haW5RdWFudGlsZXMsXG4gIGlzSW5kZXhlZEZpZWxkLFxuICBnZXRQcm9wZXJ0eUJ5Wm9vbVxufSBmcm9tICcuL2NvbW1vbi10aWxlL3RpbGUtdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9ISUdITElHSFRfRklMTF9DT0xPUiA9IFsyNTIsIDI0MiwgMjYsIDE1MF07XG5leHBvcnQgY29uc3QgREVGQVVMVF9ISUdITElHSFRfU1RST0tFX0NPTE9SID0gWzI1MiwgMjQyLCAyNiwgMjU1XTtcbmV4cG9ydCBjb25zdCBNQVhfQ0FDSEVfU0laRV9NT0JJTEUgPSAxOyAvLyBNaW5pbWl6ZSBjYWNoaW5nLCB2aXNpYmxlIHRpbGVzIHdpbGwgYWx3YXlzIGJlIGxvYWRlZFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU1RST0tFX1dJRFRIID0gMTtcblxuLyoqXG4gKiBUeXBlIGZvciB0cmFuc2Zvcm1SZXF1ZXN0IHJldHVybmVkIHBhcmFtZXRlcnMuXG4gKi9cbmV4cG9ydCB0eXBlIFJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAvKiogVGhlIFVSTCB0byBiZSByZXF1ZXN0ZWQuICovXG4gIHVybDogc3RyaW5nO1xuICAvKiogU2VhcmNoIHBhcmFtZXRlcnMgdG8gYmUgYWRkZWQgb250byB0aGUgVVJMLiAqL1xuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgLyoqIE9wdGlvbnMgcGFzc2VkIHRvIGZldGNoLiAqL1xuICBvcHRpb25zOiBSZXF1ZXN0SW5pdDtcbn07XG5cbi8vIFRoaXMgdHlwZSAqc2VlbXMqIHRvIGJlIHdoYXQgbG9hZGVycy5nbCBjdXJyZW50bHkgcmV0dXJucyBmb3IgdGlsZSBjb250ZW50LlxuLy8gQXBwYXJlbnRseSB0aGlzIG1pZ2h0IGJlIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gdGhlIGxvYWRlcnMgdmVyc2lvbiwgYW5kIGZvci4uLlxuLy8gcmVhc29ucyB3ZSB1c2UgdHdvIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBsb2FkZXJzIHJpZ2h0IG5vdy5cbi8vIFRPRE86IFRoZSBGZWF0dXJlc1tdIHZlcnNpb24gc2hvdWxkIG5vdCBiZSBuZWVkZWQgd2hlbiB3ZSB1cGRhdGUgdG8gYSBuZXdlclxuLy8gdmVyc2lvbiBvZiBEZWNrLmdsIGFuZCB1c2Ugb25seSBvbmUgdmVyc2lvbiBvZiBsb2FkZXJzXG50eXBlIFRpbGVDb250ZW50ID1cbiAgfCAoRmVhdHVyZUNvbGxlY3Rpb24gJiB7c2hhcGU6ICdnZW9qc29uLXRhYmxlJ30pXG4gIHwgKEZlYXR1cmVbXSAmIHtzaGFwZTogdW5kZWZpbmVkfSk7XG5cbnR5cGUgVmVjdG9yVGlsZSA9IFRpbGUyREhlYWRlcjxUaWxlQ29udGVudD47XG5cbnR5cGUgTGF5ZXJEYXRhID0gQ29tbW9uTGF5ZXJEYXRhICYge1xuICB0aWxlc2V0RGF0YVVybD86IHN0cmluZyB8IG51bGw7XG4gIHRpbGVTb3VyY2U6IE1WVFRpbGVTb3VyY2UgfCBQTVRpbGVzVGlsZVNvdXJjZSB8IG51bGw7XG59O1xuXG50eXBlIFZlY3RvclRpbGVMYXllclJlbmRlck9wdGlvbnMgPSBNZXJnZTxcbiAge1xuICAgIGlkeDogbnVtYmVyO1xuICAgIHZpc2libGU6IGJvb2xlYW47XG4gICAgbWFwU3RhdGU6IE1hcFN0YXRlO1xuICAgIGRhdGE6IGFueTtcbiAgICBhbmltYXRpb25Db25maWc6IEFuaW1hdGlvbkNvbmZpZztcbiAgICBncHVGaWx0ZXI6IEdwdUZpbHRlcjtcbiAgICBsYXllckNhbGxiYWNrczogQmluZGVkTGF5ZXJDYWxsYmFja3M7XG4gICAgb2JqZWN0SG92ZXJlZDoge1xuICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgIHRpbGU6IFZlY3RvclRpbGU7XG4gICAgICBzb3VyY2VMYXllcjogdHlwZW9mIEdlb0pzb25MYXllcjtcbiAgICB9O1xuICB9LFxuICBMYXllckRhdGFcbj47XG5cbmV4cG9ydCBjb25zdCB2ZWN0b3JUaWxlVmlzQ29uZmlncyA9IHtcbiAgLi4uY29tbW9uVGlsZVZpc0NvbmZpZ3MsXG5cbiAgc3Ryb2tlZDoge1xuICAgIC4uLkxBWUVSX1ZJU19DT05GSUdTLnN0cm9rZWQsXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuXG4gIC8vIFRPRE8gZmlndXJlIG91dCB3aHkgc3Ryb2tlQ29sb3JTY2FsZSBjYW4ndCBiZSBjb25zdFxuICBzdHJva2VDb2xvclNjYWxlOiAnc3Ryb2tlQ29sb3JTY2FsZScgYXMgYW55LFxuICBzdHJva2VDb2xvclJhbmdlOiAnc3Ryb2tlQ29sb3JSYW5nZScgYXMgY29uc3QsXG5cbiAgc2l6ZVJhbmdlOiAnc3Ryb2tlV2lkdGhSYW5nZScgYXMgY29uc3QsXG4gIHN0cm9rZVdpZHRoOiB7XG4gICAgLi4uTEFZRVJfVklTX0NPTkZJR1MudGhpY2tuZXNzLFxuICAgIHByb3BlcnR5OiAnc3Ryb2tlV2lkdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogMC41LFxuICAgIGFsbG93Q3VzdG9tVmFsdWU6IGZhbHNlXG4gIH0sXG5cbiAgcmFkaXVzU2NhbGU6ICdyYWRpdXNTY2FsZScgYXMgYW55LFxuICByYWRpdXNSYW5nZToge1xuICAgIC4uLkxBWUVSX1ZJU19DT05GSUdTLnJhZGl1c1JhbmdlLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGRlZmF1bHRWYWx1ZTogWzAsIDFdLFxuICAgIGlzUmFuZ2VkOiB0cnVlLFxuICAgIHJhbmdlOiBbMCwgMV0sXG4gICAgc3RlcDogMC4wMVxuICB9IGFzIFZpc0NvbmZpZ1JhbmdlXG59O1xuXG5leHBvcnQgdHlwZSBWZWN0b3JUaWxlTGF5ZXJDb25maWcgPSBNZXJnZTxcbiAgQWJzdHJhY3RUaWxlTGF5ZXJDb25maWcsXG4gIHtcbiAgICBzaXplRmllbGQ/OiBWaXN1YWxDaGFubmVsRmllbGQ7XG4gICAgc2l6ZVNjYWxlPzogc3RyaW5nO1xuICAgIHNpemVEb21haW4/OiBWaXN1YWxDaGFubmVsRG9tYWluO1xuXG4gICAgc3Ryb2tlQ29sb3JGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xuXG4gICAgcmFkaXVzRmllbGQ/OiBWaXN1YWxDaGFubmVsRmllbGQ7XG4gICAgcmFkaXVzU2NhbGU/OiBzdHJpbmc7XG4gICAgcmFkaXVzRG9tYWluPzogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgICByYWRpdXNSYW5nZT86IGFueTtcbiAgfVxuPjtcblxuZXhwb3J0IHR5cGUgVmVjdG9yVGlsZUxheWVyVmlzQ29uZmlnU2V0dGluZ3MgPSBNZXJnZTxcbiAgQWJzdHJhY3RUaWxlTGF5ZXJWaXNDb25maWdTZXR0aW5ncyxcbiAge1xuICAgIHNpemVSYW5nZTogVmlzQ29uZmlnUmFuZ2U7XG4gICAgc3Ryb2tlV2lkdGg6IFZpc0NvbmZpZ051bWJlcjtcbiAgfVxuPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllckJvdW5kc0xheWVyKGlkOiBzdHJpbmcsIHByb3BzOiB7Ym91bmRzPzogbnVtYmVyW119KTogRGVja0xheWVyW10ge1xuICBjb25zdCB7Ym91bmRzfSA9IHByb3BzO1xuICBpZiAoYm91bmRzPy5sZW5ndGggIT09IDQpIHJldHVybiBbXTtcblxuICBjb25zdCBkYXRhID0gW1xuICAgIHtcbiAgICAgIHBhdGg6IFtcbiAgICAgICAgW2JvdW5kc1swXSwgYm91bmRzWzFdXSxcbiAgICAgICAgW2JvdW5kc1syXSwgYm91bmRzWzFdXSxcbiAgICAgICAgW2JvdW5kc1syXSwgYm91bmRzWzNdXSxcbiAgICAgICAgW2JvdW5kc1swXSwgYm91bmRzWzNdXSxcbiAgICAgICAgW2JvdW5kc1swXSwgYm91bmRzWzFdXVxuICAgICAgXVxuICAgIH1cbiAgXTtcblxuICBjb25zdCBsYXllciA9IG5ldyBQYXRoTGF5ZXIoe1xuICAgIGlkOiBgJHtpZH0tdmVjdG9yLXRpbGUtYm91bmRzYCxcbiAgICBkYXRhLFxuICAgIGdldFBhdGg6IGQgPT4gZC5wYXRoLFxuICAgIGdldENvbG9yOiBbMTI4LCAxMjgsIDEyOCwgMjU1XSxcbiAgICBnZXRXaWR0aDogMSxcbiAgICB3aWR0aFVuaXRzOiAncGl4ZWxzJyxcbiAgICBwaWNrYWJsZTogZmFsc2VcbiAgfSk7XG5cbiAgcmV0dXJuIFtsYXllcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvclRpbGVMYXllciBleHRlbmRzIEFic3RyYWN0VGlsZUxheWVyPFZlY3RvclRpbGUsIEZlYXR1cmVbXT4ge1xuICBkZWNsYXJlIGNvbmZpZzogVmVjdG9yVGlsZUxheWVyQ29uZmlnO1xuICBkZWNsYXJlIHZpc0NvbmZpZ1NldHRpbmdzOiBWZWN0b3JUaWxlTGF5ZXJWaXNDb25maWdTZXR0aW5ncztcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBYnN0cmFjdFRpbGVMYXllcj5bMF0pIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5yZWdpc3RlclZpc0NvbmZpZyh2ZWN0b3JUaWxlVmlzQ29uZmlncyk7XG4gICAgdGhpcy50aWxlRGF0YXNldCA9IHRoaXMuaW5pdFRpbGVEYXRhc2V0KCk7XG4gIH1cblxuICBtZXRhID0ge307XG5cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyhkYXRhc2V0OiBLZXBsZXJEYXRhc2V0KTogRmluZERlZmF1bHRMYXllclByb3BzUmV0dXJuVmFsdWUge1xuICAgIGlmIChkYXRhc2V0LnR5cGUgIT09IERhdGFzZXRUeXBlLlZFQ1RPUl9USUxFKSB7XG4gICAgICByZXR1cm4ge3Byb3BzOiBbXX07XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5maW5kRGVmYXVsdExheWVyUHJvcHMoZGF0YXNldCk7XG4gIH1cblxuICBpbml0VGlsZURhdGFzZXQoKTogVGlsZURhdGFzZXQ8VmVjdG9yVGlsZSwgRmVhdHVyZVtdPiB7XG4gICAgcmV0dXJuIG5ldyBUaWxlRGF0YXNldCh7XG4gICAgICBnZXRUaWxlSWQ6ICh0aWxlOiBWZWN0b3JUaWxlKTogc3RyaW5nID0+IHRpbGUuaWQsXG4gICAgICBnZXRJdGVyYWJsZTogKHRpbGU6IFZlY3RvclRpbGUpOiBGZWF0dXJlW10gPT4ge1xuICAgICAgICBpZiAodGlsZS5jb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRpbGUuY29udGVudC5zaGFwZSA9PT0gJ2dlb2pzb24tdGFibGUnID8gdGlsZS5jb250ZW50LmZlYXR1cmVzIDogdGlsZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICBnZXRSb3dDb3VudDogKGZlYXR1cmVzOiBGZWF0dXJlW10pOiBudW1iZXIgPT4gZmVhdHVyZXMubGVuZ3RoLFxuICAgICAgZ2V0Um93VmFsdWU6IHRoaXMuYWNjZXNzUm93VmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBMQVlFUl9UWVBFUy52ZWN0b3JUaWxlO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1ZlY3RvciBUaWxlJztcbiAgfVxuXG4gIGdldCBsYXllckljb24oKTogS2VwbGVyTGF5ZXJbJ2xheWVySWNvbiddIHtcbiAgICByZXR1cm4gVmVjdG9yVGlsZUljb247XG4gIH1cblxuICBnZXQgc3VwcG9ydGVkRGF0YXNldFR5cGVzKCk6IERhdGFzZXRUeXBlW10ge1xuICAgIHJldHVybiBbRGF0YXNldFR5cGUuVkVDVE9SX1RJTEVdO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCk6IFJlY29yZDxzdHJpbmcsIFZpc3VhbENoYW5uZWw+IHtcbiAgICBjb25zdCB2aXN1YWxDaGFubmVscyA9IHN1cGVyLnZpc3VhbENoYW5uZWxzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi52aXN1YWxDaGFubmVscyxcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHByb3BlcnR5OiAnc3Ryb2tlQ29sb3InLFxuICAgICAgICBmaWVsZDogJ3N0cm9rZUNvbG9yRmllbGQnLFxuICAgICAgICBzY2FsZTogJ3N0cm9rZUNvbG9yU2NhbGUnLFxuICAgICAgICBkb21haW46ICdzdHJva2VDb2xvckRvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc3Ryb2tlQ29sb3JSYW5nZScsXG4gICAgICAgIGtleTogJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgY2hhbm5lbFNjYWxlVHlwZTogQ0hBTk5FTF9TQ0FMRVMuY29sb3IsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5zdHJva2VkLFxuICAgICAgICBudWxsVmFsdWU6IHZpc3VhbENoYW5uZWxzLmNvbG9yLm51bGxWYWx1ZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6IGNvbmZpZyA9PiBjb25maWcudmlzQ29uZmlnLnN0cm9rZUNvbG9yIHx8IGNvbmZpZy5jb2xvclxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2UnLFxuICAgICAgICBmaWVsZDogJ3NpemVGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAnc2l6ZVNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnc2l6ZURvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc2l6ZVJhbmdlJyxcbiAgICAgICAga2V5OiAnc2l6ZScsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLnNpemUsXG4gICAgICAgIG51bGxWYWx1ZTogMCxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lV2lkdGgnLFxuICAgICAgICBjb25kaXRpb246IGNvbmZpZyA9PiBjb25maWcudmlzQ29uZmlnLnN0cm9rZWQsXG4gICAgICAgIGdldEF0dHJpYnV0ZVZhbHVlOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5zdHJva2VXaWR0aCB8fCBERUZBVUxUX1NUUk9LRV9XSURUSFxuICAgICAgfSxcbiAgICAgIHJhZGl1czoge1xuICAgICAgICBwcm9wZXJ0eTogJ3JhZGl1cycsXG4gICAgICAgIGZpZWxkOiAncmFkaXVzRmllbGQnLFxuICAgICAgICBzY2FsZTogJ3JhZGl1c1NjYWxlJyxcbiAgICAgICAgZG9tYWluOiAncmFkaXVzRG9tYWluJyxcbiAgICAgICAgcmFuZ2U6ICdyYWRpdXNSYW5nZScsXG4gICAgICAgIGtleTogJ3JhZGl1cycsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLnNpemUsXG4gICAgICAgIG51bGxWYWx1ZTogMCxcbiAgICAgICAgZ2V0QXR0cmlidXRlVmFsdWU6IGNvbmZpZyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZy52aXNDb25maWcucmFkaXVzIHx8IGNvbmZpZy5yYWRpdXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9pbnRSYWRpdXMnLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZyA9PiBjb25maWcucmFkaXVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldERlZmF1bHRMYXllckNvbmZpZyhcbiAgICBwcm9wczogTGF5ZXJCYXNlQ29uZmlnUGFydGlhbFxuICApOiBMYXllckJhc2VDb25maWcgJiBQYXJ0aWFsPExheWVyQ29sb3JDb25maWcgJiBMYXllckhlaWdodENvbmZpZz4ge1xuICAgIGNvbnN0IGRlZmF1bHRMYXllckNvbmZpZyA9IHN1cGVyLmdldERlZmF1bHRMYXllckNvbmZpZyhwcm9wcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRMYXllckNvbmZpZyxcbiAgICAgIGNvbG9yU2NhbGU6IFNDQUxFX1RZUEVTLnF1YW50aXplLFxuXG4gICAgICBzdHJva2VDb2xvckZpZWxkOiBudWxsLFxuICAgICAgc3Ryb2tlQ29sb3JEb21haW46IFswLCAxXSxcbiAgICAgIHN0cm9rZUNvbG9yU2NhbGU6IFNDQUxFX1RZUEVTLnF1YW50aWxlLFxuICAgICAgY29sb3JVSToge1xuICAgICAgICAuLi5kZWZhdWx0TGF5ZXJDb25maWcuY29sb3JVSSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMYXllckNvbmZpZ1xuICAgICAgICBzdHJva2VDb2xvclJhbmdlOiBERUZBVUxUX0NPTE9SX1VJXG4gICAgICB9LFxuXG4gICAgICByYWRpdXNGaWVsZDogbnVsbCxcbiAgICAgIHJhZGl1c0RvbWFpbjogWzAsIDFdLFxuICAgICAgcmFkaXVzU2NhbGU6IFNDQUxFX1RZUEVTLmxpbmVhclxuICAgIH07XG4gIH1cblxuICBnZXRIb3ZlckRhdGEoXG4gICAgb2JqZWN0OiB7cHJvcGVydGllcz86IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+Pn0sXG4gICAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgICBmaWVsZHM6IEtlcGxlckZpZWxkW11cbiAgKTogKFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbClbXSB7XG4gICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiBvYmplY3QucHJvcGVydGllcz8uW2YubmFtZV0gPz8gbnVsbCk7XG4gIH1cblxuICBjYWxjdWxhdGVMYXllckRvbWFpbihcbiAgICBkYXRhc2V0OiBLZXBsZXJEYXRhc2V0LFxuICAgIHZpc3VhbENoYW5uZWw6IFZpc3VhbENoYW5uZWxcbiAgKTogRG9tYWluU3RvcHMgfCBudW1iZXJbXSB7XG4gICAgY29uc3QgZGVmYXVsdERvbWFpbiA9IFswLCAxXTtcblxuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5jb25maWdbdmlzdWFsQ2hhbm5lbC5maWVsZF07XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvbmZpZ1t2aXN1YWxDaGFubmVsLnNjYWxlXTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAvLyBpZiBjb2xvckZpZWxkIG9yIHNpemVGaWVsZCB3ZXJlIHNldCBiYWNrIHRvIG51bGxcbiAgICAgIHJldHVybiBkZWZhdWx0RG9tYWluO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgPT09IFNDQUxFX1RZUEVTLnF1YW50aWxlICYmIGlzRG9tYWluUXVhbnRpbGVzKGZpZWxkPy5maWx0ZXJQcm9wcz8uZG9tYWluUXVhbnRpbGVzKSkge1xuICAgICAgcmV0dXJuIGZpZWxkLmZpbHRlclByb3BzLmRvbWFpblF1YW50aWxlcztcbiAgICB9XG4gICAgaWYgKGlzRG9tYWluU3RvcHMoZmllbGQ/LmZpbHRlclByb3BzPy5kb21haW5TdG9wcykpIHtcbiAgICAgIHJldHVybiBmaWVsZC5maWx0ZXJQcm9wcy5kb21haW5TdG9wcztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQ/LmZpbHRlclByb3BzPy5kb21haW4pKSB7XG4gICAgICByZXR1cm4gZmllbGQuZmlsdGVyUHJvcHMuZG9tYWluO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0RG9tYWluO1xuICB9XG5cbiAgZ2V0U2NhbGVPcHRpb25zKGNoYW5uZWxLZXk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBsZXQgb3B0aW9ucyA9IEtlcGxlckxheWVyLnByb3RvdHlwZS5nZXRTY2FsZU9wdGlvbnMuY2FsbCh0aGlzLCBjaGFubmVsS2V5KTtcblxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzLnN0cm9rZUNvbG9yO1xuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5jb25maWdbY2hhbm5lbC5maWVsZF07XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgaXNEb21haW5RdWFudGlsZXMoZmllbGQ/LmZpbHRlclByb3BzPy5kb21haW5RdWFudGlsZXMpIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZy5keW5hbWljQ29sb3IgfHxcbiAgICAgICAgLy8gSWYgd2UndmUgc2V0IHRoZSBzY2FsZSB0byBxdWFudGlsZSwgd2UgbmVlZCB0byBpbmNsdWRlIGl0IC0gdGhlcmUncyBhIGxvYWRpbmdcbiAgICAgICAgLy8gcGVyaW9kIGluIHdoaWNoIHRoZSB2aXNDb25maWcgaXNuJ3Qgc2V0IHlldCwgYnV0IGlmIHdlIGRvbid0IHJldHVybiB0aGUgcmlnaHRcbiAgICAgICAgLy8gc2NhbGUgdHlwZSB3ZSBsb3NlIGl0XG4gICAgICAgIHRoaXMuY29uZmlnLmNvbG9yU2NhbGUgPT09IFNDQUxFX1RZUEVTLnF1YW50aWxlXG4gICAgICApXG4gICAgKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucy5maWx0ZXIoc2NhbGUgPT4gc2NhbGUgIT09IFNDQUxFX1RZUEVTLnF1YW50aWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGFjY2Vzc1Jvd1ZhbHVlKFxuICAgIGZpZWxkPzogS2VwbGVyRmllbGQsXG4gICAgaW5kZXhLZXk/OiBudW1iZXIgfCBudWxsXG4gICk6IChmaWVsZDogS2VwbGVyRmllbGQsIGRhdHVtOiBGZWF0dXJlKSA9PiBudW1iZXIgfCBudWxsIHtcbiAgICAvLyBpZiBpcyBpbmRleGVkIGZpZWxkXG4gICAgaWYgKGlzSW5kZXhlZEZpZWxkKGZpZWxkKSAmJiBpbmRleEtleSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZmllbGROYW1lID0gaW5kZXhLZXkgJiYgZmllbGQ/LmluZGV4Qnk/Lm1hcHBlZFZhbHVlW2luZGV4S2V5XTtcbiAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChmLCBkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmIChkYXR1bS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0dW0ucHJvcGVydGllc1tmaWVsZE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPIGRlYnVnIHRoaXMgd2l0aCBpbmRleGVkIHRpbGVkIGRhdGFzZXRcbiAgICAgICAgICByZXR1cm4gZGF0dW1bZmllbGROYW1lXTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0XG4gICAgcmV0dXJuIChmLCBkYXR1bSkgPT4ge1xuICAgICAgaWYgKGYgJiYgZGF0dW0ucHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gZGF0dW0ucHJvcGVydGllc1tmLm5hbWVdO1xuICAgICAgfVxuICAgICAgLy8gc3VwcG9ydCBwaWNraW5nICYgaGlnaGxpZ2h0aW5nXG4gICAgICByZXR1cm4gZiA/IGRhdHVtW2YuZmllbGRJZHhdIDogbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJNZXRhKGRhdGFzZXQ6IEtlcGxlckRhdGFzZXQsIGRhdGFzZXRzOiBLZXBsZXJEYXRhc2V0cyk6IHZvaWQge1xuICAgIGlmIChkYXRhc2V0LnR5cGUgIT09IERhdGFzZXRUeXBlLlZFQ1RPUl9USUxFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YXNldE1ldGEgPSBkYXRhc2V0Lm1ldGFkYXRhIGFzIFZlY3RvclRpbGVNZXRhZGF0YSAmIFZlY3RvclRpbGVEYXRhc2V0TWV0YWRhdGE7XG4gICAgdGhpcy51cGRhdGVNZXRhKHtcbiAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5pZCxcbiAgICAgIGRhdGFzZXRzLFxuICAgICAgYm91bmRzOiBkYXRhc2V0TWV0YS5ib3VuZHNcbiAgICB9KTtcbiAgfVxuXG4gIGZvcm1hdExheWVyRGF0YShcbiAgICBkYXRhc2V0czogS2VwbGVyRGF0YXNldHMsXG4gICAgb2xkTGF5ZXJEYXRhOiB1bmtub3duLFxuICAgIGFuaW1hdGlvbkNvbmZpZzogQW5pbWF0aW9uQ29uZmlnXG4gICk6IExheWVyRGF0YSB7XG4gICAgY29uc3Qge2RhdGFJZH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIW5vdE51bGxvclVuZGVmaW5lZChkYXRhSWQpKSB7XG4gICAgICByZXR1cm4ge3RpbGVTb3VyY2U6IG51bGx9O1xuICAgIH1cbiAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbZGF0YUlkXTtcblxuICAgIGxldCB0aWxlc2V0RGF0YVVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGxldCB0aWxlU291cmNlOiBMYXllckRhdGFbJ3RpbGVTb3VyY2UnXSA9IG51bGw7XG5cbiAgICBpZiAoZGF0YXNldD8udHlwZSA9PT0gRGF0YXNldFR5cGUuVkVDVE9SX1RJTEUpIHtcbiAgICAgIGNvbnN0IGRhdGFzZXRNZXRhZGF0YSA9IGRhdGFzZXQubWV0YWRhdGEgYXMgVmVjdG9yVGlsZU1ldGFkYXRhICYgVmVjdG9yVGlsZURhdGFzZXRNZXRhZGF0YTtcbiAgICAgIGNvbnN0IHJlbW90ZVRpbGVGb3JtYXQgPSBkYXRhc2V0TWV0YWRhdGE/LnJlbW90ZVRpbGVGb3JtYXQ7XG4gICAgICBpZiAocmVtb3RlVGlsZUZvcm1hdCA9PT0gUmVtb3RlVGlsZUZvcm1hdC5NVlQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtRmV0Y2ggPSBhc3luYyAoaW5wdXQ6IFJlcXVlc3RJbmZvIHwgVVJMLCBpbml0PzogUmVxdWVzdEluaXQgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YTogUmVxdWVzdFBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICB1cmw6IGlucHV0IGFzIHN0cmluZyxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgICAgICAgICAgb3B0aW9uczogaW5pdCA/PyB7fVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gZmV0Y2gocmVxdWVzdERhdGEudXJsLCByZXF1ZXN0RGF0YS5vcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aWxlc2V0RGF0YVVybCA9IGRhdGFzZXRNZXRhZGF0YT8udGlsZXNldERhdGFVcmw7XG4gICAgICAgIHRpbGVTb3VyY2UgPSB0aWxlc2V0RGF0YVVybFxuICAgICAgICAgID8gTVZUU291cmNlLmNyZWF0ZURhdGFTb3VyY2UoZGVjb2RlVVJJQ29tcG9uZW50KHRpbGVzZXREYXRhVXJsKSwge1xuICAgICAgICAgICAgICBtdnQ6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVVybDogZGF0YXNldE1ldGFkYXRhPy50aWxlc2V0TWV0YWRhdGFVcmwgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgZmV0Y2g6IHRyYW5zZm9ybUZldGNoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVtb3RlVGlsZUZvcm1hdCA9PT0gUmVtb3RlVGlsZUZvcm1hdC5QTVRJTEVTKSB7XG4gICAgICAgIC8vIFRPRE86IHRvIHJlbmRlciBpbWFnZSBwbXRpbGVzIG5lZWQgdG8gdXNlIFRpbGVMYXllciBhbmQgQml0bWFwTGF5ZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9sb2FkZXJzLmdsL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL3dlYnNpdGUvdGlsZXMvY29tcG9uZW50cy90aWxlLXNvdXJjZS1sYXllci50cylcbiAgICAgICAgdGlsZXNldERhdGFVcmwgPSBkYXRhc2V0TWV0YWRhdGE/LnRpbGVzZXREYXRhVXJsO1xuICAgICAgICB0aWxlU291cmNlID0gdGlsZXNldERhdGFVcmwgPyBQTVRpbGVzU291cmNlLmNyZWF0ZURhdGFTb3VyY2UodGlsZXNldERhdGFVcmwsIHt9KSA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmZvcm1hdExheWVyRGF0YShkYXRhc2V0cywgb2xkTGF5ZXJEYXRhLCBhbmltYXRpb25Db25maWcpLFxuICAgICAgdGlsZXNldERhdGFVcmw6IHR5cGVvZiB0aWxlc2V0RGF0YVVybCA9PT0gJ3N0cmluZycgPyBnZXRUaWxlVXJsKHRpbGVzZXREYXRhVXJsKSA6IG51bGwsXG4gICAgICB0aWxlU291cmNlXG4gICAgfTtcbiAgfVxuXG4gIGhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SW5mbykge1xuICAgIGlmIChzdXBlci5oYXNIb3ZlcmVkT2JqZWN0KG9iamVjdEluZm8pKSB7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IG9iamVjdEluZm8/LnRpbGU/LmNvbnRlbnQ/LmZlYXR1cmVzO1xuICAgICAgcmV0dXJuIGZlYXR1cmVzW29iamVjdEluZm8uaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlbmRlclN1YkxheWVycyhwcm9wczogUmVjb3JkPHN0cmluZywgYW55Pik6IERlY2tMYXllciB8IERlY2tMYXllcltdIHtcbiAgICBsZXQge2RhdGF9ID0gcHJvcHM7XG5cbiAgICBkYXRhID0gZGF0YT8uc2hhcGUgPT09ICdnZW9qc29uLXRhYmxlJyA/IGRhdGEuZmVhdHVyZXMgOiBkYXRhO1xuICAgIGlmICghZGF0YT8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGlsZTogVGlsZTJESGVhZGVyID0gcHJvcHMudGlsZTtcbiAgICBjb25zdCB6b29tID0gdGlsZS5pbmRleC56O1xuXG4gICAgcmV0dXJuIG5ldyBHZW9Kc29uTGF5ZXIoe1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBkYXRhLFxuICAgICAgZ2V0RmlsbENvbG9yOiBwcm9wcy5nZXRGaWxsQ29sb3JCeVpvb20gPyBwcm9wcy5nZXRGaWxsQ29sb3Ioem9vbSkgOiBwcm9wcy5nZXRGaWxsQ29sb3IsXG4gICAgICBnZXRFbGV2YXRpb246IHByb3BzLmdldEVsZXZhdGlvbkJ5Wm9vbSA/IHByb3BzLmdldEVsZXZhdGlvbih6b29tKSA6IHByb3BzLmdldEVsZXZhdGlvbixcbiAgICAgIC8vIHJhZGl1cyBmb3IgcG9pbnRzXG4gICAgICBwb2ludFJhZGl1c1NjYWxlOiBwcm9wcy5wb2ludFJhZGl1c1NjYWxlLCAvLyBwcm9wcy5nZXRQb2ludFJhZGl1c1NjYWxlQnlab29tKHpvb20pLFxuICAgICAgcG9pbnRSYWRpdXNVbml0czogcHJvcHMucG9pbnRSYWRpdXNVbml0cyxcbiAgICAgIGdldFBvaW50UmFkaXVzOiBwcm9wcy5nZXRQb2ludFJhZGl1cyxcbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB0aWxlIExheWVyIHJlc2V0IGF1dG9IaWdobGlnaHQgdG8gZmFsc2VcbiAgICAgIHBpY2thYmxlOiB0cnVlLFxuICAgICAgYXV0b0hpZ2hsaWdodDogdHJ1ZSxcbiAgICAgIHN0cm9rZWQ6IHByb3BzLnN0cm9rZWQsXG4gICAgICAvLyB3cmFwTG9uZ2l0dWRlOiB0cnVlIGNhdXNlcyBtaXNzaW5nIHNpZGUgcG9seWdvbiB3aGVuIGV4dHJ1ZGUgaXMgZW5hYmxlZFxuICAgICAgd3JhcExvbmdpdHVkZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgZGVjayBsYXllclxuICByZW5kZXJMYXllcihvcHRzOiBWZWN0b3JUaWxlTGF5ZXJSZW5kZXJPcHRpb25zKTogRGVja0xheWVyW10ge1xuICAgIGNvbnN0IHttYXBTdGF0ZSwgZGF0YSwgYW5pbWF0aW9uQ29uZmlnLCBncHVGaWx0ZXIsIG9iamVjdEhvdmVyZWQsIGxheWVyQ2FsbGJhY2tzfSA9IG9wdHM7XG4gICAgY29uc3Qge2FuaW1hdGlvbiwgdmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgdGhpcy5zZXRMYXllckRvbWFpbiA9IGxheWVyQ2FsbGJhY2tzLm9uU2V0TGF5ZXJEb21haW47XG5cbiAgICBjb25zdCBkZWZhdWx0TGF5ZXJQcm9wcyA9IHRoaXMuZ2V0RGVmYXVsdERlY2tMYXllclByb3BzKG9wdHMpO1xuICAgIGNvbnN0IGVsZVpvb21GYWN0b3IgPSB0aGlzLmdldEVsZXZhdGlvblpvb21GYWN0b3IobWFwU3RhdGUpO1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0aGlzLmNvbmZpZy52aXNDb25maWcudHJhbnNpdGlvblxuICAgICAgPyB7XG4gICAgICAgICAgZ2V0RmlsbENvbG9yOiB7XG4gICAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uQ29uZmlnLmR1cmF0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25Db25maWcuZHVyYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgY29sb3JGaWVsZCA9IHRoaXMuY29uZmlnLmNvbG9yRmllbGQgYXMgS2VwbGVyRmllbGQ7XG4gICAgY29uc3QgaGVpZ2h0RmllbGQgPSB0aGlzLmNvbmZpZy5oZWlnaHRGaWVsZCBhcyBLZXBsZXJGaWVsZDtcbiAgICBjb25zdCBzdHJva2VDb2xvckZpZWxkID0gdGhpcy5jb25maWcuc3Ryb2tlQ29sb3JGaWVsZCBhcyBLZXBsZXJGaWVsZDtcbiAgICBjb25zdCBzaXplRmllbGQgPSB0aGlzLmNvbmZpZy5zaXplRmllbGQgYXMgS2VwbGVyRmllbGQ7XG4gICAgY29uc3QgcmFkaXVzRmllbGQgPSB0aGlzLmNvbmZpZy5yYWRpdXNGaWVsZCBhcyBLZXBsZXJGaWVsZDtcblxuICAgIGlmIChkYXRhLnRpbGVTb3VyY2UpIHtcbiAgICAgIGNvbnN0IGhvdmVyZWRPYmplY3QgPSB0aGlzLmhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SG92ZXJlZCk7XG5cbiAgICAgIGNvbnN0IGxheWVycyA9IFtcbiAgICAgICAgbmV3IEN1c3RvbU1WVExheWVyKHtcbiAgICAgICAgICAuLi5kZWZhdWx0TGF5ZXJQcm9wcyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIG9uVmlld3BvcnRMb2FkOiB0aGlzLm9uVmlld3BvcnRMb2FkLFxuICAgICAgICAgIGRhdGE6IGRhdGEudGlsZXNldERhdGFVcmwsXG4gICAgICAgICAgZ2V0VGlsZURhdGE6IGRhdGEudGlsZVNvdXJjZT8uZ2V0VGlsZURhdGEsXG4gICAgICAgICAgdGlsZVNvdXJjZTogZGF0YS50aWxlU291cmNlLFxuICAgICAgICAgIGdldEZpbHRlclZhbHVlOiB0aGlzLmdldEdwdUZpbHRlclZhbHVlQWNjZXNzb3Iob3B0cyksXG4gICAgICAgICAgZmlsdGVyUmFuZ2U6IGdwdUZpbHRlci5maWx0ZXJSYW5nZSxcbiAgICAgICAgICBsaW5lV2lkdGhVbml0czogJ3BpeGVscycsXG5cbiAgICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgICAgIGVsZXZhdGlvblNjYWxlOiB2aXNDb25maWcuZWxldmF0aW9uU2NhbGUgKiBlbGVab29tRmFjdG9yLFxuICAgICAgICAgIGV4dHJ1ZGVkOiB2aXNDb25maWcuZW5hYmxlM2QsXG4gICAgICAgICAgc3Ryb2tlZDogdmlzQ29uZmlnLnN0cm9rZWQsXG5cbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGhhcmQgY29kZWQsIGRlc2lnbiBhIFVJIHRvIGFsbG93IHVzZXIgYXNzaWduZWQgdW5pcXVlIHByb3BlcnR5IGlkXG4gICAgICAgICAgLy8gdW5pcXVlSWRQcm9wZXJ0eTogJ3VmaWQnLFxuICAgICAgICAgIHJlbmRlclN1YkxheWVyczogdGhpcy5yZW5kZXJTdWJMYXllcnMsXG4gICAgICAgICAgLy8gd2hlbiByYWRpdXNVbml0cyBpcyBtZXRlclxuICAgICAgICAgIGdldFBvaW50UmFkaXVzU2NhbGVCeVpvb206IGdldFByb3BlcnR5Qnlab29tKHZpc0NvbmZpZy5yYWRpdXNCeVpvb20sIHZpc0NvbmZpZy5yYWRpdXMpLFxuICAgICAgICAgIHBvaW50UmFkaXVzVW5pdHM6IHZpc0NvbmZpZy5yYWRpdXNVbml0cyA/ICdwaXhlbHMnIDogJ21ldGVycycsXG4gICAgICAgICAgcG9pbnRSYWRpdXNTY2FsZTogcmFkaXVzRmllbGQgPyB2aXNDb25maWcucmFkaXVzIDogMSxcblxuICAgICAgICAgIHBvaW50UmFkaXVzTWluUGl4ZWxzOiAxLFxuICAgICAgICAgIGF1dG9IaWdobGlnaHQ6IHRydWUsXG4gICAgICAgICAgaGlnaGxpZ2h0Q29sb3I6IERFRkFVTFRfSElHSExJR0hUX0ZJTExfQ09MT1IsXG4gICAgICAgICAgcGlja2FibGU6IHRydWUsXG4gICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICAgIGdldEZpbHRlclZhbHVlOiB7XG4gICAgICAgICAgICAgIC4uLmdwdUZpbHRlci5maWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICAgICAgICBjdXJyZW50VGltZTogYW5pbWF0aW9uLmVuYWJsZWQgPyBhbmltYXRpb25Db25maWcuY3VycmVudFRpbWUgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbmZpZy5jb2xvcixcbiAgICAgICAgICAgICAgY29sb3JGaWVsZDogdGhpcy5jb25maWcuY29sb3JGaWVsZCxcbiAgICAgICAgICAgICAgY29sb3JTY2FsZTogdGhpcy5jb25maWcuY29sb3JTY2FsZSxcbiAgICAgICAgICAgICAgY29sb3JEb21haW46IHRoaXMuY29uZmlnLmNvbG9yRG9tYWluLFxuICAgICAgICAgICAgICBjb2xvclJhbmdlOiB2aXNDb25maWcuY29sb3JSYW5nZSxcbiAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGlzSW5kZXhlZEZpZWxkKGNvbG9yRmllbGQpID8gYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lIDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVsZXZhdGlvbjoge1xuICAgICAgICAgICAgICBoZWlnaHRGaWVsZDogdGhpcy5jb25maWcuaGVpZ2h0RmllbGQsXG4gICAgICAgICAgICAgIGhlaWdodFNjYWxlVHlwZTogdGhpcy5jb25maWcuaGVpZ2h0U2NhbGUsXG4gICAgICAgICAgICAgIGhlaWdodFJhbmdlOiB2aXNDb25maWcuaGVpZ2h0UmFuZ2UsXG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiBpc0luZGV4ZWRGaWVsZChoZWlnaHRGaWVsZCkgPyBhbmltYXRpb25Db25maWcuY3VycmVudFRpbWUgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TGluZUNvbG9yOiB7XG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiB2aXNDb25maWcuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yRmllbGQ6IHRoaXMuY29uZmlnLnN0cm9rZUNvbG9yRmllbGQsXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcHJvcCBub3QgaW4gTGF5ZXJDb25maWdcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3JTY2FsZTogdGhpcy5jb25maWcuc3Ryb2tlQ29sb3JTY2FsZSxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwcm9wIG5vdCBpbiBMYXllckNvbmZpZ1xuICAgICAgICAgICAgICBzdHJva2VDb2xvckRvbWFpbjogdGhpcy5jb25maWcuc3Ryb2tlQ29sb3JEb21haW4sXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBTdHJpcCBvdXQgZW1wdHkgYXJyYXlzIGZyb20gaW5kaXZpZHVhbCBjb2xvciBtYXAgc3RlcHMsIGFuZCByZXBsYWNlIHdpdGggYG51bGxgLCBvdGhlcndpc2UgdGhlIGxheWVyIG1heSBzaG93IHRoZSBpbmNvcnJlY3QgY29sb3IuXG4gICAgICAgICAgICAgIC8vIFNvIGZhciBpdCBzZWVtcyB0aGF0IGl0IHVzZXMgdGhlIHByZXZpb3VzIGNvbG9yIGNob3NlbiBpbiB0aGUgcGFsZXR0ZSByYXRoZXIgdGhhbiB0aGUgY3VycmVudGx5IGNob3NlbiBjb2xvciBmb3IgdGhlIHNwZWNpZmljIGN1c3RvbSBvcmRpbmFsIHZhbHVlIHdoZW4gdGhlcmUgYXJlIFwic3BhcnNlXCIgY29sb3IgbWFwcy5cbiAgICAgICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGEgY29sb3IgbWFwIHdpdGggXCJob2xlc1wiIG9mIGNvbG9ycyB3aXRoIHVuYXNzaWduZWQgZmllbGQgdmFsdWVzLCB3aGljaCBtYXkgaGF2ZSBiZWVuIGFzc2lnbmVkIGluIHRoZSBwYXN0LlxuICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSBcImFiY1wiIHdhcyBncmVlbiwgc3RvcmVkIGFzIGBbXCJhYmNcIl1gLiBUaGVuIFwiYWJjXCIgd2FzIHJlYXNzaWduZWQgdG8gdGhlIHJlZCBjb2xvciBtYXAgc3RlcCwgc3RvcmVkIGFzIGBbXCJhYmNcIl1gLiBOb3cgdGhlIGdyZWVuIGNvbG9yIG1hcCBzdGVwJ3Mgc3RvcmVkIHZhbHVlIGlzIGBbXWAsIGFuZCB0aGUgbGF5ZXIgd2lsbCBpbmNvcnJlY3RseSBzdGlsbCByZW5kZXIgXCJhYmNcIiBpbiBncmVlbi5cbiAgICAgICAgICAgICAgLy8gUXVpY2sgcGF0Y2ggZXhhbXBsZTpcbiAgICAgICAgICAgICAgLy8gc3Ryb2tlQ29sb3JSYW5nZTogdmlzQ29uZmlnPy5zdHJva2VDb2xvclJhbmdlPy5jb2xvck1hcD8ubWFwKGNtID0+XG4gICAgICAgICAgICAgIC8vICAgY21bMF0/Lmxlbmd0aCA9PT0gMCA/IFtudWxsLCBjbVsxXV0gOiBjbVxuICAgICAgICAgICAgICAvLyApLFxuICAgICAgICAgICAgICAvLyBOb3RlOiBmb3IgcmVndWxhciBzY2FsZXMgdGhlIGNvbG9yTWFwIGluIHRoZSBhYm92ZSBwYXRjaCBpcyB1bmRlZmluZWQgYW5kIGJyZWFrcyBzdHJva2VDb2xvclJhbmdlIHVwZGF0ZSB0cmlnZ2VyLlxuICAgICAgICAgICAgICBzdHJva2VDb2xvclJhbmdlOiB2aXNDb25maWcuc3Ryb2tlQ29sb3JSYW5nZSxcbiAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGlzSW5kZXhlZEZpZWxkKHN0cm9rZUNvbG9yRmllbGQpID8gYW5pbWF0aW9uQ29uZmlnLmN1cnJlbnRUaW1lIDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldExpbmVXaWR0aDoge1xuICAgICAgICAgICAgICBzaXplUmFuZ2U6IHZpc0NvbmZpZy5zaXplUmFuZ2UsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB2aXNDb25maWcuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIHNpemVGaWVsZDogdGhpcy5jb25maWcuc2l6ZUZpZWxkLFxuICAgICAgICAgICAgICBzaXplU2NhbGU6IHRoaXMuY29uZmlnLnNpemVTY2FsZSxcbiAgICAgICAgICAgICAgc2l6ZURvbWFpbjogdGhpcy5jb25maWcuc2l6ZURvbWFpbixcbiAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGlzSW5kZXhlZEZpZWxkKHNpemVGaWVsZCkgPyBhbmltYXRpb25Db25maWcuY3VycmVudFRpbWUgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRSYWRpdXM6IHtcbiAgICAgICAgICAgICAgcmFkaXVzOiB2aXNDb25maWcucmFkaXVzLFxuICAgICAgICAgICAgICByYWRpdXNGaWVsZDogdGhpcy5jb25maWcucmFkaXVzRmllbGQsXG4gICAgICAgICAgICAgIHJhZGl1c1NjYWxlOiB0aGlzLmNvbmZpZy5yYWRpdXNTY2FsZSxcbiAgICAgICAgICAgICAgcmFkaXVzRG9tYWluOiB0aGlzLmNvbmZpZy5yYWRpdXNEb21haW4sXG4gICAgICAgICAgICAgIHJhZGl1c1JhbmdlOiB0aGlzLmNvbmZpZy5yYWRpdXNSYW5nZSxcbiAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGlzSW5kZXhlZEZpZWxkKHJhZGl1c0ZpZWxkKSA/IGFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZSA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9zdWJMYXllclByb3BzOiB7XG4gICAgICAgICAgICAncG9seWdvbnMtc3Ryb2tlJzoge29wYWNpdHk6IHZpc0NvbmZpZy5zdHJva2VPcGFjaXR5fSxcbiAgICAgICAgICAgICdwb2x5Z29ucy1maWxsJzoge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgY3VsbEZhY2U6IEdMLkJBQ0tcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9hZE9wdGlvbnM6IHtcbiAgICAgICAgICAgIG12dDogZ2V0TG9hZGVyT3B0aW9ucygpLm12dFxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIC8vIGhvdmVyIGxheWVyXG4gICAgICAgIC4uLihob3ZlcmVkT2JqZWN0XG4gICAgICAgICAgPyBbXG4gICAgICAgICAgICAgIG5ldyBHZW9Kc29uTGF5ZXIoe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcHJvcHMgbm90IHR5cGVkP1xuICAgICAgICAgICAgICAgIC4uLm9iamVjdEhvdmVyZWQuc291cmNlTGF5ZXI/LnByb3BzLFxuICAgICAgICAgICAgICAgIC4uLih0aGlzLmdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMoKSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JhcExvbmdpdHVkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogW2hvdmVyZWRPYmplY3RdLFxuICAgICAgICAgICAgICAgIGdldExpbmVDb2xvcjogREVGQVVMVF9ISUdITElHSFRfU1RST0tFX0NPTE9SLFxuICAgICAgICAgICAgICAgIGdldEZpbGxDb2xvcjogREVGQVVMVF9ISUdITElHSFRfRklMTF9DT0xPUixcbiAgICAgICAgICAgICAgICBnZXRMaW5lV2lkdGg6IHZpc0NvbmZpZy5zdHJva2VXaWR0aCArIDEsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoVW5pdHM6ICdwaXhlbHMnLFxuICAgICAgICAgICAgICAgIHN0cm9rZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlsbGVkOiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgOiBbXSlcbiAgICAgICAgLy8gLi4udGlsZUxheWVyQm91bmRzTGF5ZXIoZGVmYXVsdExheWVyUHJvcHMuaWQsIGRhdGEpLFxuICAgICAgXTtcblxuICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0EsSUFBQUEsTUFBQSxHQUFBQyxPQUFBO0FBQ0EsSUFBQUMsSUFBQSxHQUFBRCxPQUFBO0FBQ0EsSUFBQUUsUUFBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsVUFBQSxHQUFBQyxzQkFBQSxDQUFBSixPQUFBO0FBRUEsSUFBQUssWUFBQSxHQUFBTCxPQUFBO0FBQ0EsSUFBQU0sV0FBQSxHQUFBTixPQUFBO0FBVUEsSUFBQU8sTUFBQSxHQUFBUCxPQUFBO0FBc0JBLElBQUFRLFNBQUEsR0FBQVIsT0FBQTtBQUNBLElBQUFTLGVBQUEsR0FBQUwsc0JBQUEsQ0FBQUosT0FBQTtBQUNBLElBQUFVLFVBQUEsR0FBQU4sc0JBQUEsQ0FBQUosT0FBQTtBQVVBLElBQUFXLGtCQUFBLEdBQUFDLHVCQUFBLENBQUFaLE9BQUE7QUFNQSxJQUFBYSxZQUFBLEdBQUFULHNCQUFBLENBQUFKLE9BQUE7QUFDQSxJQUFBYyxVQUFBLEdBQUFkLE9BQUE7QUFLa0MsU0FBQWUseUJBQUFDLENBQUEsNkJBQUFDLE9BQUEsbUJBQUFDLENBQUEsT0FBQUQsT0FBQSxJQUFBRSxDQUFBLE9BQUFGLE9BQUEsWUFBQUYsd0JBQUEsWUFBQUEseUJBQUFDLENBQUEsV0FBQUEsQ0FBQSxHQUFBRyxDQUFBLEdBQUFELENBQUEsS0FBQUYsQ0FBQTtBQUFBLFNBQUFKLHdCQUFBSSxDQUFBLEVBQUFFLENBQUEsU0FBQUEsQ0FBQSxJQUFBRixDQUFBLElBQUFBLENBQUEsQ0FBQUksVUFBQSxTQUFBSixDQUFBLGVBQUFB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