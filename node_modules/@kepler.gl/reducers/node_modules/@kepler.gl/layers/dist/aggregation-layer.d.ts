import Layer, { LayerBaseConfig, LayerBaseConfigPartial, LayerColorConfig, LayerSizeConfig, VisualChannelDescription, VisualChannels } from './base-layer';
import { DataContainerInterface } from '@kepler.gl/utils';
import { Field, LayerColumn, Merge } from '@kepler.gl/types';
import { KeplerTable, Datasets } from '@kepler.gl/table';
declare type AggregationLayerColumns = {
    lat: LayerColumn;
    lng: LayerColumn;
};
export declare type AggregationLayerData = {
    index: number;
};
export declare const pointPosAccessor: ({ lat, lng }: AggregationLayerColumns) => (dc: any) => (d: any) => any[];
export declare const pointPosResolver: ({ lat, lng }: AggregationLayerColumns) => string;
export declare const getValueAggrFunc: (getPointData: any) => (field: any, aggregation: any) => (points: any) => any;
export declare const getFilterDataFunc: (filterRange: number[][], getFilterValue: (d: unknown) => (number | number[])[]) => (d: unknown) => boolean;
export declare const aggregateRequiredColumns: ['lat', 'lng'];
export declare type AggregationLayerVisualChannelConfig = LayerColorConfig & LayerSizeConfig;
export declare type AggregationLayerConfig = Merge<LayerBaseConfig, {
    columns: AggregationLayerColumns;
}> & AggregationLayerVisualChannelConfig;
export default class AggregationLayer extends Layer {
    getColorRange: any;
    config: AggregationLayerConfig;
    getPointData: (any: any) => any;
    gpuFilterGetIndex: (any: any) => number;
    gpuFilterGetData: (dataContainer: any, data: any, fieldIndex: any) => any;
    constructor(props: {
        id?: string;
    } & LayerBaseConfigPartial);
    get isAggregated(): true;
    get requiredLayerColumns(): ["lat", "lng"];
    get columnPairs(): import("@kepler.gl/types").ColumnPairs;
    get noneLayerDataAffectingProps(): string[];
    get visualChannels(): VisualChannels;
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */
    getVisualChannelDescription(key: string): VisualChannelDescription;
    getHoverData(object: any, dataContainer: DataContainerInterface, fields: Field[]): any;
    getFilteredItemCount(): null;
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */
    updateLayerVisualChannel({ dataContainer }: {
        dataContainer: any;
    }, channel: any): void;
    /**
     * Validate aggregation type on top of basic layer visual channel validation
     * @param channel
     */
    validateVisualChannel(channel: any): void;
    /**
     * Validate aggregation type based on selected field
     */
    validateAggregationType(channel: any): void;
    getAggregationOptions(channel: any): string[];
    /**
     * Get scale options based on current field and aggregation type
     * @param channel
     * @returns
     */
    getScaleOptions(channel: string): string[];
    /**
     * Aggregation layer handles visual channel aggregation inside deck.gl layer
     */
    updateLayerDomain(): AggregationLayer;
    updateLayerMeta(dataset: KeplerTable, getPosition: any): void;
    calculateDataAttribute({ filteredIndex }: KeplerTable, getPosition: any): AggregationLayerData[];
    formatLayerData(datasets: Datasets, oldLayerData: any): {};
    getDefaultDeckLayerProps(opts: any): any;
    getDefaultAggregationLayerProp(opts: any): any;
}
export {};
