"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrowTextVector = exports.formatTextLabelData = exports.defaultPadding = void 0;
exports.getTextOffsetByRadius = getTextOffsetByRadius;
exports.textLabelAccessor = void 0;
var arrow = _interopRequireWildcard(require("apache-arrow"));
var _viewportMercatorProject = require("viewport-mercator-project");
var _utils = require("@kepler.gl/utils");
var _commonUtils = require("@kepler.gl/common-utils");
var _lodash = _interopRequireDefault(require("lodash.uniq"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

var defaultPadding = exports.defaultPadding = 20;
function getTextOffsetByRadius(radiusScale, getRadius, mapState) {
  return function (textLabel) {
    var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(mapState);
    var xMult = textLabel.anchor === 'middle' ? 0 : textLabel.anchor === 'start' ? 1 : -1;
    var yMult = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? 1 : -1;
    var sizeOffset = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? textLabel.size : textLabel.size;
    var pixelRadius = radiusScale * distanceScale.pixelsPerMeter[0];
    var padding = defaultPadding;
    return typeof getRadius === 'function' ? function (d) {
      return [xMult * (getRadius(d) * pixelRadius + padding), yMult * (getRadius(d) * pixelRadius + padding + sizeOffset)];
    } : [xMult * (getRadius * pixelRadius + padding), yMult * (getRadius * pixelRadius + padding + sizeOffset)];
  };
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
var textLabelAccessor = exports.textLabelAccessor = function textLabelAccessor(textLabel) {
  return function (dc) {
    return function (d) {
      var val = textLabel.field.valueAccessor(d);
      return (0, _commonUtils.notNullorUndefined)(val) ? String(val) : '';
    };
  };
};
var formatTextLabelData = exports.formatTextLabelData = function formatTextLabelData(_ref) {
  var textLabel = _ref.textLabel,
    triggerChanged = _ref.triggerChanged,
    oldLayerData = _ref.oldLayerData,
    data = _ref.data,
    dataContainer = _ref.dataContainer,
    filteredIndex = _ref.filteredIndex;
  return textLabel.map(function (tl, i) {
    if (!tl.field) {
      // if no field selected,
      return {
        getText: null,
        characterSet: []
      };
    }
    var getTextAccessor = textLabelAccessor(tl)(dataContainer);
    var characterSet;
    var getText = getTextAccessor;
    var rebuildArrowTextVector = true;
    if (!(triggerChanged !== null && triggerChanged !== void 0 && triggerChanged["getLabelCharacterSet-".concat(i)]) && oldLayerData && oldLayerData.textLabels && oldLayerData.textLabels[i]) {
      characterSet = oldLayerData.textLabels[i].characterSet;
      getText = oldLayerData.textLabels[i].getText;
      rebuildArrowTextVector = false;
    } else {
      if (data instanceof arrow.Table) {
        // we don't filter out arrow tables,
        // so we use filteredIndex array instead
        var allLabels = [];
        if (tl.field) {
          if (filteredIndex) {
            filteredIndex.forEach(function (value, index) {
              if (value > 0) allLabels.push(getTextAccessor({
                index: index
              }));
            });
          } else {
            for (var index = 0; index < dataContainer.numRows(); ++index) {
              allLabels.push(getTextAccessor({
                index: index
              }));
            }
          }
        }
        characterSet = (0, _lodash["default"])(allLabels.join(''));
      } else {
        var _allLabels = tl.field ? data.map(getTextAccessor) : [];
        characterSet = (0, _lodash["default"])(_allLabels.join(''));
      }
    }

    // For Arrow Layers getText has to be an arrow vector.
    // For now check here for ArrowTable, not ArrowDataContainer.
    if (rebuildArrowTextVector && data instanceof arrow.Table && dataContainer instanceof _utils.ArrowDataContainer) {
      getText = dataContainer.getColumn(tl.field.fieldIdx);
      try {
        getText = getArrowTextVector(getText, getTextAccessor);
      } catch (error) {
        // empty text labels
        getText = getArrowTextVector(getText, function () {
          return ' ';
        });
      }
    }
    return {
      characterSet: characterSet,
      getText: getText
    };
  });
};

/**
 * Get an arrow vector suitable to render text labels with arrow layers.
 * @param getText A candidate arrow vector to use for text labels.
 * @param getTextAccessor Text label accessor.
 */
var getArrowTextVector = exports.getArrowTextVector = function getArrowTextVector(candidateTextVector, getTextAccessor) {
  // if the passed vector is suitable for text labels
  if (arrow.DataType.isUtf8(candidateTextVector === null || candidateTextVector === void 0 ? void 0 : candidateTextVector.type)) {
    return candidateTextVector;
  }

  // create utf8 vector from source vector with the same number of batches.
  // @ts-expect-error
  var offsets = candidateTextVector._offsets;
  var numOffsets = offsets.length;
  var batchVectors = [];
  var datum = {
    index: 0
  };
  for (var batchIndex = 0; batchIndex < numOffsets - 1; batchIndex++) {
    var batchStart = offsets[batchIndex];
    var batchEnd = offsets[batchIndex + 1];
    var batchLabels = [];
    for (var rowIndex = batchStart; rowIndex < batchEnd; ++rowIndex) {
      datum.index = rowIndex;
      batchLabels.push(getTextAccessor(datum));
    }
    batchVectors.push(arrow.vectorFromArray(batchLabels, new arrow.Utf8()));
  }
  var input = batchVectors.flatMap(function (x) {
    return x.data;
  }).flat(Number.POSITIVE_INFINITY);
  return new arrow.Vector(input);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhcnJvdyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl92aWV3cG9ydE1lcmNhdG9yUHJvamVjdCIsIl91dGlscyIsIl9jb21tb25VdGlscyIsIl9sb2Rhc2giLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiaGFzIiwiZ2V0IiwibiIsIl9fcHJvdG9fXyIsImEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwiZGVmYXVsdFBhZGRpbmciLCJleHBvcnRzIiwiZ2V0VGV4dE9mZnNldEJ5UmFkaXVzIiwicmFkaXVzU2NhbGUiLCJnZXRSYWRpdXMiLCJtYXBTdGF0ZSIsInRleHRMYWJlbCIsImRpc3RhbmNlU2NhbGUiLCJnZXREaXN0YW5jZVNjYWxlcyIsInhNdWx0IiwiYW5jaG9yIiwieU11bHQiLCJhbGlnbm1lbnQiLCJzaXplT2Zmc2V0Iiwic2l6ZSIsInBpeGVsUmFkaXVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJwYWRkaW5nIiwiZCIsInRleHRMYWJlbEFjY2Vzc29yIiwiZGMiLCJ2YWwiLCJmaWVsZCIsInZhbHVlQWNjZXNzb3IiLCJub3ROdWxsb3JVbmRlZmluZWQiLCJTdHJpbmciLCJmb3JtYXRUZXh0TGFiZWxEYXRhIiwiX3JlZiIsInRyaWdnZXJDaGFuZ2VkIiwib2xkTGF5ZXJEYXRhIiwiZGF0YSIsImRhdGFDb250YWluZXIiLCJmaWx0ZXJlZEluZGV4IiwibWFwIiwidGwiLCJnZXRUZXh0IiwiY2hhcmFjdGVyU2V0IiwiZ2V0VGV4dEFjY2Vzc29yIiwicmVidWlsZEFycm93VGV4dFZlY3RvciIsImNvbmNhdCIsInRleHRMYWJlbHMiLCJUYWJsZSIsImFsbExhYmVscyIsImZvckVhY2giLCJ2YWx1ZSIsImluZGV4IiwicHVzaCIsIm51bVJvd3MiLCJ1bmlxIiwiam9pbiIsIkFycm93RGF0YUNvbnRhaW5lciIsImdldENvbHVtbiIsImZpZWxkSWR4IiwiZ2V0QXJyb3dUZXh0VmVjdG9yIiwiZXJyb3IiLCJjYW5kaWRhdGVUZXh0VmVjdG9yIiwiRGF0YVR5cGUiLCJpc1V0ZjgiLCJ0eXBlIiwib2Zmc2V0cyIsIl9vZmZzZXRzIiwibnVtT2Zmc2V0cyIsImxlbmd0aCIsImJhdGNoVmVjdG9ycyIsImRhdHVtIiwiYmF0Y2hJbmRleCIsImJhdGNoU3RhcnQiLCJiYXRjaEVuZCIsImJhdGNoTGFiZWxzIiwicm93SW5kZXgiLCJ2ZWN0b3JGcm9tQXJyYXkiLCJVdGY4IiwiaW5wdXQiLCJmbGF0TWFwIiwieCIsImZsYXQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIlZlY3RvciJdLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXllci10ZXh0LWxhYmVsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5pbXBvcnQge2dldERpc3RhbmNlU2NhbGVzfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7RGF0YUNvbnRhaW5lckludGVyZmFjZSwgQXJyb3dEYXRhQ29udGFpbmVyfSBmcm9tICdAa2VwbGVyLmdsL3V0aWxzJztcbmltcG9ydCB7bm90TnVsbG9yVW5kZWZpbmVkfSBmcm9tICdAa2VwbGVyLmdsL2NvbW1vbi11dGlscyc7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFkZGluZyA9IDIwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dE9mZnNldEJ5UmFkaXVzKHJhZGl1c1NjYWxlLCBnZXRSYWRpdXMsIG1hcFN0YXRlKSB7XG4gIHJldHVybiB0ZXh0TGFiZWwgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGUgPSBnZXREaXN0YW5jZVNjYWxlcyhtYXBTdGF0ZSk7XG4gICAgY29uc3QgeE11bHQgPSB0ZXh0TGFiZWwuYW5jaG9yID09PSAnbWlkZGxlJyA/IDAgOiB0ZXh0TGFiZWwuYW5jaG9yID09PSAnc3RhcnQnID8gMSA6IC0xO1xuICAgIGNvbnN0IHlNdWx0ID0gdGV4dExhYmVsLmFsaWdubWVudCA9PT0gJ2NlbnRlcicgPyAwIDogdGV4dExhYmVsLmFsaWdubWVudCA9PT0gJ2JvdHRvbScgPyAxIDogLTE7XG5cbiAgICBjb25zdCBzaXplT2Zmc2V0ID1cbiAgICAgIHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdjZW50ZXInXG4gICAgICAgID8gMFxuICAgICAgICA6IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdib3R0b20nXG4gICAgICAgID8gdGV4dExhYmVsLnNpemVcbiAgICAgICAgOiB0ZXh0TGFiZWwuc2l6ZTtcblxuICAgIGNvbnN0IHBpeGVsUmFkaXVzID0gcmFkaXVzU2NhbGUgKiBkaXN0YW5jZVNjYWxlLnBpeGVsc1Blck1ldGVyWzBdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZztcblxuICAgIHJldHVybiB0eXBlb2YgZ2V0UmFkaXVzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGQgPT4gW1xuICAgICAgICAgIHhNdWx0ICogKGdldFJhZGl1cyhkKSAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyksXG4gICAgICAgICAgeU11bHQgKiAoZ2V0UmFkaXVzKGQpICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nICsgc2l6ZU9mZnNldClcbiAgICAgICAgXVxuICAgICAgOiBbXG4gICAgICAgICAgeE11bHQgKiAoZ2V0UmFkaXVzICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5TXVsdCAqIChnZXRSYWRpdXMgKiBwaXhlbFJhZGl1cyArIHBhZGRpbmcgKyBzaXplT2Zmc2V0KVxuICAgICAgICBdO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgY29uc3QgdGV4dExhYmVsQWNjZXNzb3IgPSB0ZXh0TGFiZWwgPT4gZGMgPT4gZCA9PiB7XG4gIGNvbnN0IHZhbCA9IHRleHRMYWJlbC5maWVsZC52YWx1ZUFjY2Vzc29yKGQpO1xuICByZXR1cm4gbm90TnVsbG9yVW5kZWZpbmVkKHZhbCkgPyBTdHJpbmcodmFsKSA6ICcnO1xufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdFRleHRMYWJlbERhdGEgPSAoe1xuICB0ZXh0TGFiZWwsXG4gIHRyaWdnZXJDaGFuZ2VkLFxuICBvbGRMYXllckRhdGEsXG4gIGRhdGEsXG4gIGRhdGFDb250YWluZXIsXG4gIGZpbHRlcmVkSW5kZXhcbn06IHtcbiAgdGV4dExhYmVsOiBhbnk7XG4gIHRyaWdnZXJDaGFuZ2VkPzogYm9vbGVhbiB8IHtba2V5OiBzdHJpbmddOiBib29sZWFufTtcbiAgb2xkTGF5ZXJEYXRhOiBhbnk7XG4gIGRhdGE6IGFueTtcbiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZTtcbiAgZmlsdGVyZWRJbmRleD86IFVpbnQ4Q2xhbXBlZEFycmF5IHwgbnVsbDtcbn0pID0+IHtcbiAgcmV0dXJuIHRleHRMYWJlbC5tYXAoKHRsLCBpKSA9PiB7XG4gICAgaWYgKCF0bC5maWVsZCkge1xuICAgICAgLy8gaWYgbm8gZmllbGQgc2VsZWN0ZWQsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRUZXh0OiBudWxsLFxuICAgICAgICBjaGFyYWN0ZXJTZXQ6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdldFRleHRBY2Nlc3NvcjogKGQ6IHtpbmRleDogbnVtYmVyfSkgPT4gc3RyaW5nID0gdGV4dExhYmVsQWNjZXNzb3IodGwpKGRhdGFDb250YWluZXIpO1xuICAgIGxldCBjaGFyYWN0ZXJTZXQ7XG4gICAgbGV0IGdldFRleHQ6IHR5cGVvZiBnZXRUZXh0QWNjZXNzb3IgfCBhcnJvdy5WZWN0b3IgPSBnZXRUZXh0QWNjZXNzb3I7XG5cbiAgICBsZXQgcmVidWlsZEFycm93VGV4dFZlY3RvciA9IHRydWU7XG4gICAgaWYgKFxuICAgICAgIXRyaWdnZXJDaGFuZ2VkPy5bYGdldExhYmVsQ2hhcmFjdGVyU2V0LSR7aX1gXSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEudGV4dExhYmVscyAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHNbaV1cbiAgICApIHtcbiAgICAgIGNoYXJhY3RlclNldCA9IG9sZExheWVyRGF0YS50ZXh0TGFiZWxzW2ldLmNoYXJhY3RlclNldDtcbiAgICAgIGdldFRleHQgPSBvbGRMYXllckRhdGEudGV4dExhYmVsc1tpXS5nZXRUZXh0O1xuICAgICAgcmVidWlsZEFycm93VGV4dFZlY3RvciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIGFycm93LlRhYmxlKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGZpbHRlciBvdXQgYXJyb3cgdGFibGVzLFxuICAgICAgICAvLyBzbyB3ZSB1c2UgZmlsdGVyZWRJbmRleCBhcnJheSBpbnN0ZWFkXG4gICAgICAgIGNvbnN0IGFsbExhYmVsczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKHRsLmZpZWxkKSB7XG4gICAgICAgICAgaWYgKGZpbHRlcmVkSW5kZXgpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSW5kZXguZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIGFsbExhYmVscy5wdXNoKGdldFRleHRBY2Nlc3Nvcih7aW5kZXh9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRhdGFDb250YWluZXIubnVtUm93cygpOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgIGFsbExhYmVscy5wdXNoKGdldFRleHRBY2Nlc3Nvcih7aW5kZXh9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXJhY3RlclNldCA9IHVuaXEoYWxsTGFiZWxzLmpvaW4oJycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFsbExhYmVscyA9IHRsLmZpZWxkID8gZGF0YS5tYXAoZ2V0VGV4dEFjY2Vzc29yKSA6IFtdO1xuICAgICAgICBjaGFyYWN0ZXJTZXQgPSB1bmlxKGFsbExhYmVscy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIEFycm93IExheWVycyBnZXRUZXh0IGhhcyB0byBiZSBhbiBhcnJvdyB2ZWN0b3IuXG4gICAgLy8gRm9yIG5vdyBjaGVjayBoZXJlIGZvciBBcnJvd1RhYmxlLCBub3QgQXJyb3dEYXRhQ29udGFpbmVyLlxuICAgIGlmIChcbiAgICAgIHJlYnVpbGRBcnJvd1RleHRWZWN0b3IgJiZcbiAgICAgIGRhdGEgaW5zdGFuY2VvZiBhcnJvdy5UYWJsZSAmJlxuICAgICAgZGF0YUNvbnRhaW5lciBpbnN0YW5jZW9mIEFycm93RGF0YUNvbnRhaW5lclxuICAgICkge1xuICAgICAgZ2V0VGV4dCA9IGRhdGFDb250YWluZXIuZ2V0Q29sdW1uKHRsLmZpZWxkLmZpZWxkSWR4KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdldFRleHQgPSBnZXRBcnJvd1RleHRWZWN0b3IoZ2V0VGV4dCBhcyBhcnJvdy5WZWN0b3IsIGdldFRleHRBY2Nlc3Nvcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBlbXB0eSB0ZXh0IGxhYmVsc1xuICAgICAgICBnZXRUZXh0ID0gZ2V0QXJyb3dUZXh0VmVjdG9yKGdldFRleHQsICgpID0+ICcgJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJhY3RlclNldCxcbiAgICAgIGdldFRleHRcbiAgICB9O1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGFycm93IHZlY3RvciBzdWl0YWJsZSB0byByZW5kZXIgdGV4dCBsYWJlbHMgd2l0aCBhcnJvdyBsYXllcnMuXG4gKiBAcGFyYW0gZ2V0VGV4dCBBIGNhbmRpZGF0ZSBhcnJvdyB2ZWN0b3IgdG8gdXNlIGZvciB0ZXh0IGxhYmVscy5cbiAqIEBwYXJhbSBnZXRUZXh0QWNjZXNzb3IgVGV4dCBsYWJlbCBhY2Nlc3Nvci5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFycm93VGV4dFZlY3RvciA9IChcbiAgY2FuZGlkYXRlVGV4dFZlY3RvcjogYXJyb3cuVmVjdG9yLFxuICBnZXRUZXh0QWNjZXNzb3I6ICh7aW5kZXh9OiB7aW5kZXg6IG51bWJlcn0pID0+IHN0cmluZ1xuKTogYXJyb3cuVmVjdG9yID0+IHtcbiAgLy8gaWYgdGhlIHBhc3NlZCB2ZWN0b3IgaXMgc3VpdGFibGUgZm9yIHRleHQgbGFiZWxzXG4gIGlmIChhcnJvdy5EYXRhVHlwZS5pc1V0ZjgoY2FuZGlkYXRlVGV4dFZlY3Rvcj8udHlwZSkpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlVGV4dFZlY3RvcjtcbiAgfVxuXG4gIC8vIGNyZWF0ZSB1dGY4IHZlY3RvciBmcm9tIHNvdXJjZSB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYmF0Y2hlcy5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBjb25zdCBvZmZzZXRzID0gY2FuZGlkYXRlVGV4dFZlY3Rvci5fb2Zmc2V0cztcbiAgY29uc3QgbnVtT2Zmc2V0cyA9IG9mZnNldHMubGVuZ3RoO1xuICBjb25zdCBiYXRjaFZlY3RvcnM6IGFycm93LlZlY3RvcltdID0gW107XG4gIGNvbnN0IGRhdHVtID0ge2luZGV4OiAwfTtcbiAgZm9yIChsZXQgYmF0Y2hJbmRleCA9IDA7IGJhdGNoSW5kZXggPCBudW1PZmZzZXRzIC0gMTsgYmF0Y2hJbmRleCsrKSB7XG4gICAgY29uc3QgYmF0Y2hTdGFydCA9IG9mZnNldHNbYmF0Y2hJbmRleF07XG4gICAgY29uc3QgYmF0Y2hFbmQgPSBvZmZzZXRzW2JhdGNoSW5kZXggKyAxXTtcblxuICAgIGNvbnN0IGJhdGNoTGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IHJvd0luZGV4ID0gYmF0Y2hTdGFydDsgcm93SW5kZXggPCBiYXRjaEVuZDsgKytyb3dJbmRleCkge1xuICAgICAgZGF0dW0uaW5kZXggPSByb3dJbmRleDtcbiAgICAgIGJhdGNoTGFiZWxzLnB1c2goZ2V0VGV4dEFjY2Vzc29yKGRhdHVtKSk7XG4gICAgfVxuXG4gICAgYmF0Y2hWZWN0b3JzLnB1c2goYXJyb3cudmVjdG9yRnJvbUFycmF5KGJhdGNoTGFiZWxzLCBuZXcgYXJyb3cuVXRmOCgpKSk7XG4gIH1cblxuICBjb25zdCBpbnB1dCA9IGJhdGNoVmVjdG9ycy5mbGF0TWFwKHggPT4geC5kYXRhKS5mbGF0KE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cbiAgcmV0dXJuIG5ldyBhcnJvdy5WZWN0b3IoaW5wdXQpO1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUdBLElBQUFBLEtBQUEsR0FBQUMsdUJBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLHdCQUFBLEdBQUFELE9BQUE7QUFDQSxJQUFBRSxNQUFBLEdBQUFGLE9BQUE7QUFDQSxJQUFBRyxZQUFBLEdBQUFILE9BQUE7QUFDQSxJQUFBSSxPQUFBLEdBQUFDLHNCQUFBLENBQUFMLE9BQUE7QUFBK0IsU0FBQU0seUJBQUFDLENBQUEsNkJBQUFDLE9BQUEsbUJBQUFDLENBQUEsT0FBQUQsT0FBQSxJQUFBRSxDQUFBLE9BQUFGLE9BQUEsWUFBQUYsd0JBQUEsWUFBQUEseUJBQUFDLENBQUEsV0FBQUEsQ0FBQSxHQUFBRyxDQUFBLEdBQUFELENBQUEsS0FBQUYsQ0FBQTtBQUFBLFNBQUFSLHdCQUFBUSxDQUFBLEVBQUFFLENBQUEsU0FBQUEsQ0FBQSxJQUFBRixDQUFBLElBQUFBLENBQUEsQ0FBQUksVUFBQSxTQUFBSixDQUFBLGVBQUFBLENBQUEsZ0JBQUFLLE9BQUEsQ0FBQUwsQ0FBQSwwQkFBQUEsQ0FBQSxzQkFBQUEsQ0FBQSxRQUFBRyxDQUFBLEdBQUFKLHdCQUFBLENBQUFHLENBQUEsT0FBQUMsQ0FBQSxJQUFBQSxDQUFBLENBQUFHLEdBQUEsQ0FBQU4sQ0FBQSxVQUFBRyxDQUFBLENBQUFJLEdBQUEsQ0FBQVAsQ0FBQSxPQUFBUSxDQUFBLEtBQUFDLFNBQUEsVUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLGNBQUEsSUFBQUQsTUFBQSxDQUFBRSx3QkFBQSxXQUFBQyxDQUFBLElBQUFkLENBQUEsb0JBQUFjLENBQUEsT0FBQUMsY0FBQSxDQUFBQyxJQUFBLENBQUFoQixDQUFBLEVBQUFjLENBQUEsU0FBQUcsQ0FBQSxHQUFBUCxDQUFBLEdBQUFDLE1BQUEsQ0FBQUUsd0JBQUEsQ0FBQWIsQ0FBQSxFQUFBYyxDQUFBLFVBQUFHLENBQUEsS0FBQUEsQ0FBQSxDQUFBVixHQUFBLElBQUFVLENBQUEsQ0FBQUMsR0FBQSxJQUFBUCxNQUFBLENBQUFDLGNBQUEsQ0FBQUosQ0FBQSxFQUFBTSxDQUFBLEVBQUFHLENBQUEsSUFBQVQsQ0FBQSxDQUFBTSxDQUFBLElBQUFkLENBQUEsQ0FBQWMsQ0FBQSxZQUFBTixDQUFBLGNBQUFSLENBQUEsRUFBQUcsQ0FBQSxJQUFBQSxDQUFBLENBQUFlLEdBQUEsQ0FBQWxCLENBQUEsRUFBQVEsQ0FBQSxHQUFBQSxDQUFBO0FBUC9CO0FBQ0E7O0FBUU8sSUFBTVcsY0FBYyxHQUFBQyxPQUFBLENBQUFELGNBQUEsR0FBRyxFQUFFO0FBRXpCLFNBQVNFLHFCQUFxQkEsQ0FBQ0MsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRTtFQUN0RSxPQUFPLFVBQUFDLFNBQVMsRUFBSTtJQUNsQixJQUFNQyxhQUFhLEdBQUcsSUFBQUMsMENBQWlCLEVBQUNILFFBQVEsQ0FBQztJQUNqRCxJQUFNSSxLQUFLLEdBQUdILFNBQVMsQ0FBQ0ksTUFBTSxLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUdKLFNBQVMsQ0FBQ0ksTUFBTSxLQUFLLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZGLElBQU1DLEtBQUssR0FBR0wsU0FBUyxDQUFDTSxTQUFTLEtBQUssUUFBUSxHQUFHLENBQUMsR0FBR04sU0FBUyxDQUFDTSxTQUFTLEtBQUssUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFOUYsSUFBTUMsVUFBVSxHQUNkUCxTQUFTLENBQUNNLFNBQVMsS0FBSyxRQUFRLEdBQzVCLENBQUMsR0FDRE4sU0FBUyxDQUFDTSxTQUFTLEtBQUssUUFBUSxHQUNoQ04sU0FBUyxDQUFDUSxJQUFJLEdBQ2RSLFNBQVMsQ0FBQ1EsSUFBSTtJQUVwQixJQUFNQyxXQUFXLEdBQUdaLFdBQVcsR0FBR0ksYUFBYSxDQUFDUyxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLElBQU1DLE9BQU8sR0FBR2pCLGNBQWM7SUFFOUIsT0FBTyxPQUFPSSxTQUFTLEtBQUssVUFBVSxHQUNsQyxVQUFBYyxDQUFDO01BQUEsT0FBSSxDQUNIVCxLQUFLLElBQUlMLFNBQVMsQ0FBQ2MsQ0FBQyxDQUFDLEdBQUdILFdBQVcsR0FBR0UsT0FBTyxDQUFDLEVBQzlDTixLQUFLLElBQUlQLFNBQVMsQ0FBQ2MsQ0FBQyxDQUFDLEdBQUdILFdBQVcsR0FBR0UsT0FBTyxHQUFHSixVQUFVLENBQUMsQ0FDNUQ7SUFBQSxJQUNELENBQ0VKLEtBQUssSUFBSUwsU0FBUyxHQUFHVyxXQUFXLEdBQUdFLE9BQU8sQ0FBQyxFQUMzQ04sS0FBSyxJQUFJUCxTQUFTLEdBQUdXLFdBQVcsR0FBR0UsT0FBTyxHQUFHSixVQUFVLENBQUMsQ0FDekQ7RUFDUCxDQUFDO0FBQ0g7O0FBRUE7QUFDTyxJQUFNTSxpQkFBaUIsR0FBQWxCLE9BQUEsQ0FBQWtCLGlCQUFBLEdBQUcsU0FBcEJBLGlCQUFpQkEsQ0FBR2IsU0FBUztFQUFBLE9BQUksVUFBQWMsRUFBRTtJQUFBLE9BQUksVUFBQUYsQ0FBQyxFQUFJO01BQ3ZELElBQU1HLEdBQUcsR0FBR2YsU0FBUyxDQUFDZ0IsS0FBSyxDQUFDQyxhQUFhLENBQUNMLENBQUMsQ0FBQztNQUM1QyxPQUFPLElBQUFNLCtCQUFrQixFQUFDSCxHQUFHLENBQUMsR0FBR0ksTUFBTSxDQUFDSixHQUFHLENBQUMsR0FBRyxFQUFFO0lBQ25ELENBQUM7RUFBQTtBQUFBO0FBRU0sSUFBTUssbUJBQW1CLEdBQUF6QixPQUFBLENBQUF5QixtQkFBQSxHQUFHLFNBQXRCQSxtQkFBbUJBLENBQUFDLElBQUEsRUFjMUI7RUFBQSxJQWJKckIsU0FBUyxHQUFBcUIsSUFBQSxDQUFUckIsU0FBUztJQUNUc0IsY0FBYyxHQUFBRCxJQUFBLENBQWRDLGNBQWM7SUFDZEMsWUFBWSxHQUFBRixJQUFBLENBQVpFLFlBQVk7SUFDWkMsSUFBSSxHQUFBSCxJQUFBLENBQUpHLElBQUk7SUFDSkMsYUFBYSxHQUFBSixJQUFBLENBQWJJLGFBQWE7SUFDYkMsYUFBYSxHQUFBTCxJQUFBLENBQWJLLGFBQWE7RUFTYixPQUFPMUIsU0FBUyxDQUFDMkIsR0FBRyxDQUFDLFVBQUNDLEVBQUUsRUFBRXBDLENBQUMsRUFBSztJQUM5QixJQUFJLENBQUNvQyxFQUFFLENBQUNaLEtBQUssRUFBRTtNQUNiO01BQ0EsT0FBTztRQUNMYSxPQUFPLEVBQUUsSUFBSTtRQUNiQyxZQUFZLEVBQUU7TUFDaEIsQ0FBQztJQUNIO0lBRUEsSUFBTUMsZUFBK0MsR0FBR2xCLGlCQUFpQixDQUFDZSxFQUFFLENBQUMsQ0FBQ0gsYUFBYSxDQUFDO0lBQzVGLElBQUlLLFlBQVk7SUFDaEIsSUFBSUQsT0FBOEMsR0FBR0UsZUFBZTtJQUVwRSxJQUFJQyxzQkFBc0IsR0FBRyxJQUFJO0lBQ2pDLElBQ0UsRUFBQ1YsY0FBYyxhQUFkQSxjQUFjLGVBQWRBLGNBQWMseUJBQUFXLE1BQUEsQ0FBMkJ6QyxDQUFDLEVBQUcsS0FDOUMrQixZQUFZLElBQ1pBLFlBQVksQ0FBQ1csVUFBVSxJQUN2QlgsWUFBWSxDQUFDVyxVQUFVLENBQUMxQyxDQUFDLENBQUMsRUFDMUI7TUFDQXNDLFlBQVksR0FBR1AsWUFBWSxDQUFDVyxVQUFVLENBQUMxQyxDQUFDLENBQUMsQ0FBQ3NDLFlBQVk7TUFDdERELE9BQU8sR0FBR04sWUFBWSxDQUFDVyxVQUFVLENBQUMxQyxDQUFDLENBQUMsQ0FBQ3FDLE9BQU87TUFDNUNHLHNCQUFzQixHQUFHLEtBQUs7SUFDaEMsQ0FBQyxNQUFNO01BQ0wsSUFBSVIsSUFBSSxZQUFZMUQsS0FBSyxDQUFDcUUsS0FBSyxFQUFFO1FBQy9CO1FBQ0E7UUFDQSxJQUFNQyxTQUFtQixHQUFHLEVBQUU7UUFDOUIsSUFBSVIsRUFBRSxDQUFDWixLQUFLLEVBQUU7VUFDWixJQUFJVSxhQUFhLEVBQUU7WUFDakJBLGFBQWEsQ0FBQ1csT0FBTyxDQUFDLFVBQUNDLEtBQUssRUFBRUMsS0FBSyxFQUFLO2NBQ3RDLElBQUlELEtBQUssR0FBRyxDQUFDLEVBQUVGLFNBQVMsQ0FBQ0ksSUFBSSxDQUFDVCxlQUFlLENBQUM7Z0JBQUNRLEtBQUssRUFBTEE7Y0FBSyxDQUFDLENBQUMsQ0FBQztZQUN6RCxDQUFDLENBQUM7VUFDSixDQUFDLE1BQU07WUFDTCxLQUFLLElBQUlBLEtBQUssR0FBRyxDQUFDLEVBQUVBLEtBQUssR0FBR2QsYUFBYSxDQUFDZ0IsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFRixLQUFLLEVBQUU7Y0FDNURILFNBQVMsQ0FBQ0ksSUFBSSxDQUFDVCxlQUFlLENBQUM7Z0JBQUNRLEtBQUssRUFBTEE7Y0FBSyxDQUFDLENBQUMsQ0FBQztZQUMxQztVQUNGO1FBQ0Y7UUFDQVQsWUFBWSxHQUFHLElBQUFZLGtCQUFJLEVBQUNOLFNBQVMsQ0FBQ08sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO01BQ3pDLENBQUMsTUFBTTtRQUNMLElBQU1QLFVBQVMsR0FBR1IsRUFBRSxDQUFDWixLQUFLLEdBQUdRLElBQUksQ0FBQ0csR0FBRyxDQUFDSSxlQUFlLENBQUMsR0FBRyxFQUFFO1FBQzNERCxZQUFZLEdBQUcsSUFBQVksa0JBQUksRUFBQ04sVUFBUyxDQUFDTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7TUFDekM7SUFDRjs7SUFFQTtJQUNBO0lBQ0EsSUFDRVgsc0JBQXNCLElBQ3RCUixJQUFJLFlBQVkxRCxLQUFLLENBQUNxRSxLQUFLLElBQzNCVixhQUFhLFlBQVltQix5QkFBa0IsRUFDM0M7TUFDQWYsT0FBTyxHQUFHSixhQUFhLENBQUNvQixTQUFTLENBQUNqQixFQUFFLENBQUNaLEtBQUssQ0FBQzhCLFFBQVEsQ0FBQztNQUNwRCxJQUFJO1FBQ0ZqQixPQUFPLEdBQUdrQixrQkFBa0IsQ0FBQ2xCLE9BQU8sRUFBa0JFLGVBQWUsQ0FBQztNQUN4RSxDQUFDLENBQUMsT0FBT2lCLEtBQUssRUFBRTtRQUNkO1FBQ0FuQixPQUFPLEdBQUdrQixrQkFBa0IsQ0FBQ2xCLE9BQU8sRUFBRTtVQUFBLE9BQU0sR0FBRztRQUFBLEVBQUM7TUFDbEQ7SUFDRjtJQUVBLE9BQU87TUFDTEMsWUFBWSxFQUFaQSxZQUFZO01BQ1pELE9BQU8sRUFBUEE7SUFDRixDQUFDO0VBQ0gsQ0FBQyxDQUFDO0FBQ0osQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTWtCLGtCQUFrQixHQUFBcEQsT0FBQSxDQUFBb0Qsa0JBQUEsR0FBRyxTQUFyQkEsa0JBQWtCQSxDQUM3QkUsbUJBQWlDLEVBQ2pDbEIsZUFBcUQsRUFDcEM7RUFDakI7RUFDQSxJQUFJakUsS0FBSyxDQUFDb0YsUUFBUSxDQUFDQyxNQUFNLENBQUNGLG1CQUFtQixhQUFuQkEsbUJBQW1CLHVCQUFuQkEsbUJBQW1CLENBQUVHLElBQUksQ0FBQyxFQUFFO0lBQ3BELE9BQU9ILG1CQUFtQjtFQUM1Qjs7RUFFQTtFQUNBO0VBQ0EsSUFBTUksT0FBTyxHQUFHSixtQkFBbUIsQ0FBQ0ssUUFBUTtFQUM1QyxJQUFNQyxVQUFVLEdBQUdGLE9BQU8sQ0FBQ0csTUFBTTtFQUNqQyxJQUFNQyxZQUE0QixHQUFHLEVBQUU7RUFDdkMsSUFBTUMsS0FBSyxHQUFHO0lBQUNuQixLQUFLLEVBQUU7RUFBQyxDQUFDO0VBQ3hCLEtBQUssSUFBSW9CLFVBQVUsR0FBRyxDQUFDLEVBQUVBLFVBQVUsR0FBR0osVUFBVSxHQUFHLENBQUMsRUFBRUksVUFBVSxFQUFFLEVBQUU7SUFDbEUsSUFBTUMsVUFBVSxHQUFHUCxPQUFPLENBQUNNLFVBQVUsQ0FBQztJQUN0QyxJQUFNRSxRQUFRLEdBQUdSLE9BQU8sQ0FBQ00sVUFBVSxHQUFHLENBQUMsQ0FBQztJQUV4QyxJQUFNRyxXQUFxQixHQUFHLEVBQUU7SUFDaEMsS0FBSyxJQUFJQyxRQUFRLEdBQUdILFVBQVUsRUFBRUcsUUFBUSxHQUFHRixRQUFRLEVBQUUsRUFBRUUsUUFBUSxFQUFFO01BQy9ETCxLQUFLLENBQUNuQixLQUFLLEdBQUd3QixRQUFRO01BQ3RCRCxXQUFXLENBQUN0QixJQUFJLENBQUNULGVBQWUsQ0FBQzJCLEtBQUssQ0FBQyxDQUFDO0lBQzFDO0lBRUFELFlBQVksQ0FBQ2pCLElBQUksQ0FBQzFFLEtBQUssQ0FBQ2tHLGVBQWUsQ0FBQ0YsV0FBVyxFQUFFLElBQUloRyxLQUFLLENBQUNtRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDekU7RUFFQSxJQUFNQyxLQUFLLEdBQUdULFlBQVksQ0FBQ1UsT0FBTyxDQUFDLFVBQUFDLENBQUM7SUFBQSxPQUFJQSxDQUFDLENBQUM1QyxJQUFJO0VBQUEsRUFBQyxDQUFDNkMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLGlCQUFpQixDQUFDO0VBRTlFLE9BQU8sSUFBSXpHLEtBQUssQ0FBQzBHLE1BQU0sQ0FBQ04sS0FBSyxDQUFDO0FBQ2hDLENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=