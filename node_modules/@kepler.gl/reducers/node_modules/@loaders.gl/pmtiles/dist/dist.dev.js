(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['loaders'] = factory();
  else root['loaders'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global-plugin:@loaders.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@loaders.gl/core"(exports, module) {
      module.exports = globalThis.loaders;
    }
  });

  // ../../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i2 = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i2];
        i2 += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i2 = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i2 - d] |= s * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        // === READING =================================================================
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b;
          b = buf[this.pos++];
          val = b & 127;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128)
            return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder2(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        // verbose for performance reasons; doesn't affect gzipped size
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val) {
          var type = val & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        // === WRITING =================================================================
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min) {
          var length = this.length || 16;
          while (length < this.pos + min)
            length *= 2;
          if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i2 = 0; i2 < len; i2++)
            this.buf[this.pos++] = buffer[i2];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      function readVarintRemainder2(l, s, p) {
        var buf = p.buf, h, b;
        b = buf[p.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum2(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum2(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum2(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum2(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum2(l, h, s);
        b = buf[p.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum2(l, h, s);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum2(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i2 = pbf.pos - 1; i2 >= startPos; i2--)
          pbf.buf[i2 + extraLen] = pbf.buf[i2];
      }
      function writePackedVarint(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeVarint(arr[i2]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeSVarint(arr[i2]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeFloat(arr[i2]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeDouble(arr[i2]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeBoolean(arr[i2]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeFixed32(arr[i2]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeSFixed32(arr[i2]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeFixed64(arr[i2]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i2 = 0; i2 < arr.length; i2++)
          pbf.writeSFixed64(arr[i2]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i2 = pos;
        while (i2 < end) {
          var b0 = buf[i2];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i2 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i2 + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i2 + 1];
            b2 = buf[i2 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i2 + 1];
            b2 = buf[i2 + 2];
            b3 = buf[i2 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i2 += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i2 = 0, c, lead; i2 < str.length; i2++) {
          c = str.charCodeAt(i2);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i2 + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    PMTilesSource: () => PMTilesSource,
    PMTilesTileSource: () => PMTilesTileSource,
    _PMTilesLoader: () => PMTilesLoader
  });
  __reExport(bundle_exports, __toESM(require_core(), 1));

  // ../loader-utils/src/lib/env-utils/assert.ts
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../loader-utils/src/lib/env-utils/globals.ts
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = (
    // @ts-ignore process does not exist on browser
    Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
  );
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@probe.gl/log/node_modules/@probe.gl/env/dist/lib/globals.js
  var window_2 = globalThis;
  var document_2 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/log/node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && window.process?.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
  }

  // ../../node_modules/@probe.gl/log/node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser2() {
    const isNode = (
      // @ts-expect-error
      typeof process === "object" && String(process) === "[object process]" && !process?.browser
    );
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/log/node_modules/@probe.gl/env/dist/index.js
  var VERSION = true ? "4.0.7" : "untranspiled source";

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig, type = "sessionStorage") {
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
      formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1e3) {
      formatted = `${ms.toFixed(0)}ms`;
    } else {
      formatted = `${(ms / 1e3).toFixed(2)}s`;
    }
    return formatted;
  }
  function leftPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${" ".repeat(padLength)}${string}`;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser2 && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = `\x1B[${colorCode}m${string}\x1B[39m`;
      }
      if (background) {
        const colorCode = getColor(background);
        string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj, predefined = ["constructor"]) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name) => key === name)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser2() && window_2.performance) {
      timestamp = window_2?.performance?.now?.();
    } else if ("hrtime" in process_) {
      const timeParts = process_?.hrtime?.();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser2() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = { once: true };
  var Log = class {
    constructor({ id } = { id: "" }) {
      this.VERSION = VERSION;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
      this.timeStamp(`${this.id} started`);
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */
    set priority(newPriority) {
      this.level = newPriority;
    }
    /** @deprecated use logLevel */
    get priority() {
      return this.level;
    }
    /** @deprecated use logLevel */
    getPriority() {
      return this.level;
    }
    // Configure
    enable(enabled = true) {
      this._storage.setConfiguration({ enabled });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({ level });
      return this;
    }
    /** return the current status of the setting */
    get(setting) {
      return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
      this._storage.setConfiguration({ [setting]: value });
    }
    /** Logs the current settings as a table */
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    // Unconditional logging
    assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */
    deprecated(oldUsage, newUsage) {
      return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */
    removed(oldUsage, newUsage) {
      return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message, opts = { collapsed: false }) {
      const options = normalizeArguments({ logLevel, message, opts });
      const { collapsed } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message, opts = {}) {
      return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({ logLevel, message, args, opts });
        method = method || opts.method;
        assert2(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert2(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const { logLevel, message } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert2(messageType === "string" || messageType === "object");
    return Object.assign(opts, { args }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/init.js
  globalThis.probe = {};

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({ id: "@probe.gl/log" });

  // ../loader-utils/src/lib/log-utils/log.ts
  var VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var version = VERSION2[0] >= "0" && VERSION2[0] <= "9" ? `v${VERSION2}` : "";
  function createLog() {
    const log2 = new Log({ id: "loaders.gl" });
    globalThis.loaders = globalThis.loaders || {};
    globalThis.loaders.log = log2;
    globalThis.loaders.version = version;
    globalThis.probe = globalThis.probe || {};
    globalThis.probe.loaders = log2;
    return log2;
  }
  var log = createLog();

  // ../loader-utils/src/lib/path-utils/file-aliases.ts
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename) {
    for (const alias in fileAliases) {
      if (filename.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename = filename.replace(alias, replacement);
      }
    }
    if (!filename.startsWith("http://") && !filename.startsWith("https://")) {
      filename = `${pathPrefix}${filename}`;
    }
    return filename;
  }

  // ../loader-utils/src/lib/files/blob-file.ts
  var BlobFile = class {
    handle;
    size;
    bigsize;
    url;
    constructor(blob) {
      this.handle = blob instanceof ArrayBuffer ? new Blob([blob]) : blob;
      this.size = blob instanceof ArrayBuffer ? blob.byteLength : blob.size;
      this.bigsize = BigInt(this.size);
      this.url = blob instanceof File ? blob.name : "";
    }
    async close() {
    }
    async stat() {
      return {
        size: this.handle.size,
        bigsize: BigInt(this.handle.size),
        isDirectory: false
      };
    }
    async read(start, length) {
      const arrayBuffer = await this.handle.slice(Number(start), Number(start) + Number(length)).arrayBuffer();
      return arrayBuffer;
    }
  };

  // ../loader-utils/src/lib/sources/data-source.ts
  var DataSource = class {
    /** A resolved fetch function extracted from loadOptions prop */
    fetch;
    /** The actual load options, if calling a loaders.gl loader */
    loadOptions;
    _needsRefresh = true;
    props;
    constructor(props) {
      this.props = { ...props };
      this.loadOptions = { ...props.loadOptions };
      this.fetch = getFetchFunction(this.loadOptions);
    }
    setProps(props) {
      this.props = Object.assign(this.props, props);
      this.setNeedsRefresh();
    }
    /** Mark this data source as needing a refresh (redraw) */
    setNeedsRefresh() {
      this._needsRefresh = true;
    }
    /**
     * Does this data source need refreshing?
     * @note The specifics of the refresh mechanism depends on type of data source
     */
    getNeedsRefresh(clear = true) {
      const needsRefresh = this._needsRefresh;
      if (clear) {
        this._needsRefresh = false;
      }
      return needsRefresh;
    }
  };
  function getFetchFunction(options) {
    const fetchFunction = options?.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options?.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }

  // ../images/src/lib/utils/version.ts
  var VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";

  // ../images/src/lib/category-api/image-type.ts
  var parseImageNode = globalThis.loaders?.parseImageNode;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../images/src/lib/category-api/parsed-image-api.ts
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../images/src/lib/parsers/svg-utils.ts
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error) {
        throw new Error(error.message);
      }
      const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
      return src;
    }
    return getBlob(arrayBuffer, url);
  }
  function getBlob(arrayBuffer, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer)]);
  }

  // ../images/src/lib/parsers/parse-to-image.ts
  async function parseToImage(arrayBuffer, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve, reject) => {
      try {
        image.onload = () => resolve(image);
        image.onerror = (error) => {
          const message = error instanceof Error ? error.message : "error";
          reject(new Error(message));
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  // ../images/src/lib/parsers/parse-to-image-bitmap.ts
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error) {
        console.warn(error);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../images/src/lib/category-api/parse-isobmff-binary.ts
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return { extension: "avif", mimeType: "image/avif" };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header, offset = 0) {
    const headerBytes = stringToBytes(header);
    for (let i2 = 0; i2 < headerBytes.length; ++i2) {
      if (headerBytes[i2] !== buffer[i2 + offset]) {
        return false;
      }
    }
    return true;
  }

  // ../images/src/lib/category-api/binary-image-api.ts
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      // TODO - decode width and height
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const { tableMarkers, sofMarkers } = getJpegMarkers();
    let i2 = 2;
    while (i2 + 9 < dataView.byteLength) {
      const marker = dataView.getUint16(i2, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i2 + 5, BIG_ENDIAN),
          // Number of lines
          width: dataView.getUint16(i2 + 7, BIG_ENDIAN)
          // Number of pixels per line
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i2 += 2;
      i2 += dataView.getUint16(i2, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i2 = 65504; i2 < 65520; ++i2) {
      tableMarkers.add(i2);
    }
    const sofMarkers = /* @__PURE__ */ new Set([
      65472,
      65473,
      65474,
      65475,
      65477,
      65478,
      65479,
      65481,
      65482,
      65483,
      65485,
      65486,
      65487,
      65502
    ]);
    return { tableMarkers, sofMarkers };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../images/src/lib/parsers/parse-to-node-image.ts
  async function parseToNodeImage(arrayBuffer, options) {
    const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
    const parseImageNode2 = globalThis.loaders?.parseImageNode;
    assert(parseImageNode2);
    return await parseImageNode2(arrayBuffer, mimeType);
  }

  // ../images/src/lib/parsers/parse-image.ts
  async function parseImage(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const { url } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer, options);
        break;
      default:
        assert(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../images/src/image-loader.ts
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = [
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
    "image/avif",
    "image/bmp",
    "image/vnd.microsoft.icon",
    "image/svg+xml"
  ];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
      // if format is HTML
    }
    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
  };
  var ImageLoader = {
    dataType: null,
    batchType: null,
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    // TODO: byteOffset, byteLength;
    tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../mvt/src/lib/get-schemas-from-tilejson.ts
  function getSchemaFromTileJSONLayer(layer) {
    const fields = [];
    if (layer.fields) {
      for (const field of layer.fields) {
        fields.push({
          name: field.name,
          type: getDataTypeFromTileJSONField(field),
          metadata: getMetadataFromTileJSONField(field)
        });
      }
    }
    return {
      metadata: getMetadataFromTileJSONLayer(layer),
      fields
    };
  }
  function getMetadataFromTileJSONLayer(layer) {
    const metadata = {};
    for (const [key, value] of Object.entries(layer)) {
      if (key !== "fields" && value) {
        metadata[key] = JSON.stringify(value);
      }
    }
    return metadata;
  }
  function getDataTypeFromTileJSONField(field) {
    switch (field.type.toLowerCase()) {
      case "float32":
        return "float32";
      case "number":
      case "float64":
        return "float64";
      case "string":
      case "utf8":
        return "utf8";
      case "boolean":
        return "bool";
      default:
        return "null";
    }
  }
  function getMetadataFromTileJSONField(field) {
    const metadata = {};
    for (const [key, value] of Object.entries(field)) {
      if (key !== "name" && value) {
        metadata[key] = JSON.stringify(value);
      }
    }
    return metadata;
  }

  // ../mvt/src/lib/parse-tilejson.ts
  var isObject = (x2) => x2 !== null && typeof x2 === "object";
  function parseTileJSON(jsonMetadata, options) {
    if (!jsonMetadata || !isObject(jsonMetadata)) {
      return null;
    }
    let tileJSON = {
      name: jsonMetadata.name || "",
      description: jsonMetadata.description || ""
    };
    if (typeof jsonMetadata.generator === "string") {
      tileJSON.generator = jsonMetadata.generator;
    }
    if (typeof jsonMetadata.generator_options === "string") {
      tileJSON.generatorOptions = jsonMetadata.generator_options;
    }
    tileJSON.boundingBox = parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);
    tileJSON.center = parseCenter(jsonMetadata.center);
    tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);
    tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);
    if (typeof jsonMetadata?.json === "string") {
      try {
        tileJSON.metaJson = JSON.parse(jsonMetadata.json);
      } catch (error) {
        console.warn("Failed to parse tilejson.json field", error);
      }
    }
    const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;
    const tileStatsLayers = parseTilestatsLayers(tilestats, options);
    const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers);
    const layers = mergeLayers(tileJSONlayers, tileStatsLayers);
    tileJSON = {
      ...tileJSON,
      layers
    };
    if (tileJSON.maxZoom === null && layers.length > 0) {
      tileJSON.maxZoom = layers[0].maxZoom || null;
    }
    if (tileJSON.minZoom === null && layers.length > 0) {
      tileJSON.minZoom = layers[0].minZoom || null;
    }
    return tileJSON;
  }
  function parseTileJSONLayers(layers) {
    if (!Array.isArray(layers)) {
      return [];
    }
    return layers.map((layer) => parseTileJSONLayer(layer));
  }
  function parseTileJSONLayer(layer) {
    const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({
      name: key,
      ...attributeTypeToFieldType(String(datatype))
    }));
    const layer2 = { ...layer };
    delete layer2.fields;
    return {
      name: layer.id || "",
      ...layer2,
      fields
    };
  }
  function parseTilestatsLayers(tilestats, options) {
    if (isObject(tilestats) && Array.isArray(tilestats.layers)) {
      return tilestats.layers.map((layer) => parseTilestatsForLayer(layer, options));
    }
    return [];
  }
  function parseTilestatsForLayer(layer, options) {
    const fields = [];
    const indexedAttributes = {};
    const attributes = layer.attributes || [];
    for (const attribute of attributes) {
      const name = attribute.attribute;
      if (typeof name === "string") {
        if (name.split("|").length > 1) {
          const fname = name.split("|")[0];
          indexedAttributes[fname] = indexedAttributes[fname] || [];
          indexedAttributes[fname].push(attribute);
          console.warn("ignoring tilestats indexed field", fname);
        } else if (!fields[name]) {
          fields.push(attributeToField(attribute, options));
        } else {
        }
      }
    }
    return {
      name: layer.layer || "",
      dominantGeometry: layer.geometry,
      fields
    };
  }
  function mergeLayers(layers, tilestatsLayers) {
    return layers.map((layer) => {
      const tilestatsLayer = tilestatsLayers.find((tsLayer) => tsLayer.name === layer.name);
      const fields = tilestatsLayer?.fields || layer.fields || [];
      const mergedLayer = {
        ...layer,
        ...tilestatsLayer,
        fields
      };
      mergedLayer.schema = getSchemaFromTileJSONLayer(mergedLayer);
      return mergedLayer;
    });
  }
  function parseBounds(bounds) {
    const result = fromArrayOrString(bounds);
    if (Array.isArray(result) && result.length === 4 && [result[0], result[2]].every(isLng) && [result[1], result[3]].every(isLat)) {
      return [
        [result[0], result[1]],
        [result[2], result[3]]
      ];
    }
    return void 0;
  }
  function parseCenter(center) {
    const result = fromArrayOrString(center);
    if (Array.isArray(result) && result.length === 3 && isLng(result[0]) && isLat(result[1]) && isZoom(result[2])) {
      return result;
    }
    return null;
  }
  function safeParseFloat(input) {
    const result = typeof input === "string" ? parseFloat(input) : typeof input === "number" ? input : null;
    return result === null || isNaN(result) ? null : result;
  }
  function isLat(num) {
    return Number.isFinite(num) && num <= 90 && num >= -90;
  }
  function isLng(num) {
    return Number.isFinite(num) && num <= 180 && num >= -180;
  }
  function isZoom(num) {
    return Number.isFinite(num) && num >= 0 && num <= 22;
  }
  function fromArrayOrString(data) {
    if (typeof data === "string") {
      return data.split(",").map(parseFloat);
    } else if (Array.isArray(data)) {
      return data;
    }
    return null;
  }
  var attrTypeMap = {
    number: {
      type: "float32"
    },
    numeric: {
      type: "float32"
    },
    string: {
      type: "utf8"
    },
    vachar: {
      type: "utf8"
    },
    float: {
      type: "float32"
    },
    int: {
      type: "int32"
    },
    int4: {
      type: "int32"
    },
    boolean: {
      type: "boolean"
    },
    bool: {
      type: "boolean"
    }
  };
  function attributeToField(attribute = {}, options) {
    const fieldTypes = attributeTypeToFieldType(attribute.type);
    const field = {
      name: attribute.attribute,
      // what happens if attribute type is string...
      // filterProps: getFilterProps(fieldTypes.type, attribute),
      ...fieldTypes
    };
    if (typeof attribute.min === "number") {
      field.min = attribute.min;
    }
    if (typeof attribute.max === "number") {
      field.max = attribute.max;
    }
    if (typeof attribute.count === "number") {
      field.uniqueValueCount = attribute.count;
    }
    if (attribute.values) {
      field.values = attribute.values;
    }
    if (field.values && typeof options.maxValues === "number") {
      field.values = field.values?.slice(0, options.maxValues);
    }
    return field;
  }
  function attributeTypeToFieldType(aType) {
    const type = aType.toLowerCase();
    if (!type || !attrTypeMap[type]) {
    }
    return attrTypeMap[type] || { type: "string" };
  }

  // ../mvt/src/tilejson-loader.ts
  var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var TileJSONLoader = {
    dataType: null,
    batchType: null,
    name: "TileJSON",
    id: "tilejson",
    module: "pmtiles",
    version: VERSION4,
    worker: true,
    extensions: ["json"],
    mimeTypes: ["application/json"],
    text: true,
    options: {
      tilejson: {
        maxValues: void 0
      }
    },
    parse: async (arrayBuffer, options) => {
      const jsonString = new TextDecoder().decode(arrayBuffer);
      const json = JSON.parse(jsonString);
      const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };
      return parseTileJSON(json, tilejsonOptions);
    },
    parseTextSync: (text, options) => {
      const json = JSON.parse(text);
      const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };
      return parseTileJSON(json, tilejsonOptions);
    }
  };

  // ../../node_modules/@math.gl/polygon/dist/polygon-utils.js
  var DimIndex = {
    x: 0,
    y: 1,
    z: 2
  };
  function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = "xy" } = options;
    const dim = options.size || 2;
    let area2 = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
      area2 += (points[i2 + i0] - points[j + i0]) * (points[i2 + i1] + points[j + i1]);
      j = i2;
    }
    return area2 / 2;
  }

  // ../../node_modules/@math.gl/polygon/dist/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas, plane = "xy") {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x2;
    let y;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = positions[i2];
        y = positions[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y < minY)
          minY = y;
        if (x2 > maxX)
          maxX = x2;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2, plane) {
    let i2;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, { start, end, size: dim, plane });
    }
    let i0 = DimIndex[plane[0]];
    let i1 = DimIndex[plane[1]];
    if (clockwise === area2 < 0) {
      for (i2 = start; i2 < end; i2 += dim)
        last = insertNode(i2, data[i2 + i0], data[i2 + i1], last);
    } else {
      for (i2 = end - dim; i2 >= start; i2 -= dim)
        last = insertNode(i2, data[i2 + i0], data[i2 + i1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start;
    let again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x;
    const bx = b.x;
    const cx = c.x;
    const ay = a.y;
    const by = b.y;
    const cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ;
    let n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
      const a = p.prev;
      const b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i2;
    let len;
    let start;
    let end;
    let list;
    for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      start = holeIndices[i2] * dim;
      end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i2 + 1], plane);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i2 = 0; i2 < queue.length; i2++) {
      outerNode = eliminateHole(queue[i2], outerNode);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          m = p.x < p.next.x ? p : p.next;
          if (x2 === hx)
            return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === 0)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let e;
    let i2;
    let inSize = 1;
    let numMerges;
    let p;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i2 = 0; i2 < inSize; i2++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y, minX, minY, invSize) {
    x2 = (x2 - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x2 | y << 1;
  }
  function getLeftmost(start) {
    let p = start;
    let leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Vertex(a.i, a.x, a.y);
    const b2 = new Vertex(b.i, b.x, b.y);
    const an = a.next;
    const bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i2, x2, y, last) {
    const p = new Vertex(i2, x2, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  var Vertex = class {
    constructor(i2, x2, y) {
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
      this.i = i2;
      this.x = x2;
      this.y = y;
    }
  };

  // ../gis/src/lib/binary-features/flat-geojson-to-binary.ts
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
    return fillArrays(
      features,
      {
        propArrayTypes,
        ...geometryInfo
      },
      {
        numericPropKeys: options && options.numericPropKeys || numericPropKeys,
        PositionDataType: options ? options.PositionDataType : Float32Array,
        triangulate: options ? options.triangulate : true
      }
    );
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    if (triangulate) {
      polygons.triangles = [];
    }
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T = propArrayTypes[propName];
        object.numericProps[propName] = new T(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({ id: feature.id });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({ id: feature.id });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({ id: feature.id });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.pointPosition,
      indexMap.pointPosition + nPositions
    );
    points.featureIds.fill(
      indexMap.pointFeature,
      indexMap.pointPosition,
      indexMap.pointPosition + nPositions
    );
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.linePosition,
      indexMap.linePosition + nPositions
    );
    lines.featureIds.fill(
      indexMap.lineFeature,
      indexMap.linePosition,
      indexMap.linePosition + nPositions
    );
    for (let i2 = 0, il = geometry.indices.length; i2 < il; ++i2) {
      const start = geometry.indices[i2];
      const end = i2 === il - 1 ? geometry.data.length : geometry.indices[i2 + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(
      indexMap.feature,
      indexMap.polygonPosition,
      indexMap.polygonPosition + nPositions
    );
    polygons.featureIds.fill(
      indexMap.polygonFeature,
      indexMap.polygonPosition,
      indexMap.polygonPosition + nPositions
    );
    for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l];
      const indices = geometry.indices[l];
      const nextIndices = geometry.indices[l + 1];
      for (let i2 = 0, il = indices.length; i2 < il; ++i2) {
        const start = indices[i2];
        const end = i2 === il - 1 ? (
          // last line, so either read to:
          nextIndices === void 0 ? geometry.data.length : nextIndices[0]
        ) : indices[i2 + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
    }
  }
  function triangulatePolygon(polygons, areas, indices, {
    startPosition,
    endPosition,
    coordLength
  }) {
    if (!polygons.triangles) {
      return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t = 0, tl = triangles.length; t < tl; ++t) {
      polygons.triangles.push(startPosition + triangles[t]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = { value: obj[key], size };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
      shape: "binary-feature-collection",
      points: {
        ...points,
        positions: { value: points.positions, size: coordLength },
        globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
        featureIds: { value: points.featureIds, size: 1 },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: { value: lines.positions, size: coordLength },
        pathIndices: { value: lines.pathIndices, size: 1 },
        globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
        featureIds: { value: lines.featureIds, size: 1 },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: { value: polygons.positions, size: coordLength },
        polygonIndices: { value: polygons.polygonIndices, size: 1 },
        primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
        globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
        featureIds: { value: polygons.featureIds, size: 1 },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
      // triangles not expected
    };
    if (binaryFeatures.polygons && polygons.triangles) {
      binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
    }
    return binaryFeatures;
  }
  function fillNumericProperties(object, properties, index, length) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x2, constructor) {
    if (constructor === Array || !Number.isFinite(x2)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
  }

  // ../mvt/src/lib/parse-mvt.ts
  var import_pbf = __toESM(require_pbf(), 1);

  // ../mvt/src/lib/utils/geometry-utils.ts
  function signedArea(ring) {
    let sum = 0;
    for (let i2 = 0, j = ring.length - 1, p1, p2; i2 < ring.length; j = i2++) {
      p1 = ring[i2];
      p2 = ring[j];
      sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
  }
  function convertToLocalCoordinates(coordinates, extent) {
    if (Array.isArray(coordinates[0])) {
      for (const subcoords of coordinates) {
        convertToLocalCoordinates(subcoords, extent);
      }
      return;
    }
    const p = coordinates;
    p[0] /= extent;
    p[1] /= extent;
  }
  function convertToLocalCoordinatesFlat(data, extent) {
    for (let i2 = 0; i2 < data.length; ++i2) {
      data[i2] /= extent;
    }
  }
  function projectToLngLat(line, tileIndex, extent) {
    if (typeof line[0][0] !== "number") {
      for (const point of line) {
        projectToLngLat(point, tileIndex, extent);
      }
      return;
    }
    const size = extent * Math.pow(2, tileIndex.z);
    const x0 = extent * tileIndex.x;
    const y0 = extent * tileIndex.y;
    for (let j = 0; j < line.length; j++) {
      const p = line[j];
      p[0] = (p[0] + x0) * 360 / size - 180;
      const y2 = 180 - (p[1] + y0) * 360 / size;
      p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
  }
  function projectToLngLatFlat(data, tileIndex, extent) {
    const { x: x2, y, z } = tileIndex;
    const size = extent * Math.pow(2, z);
    const x0 = extent * x2;
    const y0 = extent * y;
    for (let j = 0, jl = data.length; j < jl; j += 2) {
      data[j] = (data[j] + x0) * 360 / size - 180;
      const y2 = 180 - (data[j + 1] + y0) * 360 / size;
      data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
  }
  function classifyRings(rings) {
    const len = rings.length;
    if (len <= 1)
      return [rings];
    const polygons = [];
    let polygon;
    let ccw;
    for (let i2 = 0; i2 < len; i2++) {
      const area2 = signedArea(rings[i2]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i2]];
      } else if (polygon)
        polygon.push(rings[i2]);
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function classifyRingsFlat(geom) {
    const len = geom.indices.length;
    const type = "Polygon";
    if (len <= 1) {
      return {
        type,
        data: geom.data,
        areas: [[getPolygonSignedArea(geom.data)]],
        indices: [geom.indices]
      };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for (let endIndex, i2 = 0, startIndex; i2 < len; i2++) {
      startIndex = geom.indices[i2] - offset;
      endIndex = geom.indices[i2 + 1] - offset || geom.data.length;
      const shape = geom.data.slice(startIndex, endIndex);
      const area2 = getPolygonSignedArea(shape);
      if (area2 === 0) {
        const before = geom.data.slice(0, startIndex);
        const after = geom.data.slice(endIndex);
        geom.data = before.concat(after);
        offset += endIndex - startIndex;
        continue;
      }
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon.length) {
          areas.push(ringAreas);
          polygons.push(polygon);
        }
        polygon = [startIndex];
        ringAreas = [area2];
      } else {
        ringAreas.push(area2);
        polygon.push(startIndex);
      }
    }
    if (ringAreas)
      areas.push(ringAreas);
    if (polygon.length)
      polygons.push(polygon);
    return { type, areas, indices: polygons, data: geom.data };
  }

  // ../mvt/src/lib/vector-tile/vector-tile-feature.ts
  var VectorTileFeature = class {
    properties;
    extent;
    type;
    id;
    _pbf;
    _geometry;
    _keys;
    _values;
    _geometryInfo;
    // eslint-disable-next-line max-params
    constructor(pbf, end, extent, keys, values, geometryInfo) {
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      this._geometryInfo = geometryInfo;
      pbf.readFields(readFeature, this, end);
    }
    toGeoJSONFeature(coordinates, tileIndex) {
      const coords = this.loadGeometry();
      switch (coordinates) {
        case "wgs84":
          return _toGeoJSONFeature(
            this,
            coords,
            (line) => projectToLngLat(line, tileIndex, this.extent)
          );
        default:
          return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);
      }
    }
    /**
     *
     * @param options
     * @returns
     */
    toBinaryFeature(coordinates, tileIndex) {
      const geom = this.loadFlatGeometry();
      switch (coordinates) {
        case "wgs84":
          return this._toBinaryCoordinates(
            geom,
            (coords) => projectToLngLatFlat(coords, tileIndex, this.extent)
          );
        default:
          return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);
      }
    }
    /** Read a bounding box from the feature */
    // eslint-disable-next-line max-statements
    bbox() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd = 1;
      let length = 0;
      let x2 = 0;
      let y = 0;
      let x1 = Infinity;
      let x22 = -Infinity;
      let y1 = Infinity;
      let y2 = -Infinity;
      while (pbf.pos < end) {
        if (length <= 0) {
          const cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length = cmdLen >> 3;
        }
        length--;
        if (cmd === 1 || cmd === 2) {
          x2 += pbf.readSVarint();
          y += pbf.readSVarint();
          if (x2 < x1)
            x1 = x2;
          if (x2 > x22)
            x22 = x2;
          if (y < y1)
            y1 = y;
          if (y > y2)
            y2 = y;
        } else if (cmd !== 7) {
          throw new Error(`unknown command ${cmd}`);
        }
      }
      return [x1, y1, x22, y2];
    }
    // BINARY HELPERS
    /**
     *
     * @param transform
     * @returns result
     */
    _toBinaryCoordinates(geom, transform) {
      let geometry;
      transform(geom.data, this.extent);
      const coordLength = 2;
      switch (this.type) {
        case 1:
          this._geometryInfo.pointFeaturesCount++;
          this._geometryInfo.pointPositionsCount += geom.indices.length;
          geometry = { type: "Point", ...geom };
          break;
        case 2:
          this._geometryInfo.lineFeaturesCount++;
          this._geometryInfo.linePathsCount += geom.indices.length;
          this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
          geometry = { type: "LineString", ...geom };
          break;
        case 3:
          geometry = classifyRingsFlat(geom);
          this._geometryInfo.polygonFeaturesCount++;
          this._geometryInfo.polygonObjectsCount += geometry.indices.length;
          for (const indices of geometry.indices) {
            this._geometryInfo.polygonRingsCount += indices.length;
          }
          this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
          break;
        default:
          throw new Error(`Invalid geometry type: ${this.type}`);
      }
      const result = { type: "Feature", geometry, properties: this.properties };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    // GEOJSON HELPER
    // eslint-disable-next-line complexity, max-statements
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd = 1;
      let length = 0;
      let x2 = 0;
      let y = 0;
      const lines = [];
      let line;
      while (pbf.pos < end) {
        if (length <= 0) {
          const cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length = cmdLen >> 3;
        }
        length--;
        switch (cmd) {
          case 1:
          case 2:
            x2 += pbf.readSVarint();
            y += pbf.readSVarint();
            if (cmd === 1) {
              if (line)
                lines.push(line);
              line = [];
            }
            if (line)
              line.push([x2, y]);
            break;
          case 7:
            if (line) {
              line.push(line[0].slice());
            }
            break;
          default:
            throw new Error(`unknown command ${cmd}`);
        }
      }
      if (line)
        lines.push(line);
      return lines;
    }
    /**
     * Expands the protobuf data to an intermediate Flat GeoJSON
     * data format, which maps closely to the binary data buffers.
     * It is similar to GeoJSON, but rather than storing the coordinates
     * in multidimensional arrays, we have a 1D `data` with all the
     * coordinates, and then index into this using the `indices`
     * parameter, e.g.
     *
     * geometry: {
     *   type: 'Point', data: [1,2], indices: [0]
     * }
     * geometry: {
     *   type: 'LineString', data: [1,2,3,4,...], indices: [0]
     * }
     * geometry: {
     *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]
     * }
     * Thus the indices member lets us look up the relevant range
     * from the data array.
     * The Multi* versions of the above types share the same data
     * structure, just with multiple elements in the indices array
     */
    // eslint-disable-next-line complexity, max-statements
    loadFlatGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const endPos = pbf.readVarint() + pbf.pos;
      let cmd = 1;
      let cmdLen;
      let length = 0;
      let x2 = 0;
      let y = 0;
      let i2 = 0;
      const indices = [];
      const data = [];
      while (pbf.pos < endPos) {
        if (length <= 0) {
          cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length = cmdLen >> 3;
        }
        length--;
        if (cmd === 1 || cmd === 2) {
          x2 += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            indices.push(i2);
          }
          data.push(x2, y);
          i2 += 2;
        } else if (cmd === 7) {
          if (i2 > 0) {
            const start = indices[indices.length - 1];
            data.push(data[start], data[start + 1]);
            i2 += 2;
          }
        } else {
          throw new Error(`unknown command ${cmd}`);
        }
      }
      return { data, indices };
    }
  };
  __publicField(VectorTileFeature, "types", ["Unknown", "Point", "LineString", "Polygon"]);
  function _toGeoJSONFeature(vtFeature, coords, transform) {
    let type = VectorTileFeature.types[vtFeature.type];
    let i2;
    let j;
    let coordinates;
    switch (vtFeature.type) {
      case 1:
        const points = [];
        for (i2 = 0; i2 < coords.length; i2++) {
          points[i2] = coords[i2][0];
        }
        coordinates = points;
        transform(coordinates, vtFeature.extent);
        break;
      case 2:
        coordinates = coords;
        for (i2 = 0; i2 < coordinates.length; i2++) {
          transform(coordinates[i2], vtFeature.extent);
        }
        break;
      case 3:
        coordinates = classifyRings(coords);
        for (i2 = 0; i2 < coordinates.length; i2++) {
          for (j = 0; j < coordinates[i2].length; j++) {
            transform(coordinates[i2][j], vtFeature.extent);
          }
        }
        break;
      default:
        throw new Error("illegal vector tile type");
    }
    if (coordinates.length === 1) {
      coordinates = coordinates[0];
    } else {
      type = `Multi${type}`;
    }
    const result = {
      type: "Feature",
      geometry: {
        type,
        coordinates
      },
      properties: vtFeature.properties
    };
    if (vtFeature.id !== null) {
      result.properties ||= {};
      result.properties.id = vtFeature.id;
    }
    return result;
  }
  function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../mvt/src/lib/vector-tile/vector-tile-layer.ts
  var VectorTileLayer = class {
    version;
    name;
    extent;
    length;
    _pbf;
    _keys;
    _values;
    _features;
    constructor(pbf, end) {
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    /**
     * return feature `i` from this layer as a `VectorTileFeature`
     * @param index
     * @returns feature
     */
    getGeoJSONFeature(i2) {
      if (i2 < 0 || i2 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i2];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    }
    /**
     * return binary feature `i` from this layer as a `VectorTileFeature`
     *
     * @param index
     * @param geometryInfo
     * @returns binary feature
     */
    getBinaryFeature(i2, geometryInfo) {
      if (i2 < 0 || i2 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i2];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(
        this._pbf,
        end,
        this.extent,
        this._keys,
        this._values,
        geometryInfo
      );
    }
  };
  function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../mvt/src/lib/vector-tile/vector-tile.ts
  var VectorTile = class {
    layers;
    constructor(pbf, end) {
      this.layers = pbf.readFields(readTile, {}, end);
    }
  };
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../mvt/src/lib/parse-mvt.ts
  function parseMVT(arrayBuffer, options) {
    const mvtOptions = checkOptions(options);
    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;
    switch (shape) {
      case "columnar-table":
        return { shape: "columnar-table", data: parseToBinary(arrayBuffer, mvtOptions) };
      case "geojson-table": {
        const table = {
          shape: "geojson-table",
          type: "FeatureCollection",
          features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
        };
        return table;
      }
      case "geojson":
        return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
      case "binary-geometry":
        return parseToBinary(arrayBuffer, mvtOptions);
      case "binary":
        return parseToBinary(arrayBuffer, mvtOptions);
      default:
        throw new Error(shape || "undefined shape");
    }
  }
  function parseToBinary(arrayBuffer, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
    binaryData.byteLength = arrayBuffer.byteLength;
    return binaryData;
  }
  function parseToFlatGeoJson(arrayBuffer, options) {
    const features = [];
    const geometryInfo = {
      coordLength: 2,
      pointPositionsCount: 0,
      pointFeaturesCount: 0,
      linePositionsCount: 0,
      linePathsCount: 0,
      lineFeaturesCount: 0,
      polygonPositionsCount: 0,
      polygonObjectsCount: 0,
      polygonRingsCount: 0,
      polygonFeaturesCount: 0
    };
    if (arrayBuffer.byteLength <= 0) {
      return [features, geometryInfo];
    }
    const tile = new VectorTile(new import_pbf.default(arrayBuffer));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
        const vectorTileFeature = vectorTileLayer.getBinaryFeature(i2, geometryInfo);
        const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return [features, geometryInfo];
  }
  function parseToGeojsonFeatures(arrayBuffer, options) {
    if (arrayBuffer.byteLength <= 0) {
      return [];
    }
    const features = [];
    const tile = new VectorTile(new import_pbf.default(arrayBuffer));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
        const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i2);
        const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return features;
  }
  function checkOptions(options) {
    if (!options?.mvt) {
      throw new Error("mvt options required");
    }
    if (options.mvt?.coordinates === "wgs84" && !options.mvt.tileIndex) {
      throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
    }
    if (options.gis) {
      log.warn('MVTLoader: "options.gis" is deprecated, use "options.mvt.shape" instead')();
    }
    return options.mvt;
  }
  function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSONFeature(
      options.coordinates || "local",
      options.tileIndex
    );
    if (options.layerProperty) {
      decodedFeature.properties ||= {};
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryFeature(options.coordinates || "local", options.tileIndex);
    if (options.layerProperty && decodedFeature.properties) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }

  // ../mvt/src/mvt-loader.ts
  var VERSION5 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var MVTWorkerLoader = {
    dataType: null,
    batchType: null,
    name: "Mapbox Vector Tile",
    id: "mvt",
    module: "mvt",
    version: VERSION5,
    // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
    extensions: ["mvt", "pbf"],
    mimeTypes: [
      // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
      // 'application/octet-stream'
    ],
    worker: true,
    category: "geometry",
    options: {
      mvt: {
        shape: "geojson",
        coordinates: "local",
        layerProperty: "layerName",
        layers: void 0,
        tileIndex: void 0
      }
    }
  };
  var MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
    parseSync: parseMVT,
    binary: true
  };

  // ../../node_modules/pmtiles/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    Compression: () => Compression,
    EtagMismatch: () => EtagMismatch,
    FetchSource: () => FetchSource,
    FileSource: () => FileSource,
    PMTiles: () => PMTiles,
    Protocol: () => Protocol,
    ResolvedValueCache: () => ResolvedValueCache,
    SharedPromiseCache: () => SharedPromiseCache,
    TileType: () => TileType,
    bytesToHeader: () => bytesToHeader,
    findTile: () => findTile,
    getUint64: () => getUint64,
    leafletRasterLayer: () => leafletRasterLayer,
    readVarint: () => readVarint,
    tileIdToZxy: () => tileIdToZxy,
    tileTypeExt: () => tileTypeExt,
    zxyToTileId: () => zxyToTileId
  });
  var __pow = Math.pow;
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b[i2] = start += 1 << eb[i2 - 1];
    }
    var r = new i32(b[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j = b[i2]; j < b[i2 + 1]; ++j) {
        r[j] = j - b[i2] << 5 | i2;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i = 0; i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var x;
  var i;
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i2 = 0;
    var l = new u16(mb);
    for (; i2 < s; ++i2) {
      if (cd[i2])
        ++l[cd[i2] - 1];
    }
    var le = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v = le[cd[i2] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i = 0; i < 144; ++i)
    flt[i] = 8;
  var i;
  for (i = 144; i < 256; ++i)
    flt[i] = 9;
  var i;
  for (i = 256; i < 280; ++i)
    flt[i] = 7;
  var i;
  for (i = 280; i < 288; ++i)
    flt[i] = 8;
  var i;
  var fdt = new u8(32);
  for (i = 0; i < 32; ++i)
    fdt[i] = 5;
  var i;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i2 = 1; i2 < a.length; ++i2) {
      if (a[i2] > m)
        m = a[i2];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    var n = new u8(e - s);
    n.set(v.subarray(s, e));
    return n;
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf || st.i != 2;
    var noSt = st.i;
    if (!buf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i2++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i2++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (noBuf)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b = fleb[i2];
            add = bits(dat, pos, (1 << b) - 1) + fl[i2];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift2 = dl - dt, dend = Math.min(dt, end);
            if (shift2 + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift2 + bt];
          }
          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }
          bt = end;
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  var gzl = function(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
  };
  var zls = function(d, dict) {
    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
      err(6, "invalid zlib data");
    if ((d[1] >> 5 & 1) == +!dict)
      err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d[1] >> 3 & 4) + 2;
  };
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length)
      err(6, "invalid gzip data");
    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
  }
  function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
  var shift = (n, shift2) => {
    return n * __pow(2, shift2);
  };
  var unshift = (n, shift2) => {
    return Math.floor(n / __pow(2, shift2));
  };
  var getUint24 = (view, pos) => {
    return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);
  };
  var getUint48 = (view, pos) => {
    return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);
  };
  var compare = (tz, tx, ty, view, i2) => {
    if (tz !== view.getUint8(i2))
      return tz - view.getUint8(i2);
    const x2 = getUint24(view, i2 + 1);
    if (tx !== x2)
      return tx - x2;
    const y = getUint24(view, i2 + 4);
    if (ty !== y)
      return ty - y;
    return 0;
  };
  var queryLeafdir = (view, z, x2, y) => {
    const offsetLen = queryView(view, z | 128, x2, y);
    if (offsetLen) {
      return {
        z,
        x: x2,
        y,
        offset: offsetLen[0],
        length: offsetLen[1],
        isDir: true
      };
    }
    return null;
  };
  var queryTile = (view, z, x2, y) => {
    const offsetLen = queryView(view, z, x2, y);
    if (offsetLen) {
      return {
        z,
        x: x2,
        y,
        offset: offsetLen[0],
        length: offsetLen[1],
        isDir: false
      };
    }
    return null;
  };
  var queryView = (view, z, x2, y) => {
    let m = 0;
    let n = view.byteLength / 17 - 1;
    while (m <= n) {
      const k = n + m >> 1;
      const cmp = compare(z, x2, y, view, k * 17);
      if (cmp > 0) {
        m = k + 1;
      } else if (cmp < 0) {
        n = k - 1;
      } else {
        return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];
      }
    }
    return null;
  };
  var entrySort = (a, b) => {
    if (a.isDir && !b.isDir) {
      return 1;
    }
    if (!a.isDir && b.isDir) {
      return -1;
    }
    if (a.z !== b.z) {
      return a.z - b.z;
    }
    if (a.x !== b.x) {
      return a.x - b.x;
    }
    return a.y - b.y;
  };
  var parseEntry = (dataview, i2) => {
    const zRaw = dataview.getUint8(i2 * 17);
    const z = zRaw & 127;
    return {
      z,
      x: getUint24(dataview, i2 * 17 + 1),
      y: getUint24(dataview, i2 * 17 + 4),
      offset: getUint48(dataview, i2 * 17 + 7),
      length: dataview.getUint32(i2 * 17 + 13, true),
      isDir: zRaw >> 7 === 1
    };
  };
  var sortDir = (a) => {
    const entries = [];
    const view = new DataView(a);
    for (let i2 = 0; i2 < view.byteLength / 17; i2++) {
      entries.push(parseEntry(view, i2));
    }
    return createDirectory(entries);
  };
  var createDirectory = (entries) => {
    entries.sort(entrySort);
    const buffer = new ArrayBuffer(17 * entries.length);
    const arr = new Uint8Array(buffer);
    for (let i2 = 0; i2 < entries.length; i2++) {
      const entry = entries[i2];
      let z = entry.z;
      if (entry.isDir)
        z = z | 128;
      arr[i2 * 17] = z;
      arr[i2 * 17 + 1] = entry.x & 255;
      arr[i2 * 17 + 2] = entry.x >> 8 & 255;
      arr[i2 * 17 + 3] = entry.x >> 16 & 255;
      arr[i2 * 17 + 4] = entry.y & 255;
      arr[i2 * 17 + 5] = entry.y >> 8 & 255;
      arr[i2 * 17 + 6] = entry.y >> 16 & 255;
      arr[i2 * 17 + 7] = entry.offset & 255;
      arr[i2 * 17 + 8] = unshift(entry.offset, 8) & 255;
      arr[i2 * 17 + 9] = unshift(entry.offset, 16) & 255;
      arr[i2 * 17 + 10] = unshift(entry.offset, 24) & 255;
      arr[i2 * 17 + 11] = unshift(entry.offset, 32) & 255;
      arr[i2 * 17 + 12] = unshift(entry.offset, 48) & 255;
      arr[i2 * 17 + 13] = entry.length & 255;
      arr[i2 * 17 + 14] = entry.length >> 8 & 255;
      arr[i2 * 17 + 15] = entry.length >> 16 & 255;
      arr[i2 * 17 + 16] = entry.length >> 24 & 255;
    }
    return buffer;
  };
  var deriveLeaf = (view, tile) => {
    if (view.byteLength < 17)
      return null;
    const numEntries = view.byteLength / 17;
    const entry = parseEntry(view, numEntries - 1);
    if (entry.isDir) {
      const leafLevel = entry.z;
      const levelDiff = tile.z - leafLevel;
      const leafX = Math.trunc(tile.x / (1 << levelDiff));
      const leafY = Math.trunc(tile.y / (1 << levelDiff));
      return { z: leafLevel, x: leafX, y: leafY };
    }
    return null;
  };
  function getHeader(source) {
    return __async(this, null, function* () {
      const resp = yield source.getBytes(0, 512e3);
      const dataview = new DataView(resp.data);
      const jsonSize = dataview.getUint32(4, true);
      const rootEntries = dataview.getUint16(8, true);
      const dec = new TextDecoder("utf-8");
      const jsonMetadata = JSON.parse(
        dec.decode(new DataView(resp.data, 10, jsonSize))
      );
      let tileCompression = 0;
      if (jsonMetadata.compression === "gzip") {
        tileCompression = 2;
      }
      let minzoom = 0;
      if ("minzoom" in jsonMetadata) {
        minzoom = +jsonMetadata.minzoom;
      }
      let maxzoom = 0;
      if ("maxzoom" in jsonMetadata) {
        maxzoom = +jsonMetadata.maxzoom;
      }
      let centerLon = 0;
      let centerLat = 0;
      let centerZoom = 0;
      let minLon = -180;
      let minLat = -85;
      let maxLon = 180;
      let maxLat = 85;
      if (jsonMetadata.bounds) {
        const split = jsonMetadata.bounds.split(",");
        minLon = +split[0];
        minLat = +split[1];
        maxLon = +split[2];
        maxLat = +split[3];
      }
      if (jsonMetadata.center) {
        const split = jsonMetadata.center.split(",");
        centerLon = +split[0];
        centerLat = +split[1];
        centerZoom = +split[2];
      }
      const header = {
        specVersion: dataview.getUint16(2, true),
        rootDirectoryOffset: 10 + jsonSize,
        rootDirectoryLength: rootEntries * 17,
        jsonMetadataOffset: 10,
        jsonMetadataLength: jsonSize,
        leafDirectoryOffset: 0,
        leafDirectoryLength: void 0,
        tileDataOffset: 0,
        tileDataLength: void 0,
        numAddressedTiles: 0,
        numTileEntries: 0,
        numTileContents: 0,
        clustered: false,
        internalCompression: 1,
        tileCompression,
        tileType: 1,
        minZoom: minzoom,
        maxZoom: maxzoom,
        minLon,
        minLat,
        maxLon,
        maxLat,
        centerZoom,
        centerLon,
        centerLat,
        etag: resp.etag
      };
      return header;
    });
  }
  function getZxy(header, source, cache2, z, x2, y, signal) {
    return __async(this, null, function* () {
      let rootDir = yield cache2.getArrayBuffer(
        source,
        header.rootDirectoryOffset,
        header.rootDirectoryLength,
        header
      );
      if (header.specVersion === 1) {
        rootDir = sortDir(rootDir);
      }
      const entry = queryTile(new DataView(rootDir), z, x2, y);
      if (entry) {
        const resp = yield source.getBytes(entry.offset, entry.length, signal);
        let tileData = resp.data;
        const view = new DataView(tileData);
        if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {
          tileData = decompressSync(new Uint8Array(tileData));
        }
        return {
          data: tileData
        };
      }
      const leafcoords = deriveLeaf(new DataView(rootDir), { z, x: x2, y });
      if (leafcoords) {
        const leafdirEntry = queryLeafdir(
          new DataView(rootDir),
          leafcoords.z,
          leafcoords.x,
          leafcoords.y
        );
        if (leafdirEntry) {
          let leafDir = yield cache2.getArrayBuffer(
            source,
            leafdirEntry.offset,
            leafdirEntry.length,
            header
          );
          if (header.specVersion === 1) {
            leafDir = sortDir(leafDir);
          }
          const tileEntry = queryTile(new DataView(leafDir), z, x2, y);
          if (tileEntry) {
            const resp = yield source.getBytes(
              tileEntry.offset,
              tileEntry.length,
              signal
            );
            let tileData = resp.data;
            const view = new DataView(tileData);
            if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {
              tileData = decompressSync(new Uint8Array(tileData));
            }
            return {
              data: tileData
            };
          }
        }
      }
      return void 0;
    });
  }
  var v2_default = {
    getHeader,
    getZxy
  };
  var leafletRasterLayer = (source, options) => {
    let loaded = false;
    let mimeType = "";
    const cls = L.GridLayer.extend({
      createTile: (coord, done) => {
        const el = document.createElement("img");
        const controller = new AbortController();
        const signal = controller.signal;
        el.cancel = () => {
          controller.abort();
        };
        if (!loaded) {
          source.getHeader().then((header) => {
            if (header.tileType === 1) {
              console.error(
                "Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details."
              );
            } else if (header.tileType === 2) {
              mimeType = "image/png";
            } else if (header.tileType === 3) {
              mimeType = "image/jpeg";
            } else if (header.tileType === 4) {
              mimeType = "image/webp";
            } else if (header.tileType === 5) {
              mimeType = "image/avif";
            }
          });
          loaded = true;
        }
        source.getZxy(coord.z, coord.x, coord.y, signal).then((arr) => {
          if (arr) {
            const blob = new Blob([arr.data], { type: mimeType });
            const imageUrl = window.URL.createObjectURL(blob);
            el.src = imageUrl;
            el.cancel = void 0;
            done(void 0, el);
          }
        }).catch((e) => {
          if (e.name !== "AbortError") {
            throw e;
          }
        });
        return el;
      },
      _removeTile: function(key) {
        const tile = this._tiles[key];
        if (!tile) {
          return;
        }
        if (tile.el.cancel)
          tile.el.cancel();
        tile.el.width = 0;
        tile.el.height = 0;
        tile.el.deleted = true;
        L.DomUtil.remove(tile.el);
        delete this._tiles[key];
        this.fire("tileunload", {
          tile: tile.el,
          coords: this._keyToTileCoords(key)
        });
      }
    });
    return new cls(options);
  };
  var v3compat = (v4) => (requestParameters, arg2) => {
    if (arg2 instanceof AbortController) {
      return v4(requestParameters, arg2);
    }
    const abortController = new AbortController();
    v4(requestParameters, abortController).then(
      (result) => {
        return arg2(
          void 0,
          result.data,
          result.cacheControl || "",
          result.expires || ""
        );
      },
      (err2) => {
        return arg2(err2);
      }
    ).catch((e) => {
      return arg2(e);
    });
    return { cancel: () => abortController.abort() };
  };
  var Protocol = class {
    constructor() {
      this.tilev4 = (params, abortController) => __async(this, null, function* () {
        if (params.type === "json") {
          const pmtilesUrl2 = params.url.substr(10);
          let instance2 = this.tiles.get(pmtilesUrl2);
          if (!instance2) {
            instance2 = new PMTiles(pmtilesUrl2);
            this.tiles.set(pmtilesUrl2, instance2);
          }
          const h = yield instance2.getHeader();
          return {
            data: {
              tiles: [`${params.url}/{z}/{x}/{y}`],
              minzoom: h.minZoom,
              maxzoom: h.maxZoom,
              bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat]
            }
          };
        }
        const re = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/);
        const result = params.url.match(re);
        if (!result) {
          throw new Error("Invalid PMTiles protocol URL");
        }
        const pmtilesUrl = result[1];
        let instance = this.tiles.get(pmtilesUrl);
        if (!instance) {
          instance = new PMTiles(pmtilesUrl);
          this.tiles.set(pmtilesUrl, instance);
        }
        const z = result[2];
        const x2 = result[3];
        const y = result[4];
        const header = yield instance.getHeader();
        const resp = yield instance == null ? void 0 : instance.getZxy(+z, +x2, +y, abortController.signal);
        if (resp) {
          return {
            data: new Uint8Array(resp.data),
            cacheControl: resp.cacheControl,
            expires: resp.expires
          };
        }
        if (header.tileType === 1) {
          return { data: new Uint8Array() };
        }
        return { data: null };
      });
      this.tile = v3compat(this.tilev4);
      this.tiles = /* @__PURE__ */ new Map();
    }
    /**
     * Add a {@link PMTiles} instance to the global protocol instance.
     *
     * For remote fetch sources, references in MapLibre styles like pmtiles://http://...
     * will resolve to the same instance if the URLs match.
     */
    add(p) {
      this.tiles.set(p.source.getKey(), p);
    }
    /**
     * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.
     */
    get(url) {
      return this.tiles.get(url);
    }
  };
  function toNum(low, high) {
    return (high >>> 0) * 4294967296 + (low >>> 0);
  }
  function readVarintRemainder(l, p) {
    const buf = p.buf;
    let b = buf[p.pos++];
    let h = (b & 112) >> 4;
    if (b < 128)
      return toNum(l, h);
    b = buf[p.pos++];
    h |= (b & 127) << 3;
    if (b < 128)
      return toNum(l, h);
    b = buf[p.pos++];
    h |= (b & 127) << 10;
    if (b < 128)
      return toNum(l, h);
    b = buf[p.pos++];
    h |= (b & 127) << 17;
    if (b < 128)
      return toNum(l, h);
    b = buf[p.pos++];
    h |= (b & 127) << 24;
    if (b < 128)
      return toNum(l, h);
    b = buf[p.pos++];
    h |= (b & 1) << 31;
    if (b < 128)
      return toNum(l, h);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function readVarint(p) {
    const buf = p.buf;
    let b = buf[p.pos++];
    let val = b & 127;
    if (b < 128)
      return val;
    b = buf[p.pos++];
    val |= (b & 127) << 7;
    if (b < 128)
      return val;
    b = buf[p.pos++];
    val |= (b & 127) << 14;
    if (b < 128)
      return val;
    b = buf[p.pos++];
    val |= (b & 127) << 21;
    if (b < 128)
      return val;
    b = buf[p.pos];
    val |= (b & 15) << 28;
    return readVarintRemainder(val, p);
  }
  function rotate(n, xy, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        xy[0] = n - 1 - xy[0];
        xy[1] = n - 1 - xy[1];
      }
      const t = xy[0];
      xy[0] = xy[1];
      xy[1] = t;
    }
  }
  function idOnLevel(z, pos) {
    const n = __pow(2, z);
    let rx = pos;
    let ry = pos;
    let t = pos;
    const xy = [0, 0];
    let s = 1;
    while (s < n) {
      rx = 1 & t / 2;
      ry = 1 & (t ^ rx);
      rotate(s, xy, rx, ry);
      xy[0] += s * rx;
      xy[1] += s * ry;
      t = t / 4;
      s *= 2;
    }
    return [z, xy[0], xy[1]];
  }
  var tzValues = [
    0,
    1,
    5,
    21,
    85,
    341,
    1365,
    5461,
    21845,
    87381,
    349525,
    1398101,
    5592405,
    22369621,
    89478485,
    357913941,
    1431655765,
    5726623061,
    22906492245,
    91625968981,
    366503875925,
    1466015503701,
    5864062014805,
    23456248059221,
    93824992236885,
    375299968947541,
    1501199875790165
  ];
  function zxyToTileId(z, x2, y) {
    if (z > 26) {
      throw Error("Tile zoom level exceeds max safe number limit (26)");
    }
    if (x2 > __pow(2, z) - 1 || y > __pow(2, z) - 1) {
      throw Error("tile x/y outside zoom level bounds");
    }
    const acc = tzValues[z];
    const n = __pow(2, z);
    let rx = 0;
    let ry = 0;
    let d = 0;
    const xy = [x2, y];
    let s = n / 2;
    while (s > 0) {
      rx = (xy[0] & s) > 0 ? 1 : 0;
      ry = (xy[1] & s) > 0 ? 1 : 0;
      d += s * s * (3 * rx ^ ry);
      rotate(s, xy, rx, ry);
      s = s / 2;
    }
    return acc + d;
  }
  function tileIdToZxy(i2) {
    let acc = 0;
    const z = 0;
    for (let z2 = 0; z2 < 27; z2++) {
      const numTiles = (1 << z2) * (1 << z2);
      if (acc + numTiles > i2) {
        return idOnLevel(z2, i2 - acc);
      }
      acc += numTiles;
    }
    throw Error("Tile zoom level exceeds max safe number limit (26)");
  }
  var Compression = /* @__PURE__ */ ((Compression2) => {
    Compression2[Compression2["Unknown"] = 0] = "Unknown";
    Compression2[Compression2["None"] = 1] = "None";
    Compression2[Compression2["Gzip"] = 2] = "Gzip";
    Compression2[Compression2["Brotli"] = 3] = "Brotli";
    Compression2[Compression2["Zstd"] = 4] = "Zstd";
    return Compression2;
  })(Compression || {});
  function defaultDecompress(buf, compression) {
    return __async(this, null, function* () {
      if (compression === 1 || compression === 0) {
        return buf;
      }
      if (compression === 2) {
        if (typeof globalThis.DecompressionStream === "undefined") {
          return decompressSync(new Uint8Array(buf));
        }
        const stream = new Response(buf).body;
        if (!stream) {
          throw Error("Failed to read response stream");
        }
        const result = stream.pipeThrough(
          // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers
          new globalThis.DecompressionStream("gzip")
        );
        return new Response(result).arrayBuffer();
      }
      throw Error("Compression method not supported");
    });
  }
  var TileType = /* @__PURE__ */ ((TileType22) => {
    TileType22[TileType22["Unknown"] = 0] = "Unknown";
    TileType22[TileType22["Mvt"] = 1] = "Mvt";
    TileType22[TileType22["Png"] = 2] = "Png";
    TileType22[TileType22["Jpeg"] = 3] = "Jpeg";
    TileType22[TileType22["Webp"] = 4] = "Webp";
    TileType22[TileType22["Avif"] = 5] = "Avif";
    return TileType22;
  })(TileType || {});
  function tileTypeExt(t) {
    if (t === 1)
      return ".mvt";
    if (t === 2)
      return ".png";
    if (t === 3)
      return ".jpg";
    if (t === 4)
      return ".webp";
    if (t === 5)
      return ".avif";
    return "";
  }
  var HEADER_SIZE_BYTES = 127;
  function findTile(entries, tileId) {
    let m = 0;
    let n = entries.length - 1;
    while (m <= n) {
      const k = n + m >> 1;
      const cmp = tileId - entries[k].tileId;
      if (cmp > 0) {
        m = k + 1;
      } else if (cmp < 0) {
        n = k - 1;
      } else {
        return entries[k];
      }
    }
    if (n >= 0) {
      if (entries[n].runLength === 0) {
        return entries[n];
      }
      if (tileId - entries[n].tileId < entries[n].runLength) {
        return entries[n];
      }
    }
    return null;
  }
  var FileSource = class {
    constructor(file) {
      this.file = file;
    }
    getKey() {
      return this.file.name;
    }
    getBytes(offset, length) {
      return __async(this, null, function* () {
        const blob = this.file.slice(offset, offset + length);
        const a = yield blob.arrayBuffer();
        return { data: a };
      });
    }
  };
  var FetchSource = class {
    constructor(url, customHeaders = new Headers()) {
      this.url = url;
      this.customHeaders = customHeaders;
      this.mustReload = false;
      let userAgent = "";
      if ("navigator" in globalThis) {
        userAgent = globalThis.navigator.userAgent || "";
      }
      const isWindows = userAgent.indexOf("Windows") > -1;
      const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);
      this.chromeWindowsNoCache = false;
      if (isWindows && isChromiumBased) {
        this.chromeWindowsNoCache = true;
      }
    }
    getKey() {
      return this.url;
    }
    /**
     * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.
     */
    setHeaders(customHeaders) {
      this.customHeaders = customHeaders;
    }
    getBytes(offset, length, passedSignal, etag) {
      return __async(this, null, function* () {
        let controller;
        let signal;
        if (passedSignal) {
          signal = passedSignal;
        } else {
          controller = new AbortController();
          signal = controller.signal;
        }
        const requestHeaders = new Headers(this.customHeaders);
        requestHeaders.set("range", `bytes=${offset}-${offset + length - 1}`);
        let cache2;
        if (this.mustReload) {
          cache2 = "reload";
        } else if (this.chromeWindowsNoCache) {
          cache2 = "no-store";
        }
        let resp = yield fetch(this.url, {
          signal,
          cache: cache2,
          headers: requestHeaders
          //biome-ignore lint: "cache" is incompatible between cloudflare workers and browser
        });
        if (offset === 0 && resp.status === 416) {
          const contentRange = resp.headers.get("Content-Range");
          if (!contentRange || !contentRange.startsWith("bytes */")) {
            throw Error("Missing content-length on 416 response");
          }
          const actualLength = +contentRange.substr(8);
          resp = yield fetch(this.url, {
            signal,
            cache: "reload",
            headers: { range: `bytes=0-${actualLength - 1}` }
            //biome-ignore lint: "cache" is incompatible between cloudflare workers and browser
          });
        }
        let newEtag = resp.headers.get("Etag");
        if (newEtag == null ? void 0 : newEtag.startsWith("W/")) {
          newEtag = null;
        }
        if (resp.status === 416 || etag && newEtag && newEtag !== etag) {
          this.mustReload = true;
          throw new EtagMismatch(
            `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`
          );
        }
        if (resp.status >= 300) {
          throw Error(`Bad response code: ${resp.status}`);
        }
        const contentLength = resp.headers.get("Content-Length");
        if (resp.status === 200 && (!contentLength || +contentLength > length)) {
          if (controller)
            controller.abort();
          throw Error(
            "Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving."
          );
        }
        const a = yield resp.arrayBuffer();
        return {
          data: a,
          etag: newEtag || void 0,
          cacheControl: resp.headers.get("Cache-Control") || void 0,
          expires: resp.headers.get("Expires") || void 0
        };
      });
    }
  };
  function getUint64(v, offset) {
    const wh = v.getUint32(offset + 4, true);
    const wl = v.getUint32(offset + 0, true);
    return wh * __pow(2, 32) + wl;
  }
  function bytesToHeader(bytes, etag) {
    const v = new DataView(bytes);
    const specVersion = v.getUint8(7);
    if (specVersion > 3) {
      throw Error(
        `Archive is spec version ${specVersion} but this library supports up to spec version 3`
      );
    }
    return {
      specVersion,
      rootDirectoryOffset: getUint64(v, 8),
      rootDirectoryLength: getUint64(v, 16),
      jsonMetadataOffset: getUint64(v, 24),
      jsonMetadataLength: getUint64(v, 32),
      leafDirectoryOffset: getUint64(v, 40),
      leafDirectoryLength: getUint64(v, 48),
      tileDataOffset: getUint64(v, 56),
      tileDataLength: getUint64(v, 64),
      numAddressedTiles: getUint64(v, 72),
      numTileEntries: getUint64(v, 80),
      numTileContents: getUint64(v, 88),
      clustered: v.getUint8(96) === 1,
      internalCompression: v.getUint8(97),
      tileCompression: v.getUint8(98),
      tileType: v.getUint8(99),
      minZoom: v.getUint8(100),
      maxZoom: v.getUint8(101),
      minLon: v.getInt32(102, true) / 1e7,
      minLat: v.getInt32(106, true) / 1e7,
      maxLon: v.getInt32(110, true) / 1e7,
      maxLat: v.getInt32(114, true) / 1e7,
      centerZoom: v.getUint8(118),
      centerLon: v.getInt32(119, true) / 1e7,
      centerLat: v.getInt32(123, true) / 1e7,
      etag
    };
  }
  function deserializeIndex(buffer) {
    const p = { buf: new Uint8Array(buffer), pos: 0 };
    const numEntries = readVarint(p);
    const entries = [];
    let lastId = 0;
    for (let i2 = 0; i2 < numEntries; i2++) {
      const v = readVarint(p);
      entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });
      lastId += v;
    }
    for (let i2 = 0; i2 < numEntries; i2++) {
      entries[i2].runLength = readVarint(p);
    }
    for (let i2 = 0; i2 < numEntries; i2++) {
      entries[i2].length = readVarint(p);
    }
    for (let i2 = 0; i2 < numEntries; i2++) {
      const v = readVarint(p);
      if (v === 0 && i2 > 0) {
        entries[i2].offset = entries[i2 - 1].offset + entries[i2 - 1].length;
      } else {
        entries[i2].offset = v - 1;
      }
    }
    return entries;
  }
  function detectVersion(a) {
    const v = new DataView(a);
    if (v.getUint16(2, true) === 2) {
      console.warn(
        "PMTiles spec version 2 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade"
      );
      return 2;
    }
    if (v.getUint16(2, true) === 1) {
      console.warn(
        "PMTiles spec version 1 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade"
      );
      return 1;
    }
    return 3;
  }
  var EtagMismatch = class extends Error {
  };
  function getHeaderAndRoot(source, decompress) {
    return __async(this, null, function* () {
      const resp = yield source.getBytes(0, 16384);
      const v = new DataView(resp.data);
      if (v.getUint16(0, true) !== 19792) {
        throw new Error("Wrong magic number for PMTiles archive");
      }
      if (detectVersion(resp.data) < 3) {
        return [yield v2_default.getHeader(source)];
      }
      const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);
      const header = bytesToHeader(headerData, resp.etag);
      const rootDirData = resp.data.slice(
        header.rootDirectoryOffset,
        header.rootDirectoryOffset + header.rootDirectoryLength
      );
      const dirKey = `${source.getKey()}|${header.etag || ""}|${header.rootDirectoryOffset}|${header.rootDirectoryLength}`;
      const rootDir = deserializeIndex(
        yield decompress(rootDirData, header.internalCompression)
      );
      return [header, [dirKey, rootDir.length, rootDir]];
    });
  }
  function getDirectory(source, decompress, offset, length, header) {
    return __async(this, null, function* () {
      const resp = yield source.getBytes(offset, length, void 0, header.etag);
      const data = yield decompress(resp.data, header.internalCompression);
      const directory = deserializeIndex(data);
      if (directory.length === 0) {
        throw new Error("Empty directory is invalid");
      }
      return directory;
    });
  }
  var ResolvedValueCache = class {
    constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {
      this.cache = /* @__PURE__ */ new Map();
      this.maxCacheEntries = maxCacheEntries;
      this.counter = 1;
      this.decompress = decompress;
    }
    getHeader(source) {
      return __async(this, null, function* () {
        const cacheKey = source.getKey();
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = cacheValue.data;
          return data;
        }
        const res = yield getHeaderAndRoot(source, this.decompress);
        if (res[1]) {
          this.cache.set(res[1][0], {
            lastUsed: this.counter++,
            data: res[1][2]
          });
        }
        this.cache.set(cacheKey, {
          lastUsed: this.counter++,
          data: res[0]
        });
        this.prune();
        return res[0];
      });
    }
    getDirectory(source, offset, length, header) {
      return __async(this, null, function* () {
        const cacheKey = `${source.getKey()}|${header.etag || ""}|${offset}|${length}`;
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = cacheValue.data;
          return data;
        }
        const directory = yield getDirectory(
          source,
          this.decompress,
          offset,
          length,
          header
        );
        this.cache.set(cacheKey, {
          lastUsed: this.counter++,
          data: directory
        });
        this.prune();
        return directory;
      });
    }
    // for v2 backwards compatibility
    getArrayBuffer(source, offset, length, header) {
      return __async(this, null, function* () {
        const cacheKey = `${source.getKey()}|${header.etag || ""}|${offset}|${length}`;
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = yield cacheValue.data;
          return data;
        }
        const resp = yield source.getBytes(offset, length, void 0, header.etag);
        this.cache.set(cacheKey, {
          lastUsed: this.counter++,
          data: resp.data
        });
        this.prune();
        return resp.data;
      });
    }
    prune() {
      if (this.cache.size > this.maxCacheEntries) {
        let minUsed = Infinity;
        let minKey = void 0;
        this.cache.forEach((cacheValue, key) => {
          if (cacheValue.lastUsed < minUsed) {
            minUsed = cacheValue.lastUsed;
            minKey = key;
          }
        });
        if (minKey) {
          this.cache.delete(minKey);
        }
      }
    }
    invalidate(source) {
      return __async(this, null, function* () {
        this.cache.delete(source.getKey());
      });
    }
  };
  var SharedPromiseCache = class {
    constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {
      this.cache = /* @__PURE__ */ new Map();
      this.invalidations = /* @__PURE__ */ new Map();
      this.maxCacheEntries = maxCacheEntries;
      this.counter = 1;
      this.decompress = decompress;
    }
    getHeader(source) {
      return __async(this, null, function* () {
        const cacheKey = source.getKey();
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = yield cacheValue.data;
          return data;
        }
        const p = new Promise((resolve, reject) => {
          getHeaderAndRoot(source, this.decompress).then((res) => {
            if (res[1]) {
              this.cache.set(res[1][0], {
                lastUsed: this.counter++,
                data: Promise.resolve(res[1][2])
              });
            }
            resolve(res[0]);
            this.prune();
          }).catch((e) => {
            reject(e);
          });
        });
        this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
        return p;
      });
    }
    getDirectory(source, offset, length, header) {
      return __async(this, null, function* () {
        const cacheKey = `${source.getKey()}|${header.etag || ""}|${offset}|${length}`;
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = yield cacheValue.data;
          return data;
        }
        const p = new Promise((resolve, reject) => {
          getDirectory(source, this.decompress, offset, length, header).then((directory) => {
            resolve(directory);
            this.prune();
          }).catch((e) => {
            reject(e);
          });
        });
        this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
        return p;
      });
    }
    // for v2 backwards compatibility
    getArrayBuffer(source, offset, length, header) {
      return __async(this, null, function* () {
        const cacheKey = `${source.getKey()}|${header.etag || ""}|${offset}|${length}`;
        const cacheValue = this.cache.get(cacheKey);
        if (cacheValue) {
          cacheValue.lastUsed = this.counter++;
          const data = yield cacheValue.data;
          return data;
        }
        const p = new Promise((resolve, reject) => {
          source.getBytes(offset, length, void 0, header.etag).then((resp) => {
            resolve(resp.data);
            if (this.cache.has(cacheKey)) {
            }
            this.prune();
          }).catch((e) => {
            reject(e);
          });
        });
        this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
        return p;
      });
    }
    prune() {
      if (this.cache.size >= this.maxCacheEntries) {
        let minUsed = Infinity;
        let minKey = void 0;
        this.cache.forEach((cacheValue, key) => {
          if (cacheValue.lastUsed < minUsed) {
            minUsed = cacheValue.lastUsed;
            minKey = key;
          }
        });
        if (minKey) {
          this.cache.delete(minKey);
        }
      }
    }
    invalidate(source) {
      return __async(this, null, function* () {
        const key = source.getKey();
        if (this.invalidations.get(key)) {
          return yield this.invalidations.get(key);
        }
        this.cache.delete(source.getKey());
        const p = new Promise((resolve, reject) => {
          this.getHeader(source).then((h) => {
            resolve();
            this.invalidations.delete(key);
          }).catch((e) => {
            reject(e);
          });
        });
        this.invalidations.set(key, p);
      });
    }
  };
  var PMTiles = class {
    constructor(source, cache2, decompress) {
      if (typeof source === "string") {
        this.source = new FetchSource(source);
      } else {
        this.source = source;
      }
      if (decompress) {
        this.decompress = decompress;
      } else {
        this.decompress = defaultDecompress;
      }
      if (cache2) {
        this.cache = cache2;
      } else {
        this.cache = new SharedPromiseCache();
      }
    }
    /**
     * Return the header of the archive,
     * including information such as tile type, min/max zoom, bounds, and summary statistics.
     */
    getHeader() {
      return __async(this, null, function* () {
        return yield this.cache.getHeader(this.source);
      });
    }
    /** @hidden */
    getZxyAttempt(z, x2, y, signal) {
      return __async(this, null, function* () {
        const tileId = zxyToTileId(z, x2, y);
        const header = yield this.cache.getHeader(this.source);
        if (header.specVersion < 3) {
          return v2_default.getZxy(header, this.source, this.cache, z, x2, y, signal);
        }
        if (z < header.minZoom || z > header.maxZoom) {
          return void 0;
        }
        let dO = header.rootDirectoryOffset;
        let dL = header.rootDirectoryLength;
        for (let depth = 0; depth <= 3; depth++) {
          const directory = yield this.cache.getDirectory(
            this.source,
            dO,
            dL,
            header
          );
          const entry = findTile(directory, tileId);
          if (entry) {
            if (entry.runLength > 0) {
              const resp = yield this.source.getBytes(
                header.tileDataOffset + entry.offset,
                entry.length,
                signal,
                header.etag
              );
              return {
                data: yield this.decompress(resp.data, header.tileCompression),
                cacheControl: resp.cacheControl,
                expires: resp.expires
              };
            }
            dO = header.leafDirectoryOffset + entry.offset;
            dL = entry.length;
          } else {
            return void 0;
          }
        }
        throw Error("Maximum directory depth exceeded");
      });
    }
    /**
     * Primary method to get a single tile's bytes from an archive.
     *
     * Returns undefined if the tile does not exist in the archive.
     */
    getZxy(z, x2, y, signal) {
      return __async(this, null, function* () {
        try {
          return yield this.getZxyAttempt(z, x2, y, signal);
        } catch (e) {
          if (e instanceof EtagMismatch) {
            this.cache.invalidate(this.source);
            return yield this.getZxyAttempt(z, x2, y, signal);
          }
          throw e;
        }
      });
    }
    /** @hidden */
    getMetadataAttempt() {
      return __async(this, null, function* () {
        const header = yield this.cache.getHeader(this.source);
        const resp = yield this.source.getBytes(
          header.jsonMetadataOffset,
          header.jsonMetadataLength,
          void 0,
          header.etag
        );
        const decompressed = yield this.decompress(
          resp.data,
          header.internalCompression
        );
        const dec = new TextDecoder("utf-8");
        return JSON.parse(dec.decode(decompressed));
      });
    }
    /**
     * Return the arbitrary JSON metadata of the archive.
     */
    getMetadata() {
      return __async(this, null, function* () {
        try {
          return yield this.getMetadataAttempt();
        } catch (e) {
          if (e instanceof EtagMismatch) {
            this.cache.invalidate(this.source);
            return yield this.getMetadataAttempt();
          }
          throw e;
        }
      });
    }
    /**
     * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.
     *
     * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.
     * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,
     * the baseTilesUrl should be `https://example.com/tileset`.
     */
    getTileJson(baseTilesUrl) {
      return __async(this, null, function* () {
        const header = yield this.getHeader();
        const metadata = yield this.getMetadata();
        const ext = tileTypeExt(header.tileType);
        return {
          tilejson: "3.0.0",
          scheme: "xyz",
          tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],
          // biome-ignore lint: TileJSON spec
          vector_layers: metadata.vector_layers,
          attribution: metadata.attribution,
          description: metadata.description,
          name: metadata.name,
          version: metadata.version,
          bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],
          center: [header.centerLon, header.centerLat, header.centerZoom],
          minzoom: header.minZoom,
          maxzoom: header.maxZoom
        };
      });
    }
  };

  // src/lib/parse-pmtiles.ts
  var { TileType: TileType2 } = dist_exports;
  function parsePMTilesHeader(header, pmtilesMetadata, options, loadOptions) {
    let tilejson = null;
    if (pmtilesMetadata) {
      try {
        const string = JSON.stringify(pmtilesMetadata);
        tilejson = TileJSONLoader.parseTextSync?.(string, loadOptions) || null;
      } catch (error) {
        console.warn("PMTiles metadata could not be interpreted as TileJSON", error);
      }
    }
    const partialMetadata = {};
    if (typeof tilejson?.name === "string") {
      partialMetadata.name = tilejson.name;
    }
    if (typeof tilejson?.htmlAttribution === "string") {
      partialMetadata.attributions = [tilejson.htmlAttribution];
    }
    const metadata = {
      ...partialMetadata,
      format: "pmtiles",
      formatVersion: header.specVersion,
      attributions: [],
      tileMIMEType: decodeTileType(header.tileType),
      minZoom: header.minZoom,
      maxZoom: header.maxZoom,
      boundingBox: [
        [header.minLon, header.minLat],
        [header.maxLon, header.maxLat]
      ],
      center: [header.centerLon, header.centerLat],
      centerZoom: header.centerZoom,
      etag: header.etag
    };
    if (tilejson) {
      metadata.tilejson = tilejson;
    }
    if (options?.includeFormatHeader) {
      metadata.formatHeader = header;
      metadata.formatMetadata = metadata;
    }
    return metadata;
  }
  function decodeTileType(tileType) {
    switch (tileType) {
      case TileType2.Mvt:
        return "application/vnd.mapbox-vector-tile";
      case TileType2.Png:
        return "image/png";
      case TileType2.Jpeg:
        return "image/jpeg";
      case TileType2.Webp:
        return "image/webp";
      case TileType2.Avif:
        return "image/avif";
      default:
        return "application/octet-stream";
    }
  }

  // src/lib/blob-source.ts
  var BlobSource = class {
    blob;
    key;
    constructor(blob, key) {
      this.blob = blob;
      this.key = key;
    }
    // TODO - how is this used?
    getKey() {
      return this.blob.url || "";
    }
    async getBytes(offset, length, signal) {
      const slice = this.blob.slice(offset, offset + length);
      const data = await slice.arrayBuffer();
      return {
        data
        // etag: response.headers.get('ETag') || undefined,
        // cacheControl: response.headers.get('Cache-Control') || undefined,
        // expires: response.headers.get('Expires') || undefined
      };
    }
  };

  // src/pmtiles-source.ts
  var { PMTiles: PMTiles2 } = dist_exports;
  var VERSION6 = "1.0.0";
  var PMTilesSource = {
    name: "PMTiles",
    id: "pmtiles",
    module: "pmtiles",
    version: VERSION6,
    extensions: ["pmtiles"],
    mimeTypes: ["application/octet-stream"],
    options: { url: void 0, pmtiles: {} },
    type: "pmtiles",
    fromUrl: true,
    fromBlob: true,
    testURL: (url) => url.endsWith(".pmtiles"),
    createDataSource: (url, props) => new PMTilesTileSource(url, props)
  };
  var PMTilesTileSource = class extends DataSource {
    data;
    props;
    mimeType = null;
    pmtiles;
    metadata;
    constructor(data, props) {
      super(props);
      this.props = props;
      const url = typeof data === "string" ? resolvePath(data) : new BlobSource(data, "pmtiles");
      this.data = data;
      this.pmtiles = new PMTiles2(url);
      this.getTileData = this.getTileData.bind(this);
      this.metadata = this.getMetadata();
    }
    async getSchema() {
      return { fields: [], metadata: {} };
    }
    async getMetadata() {
      const pmtilesHeader = await this.pmtiles.getHeader();
      const pmtilesMetadata = await this.pmtiles.getMetadata() || {};
      const metadata = parsePMTilesHeader(
        pmtilesHeader,
        pmtilesMetadata,
        { includeFormatHeader: false },
        this.loadOptions
      );
      if (this.props.attributions) {
        metadata.attributions = [...this.props.attributions, ...metadata.attributions || []];
      }
      if (metadata?.tileMIMEType) {
        this.mimeType = metadata?.tileMIMEType;
      }
      return metadata;
    }
    async getTile(tileParams) {
      const { x: x2, y, z } = tileParams;
      const rangeResponse = await this.pmtiles.getZxy(z, x2, y);
      const arrayBuffer = rangeResponse?.data;
      if (!arrayBuffer) {
        return null;
      }
      return arrayBuffer;
    }
    // Tile Source interface implementation: deck.gl compatible API
    // TODO - currently only handles image tiles, not vector tiles
    async getTileData(tileParams) {
      const { x: x2, y, z } = tileParams.index;
      const metadata = await this.metadata;
      switch (metadata.tileMIMEType) {
        case "application/vnd.mapbox-vector-tile":
          return await this.getVectorTile({ x: x2, y, z, layers: [] });
        default:
          return await this.getImageTile({ x: x2, y, z, layers: [] });
      }
    }
    // ImageTileSource interface implementation
    async getImageTile(tileParams) {
      const arrayBuffer = await this.getTile(tileParams);
      return arrayBuffer ? await ImageLoader.parse(arrayBuffer, this.loadOptions) : null;
    }
    // VectorTileSource interface implementation
    async getVectorTile(tileParams) {
      const arrayBuffer = await this.getTile(tileParams);
      const loadOptions = {
        shape: "geojson-table",
        mvt: {
          coordinates: "wgs84",
          tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.z },
          ...this.loadOptions?.mvt
        },
        ...this.loadOptions
      };
      return arrayBuffer ? await MVTLoader.parse(arrayBuffer, loadOptions) : null;
    }
  };

  // src/lib/version.ts
  var VERSION7 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";

  // src/pmtiles-loader.ts
  var PMTilesLoader = {
    name: "PMTiles",
    id: "pmtiles",
    module: "pmtiles",
    version: VERSION7,
    extensions: ["pmtiles"],
    mimeTypes: ["application/octet-stream"],
    tests: ["PMTiles"],
    options: {
      pmtiles: {}
    },
    parse: async (arrayBuffer, options) => parseFileAsPMTiles(new BlobFile(new Blob([arrayBuffer])), options),
    parseFile: parseFileAsPMTiles
  };
  async function parseFileAsPMTiles(file, options) {
    const source = new PMTilesTileSource(file.handle, {
      pmtiles: options?.pmtiles || {}
    });
    const formatSpecificMetadata = await source.getMetadata();
    const { tileMIMEType, tilejson = {} } = formatSpecificMetadata;
    const { layers = [] } = tilejson;
    switch (tileMIMEType) {
      case "application/vnd.mapbox-vector-tile":
        return {
          shape: "vector-source",
          layers: layers.map((layer) => ({ name: layer.name, schema: layer.schema })),
          tables: [],
          formatSpecificMetadata
        };
      case "image/png":
      case "image/jpeg":
        return { shape: "image-source", formatSpecificMetadata };
      default:
        throw new Error(`PMTilesLoader: Unsupported tile MIME type ${tileMIMEType}`);
    }
  }
  return __toCommonJS(bundle_exports);
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
      return __exports__;
      });
