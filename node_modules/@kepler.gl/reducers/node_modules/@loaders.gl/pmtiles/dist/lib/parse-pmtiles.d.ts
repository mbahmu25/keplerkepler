import { LoaderOptions } from '@loaders.gl/loader-utils';
import type { TileJSON } from '@loaders.gl/mvt';
import * as pmtiles from 'pmtiles';
/** Metadata describing a PMTiles file */
export type PMTilesMetadata = {
    format: 'pmtiles';
    /** Version of pm tiles format used by this tileset */
    formatVersion: number;
    /** MIME type for tile contents. Unknown tile types will return 'application/octet-stream */
    tileMIMEType: 'application/vnd.mapbox-vector-tile' | 'image/png' | 'image/jpeg' | 'image/webp' | 'image/avif' | 'application/octet-stream';
    /** Name of the tileset (extracted from JSON metadata if available) */
    name?: string;
    /** Attribution string (extracted from JSON metadata if available) */
    attributions?: string[];
    /** Minimal zoom level of tiles in this tileset */
    minZoom: number;
    /** Maximal zoom level of tiles in this tileset */
    maxZoom: number;
    /** Bounding box of tiles in this tileset `[[w, s], [e, n]]`  */
    boundingBox: [min: [x: number, y: number], max: [x: number, y: number]];
    /** Center long, lat of this tileset */
    center: [number, number];
    /** Center zoom level of this tileset */
    centerZoom: number;
    /** Cache tag */
    etag?: string;
    /** Parsed TileJSON/tilestats metadata, if present */
    tilejson?: TileJSON;
    /** @deprecated PMTiles format specific header */
    formatHeader?: pmtiles.Header;
    /** @deprecated Unparsed metadata (Assumption metadata generated by e.g. tippecanoe, typically TileJSON) */
    formatMetadata?: Record<string, unknown>;
};
/**
 * Parse PMTiles metdata from a PMTiles file
 * @param header
 * @param tilejsonMetadata
 * @param options
 * @param loadOptions
 * @returns
 */
export declare function parsePMTilesHeader(header: pmtiles.Header, pmtilesMetadata: Record<string, unknown> | null, options?: {
    includeFormatHeader?: boolean;
}, loadOptions?: LoaderOptions): PMTilesMetadata;
//# sourceMappingURL=parse-pmtiles.d.ts.map