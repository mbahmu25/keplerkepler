"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  PMTilesSource: () => PMTilesSource,
  PMTilesTileSource: () => PMTilesTileSource,
  _PMTilesLoader: () => PMTilesLoader
});
module.exports = __toCommonJS(dist_exports);

// dist/pmtiles-source.js
var import_loader_utils = require("@loaders.gl/loader-utils");
var import_images = require("@loaders.gl/images");
var import_mvt2 = require("@loaders.gl/mvt");
var pmtiles2 = __toESM(require("pmtiles"), 1);

// dist/lib/parse-pmtiles.js
var import_mvt = require("@loaders.gl/mvt");
var pmtiles = __toESM(require("pmtiles"), 1);
var { TileType } = pmtiles;
function parsePMTilesHeader(header, pmtilesMetadata, options, loadOptions) {
  var _a, _b;
  let tilejson = null;
  if (pmtilesMetadata) {
    try {
      const string = JSON.stringify(pmtilesMetadata);
      tilejson = ((_b = (_a = import_mvt.TileJSONLoader).parseTextSync) == null ? void 0 : _b.call(_a, string, loadOptions)) || null;
    } catch (error) {
      console.warn("PMTiles metadata could not be interpreted as TileJSON", error);
    }
  }
  const partialMetadata = {};
  if (typeof (tilejson == null ? void 0 : tilejson.name) === "string") {
    partialMetadata.name = tilejson.name;
  }
  if (typeof (tilejson == null ? void 0 : tilejson.htmlAttribution) === "string") {
    partialMetadata.attributions = [tilejson.htmlAttribution];
  }
  const metadata = {
    ...partialMetadata,
    format: "pmtiles",
    formatVersion: header.specVersion,
    attributions: [],
    tileMIMEType: decodeTileType(header.tileType),
    minZoom: header.minZoom,
    maxZoom: header.maxZoom,
    boundingBox: [
      [header.minLon, header.minLat],
      [header.maxLon, header.maxLat]
    ],
    center: [header.centerLon, header.centerLat],
    centerZoom: header.centerZoom,
    etag: header.etag
  };
  if (tilejson) {
    metadata.tilejson = tilejson;
  }
  if (options == null ? void 0 : options.includeFormatHeader) {
    metadata.formatHeader = header;
    metadata.formatMetadata = metadata;
  }
  return metadata;
}
function decodeTileType(tileType) {
  switch (tileType) {
    case TileType.Mvt:
      return "application/vnd.mapbox-vector-tile";
    case TileType.Png:
      return "image/png";
    case TileType.Jpeg:
      return "image/jpeg";
    case TileType.Webp:
      return "image/webp";
    case TileType.Avif:
      return "image/avif";
    default:
      return "application/octet-stream";
  }
}

// dist/lib/blob-source.js
var BlobSource = class {
  blob;
  key;
  constructor(blob, key) {
    this.blob = blob;
    this.key = key;
  }
  // TODO - how is this used?
  getKey() {
    return this.blob.url || "";
  }
  async getBytes(offset, length, signal) {
    const slice = this.blob.slice(offset, offset + length);
    const data = await slice.arrayBuffer();
    return {
      data
      // etag: response.headers.get('ETag') || undefined,
      // cacheControl: response.headers.get('Cache-Control') || undefined,
      // expires: response.headers.get('Expires') || undefined
    };
  }
};

// dist/pmtiles-source.js
var { PMTiles } = pmtiles2;
var VERSION = "1.0.0";
var PMTilesSource = {
  name: "PMTiles",
  id: "pmtiles",
  module: "pmtiles",
  version: VERSION,
  extensions: ["pmtiles"],
  mimeTypes: ["application/octet-stream"],
  options: { url: void 0, pmtiles: {} },
  type: "pmtiles",
  fromUrl: true,
  fromBlob: true,
  testURL: (url) => url.endsWith(".pmtiles"),
  createDataSource: (url, props) => new PMTilesTileSource(url, props)
};
var PMTilesTileSource = class extends import_loader_utils.DataSource {
  data;
  props;
  mimeType = null;
  pmtiles;
  metadata;
  constructor(data, props) {
    super(props);
    this.props = props;
    const url = typeof data === "string" ? (0, import_loader_utils.resolvePath)(data) : new BlobSource(data, "pmtiles");
    this.data = data;
    this.pmtiles = new PMTiles(url);
    this.getTileData = this.getTileData.bind(this);
    this.metadata = this.getMetadata();
  }
  async getSchema() {
    return { fields: [], metadata: {} };
  }
  async getMetadata() {
    const pmtilesHeader = await this.pmtiles.getHeader();
    const pmtilesMetadata = await this.pmtiles.getMetadata() || {};
    const metadata = parsePMTilesHeader(pmtilesHeader, pmtilesMetadata, { includeFormatHeader: false }, this.loadOptions);
    if (this.props.attributions) {
      metadata.attributions = [...this.props.attributions, ...metadata.attributions || []];
    }
    if (metadata == null ? void 0 : metadata.tileMIMEType) {
      this.mimeType = metadata == null ? void 0 : metadata.tileMIMEType;
    }
    return metadata;
  }
  async getTile(tileParams) {
    const { x, y, z } = tileParams;
    const rangeResponse = await this.pmtiles.getZxy(z, x, y);
    const arrayBuffer = rangeResponse == null ? void 0 : rangeResponse.data;
    if (!arrayBuffer) {
      return null;
    }
    return arrayBuffer;
  }
  // Tile Source interface implementation: deck.gl compatible API
  // TODO - currently only handles image tiles, not vector tiles
  async getTileData(tileParams) {
    const { x, y, z } = tileParams.index;
    const metadata = await this.metadata;
    switch (metadata.tileMIMEType) {
      case "application/vnd.mapbox-vector-tile":
        return await this.getVectorTile({ x, y, z, layers: [] });
      default:
        return await this.getImageTile({ x, y, z, layers: [] });
    }
  }
  // ImageTileSource interface implementation
  async getImageTile(tileParams) {
    const arrayBuffer = await this.getTile(tileParams);
    return arrayBuffer ? await import_images.ImageLoader.parse(arrayBuffer, this.loadOptions) : null;
  }
  // VectorTileSource interface implementation
  async getVectorTile(tileParams) {
    var _a;
    const arrayBuffer = await this.getTile(tileParams);
    const loadOptions = {
      shape: "geojson-table",
      mvt: {
        coordinates: "wgs84",
        tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.z },
        ...(_a = this.loadOptions) == null ? void 0 : _a.mvt
      },
      ...this.loadOptions
    };
    return arrayBuffer ? await import_mvt2.MVTLoader.parse(arrayBuffer, loadOptions) : null;
  }
};

// dist/pmtiles-loader.js
var import_loader_utils2 = require("@loaders.gl/loader-utils");

// dist/lib/version.js
var VERSION2 = true ? "4.3.3" : "latest";

// dist/pmtiles-loader.js
var PMTilesLoader = {
  name: "PMTiles",
  id: "pmtiles",
  module: "pmtiles",
  version: VERSION2,
  extensions: ["pmtiles"],
  mimeTypes: ["application/octet-stream"],
  tests: ["PMTiles"],
  options: {
    pmtiles: {}
  },
  parse: async (arrayBuffer, options) => parseFileAsPMTiles(new import_loader_utils2.BlobFile(new Blob([arrayBuffer])), options),
  parseFile: parseFileAsPMTiles
};
async function parseFileAsPMTiles(file, options) {
  const source = new PMTilesTileSource(file.handle, {
    pmtiles: (options == null ? void 0 : options.pmtiles) || {}
  });
  const formatSpecificMetadata = await source.getMetadata();
  const { tileMIMEType, tilejson = {} } = formatSpecificMetadata;
  const { layers = [] } = tilejson;
  switch (tileMIMEType) {
    case "application/vnd.mapbox-vector-tile":
      return {
        shape: "vector-source",
        layers: layers.map((layer) => ({ name: layer.name, schema: layer.schema })),
        tables: [],
        formatSpecificMetadata
      };
    case "image/png":
    case "image/jpeg":
      return { shape: "image-source", formatSpecificMetadata };
    default:
      throw new Error(`PMTilesLoader: Unsupported tile MIME type ${tileMIMEType}`);
  }
}
//# sourceMappingURL=index.cjs.map
