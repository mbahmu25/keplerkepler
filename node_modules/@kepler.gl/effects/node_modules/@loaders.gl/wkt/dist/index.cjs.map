{
  "version": 3,
  "sources": ["index.js", "lib/utils/version.js", "lib/parse-wkt-crs.js", "wkt-crs-loader.js", "lib/encode-wkt-crs.js", "wkt-crs-writer.js", "lib/parse-wkt.js", "wkt-loader.js", "lib/encode-wkt.js", "wkt-writer.js", "lib/parse-wkb.js", "lib/parse-wkb-header.js", "wkb-loader.js", "lib/utils/binary-writer.js", "lib/encode-wkb.js", "wkb-writer.js", "lib/utils/hex-transcoder.js", "hex-wkb-loader.js", "lib/utils/binary-reader.js", "lib/parse-twkb.js", "twkb-loader.js", "lib/encode-twkb.js", "twkb-writer.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { WKTCRSLoader } from \"./wkt-crs-loader.js\";\nexport { WKTCRSWriter } from \"./wkt-crs-writer.js\";\nexport { WKTLoader, WKTWorkerLoader } from \"./wkt-loader.js\";\nexport { WKTWriter } from \"./wkt-writer.js\";\nexport { WKBLoader, WKBWorkerLoader } from \"./wkb-loader.js\";\nexport { WKBWriter } from \"./wkb-writer.js\";\nexport { HexWKBLoader } from \"./hex-wkb-loader.js\";\nexport { TWKBLoader } from \"./twkb-loader.js\";\nexport { TWKBWriter } from \"./twkb-writer.js\";\n// EXPERIMENTAL APIs\nexport { isWKT } from \"./lib/parse-wkt.js\";\nexport { isWKB, parseWKBHeader } from \"./lib/parse-wkb-header.js\";\nexport { isTWKB } from \"./lib/parse-twkb.js\";\nexport { encodeHex, decodeHex } from \"./lib/utils/hex-transcoder.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// parse-wkt-crs was forked from https://github.com/DanielJDufour/wkt-crs under Creative Commons CC0 1.0 license.\n/**\n *\n * @param wkt\n * @param options\n * @returns\n */\nexport function parseWKTCRS(wkt, options) {\n    if (options?.debug) {\n        console.log('[wktcrs] parse starting with\\n', wkt);\n    }\n    // move all keywords into first array item slot\n    // from PARAM[12345, 67890] to [\"PARAM\", 12345, 67890]\n    wkt = wkt.replace(/[A-Z][A-Z\\d_]+\\[/gi, (match) => `[\"${match.substr(0, match.length - 1)}\",`);\n    // wrap variables in strings\n    // from [...,NORTH] to [...,\"NORTH\"]\n    wkt = wkt.replace(/, ?([A-Z][A-Z\\d_]+[,\\]])/gi, (match, p1) => {\n        const varname = p1.substr(0, p1.length - 1);\n        return ',' + `\"${options?.raw ? 'raw:' : ''}${varname}\"${p1[p1.length - 1]}`;\n    });\n    if (options?.raw) {\n        // replace all numbers with strings\n        wkt = wkt.replace(/, {0,2}(-?[\\.\\d]+)(?=,|\\])/g, function (match, p1) {\n            return ',' + `\"${options?.raw ? 'raw:' : ''}${p1}\"`;\n        });\n    }\n    // str should now be valid JSON\n    if (options?.debug) {\n        console.log(`[wktcrs] json'd wkt: '${wkt}'`);\n    }\n    let data;\n    try {\n        data = JSON.parse(wkt);\n    }\n    catch (error) {\n        console.error(`[wktcrs] failed to parse '${wkt}'`);\n        throw error;\n    }\n    if (options?.debug) {\n        console.log(`[wktcrs] json parsed: '${wkt}'`);\n    }\n    function process(data, parent) {\n        const kw = data[0];\n        // after removing the first element with .shift()\n        // data is now just an array of attributes\n        data.forEach(function (it) {\n            if (Array.isArray(it)) {\n                process(it, data);\n            }\n        });\n        const kwarr = `MULTIPLE_${kw}`;\n        if (kwarr in parent) {\n            parent[kwarr].push(data);\n        }\n        else if (kw in parent) {\n            parent[kwarr] = [parent[kw], data];\n            delete parent[kw];\n        }\n        else {\n            parent[kw] = data;\n        }\n        return parent;\n    }\n    const result = process(data, [data]);\n    if (options?.debug) {\n        console.log('[wktcrs] parse returning', result);\n    }\n    if (options?.sort) {\n        sort(result, options);\n    }\n    return result;\n}\nfunction sort(data, options) {\n    const keys = Object.keys(data).filter((k) => !/\\d+/.test(k));\n    const keywords = options?.keywords || [];\n    if (!options?.keywords) {\n        // try to find multiples\n        const counts = {};\n        if (Array.isArray(data)) {\n            data.forEach((it) => {\n                if (Array.isArray(it) && it.length >= 2 && typeof it[1] === 'string') {\n                    const k = it[0];\n                    if (!counts[k])\n                        counts[k] = 0;\n                    counts[k]++;\n                }\n            });\n            for (const k in counts) {\n                if (counts[k] > 0)\n                    keywords.push(k);\n            }\n        }\n    }\n    keys.forEach((key) => {\n        data[key] = sort(data[key]);\n    });\n    keywords.forEach((key) => {\n        const indices = [];\n        const params = [];\n        data.forEach((item, i) => {\n            if (Array.isArray(item) && item[0] === key) {\n                indices.push(i);\n                params.push(item);\n            }\n        });\n        params.sort((a, b) => {\n            a = a[1].toString();\n            b = b[1].toString();\n            return a < b ? -1 : a > b ? 1 : 0;\n        });\n        // replace in order\n        params.forEach((param, i) => {\n            data[indices[i]] = param;\n        });\n    });\n    return data;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseWKTCRS } from \"./lib/parse-wkt-crs.js\";\n/**\n * Well-Known text CRS loader\n * @see OGC Standard: https://www.ogc.org/standards/wkt-crs\n * @see Wikipedia Page: https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems\n */\nexport const WKTCRSLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'WKT CRS (Well-Known Text Coordinate Reference System)',\n    id: 'wkt-crs',\n    module: 'wkt-crs',\n    version: VERSION,\n    worker: true,\n    extensions: [],\n    mimeTypes: ['text/plain'],\n    category: 'json',\n    text: true,\n    options: {\n        'wkt-crs': {}\n    },\n    parse: async (arrayBuffer, options) => parseWKTCRS(new TextDecoder().decode(arrayBuffer), options?.['wkt-crs']),\n    parseTextSync: (string, options) => parseWKTCRS(string, options?.['wkt-crs'])\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// parse-wkt-crs was forked from https://github.com/DanielJDufour/wkt-crs under Creative Commons CC0 1.0 license.\n/**\n * convert JSON representation of Well-Known Text\n * back to standard Well-Known Text\n */\nexport function encodeWKTCRS(wkt, options) {\n    if (Array.isArray(wkt) && wkt.length === 1 && Array.isArray(wkt[0])) {\n        wkt = wkt[0]; // ignore first extra wrapper array\n    }\n    const [kw, ...attrs] = wkt;\n    const str = `${kw}[${attrs\n        .map((attr) => {\n        if (Array.isArray(attr)) {\n            return encodeWKTCRS(attr, options);\n        }\n        else if (typeof attr === 'number') {\n            return attr.toString();\n        }\n        else if (typeof attr === 'string') {\n            // can't automatically convert all caps to varibale\n            // because EPSG is string in AUTHORITY[\"EPSG\", ...]\n            if (attr.startsWith('raw:')) {\n                // convert \"raw:NORTH\" to NORTH\n                return attr.replace('raw:', '');\n            }\n            return `\"${attr}\"`;\n        }\n        throw new Error(`[wktcrs] unexpected attribute \"${attr}\"`);\n    })\n        .join(',')}]`;\n    return str;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { encodeWKTCRS } from \"./lib/encode-wkt-crs.js\";\n/**\n * Well-Known text CRS loader\n * @see OGC Standard: https://www.ogc.org/standards/wkt-crs\n * @see Wikipedia Page: https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems\n */\nexport const WKTCRSWriter = {\n    name: 'WKT CRS (Well-Known Text Coordinate Reference System)',\n    id: 'wkt-crs',\n    module: 'wkt-crs',\n    version: VERSION,\n    worker: true,\n    extensions: [],\n    mimeTypes: ['text/plain'],\n    // category: 'json',\n    text: true,\n    options: {\n        'wkt-crs': {}\n    },\n    encode: async (wktcrs, options) => new TextEncoder().encode(encodeWKTCRS(wktcrs, options?.['wkt-crs'])),\n    encodeSync: (wktcrs, options) => new TextEncoder().encode(encodeWKTCRS(wktcrs, options?.['wkt-crs'])),\n    encodeTextSync: (wktcrs, options) => encodeWKTCRS(wktcrs, options?.['wkt-crs'])\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Fork of https://github.com/mapbox/wellknown under ISC license (MIT/BSD-2-clause equivalent)\n/* eslint-disable */\n// @ts-nocheck\nconst numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nconst tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\nexport const WKT_MAGIC_STRINGS = [\n    'POINT(',\n    'LINESTRING(',\n    'POLYGON(',\n    'MULTIPOINT(',\n    'MULTILINESTRING(',\n    'MULTIPOLYGON(',\n    'GEOMETRYCOLLECTION('\n    // We only support this \"geojson\" subset of the OGC simple features standard\n];\n/**\n * Check if a string is WKT.\n * @param input A potential WKT geometry string\n * @return `true` if input appears to be a WKT geometry string, `false` otherwise\n\n * @note We only support the \"geojson\" subset of the OGC simple features standard\n * @todo Does not handle leading spaces which appear to be permitted per the spec:\n * \"A WKT string contains no white space outside of double quotes.\n * However padding with white space to improve human readability is permitted;\n * the examples of WKT that are included in this document have\n * spaces and line feeds inserted to improve clarity. Any padding is stripped out or ignored by parsers.\"\n */\nexport function isWKT(input) {\n    return WKT_MAGIC_STRINGS.some((magicString) => input.startsWith(magicString));\n}\n/**\n * Parse WKT and return GeoJSON.\n * @param input A WKT geometry string\n * @return A GeoJSON geometry object\n *\n * @note We only support the \"geojson\" subset of the OGC simple features standard\n **/\nexport function parseWKT(input, options) {\n    // TODO handle options.wkt.shape\n    return parseWKTToGeometry(input, options);\n}\n/** Parse into GeoJSON geometry */\nfunction parseWKTToGeometry(input, options) {\n    const parts = input.split(';');\n    let _ = parts.pop();\n    const srid = (parts.shift() || '').split('=').pop();\n    const state = { parts, _, i: 0 };\n    const geometry = parseGeometry(state);\n    return options?.wkt?.crs ? addCRS(geometry, srid) : geometry;\n}\nfunction parseGeometry(state) {\n    return (parsePoint(state) ||\n        parseLineString(state) ||\n        parsePolygon(state) ||\n        parseMultiPoint(state) ||\n        parseMultiLineString(state) ||\n        parseMultiPolygon(state) ||\n        parseGeometryCollection(state));\n}\n/** Adds a coordinate reference system as an undocumented  */\nfunction addCRS(obj, srid) {\n    if (obj && srid?.match(/\\d+/)) {\n        const crs = {\n            type: 'name',\n            properties: {\n                name: 'urn:ogc:def:crs:EPSG::' + srid\n            }\n        };\n        // @ts-expect-error we assign an undocumented property on the geometry\n        obj.crs = crs;\n    }\n    return obj;\n}\n// GEOMETRIES\nfunction parsePoint(state) {\n    if (!$(/^(POINT(\\sz)?)/i, state)) {\n        return null;\n    }\n    white(state);\n    if (!$(/^(\\()/, state)) {\n        return null;\n    }\n    const c = coords(state);\n    if (!c) {\n        return null;\n    }\n    white(state);\n    if (!$(/^(\\))/, state)) {\n        return null;\n    }\n    return {\n        type: 'Point',\n        coordinates: c[0]\n    };\n}\nfunction parseMultiPoint(state) {\n    if (!$(/^(MULTIPOINT)/i, state)) {\n        return null;\n    }\n    white(state);\n    const newCoordsFormat = state._?.substring(state._?.indexOf('(') + 1, state._.length - 1)\n        .replace(/\\(/g, '')\n        .replace(/\\)/g, '');\n    state._ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    const c = multicoords(state);\n    if (!c) {\n        return null;\n    }\n    white(state);\n    return {\n        type: 'MultiPoint',\n        coordinates: c\n    };\n}\nfunction parseLineString(state) {\n    if (!$(/^(LINESTRING(\\sz)?)/i, state)) {\n        return null;\n    }\n    white(state);\n    if (!$(/^(\\()/, state)) {\n        return null;\n    }\n    const c = coords(state);\n    if (!c) {\n        return null;\n    }\n    if (!$(/^(\\))/, state)) {\n        return null;\n    }\n    return {\n        type: 'LineString',\n        coordinates: c\n    };\n}\nfunction parseMultiLineString(state) {\n    if (!$(/^(MULTILINESTRING)/i, state))\n        return null;\n    white(state);\n    const c = multicoords(state);\n    if (!c) {\n        return null;\n    }\n    white(state);\n    return {\n        // @ts-ignore\n        type: 'MultiLineString',\n        // @ts-expect-error\n        coordinates: c\n    };\n}\nfunction parsePolygon(state) {\n    if (!$(/^(POLYGON(\\sz)?)/i, state)) {\n        return null;\n    }\n    white(state);\n    const c = multicoords(state);\n    if (!c) {\n        return null;\n    }\n    return {\n        // @ts-ignore\n        type: 'Polygon',\n        // @ts-expect-error\n        coordinates: c\n    };\n}\nfunction parseMultiPolygon(state) {\n    if (!$(/^(MULTIPOLYGON)/i, state)) {\n        return null;\n    }\n    white(state);\n    const c = multicoords(state);\n    if (!c) {\n        return null;\n    }\n    return {\n        type: 'MultiPolygon',\n        // @ts-expect-error\n        coordinates: c\n    };\n}\nfunction parseGeometryCollection(state) {\n    const geometries = [];\n    let geometry;\n    if (!$(/^(GEOMETRYCOLLECTION)/i, state)) {\n        return null;\n    }\n    white(state);\n    if (!$(/^(\\()/, state)) {\n        return null;\n    }\n    while ((geometry = parseGeometry(state))) {\n        geometries.push(geometry);\n        white(state);\n        $(/^(,)/, state);\n        white(state);\n    }\n    if (!$(/^(\\))/, state)) {\n        return null;\n    }\n    return {\n        type: 'GeometryCollection',\n        geometries: geometries\n    };\n}\n// COORDINATES\nfunction multicoords(state) {\n    white(state);\n    let depth = 0;\n    const rings = [];\n    const stack = [rings];\n    let pointer = rings;\n    let elem;\n    while ((elem = $(/^(\\()/, state) || $(/^(\\))/, state) || $(/^(,)/, state) || $(tuples, state))) {\n        if (elem === '(') {\n            stack.push(pointer);\n            pointer = [];\n            stack[stack.length - 1].push(pointer);\n            depth++;\n        }\n        else if (elem === ')') {\n            // For the case: Polygon(), ...\n            if (pointer.length === 0)\n                return null;\n            // @ts-ignore\n            pointer = stack.pop();\n            // the stack was empty, input was malformed\n            if (!pointer)\n                return null;\n            depth--;\n            if (depth === 0)\n                break;\n        }\n        else if (elem === ',') {\n            pointer = [];\n            stack[stack.length - 1].push(pointer);\n        }\n        else if (!elem.split(/\\s/g).some(isNaN)) {\n            Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n        }\n        else {\n            return null;\n        }\n        white(state);\n    }\n    if (depth !== 0)\n        return null;\n    return rings;\n}\nfunction coords(state) {\n    const list = [];\n    let item;\n    let pt;\n    while ((pt = $(tuples, state) || $(/^(,)/, state))) {\n        if (pt === ',') {\n            list.push(item);\n            item = [];\n        }\n        else if (!pt.split(/\\s/g).some(isNaN)) {\n            if (!item)\n                item = [];\n            Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n        }\n        white(state);\n    }\n    if (item)\n        list.push(item);\n    else\n        return null;\n    return list.length ? list : null;\n}\n// HELPERS\nfunction $(regexp, state) {\n    const match = state._?.substring(state.i).match(regexp);\n    if (!match)\n        return null;\n    else {\n        state.i += match[0].length;\n        return match[0];\n    }\n}\nfunction white(state) {\n    $(/^\\s*/, state);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseWKT, isWKT, WKT_MAGIC_STRINGS } from \"./lib/parse-wkt.js\";\n/**\n * Well-Known text worker loader\n */\nexport const WKTWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'WKT (Well-Known Text)',\n    id: 'wkt',\n    module: 'wkt',\n    version: VERSION,\n    worker: true,\n    extensions: ['wkt'],\n    mimeTypes: ['text/plain'],\n    category: 'geometry',\n    text: true,\n    tests: WKT_MAGIC_STRINGS,\n    testText: isWKT,\n    options: {\n        wkt: {\n            shape: 'geojson-geometry',\n            crs: true\n        }\n    }\n};\n/**\n * Well-Known text loader\n */\nexport const WKTLoader = {\n    ...WKTWorkerLoader,\n    parse: async (arrayBuffer, options) => parseWKT(new TextDecoder().decode(arrayBuffer), options),\n    parseTextSync: (string, options) => parseWKT(string, options)\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Fork of https://github.com/mapbox/wellknown under ISC license (MIT/BSD-2-clause equivalent)\n/**\n * Stringifies a GeoJSON object into WKT\n * @param geojson\n * @returns string\n */\nexport function encodeWKT(geometry) {\n    if (geometry.type === 'Feature') {\n        geometry = geometry.geometry;\n    }\n    switch (geometry.type) {\n        case 'Point':\n            return `POINT ${wrapParens(pairWKT(geometry.coordinates))}`;\n        case 'LineString':\n            return `LINESTRING ${wrapParens(ringWKT(geometry.coordinates))}`;\n        case 'Polygon':\n            return `POLYGON ${wrapParens(ringsWKT(geometry.coordinates))}`;\n        case 'MultiPoint':\n            return `MULTIPOINT ${wrapParens(ringWKT(geometry.coordinates))}`;\n        case 'MultiPolygon':\n            return `MULTIPOLYGON ${wrapParens(multiRingsWKT(geometry.coordinates))}`;\n        case 'MultiLineString':\n            return `MULTILINESTRING ${wrapParens(ringsWKT(geometry.coordinates))}`;\n        case 'GeometryCollection':\n            return `GEOMETRYCOLLECTION ${wrapParens(geometry.geometries.map(encodeWKT).join(', '))}`;\n        default:\n            throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n    }\n}\nfunction pairWKT(c) {\n    return c.join(' ');\n}\nfunction ringWKT(r) {\n    return r.map(pairWKT).join(', ');\n}\nfunction ringsWKT(r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n}\nfunction multiRingsWKT(r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n}\nfunction wrapParens(s) {\n    return `(${s})`;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { encodeWKT } from \"./lib/encode-wkt.js\";\n/**\n * WKT exporter\n */\nexport const WKTWriter = {\n    name: 'WKT (Well Known Text)',\n    id: 'wkt',\n    module: 'wkt',\n    version: VERSION,\n    extensions: ['wkt'],\n    text: true,\n    encode: async (geometry) => encodeWKTSync(geometry),\n    encodeSync: encodeWKTSync,\n    encodeTextSync: encodeWKT,\n    options: {\n        wkt: {}\n    }\n};\nfunction encodeWKTSync(geometry) {\n    return new TextEncoder().encode(encodeWKT(geometry)).buffer;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { binaryToGeometry } from '@loaders.gl/gis';\nimport { parseWKBHeader, WKBGeometryType } from \"./parse-wkb-header.js\";\nexport function parseWKB(arrayBuffer, options) {\n    const binaryGeometry = parseWKBToBinary(arrayBuffer, options);\n    const shape = options?.wkb?.shape || 'binary-geometry';\n    switch (shape) {\n        case 'binary-geometry':\n            return binaryGeometry;\n        case 'geojson-geometry':\n            return binaryToGeometry(binaryGeometry);\n        case 'geometry':\n            // eslint-disable-next-line no-console\n            console.error('WKBLoader: \"geometry\" shape is deprecated, use \"binary-geometry\" instead');\n            return binaryToGeometry(binaryGeometry);\n        default:\n            throw new Error(shape);\n    }\n}\nexport function parseWKBToBinary(arrayBuffer, options) {\n    const dataView = new DataView(arrayBuffer);\n    const wkbHeader = parseWKBHeader(dataView);\n    const { geometryType, dimensions, littleEndian } = wkbHeader;\n    const offset = wkbHeader.byteOffset;\n    switch (geometryType) {\n        case WKBGeometryType.Point:\n            const point = parsePoint(dataView, offset, dimensions, littleEndian);\n            return point.geometry;\n        case WKBGeometryType.LineString:\n            const line = parseLineString(dataView, offset, dimensions, littleEndian);\n            return line.geometry;\n        case WKBGeometryType.Polygon:\n            const polygon = parsePolygon(dataView, offset, dimensions, littleEndian);\n            return polygon.geometry;\n        case WKBGeometryType.MultiPoint:\n            const multiPoint = parseMultiPoint(dataView, offset, dimensions, littleEndian);\n            multiPoint.type = 'Point';\n            return multiPoint;\n        case WKBGeometryType.MultiLineString:\n            const multiLine = parseMultiLineString(dataView, offset, dimensions, littleEndian);\n            multiLine.type = 'LineString';\n            return multiLine;\n        case WKBGeometryType.MultiPolygon:\n            const multiPolygon = parseMultiPolygon(dataView, offset, dimensions, littleEndian);\n            multiPolygon.type = 'Polygon';\n            return multiPolygon;\n        // case WKBGeometryType.GeometryCollection:\n        // TODO: handle GeometryCollections\n        // return parseGeometryCollection(dataView, offset, dimensions, littleEndian);\n        default:\n            throw new Error(`WKB: Unsupported geometry type: ${geometryType}`);\n    }\n}\n// Primitives; parse point and linear ring\nfunction parsePoint(dataView, offset, dimension, littleEndian) {\n    const positions = new Float64Array(dimension);\n    for (let i = 0; i < dimension; i++) {\n        positions[i] = dataView.getFloat64(offset, littleEndian);\n        offset += 8;\n    }\n    return {\n        geometry: { type: 'Point', positions: { value: positions, size: dimension } },\n        offset\n    };\n}\nfunction parseLineString(dataView, offset, dimension, littleEndian) {\n    const nPoints = dataView.getUint32(offset, littleEndian);\n    offset += 4;\n    // Instantiate array\n    const positions = new Float64Array(nPoints * dimension);\n    for (let i = 0; i < nPoints * dimension; i++) {\n        positions[i] = dataView.getFloat64(offset, littleEndian);\n        offset += 8;\n    }\n    const pathIndices = [0];\n    if (nPoints > 0) {\n        pathIndices.push(nPoints);\n    }\n    return {\n        geometry: {\n            type: 'LineString',\n            positions: { value: positions, size: dimension },\n            pathIndices: { value: new Uint32Array(pathIndices), size: 1 }\n        },\n        offset\n    };\n}\n// https://stackoverflow.com/a/55261098\nconst cumulativeSum = (sum) => (value) => (sum += value);\nfunction parsePolygon(dataView, offset, dimension, littleEndian) {\n    const nRings = dataView.getUint32(offset, littleEndian);\n    offset += 4;\n    const rings = [];\n    for (let i = 0; i < nRings; i++) {\n        const parsed = parseLineString(dataView, offset, dimension, littleEndian);\n        const { positions } = parsed.geometry;\n        offset = parsed.offset;\n        rings.push(positions.value);\n    }\n    const concatenatedPositions = new Float64Array(concatTypedArrays(rings).buffer);\n    const polygonIndices = [0];\n    if (concatenatedPositions.length > 0) {\n        polygonIndices.push(concatenatedPositions.length / dimension);\n    }\n    const primitivePolygonIndices = rings.map((l) => l.length / dimension).map(cumulativeSum(0));\n    primitivePolygonIndices.unshift(0);\n    return {\n        geometry: {\n            type: 'Polygon',\n            positions: { value: concatenatedPositions, size: dimension },\n            polygonIndices: {\n                value: new Uint32Array(polygonIndices),\n                size: 1\n            },\n            primitivePolygonIndices: { value: new Uint32Array(primitivePolygonIndices), size: 1 }\n        },\n        offset\n    };\n}\nfunction parseMultiPoint(dataView, offset, dimension, littleEndian) {\n    const nPoints = dataView.getUint32(offset, littleEndian);\n    offset += 4;\n    const binaryPointGeometries = [];\n    for (let i = 0; i < nPoints; i++) {\n        // Byte order for point\n        const littleEndianPoint = dataView.getUint8(offset) === 1;\n        offset++;\n        // Assert point type\n        if (dataView.getUint32(offset, littleEndianPoint) % 1000 !== 1) {\n            throw new Error('WKB: Inner geometries of MultiPoint not of type Point');\n        }\n        offset += 4;\n        const parsed = parsePoint(dataView, offset, dimension, littleEndianPoint);\n        offset = parsed.offset;\n        binaryPointGeometries.push(parsed.geometry);\n    }\n    return concatenateBinaryPointGeometries(binaryPointGeometries, dimension);\n}\nfunction parseMultiLineString(dataView, offset, dimension, littleEndian) {\n    const nLines = dataView.getUint32(offset, littleEndian);\n    offset += 4;\n    const binaryLineGeometries = [];\n    for (let i = 0; i < nLines; i++) {\n        // Byte order for line\n        const littleEndianLine = dataView.getUint8(offset) === 1;\n        offset++;\n        // Assert type LineString\n        if (dataView.getUint32(offset, littleEndianLine) % 1000 !== 2) {\n            throw new Error('WKB: Inner geometries of MultiLineString not of type LineString');\n        }\n        offset += 4;\n        const parsed = parseLineString(dataView, offset, dimension, littleEndianLine);\n        offset = parsed.offset;\n        binaryLineGeometries.push(parsed.geometry);\n    }\n    return concatenateBinaryLineGeometries(binaryLineGeometries, dimension);\n}\nfunction parseMultiPolygon(dataView, offset, dimension, littleEndian) {\n    const nPolygons = dataView.getUint32(offset, littleEndian);\n    offset += 4;\n    const binaryPolygonGeometries = [];\n    for (let i = 0; i < nPolygons; i++) {\n        // Byte order for polygon\n        const littleEndianPolygon = dataView.getUint8(offset) === 1;\n        offset++;\n        // Assert type Polygon\n        if (dataView.getUint32(offset, littleEndianPolygon) % 1000 !== 3) {\n            throw new Error('WKB: Inner geometries of MultiPolygon not of type Polygon');\n        }\n        offset += 4;\n        const parsed = parsePolygon(dataView, offset, dimension, littleEndianPolygon);\n        offset = parsed.offset;\n        binaryPolygonGeometries.push(parsed.geometry);\n    }\n    return concatenateBinaryPolygonGeometries(binaryPolygonGeometries, dimension);\n}\n// TODO - move to loaders.gl/schema/gis\nfunction concatenateBinaryPointGeometries(binaryPointGeometries, dimension) {\n    const positions = binaryPointGeometries.map((geometry) => geometry.positions.value);\n    const concatenatedPositions = new Float64Array(concatTypedArrays(positions).buffer);\n    return {\n        type: 'Point',\n        positions: { value: concatenatedPositions, size: dimension }\n    };\n}\nfunction concatenateBinaryLineGeometries(binaryLineGeometries, dimension) {\n    const lines = binaryLineGeometries.map((geometry) => geometry.positions.value);\n    const concatenatedPositions = new Float64Array(concatTypedArrays(lines).buffer);\n    const pathIndices = lines.map((line) => line.length / dimension).map(cumulativeSum(0));\n    pathIndices.unshift(0);\n    return {\n        type: 'LineString',\n        positions: { value: concatenatedPositions, size: dimension },\n        pathIndices: { value: new Uint32Array(pathIndices), size: 1 }\n    };\n}\nfunction concatenateBinaryPolygonGeometries(binaryPolygonGeometries, dimension) {\n    const polygons = [];\n    const primitivePolygons = [];\n    for (const binaryPolygon of binaryPolygonGeometries) {\n        const { positions, primitivePolygonIndices } = binaryPolygon;\n        polygons.push(positions.value);\n        primitivePolygons.push(primitivePolygonIndices.value);\n    }\n    const concatenatedPositions = new Float64Array(concatTypedArrays(polygons).buffer);\n    const polygonIndices = polygons.map((p) => p.length / dimension).map(cumulativeSum(0));\n    polygonIndices.unshift(0);\n    // Combine primitivePolygonIndices from each individual polygon\n    const primitivePolygonIndices = [0];\n    for (const primitivePolygon of primitivePolygons) {\n        primitivePolygonIndices.push(...primitivePolygon\n            .filter((x) => x > 0)\n            .map((x) => x + primitivePolygonIndices[primitivePolygonIndices.length - 1]));\n    }\n    return {\n        type: 'Polygon',\n        positions: { value: concatenatedPositions, size: dimension },\n        polygonIndices: { value: new Uint32Array(polygonIndices), size: 1 },\n        primitivePolygonIndices: { value: new Uint32Array(primitivePolygonIndices), size: 1 }\n    };\n}\n// TODO: remove copy; import from typed-array-utils\n// modules/math/src/geometry/typed-arrays/typed-array-utils.js\nfunction concatTypedArrays(arrays) {\n    let byteLength = 0;\n    for (let i = 0; i < arrays.length; ++i) {\n        byteLength += arrays[i].byteLength;\n    }\n    const buffer = new Uint8Array(byteLength);\n    let byteOffset = 0;\n    for (let i = 0; i < arrays.length; ++i) {\n        const data = new Uint8Array(arrays[i].buffer);\n        byteLength = data.length;\n        for (let j = 0; j < byteLength; ++j) {\n            buffer[byteOffset++] = data[j];\n        }\n    }\n    return buffer;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst EWKB_FLAG_Z = 0x80000000;\nconst EWKB_FLAG_M = 0x40000000;\nconst EWKB_FLAG_SRID = 0x20000000;\nconst MAX_SRID = 10000; // TBD: Assume no more than 10K SRIDs are defined\n/**\n * Integer code for geometry types in WKB and related formats\n * Reference: https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary\n */\nexport var WKBGeometryType;\n(function (WKBGeometryType) {\n    WKBGeometryType[WKBGeometryType[\"Point\"] = 1] = \"Point\";\n    WKBGeometryType[WKBGeometryType[\"LineString\"] = 2] = \"LineString\";\n    WKBGeometryType[WKBGeometryType[\"Polygon\"] = 3] = \"Polygon\";\n    WKBGeometryType[WKBGeometryType[\"MultiPoint\"] = 4] = \"MultiPoint\";\n    WKBGeometryType[WKBGeometryType[\"MultiLineString\"] = 5] = \"MultiLineString\";\n    WKBGeometryType[WKBGeometryType[\"MultiPolygon\"] = 6] = \"MultiPolygon\";\n    WKBGeometryType[WKBGeometryType[\"GeometryCollection\"] = 7] = \"GeometryCollection\";\n})(WKBGeometryType || (WKBGeometryType = {}));\n/** Sanity checks that first to 5-9 bytes could represent a supported WKB dialect header */\nexport function isWKB(arrayBuffer) {\n    const dataView = new DataView(arrayBuffer);\n    let byteOffset = 0;\n    const endianness = dataView.getUint8(byteOffset);\n    byteOffset += 1;\n    // Check valid endianness (only 0 or 1 are allowed)\n    if (endianness > 1) {\n        return false;\n    }\n    const littleEndian = endianness === 1;\n    const geometry = dataView.getUint32(byteOffset, littleEndian);\n    byteOffset += 4;\n    // check valid geometry type (we don't support extension geometries)\n    const geometryType = geometry & 0x07;\n    if (geometryType === 0 || geometryType > 7) {\n        return false;\n    }\n    const geometryFlags = geometry - geometryType;\n    // Accept iso-wkb flags\n    if (geometryFlags === 0 ||\n        geometryFlags === 1000 ||\n        geometryFlags === 2000 ||\n        geometryFlags === 3000) {\n        return true;\n    }\n    // Accept ewkb flags but reject otherwise\n    if ((geometryFlags & ~(EWKB_FLAG_Z | EWKB_FLAG_M | EWKB_FLAG_SRID)) !== 0) {\n        return false;\n    }\n    if (geometryFlags & EWKB_FLAG_SRID) {\n        const srid = dataView.getUint32(byteOffset, littleEndian);\n        byteOffset += 4;\n        if (srid > MAX_SRID) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Parses header and provides a byteOffset to start of geometry data\n * @param dataView\n * @param target optionally supply a WKBHeader object to avoid creating a new object for every call\n * @returns a header object describing the WKB data\n */\n// eslint-disable-next-line max-statements\nexport function parseWKBHeader(dataView, target) {\n    const wkbHeader = Object.assign(target || {}, {\n        type: 'wkb',\n        geometryType: 1,\n        dimensions: 2,\n        coordinates: 'xy',\n        littleEndian: true,\n        byteOffset: 0\n    });\n    // Check endianness of data\n    wkbHeader.littleEndian = dataView.getUint8(wkbHeader.byteOffset) === 1;\n    wkbHeader.byteOffset++;\n    // 4-digit code representing dimension and type of geometry\n    const geometryCode = dataView.getUint32(wkbHeader.byteOffset, wkbHeader.littleEndian);\n    wkbHeader.byteOffset += 4;\n    wkbHeader.geometryType = (geometryCode & 0x7);\n    // Check if iso-wkb variant: iso-wkb adds 1000, 2000 or 3000 to the geometry code\n    const isoType = (geometryCode - wkbHeader.geometryType) / 1000;\n    switch (isoType) {\n        case 0:\n            break;\n        case 1:\n            wkbHeader.type = 'iso-wkb';\n            wkbHeader.dimensions = 3;\n            wkbHeader.coordinates = 'xyz';\n            break;\n        case 2:\n            wkbHeader.type = 'iso-wkb';\n            wkbHeader.dimensions = 3;\n            wkbHeader.coordinates = 'xym';\n            break;\n        case 3:\n            wkbHeader.type = 'iso-wkb';\n            wkbHeader.dimensions = 4;\n            wkbHeader.coordinates = 'xyzm';\n            break;\n        default:\n            throw new Error(`WKB: Unsupported iso-wkb type: ${isoType}`);\n    }\n    // Check if EWKB variant. Uses bitmasks for Z&M dimensions as well as optional SRID field\n    const ewkbZ = geometryCode & EWKB_FLAG_Z;\n    const ewkbM = geometryCode & EWKB_FLAG_M;\n    const ewkbSRID = geometryCode & EWKB_FLAG_SRID;\n    if (ewkbZ && ewkbM) {\n        wkbHeader.type = 'ewkb';\n        wkbHeader.dimensions = 4;\n        wkbHeader.coordinates = 'xyzm';\n    }\n    else if (ewkbZ) {\n        wkbHeader.type = 'ewkb';\n        wkbHeader.dimensions = 3;\n        wkbHeader.coordinates = 'xyz';\n    }\n    else if (ewkbM) {\n        wkbHeader.type = 'ewkb';\n        wkbHeader.dimensions = 3;\n        wkbHeader.coordinates = 'xym';\n    }\n    // If SRID present read four more bytes\n    if (ewkbSRID) {\n        wkbHeader.type = 'ewkb';\n        // 4-digit code representing dimension and type of geometry\n        wkbHeader.srid = dataView.getUint32(wkbHeader.byteOffset, wkbHeader.littleEndian);\n        wkbHeader.byteOffset += 4;\n    }\n    return wkbHeader;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseWKB } from \"./lib/parse-wkb.js\";\nimport { isWKB } from \"./lib/parse-wkb-header.js\";\n/**\n * Worker loader for WKB (Well-Known Binary)\n */\nexport const WKBWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'WKB',\n    id: 'wkb',\n    module: 'wkt',\n    version: VERSION,\n    worker: true,\n    category: 'geometry',\n    extensions: ['wkb'],\n    mimeTypes: [],\n    // TODO can we define static, serializable tests, eg. some binary strings?\n    tests: [isWKB],\n    options: {\n        wkb: {\n            shape: 'binary-geometry' // 'geojson-geometry'\n        }\n    }\n};\n/**\n * Loader for WKB (Well-Known Binary)\n */\nexport const WKBLoader = {\n    ...WKBWorkerLoader,\n    parse: async (arrayBuffer) => parseWKB(arrayBuffer),\n    parseSync: parseWKB\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/cschwarz/wkx under MIT license, Copyright (c) 2013 Christian Schwarz\nconst LE = true;\nconst BE = false;\nexport class BinaryWriter {\n    arrayBuffer;\n    dataView;\n    byteOffset = 0;\n    allowResize = false;\n    constructor(size, allowResize) {\n        this.arrayBuffer = new ArrayBuffer(size);\n        this.dataView = new DataView(this.arrayBuffer);\n        this.byteOffset = 0;\n        this.allowResize = allowResize || false;\n    }\n    writeUInt8(value) {\n        this._ensureSize(1);\n        this.dataView.setUint8(this.byteOffset, value);\n        this.byteOffset += 1;\n    }\n    writeUInt16LE(value) {\n        this._ensureSize(2);\n        this.dataView.setUint16(this.byteOffset, value, LE);\n        this.byteOffset += 2;\n    }\n    writeUInt16BE(value) {\n        this._ensureSize(2);\n        this.dataView.setUint16(this.byteOffset, value, BE);\n        this.byteOffset += 2;\n    }\n    writeUInt32LE(value) {\n        this._ensureSize(4);\n        this.dataView.setUint32(this.byteOffset, value, LE);\n        this.byteOffset += 4;\n    }\n    writeUInt32BE(value) {\n        this._ensureSize(4);\n        this.dataView.setUint32(this.byteOffset, value, BE);\n        this.byteOffset += 4;\n    }\n    writeInt8(value) {\n        this._ensureSize(1);\n        this.dataView.setInt8(this.byteOffset, value);\n        this.byteOffset += 1;\n    }\n    writeInt16LE(value) {\n        this._ensureSize(2);\n        this.dataView.setInt16(this.byteOffset, value, LE);\n        this.byteOffset += 2;\n    }\n    writeInt16BE(value) {\n        this._ensureSize(2);\n        this.dataView.setInt16(this.byteOffset, value, BE);\n        this.byteOffset += 2;\n    }\n    writeInt32LE(value) {\n        this._ensureSize(4);\n        this.dataView.setInt32(this.byteOffset, value, LE);\n        this.byteOffset += 4;\n    }\n    writeInt32BE(value) {\n        this._ensureSize(4);\n        this.dataView.setInt32(this.byteOffset, value, BE);\n        this.byteOffset += 4;\n    }\n    writeFloatLE(value) {\n        this._ensureSize(4);\n        this.dataView.setFloat32(this.byteOffset, value, LE);\n        this.byteOffset += 4;\n    }\n    writeFloatBE(value) {\n        this._ensureSize(4);\n        this.dataView.setFloat32(this.byteOffset, value, BE);\n        this.byteOffset += 4;\n    }\n    writeDoubleLE(value) {\n        this._ensureSize(8);\n        this.dataView.setFloat64(this.byteOffset, value, LE);\n        this.byteOffset += 8;\n    }\n    writeDoubleBE(value) {\n        this._ensureSize(8);\n        this.dataView.setFloat64(this.byteOffset, value, BE);\n        this.byteOffset += 8;\n    }\n    /** A varint uses a variable number of bytes */\n    writeVarInt(value) {\n        // TODO - ensure size?\n        let length = 1;\n        while ((value & 0xffffff80) !== 0) {\n            this.writeUInt8((value & 0x7f) | 0x80);\n            value >>>= 7;\n            length++;\n        }\n        this.writeUInt8(value & 0x7f);\n        return length;\n    }\n    /** Append another ArrayBuffer to this ArrayBuffer */\n    writeBuffer(arrayBuffer) {\n        this._ensureSize(arrayBuffer.byteLength);\n        const tempArray = new Uint8Array(this.arrayBuffer);\n        tempArray.set(new Uint8Array(arrayBuffer), this.byteOffset);\n        this.byteOffset += arrayBuffer.byteLength;\n    }\n    /** Resizes this.arrayBuffer if not enough space */\n    _ensureSize(size) {\n        if (this.arrayBuffer.byteLength < this.byteOffset + size) {\n            if (this.allowResize) {\n                const newArrayBuffer = new ArrayBuffer(this.byteOffset + size);\n                const tempArray = new Uint8Array(newArrayBuffer);\n                tempArray.set(new Uint8Array(this.arrayBuffer));\n                this.arrayBuffer = newArrayBuffer;\n            }\n            else {\n                throw new Error('BinaryWriter overflow');\n            }\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/cschwarz/wkx under MIT license, Copyright (c) 2013 Christian Schwarz\n// Reference: https://www.ogc.org/standards/sfa\nimport { BinaryWriter } from \"./utils/binary-writer.js\";\n/**\n * Integer code for geometry type\n * Reference: https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary\n */\nexport var WKB;\n(function (WKB) {\n    WKB[WKB[\"Point\"] = 1] = \"Point\";\n    WKB[WKB[\"LineString\"] = 2] = \"LineString\";\n    WKB[WKB[\"Polygon\"] = 3] = \"Polygon\";\n    WKB[WKB[\"MultiPoint\"] = 4] = \"MultiPoint\";\n    WKB[WKB[\"MultiLineString\"] = 5] = \"MultiLineString\";\n    WKB[WKB[\"MultiPolygon\"] = 6] = \"MultiPolygon\";\n    WKB[WKB[\"GeometryCollection\"] = 7] = \"GeometryCollection\";\n})(WKB || (WKB = {}));\n/**\n * Encodes a GeoJSON object into WKB\n * @param geojson A GeoJSON Feature or Geometry\n * @returns string\n */\nexport function encodeWKB(geometry, options = {}) {\n    if (geometry.type === 'Feature') {\n        geometry = geometry.geometry;\n    }\n    switch (geometry.type) {\n        case 'Point':\n            return encodePoint(geometry.coordinates, options);\n        case 'LineString':\n            return encodeLineString(geometry.coordinates, options);\n        case 'Polygon':\n            return encodePolygon(geometry.coordinates, options);\n        case 'MultiPoint':\n            return encodeMultiPoint(geometry, options);\n        case 'MultiPolygon':\n            return encodeMultiPolygon(geometry, options);\n        case 'MultiLineString':\n            return encodeMultiLineString(geometry, options);\n        case 'GeometryCollection':\n            return encodeGeometryCollection(geometry, options);\n        default:\n            const exhaustiveCheck = geometry;\n            throw new Error(`Unhandled case: ${exhaustiveCheck}`);\n    }\n}\n/** Calculate the binary size (in the WKB encoding) of a specific GeoJSON geometry */\nfunction getGeometrySize(geometry, options) {\n    switch (geometry.type) {\n        case 'Point':\n            return getPointSize(options);\n        case 'LineString':\n            return getLineStringSize(geometry.coordinates, options);\n        case 'Polygon':\n            return getPolygonSize(geometry.coordinates, options);\n        case 'MultiPoint':\n            return getMultiPointSize(geometry, options);\n        case 'MultiPolygon':\n            return getMultiPolygonSize(geometry, options);\n        case 'MultiLineString':\n            return getMultiLineStringSize(geometry, options);\n        case 'GeometryCollection':\n            return getGeometryCollectionSize(geometry, options);\n        default:\n            const exhaustiveCheck = geometry;\n            throw new Error(`Unhandled case: ${exhaustiveCheck}`);\n    }\n}\n/** Encode Point geometry as WKB ArrayBuffer */\nfunction encodePoint(coordinates, options) {\n    const writer = new BinaryWriter(getPointSize(options));\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.Point, options);\n    // I believe this special case is to handle writing Point(NaN, NaN) correctly\n    if (typeof coordinates[0] === 'undefined' && typeof coordinates[1] === 'undefined') {\n        writer.writeDoubleLE(NaN);\n        writer.writeDoubleLE(NaN);\n        if (options.hasZ) {\n            writer.writeDoubleLE(NaN);\n        }\n        if (options.hasM) {\n            writer.writeDoubleLE(NaN);\n        }\n    }\n    else {\n        writeCoordinate(writer, coordinates, options);\n    }\n    return writer.arrayBuffer;\n}\n/** Write coordinate to buffer */\nfunction writeCoordinate(writer, coordinate, options) {\n    writer.writeDoubleLE(coordinate[0]);\n    writer.writeDoubleLE(coordinate[1]);\n    if (options.hasZ) {\n        writer.writeDoubleLE(coordinate[2]);\n    }\n    if (options.hasM) {\n        writer.writeDoubleLE(coordinate[3]);\n    }\n}\n/** Get encoded size of Point geometry */\nfunction getPointSize(options) {\n    const coordinateSize = getCoordinateSize(options);\n    return 1 + 4 + coordinateSize;\n}\n/** Encode LineString geometry as WKB ArrayBuffer */\nfunction encodeLineString(coordinates, options) {\n    const size = getLineStringSize(coordinates, options);\n    const writer = new BinaryWriter(size);\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.LineString, options);\n    writer.writeUInt32LE(coordinates.length);\n    for (const coordinate of coordinates) {\n        writeCoordinate(writer, coordinate, options);\n    }\n    return writer.arrayBuffer;\n}\n/** Get encoded size of LineString geometry */\nfunction getLineStringSize(coordinates, options) {\n    const coordinateSize = getCoordinateSize(options);\n    return 1 + 4 + 4 + coordinates.length * coordinateSize;\n}\n/** Encode Polygon geometry as WKB ArrayBuffer */\nfunction encodePolygon(coordinates, options) {\n    const writer = new BinaryWriter(getPolygonSize(coordinates, options));\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.Polygon, options);\n    const [exteriorRing, ...interiorRings] = coordinates;\n    if (exteriorRing.length > 0) {\n        writer.writeUInt32LE(1 + interiorRings.length);\n        writer.writeUInt32LE(exteriorRing.length);\n    }\n    else {\n        writer.writeUInt32LE(0);\n    }\n    for (const coordinate of exteriorRing) {\n        writeCoordinate(writer, coordinate, options);\n    }\n    for (const interiorRing of interiorRings) {\n        writer.writeUInt32LE(interiorRing.length);\n        for (const coordinate of interiorRing) {\n            writeCoordinate(writer, coordinate, options);\n        }\n    }\n    return writer.arrayBuffer;\n}\n/** Get encoded size of Polygon geometry */\nfunction getPolygonSize(coordinates, options) {\n    const coordinateSize = getCoordinateSize(options);\n    const [exteriorRing, ...interiorRings] = coordinates;\n    let size = 1 + 4 + 4;\n    if (exteriorRing.length > 0) {\n        size += 4 + exteriorRing.length * coordinateSize;\n    }\n    for (const interiorRing of interiorRings) {\n        size += 4 + interiorRing.length * coordinateSize;\n    }\n    return size;\n}\n/** Encode MultiPoint geometry as WKB ArrayBufer */\nfunction encodeMultiPoint(multiPoint, options) {\n    const writer = new BinaryWriter(getMultiPointSize(multiPoint, options));\n    const points = multiPoint.coordinates;\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.MultiPoint, options);\n    writer.writeUInt32LE(points.length);\n    for (const point of points) {\n        // TODO: add srid to this options object? {srid: multiPoint.srid}\n        const arrayBuffer = encodePoint(point, options);\n        writer.writeBuffer(arrayBuffer);\n    }\n    return writer.arrayBuffer;\n}\n/** Get encoded size of MultiPoint geometry */\nfunction getMultiPointSize(multiPoint, options) {\n    let coordinateSize = getCoordinateSize(options);\n    const points = multiPoint.coordinates;\n    // This is because each point has a 5-byte header?\n    coordinateSize += 5;\n    return 1 + 4 + 4 + points.length * coordinateSize;\n}\n/** Encode MultiLineString geometry as WKB ArrayBufer */\nfunction encodeMultiLineString(multiLineString, options) {\n    const writer = new BinaryWriter(getMultiLineStringSize(multiLineString, options));\n    const lineStrings = multiLineString.coordinates;\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.MultiLineString, options);\n    writer.writeUInt32LE(lineStrings.length);\n    for (const lineString of lineStrings) {\n        // TODO: Handle srid?\n        const encodedLineString = encodeLineString(lineString, options);\n        writer.writeBuffer(encodedLineString);\n    }\n    return writer.arrayBuffer;\n}\n/** Get encoded size of MultiLineString geometry */\nfunction getMultiLineStringSize(multiLineString, options) {\n    let size = 1 + 4 + 4;\n    const lineStrings = multiLineString.coordinates;\n    for (const lineString of lineStrings) {\n        size += getLineStringSize(lineString, options);\n    }\n    return size;\n}\nfunction encodeMultiPolygon(multiPolygon, options) {\n    const writer = new BinaryWriter(getMultiPolygonSize(multiPolygon, options));\n    const polygons = multiPolygon.coordinates;\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.MultiPolygon, options);\n    writer.writeUInt32LE(polygons.length);\n    for (const polygon of polygons) {\n        const encodedPolygon = encodePolygon(polygon, options);\n        writer.writeBuffer(encodedPolygon);\n    }\n    return writer.arrayBuffer;\n}\nfunction getMultiPolygonSize(multiPolygon, options) {\n    let size = 1 + 4 + 4;\n    const polygons = multiPolygon.coordinates;\n    for (const polygon of polygons) {\n        size += getPolygonSize(polygon, options);\n    }\n    return size;\n}\nfunction encodeGeometryCollection(collection, options) {\n    const writer = new BinaryWriter(getGeometryCollectionSize(collection, options));\n    writer.writeInt8(1);\n    writeWkbType(writer, WKB.GeometryCollection, options);\n    writer.writeUInt32LE(collection.geometries.length);\n    for (const geometry of collection.geometries) {\n        // TODO: handle srid? {srid: collection.srid}\n        const arrayBuffer = encodeWKB(geometry, options);\n        writer.writeBuffer(arrayBuffer);\n    }\n    return writer.arrayBuffer;\n}\nfunction getGeometryCollectionSize(collection, options) {\n    let size = 1 + 4 + 4;\n    for (const geometry of collection.geometries) {\n        size += getGeometrySize(geometry, options);\n    }\n    return size;\n}\n// HELPERS\n/**\n * Construct and write WKB integer code\n * Reference: https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary\n */\nfunction writeWkbType(writer, geometryType, options) {\n    const { hasZ, hasM, srid } = options;\n    let dimensionType = 0;\n    if (!srid) {\n        if (hasZ && hasM) {\n            dimensionType += 3000;\n        }\n        else if (hasZ) {\n            dimensionType += 1000;\n        }\n        else if (hasM) {\n            dimensionType += 2000;\n        }\n    }\n    else {\n        if (hasZ) {\n            dimensionType |= 0x80000000;\n        }\n        if (hasM) {\n            dimensionType |= 0x40000000;\n        }\n    }\n    writer.writeUInt32LE((dimensionType + geometryType) >>> 0);\n}\n/** Get coordinate size given Z/M dimensions */\nfunction getCoordinateSize(options) {\n    let coordinateSize = 16;\n    if (options.hasZ) {\n        coordinateSize += 8;\n    }\n    if (options.hasM) {\n        coordinateSize += 8;\n    }\n    return coordinateSize;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { encodeWKB } from \"./lib/encode-wkb.js\";\n/**\n * WKB exporter\n */\nexport const WKBWriter = {\n    name: 'WKB (Well Known Binary)',\n    id: 'wkb',\n    module: 'wkt',\n    version: VERSION,\n    extensions: ['wkb'],\n    options: {\n        wkb: {\n            hasZ: false,\n            hasM: false\n        }\n    },\n    async encode(data, options) {\n        return encodeWKB(data, options?.wkb);\n    },\n    encodeSync(data, options) {\n        return encodeWKB(data, options?.wkb);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/jessetane/hex-transcoder under MIT license\nconst alphabet = '0123456789abcdef';\nconst encodeLookup = [];\nconst decodeLookup = [];\nfor (let i = 0; i < 256; i++) {\n    encodeLookup[i] = alphabet[(i >> 4) & 0xf] + alphabet[i & 0xf];\n    if (i < 16) {\n        if (i < 10) {\n            decodeLookup[0x30 + i] = i;\n        }\n        else {\n            decodeLookup[0x61 - 10 + i] = i;\n        }\n    }\n}\n/**\n * Encode a Uint8Array to a hex string\n *\n * @param  array Bytes to encode to string\n * @return hex string\n */\nexport function encodeHex(array) {\n    const length = array.length;\n    let string = '';\n    let i = 0;\n    while (i < length) {\n        string += encodeLookup[array[i++]];\n    }\n    return string;\n}\n/**\n * Decodes a hex string to a Uint8Array\n *\n * @param string hex string to decode to Uint8Array\n * @return Uint8Array\n */\nexport function decodeHex(string) {\n    const sizeof = string.length >> 1;\n    const length = sizeof << 1;\n    const array = new Uint8Array(sizeof);\n    let n = 0;\n    let i = 0;\n    while (i < length) {\n        array[n++] = (decodeLookup[string.charCodeAt(i++)] << 4) | decodeLookup[string.charCodeAt(i++)];\n    }\n    return array;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WKBLoader } from \"./wkb-loader.js\";\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { decodeHex } from \"./lib/utils/hex-transcoder.js\";\n/**\n * Worker loader for Hex-encoded WKB (Well-Known Binary)\n */\nexport const HexWKBLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Hexadecimal WKB',\n    id: 'wkb',\n    module: 'wkt',\n    version: VERSION,\n    worker: true,\n    category: 'geometry',\n    extensions: ['wkb'],\n    mimeTypes: [],\n    options: WKBLoader.options,\n    text: true,\n    testText: isHexWKB,\n    // TODO - encoding here seems wasteful - extend hex transcoder?\n    parse: async (arrayBuffer) => parseHexWKB(new TextDecoder().decode(arrayBuffer)),\n    parseTextSync: parseHexWKB\n};\nfunction parseHexWKB(text, options) {\n    const uint8Array = decodeHex(text);\n    const binaryGeometry = WKBLoader.parseSync?.(uint8Array.buffer, options);\n    // @ts-expect-error\n    return binaryGeometry;\n}\n/**\n * Check if string is a valid Well-known binary (WKB) in HEX format\n * https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry\n *\n * @param str input string\n * @returns true if string is a valid WKB in HEX format\n */\nexport function isHexWKB(string) {\n    if (!string) {\n        return false;\n    }\n    // check if the length of the string is even and is at least 10 characters long\n    if (string.length < 10 || string.length % 2 !== 0) {\n        return false;\n    }\n    // check if first two characters are 00 or 01\n    if (!string.startsWith('00') && !string.startsWith('01')) {\n        return false;\n    }\n    // check if the rest of the string is a valid hex\n    return /^[0-9a-fA-F]+$/.test(string.slice(2));\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** A DataView that tracks byte offset when reading. */\nexport class BinaryReader {\n    arrayBuffer;\n    dataView;\n    byteOffset;\n    littleEndian;\n    constructor(arrayBuffer, isBigEndian = false) {\n        this.arrayBuffer = arrayBuffer;\n        this.dataView = new DataView(arrayBuffer);\n        this.byteOffset = 0;\n        this.littleEndian = !isBigEndian;\n    }\n    readUInt8() {\n        const value = this.dataView.getUint8(this.byteOffset);\n        this.byteOffset += 1;\n        return value;\n    }\n    readUInt16() {\n        const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);\n        this.byteOffset += 2;\n        return value;\n    }\n    readUInt32() {\n        const value = this.dataView.getUint32(this.byteOffset, this.littleEndian);\n        this.byteOffset += 4;\n        return value;\n    }\n    readInt8() {\n        const value = this.dataView.getInt8(this.byteOffset);\n        this.byteOffset += 1;\n        return value;\n    }\n    readInt16() {\n        const value = this.dataView.getInt16(this.byteOffset, this.littleEndian);\n        this.byteOffset += 2;\n        return value;\n    }\n    readInt32() {\n        const value = this.dataView.getInt32(this.byteOffset, this.littleEndian);\n        this.byteOffset += 4;\n        return value;\n    }\n    readFloat() {\n        const value = this.dataView.getFloat32(this.byteOffset, this.littleEndian);\n        this.byteOffset += 4;\n        return value;\n    }\n    readDouble() {\n        const value = this.dataView.getFloat64(this.byteOffset, this.littleEndian);\n        this.byteOffset += 8;\n        return value;\n    }\n    readVarInt() {\n        let result = 0;\n        let bytesRead = 0;\n        let nextByte;\n        do {\n            // TODO - this needs to be accessed via data view?\n            nextByte = this.dataView.getUint8(this.byteOffset + bytesRead);\n            result += (nextByte & 0x7f) << (7 * bytesRead);\n            bytesRead++;\n        } while (nextByte >= 0x80);\n        this.byteOffset += bytesRead;\n        return result;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/cschwarz/wkx under MIT license, Copyright (c) 2013 Christian Schwarz\nimport { BinaryReader } from \"./utils/binary-reader.js\";\nimport { WKBGeometryType } from \"./parse-wkb-header.js\";\n/**\n * Check if an array buffer might be a TWKB array buffer\n * @param arrayBuffer The array buffer to check\n * @returns false if this is definitely not a TWKB array buffer, true if it might be a TWKB array buffer\n */\nexport function isTWKB(arrayBuffer) {\n    const binaryReader = new BinaryReader(arrayBuffer);\n    const type = binaryReader.readUInt8();\n    const geometryType = type & 0x0f;\n    // Only geometry types 1 to 7 (point to geometry collection are currently defined)\n    if (geometryType < 1 || geometryType > 7) {\n        return false;\n    }\n    return true;\n}\nexport function parseTWKBGeometry(arrayBuffer) {\n    const binaryReader = new BinaryReader(arrayBuffer);\n    const context = parseTWKBHeader(binaryReader);\n    if (context.hasSizeAttribute) {\n        binaryReader.readVarInt();\n    }\n    if (context.hasBoundingBox) {\n        let dimensions = 2;\n        if (context.hasZ) {\n            dimensions++;\n        }\n        if (context.hasM) {\n            dimensions++;\n        }\n        // TODO why are we throwing away these datums?\n        for (let i = 0; i < dimensions; i++) {\n            binaryReader.readVarInt();\n            binaryReader.readVarInt();\n        }\n    }\n    return parseGeometry(binaryReader, context, context.geometryType);\n}\nfunction parseTWKBHeader(binaryReader) {\n    const type = binaryReader.readUInt8();\n    const metadataHeader = binaryReader.readUInt8();\n    const geometryType = type & 0x0f;\n    const precision = zigZagDecode(type >> 4);\n    const hasExtendedPrecision = Boolean((metadataHeader >> 3) & 1);\n    let hasZ = false;\n    let hasM = false;\n    let zPrecision = 0;\n    let zPrecisionFactor = 1;\n    let mPrecision = 0;\n    let mPrecisionFactor = 1;\n    if (hasExtendedPrecision) {\n        const extendedPrecision = binaryReader.readUInt8();\n        hasZ = (extendedPrecision & 0x01) === 0x01;\n        hasM = (extendedPrecision & 0x02) === 0x02;\n        zPrecision = zigZagDecode((extendedPrecision & 0x1c) >> 2);\n        zPrecisionFactor = Math.pow(10, zPrecision);\n        mPrecision = zigZagDecode((extendedPrecision & 0xe0) >> 5);\n        mPrecisionFactor = Math.pow(10, mPrecision);\n    }\n    return {\n        geometryType,\n        precision,\n        precisionFactor: Math.pow(10, precision),\n        hasBoundingBox: Boolean((metadataHeader >> 0) & 1),\n        hasSizeAttribute: Boolean((metadataHeader >> 1) & 1),\n        hasIdList: Boolean((metadataHeader >> 2) & 1),\n        hasExtendedPrecision,\n        isEmpty: Boolean((metadataHeader >> 4) & 1),\n        hasZ,\n        hasM,\n        zPrecision,\n        zPrecisionFactor,\n        mPrecision,\n        mPrecisionFactor\n    };\n}\nfunction parseGeometry(binaryReader, context, geometryType) {\n    switch (geometryType) {\n        case WKBGeometryType.Point:\n            return parsePoint(binaryReader, context);\n        case WKBGeometryType.LineString:\n            return parseLineString(binaryReader, context);\n        case WKBGeometryType.Polygon:\n            return parsePolygon(binaryReader, context);\n        case WKBGeometryType.MultiPoint:\n            return parseMultiPoint(binaryReader, context);\n        case WKBGeometryType.MultiLineString:\n            return parseMultiLineString(binaryReader, context);\n        case WKBGeometryType.MultiPolygon:\n            return parseMultiPolygon(binaryReader, context);\n        case WKBGeometryType.GeometryCollection:\n            return parseGeometryCollection(binaryReader, context);\n        default:\n            throw new Error(`GeometryType ${geometryType} not supported`);\n    }\n}\n// GEOMETRIES\nfunction parsePoint(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'Point', coordinates: [] };\n    }\n    return { type: 'Point', coordinates: readFirstPoint(reader, context) };\n}\nfunction parseLineString(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'LineString', coordinates: [] };\n    }\n    const pointCount = reader.readVarInt();\n    const previousPoint = makePreviousPoint(context);\n    const points = [];\n    for (let i = 0; i < pointCount; i++) {\n        points.push(parseNextPoint(reader, context, previousPoint));\n    }\n    return { type: 'LineString', coordinates: points };\n}\nfunction parsePolygon(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'Polygon', coordinates: [] };\n    }\n    const ringCount = reader.readVarInt();\n    const previousPoint = makePreviousPoint(context);\n    const exteriorRingLength = reader.readVarInt();\n    const exteriorRing = [];\n    for (let i = 0; i < exteriorRingLength; i++) {\n        exteriorRing.push(parseNextPoint(reader, context, previousPoint));\n    }\n    const polygon = [exteriorRing];\n    for (let i = 1; i < ringCount; i++) {\n        const interiorRingCount = reader.readVarInt();\n        const interiorRing = [];\n        for (let j = 0; j < interiorRingCount; j++) {\n            interiorRing.push(parseNextPoint(reader, context, previousPoint));\n        }\n        polygon.push(interiorRing);\n    }\n    return { type: 'Polygon', coordinates: polygon };\n}\nfunction parseMultiPoint(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'MultiPoint', coordinates: [] };\n    }\n    const previousPoint = makePreviousPoint(context);\n    const pointCount = reader.readVarInt();\n    const coordinates = [];\n    for (let i = 0; i < pointCount; i++) {\n        coordinates.push(parseNextPoint(reader, context, previousPoint));\n    }\n    return { type: 'MultiPoint', coordinates };\n}\nfunction parseMultiLineString(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'MultiLineString', coordinates: [] };\n    }\n    const previousPoint = makePreviousPoint(context);\n    const lineStringCount = reader.readVarInt();\n    const coordinates = [];\n    for (let i = 0; i < lineStringCount; i++) {\n        const pointCount = reader.readVarInt();\n        const lineString = [];\n        for (let j = 0; j < pointCount; j++) {\n            lineString.push(parseNextPoint(reader, context, previousPoint));\n        }\n        coordinates.push(lineString);\n    }\n    return { type: 'MultiLineString', coordinates };\n}\nfunction parseMultiPolygon(reader, context) {\n    if (context.isEmpty) {\n        return { type: 'MultiPolygon', coordinates: [] };\n    }\n    const previousPoint = makePreviousPoint(context);\n    const polygonCount = reader.readVarInt();\n    const polygons = [];\n    for (let i = 0; i < polygonCount; i++) {\n        const ringCount = reader.readVarInt();\n        const exteriorPointCount = reader.readVarInt();\n        const exteriorRing = [];\n        for (let j = 0; j < exteriorPointCount; j++) {\n            exteriorRing.push(parseNextPoint(reader, context, previousPoint));\n        }\n        const polygon = exteriorRing ? [exteriorRing] : [];\n        for (let j = 1; j < ringCount; j++) {\n            const interiorRing = [];\n            const interiorRingLength = reader.readVarInt();\n            for (let k = 0; k < interiorRingLength; k++) {\n                interiorRing.push(parseNextPoint(reader, context, previousPoint));\n            }\n            polygon.push(interiorRing);\n        }\n        polygons.push(polygon);\n    }\n    return { type: 'MultiPolygon', coordinates: polygons };\n}\n/** Geometry collection not yet supported */\nfunction parseGeometryCollection(reader, context) {\n    return { type: 'GeometryCollection', geometries: [] };\n    /**\n    if (context.isEmpty) {\n      return {type: 'GeometryCollection', geometries: []};\n    }\n  \n    const geometryCount = reader.readVarInt();\n  \n    const geometries: Geometry[] = new Array(geometryCount);\n    for (let i = 0; i < geometryCount; i++) {\n      const geometry = parseGeometry(reader, context, geometryType);\n      geometries.push(geometry);\n    }\n  \n    return {type: 'GeometryCollection', geometries: []};\n    */\n}\n// HELPERS\n/**\n * Maps negative values to positive values while going back and\n  forth (0 = 0, -1 = 1, 1 = 2, -2 = 3, 2 = 4, -3 = 5, 3 = 6 ...)\n */\nfunction zigZagDecode(value) {\n    return (value >> 1) ^ -(value & 1);\n}\nfunction makePointCoordinates(x, y, z, m) {\n    return (z !== undefined ? (m !== undefined ? [x, y, z, m] : [x, y, z]) : [x, y]);\n}\nfunction makePreviousPoint(context) {\n    return makePointCoordinates(0, 0, context.hasZ ? 0 : undefined, context.hasM ? 0 : undefined);\n}\nfunction readFirstPoint(reader, context) {\n    const x = zigZagDecode(reader.readVarInt()) / context.precisionFactor;\n    const y = zigZagDecode(reader.readVarInt()) / context.precisionFactor;\n    const z = context.hasZ ? zigZagDecode(reader.readVarInt()) / context.zPrecisionFactor : undefined;\n    const m = context.hasM ? zigZagDecode(reader.readVarInt()) / context.mPrecisionFactor : undefined;\n    return makePointCoordinates(x, y, z, m);\n}\n/**\n * Modifies previousPoint\n */\nfunction parseNextPoint(reader, context, previousPoint) {\n    previousPoint[0] += zigZagDecode(reader.readVarInt()) / context.precisionFactor;\n    previousPoint[1] += zigZagDecode(reader.readVarInt()) / context.precisionFactor;\n    if (context.hasZ) {\n        previousPoint[2] += zigZagDecode(reader.readVarInt()) / context.zPrecisionFactor;\n    }\n    if (context.hasM) {\n        previousPoint[3] += zigZagDecode(reader.readVarInt()) / context.mPrecisionFactor;\n    }\n    // Copy the point\n    return previousPoint.slice();\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseTWKBGeometry, isTWKB } from \"./lib/parse-twkb.js\";\n/**\n * Worker loader for WKB (Well-Known Binary)\n */\nexport const TWKBWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'TWKB (Tiny Well-Known Binary)',\n    id: 'twkb',\n    module: 'wkt',\n    version: VERSION,\n    worker: true,\n    category: 'geometry',\n    extensions: ['twkb'],\n    mimeTypes: [],\n    // TODO can we define static, serializable tests, eg. some binary strings?\n    tests: [isTWKB],\n    options: {\n        wkb: {\n            shape: 'binary-geometry' // 'geojson-geometry'\n        }\n    }\n};\n/**\n * Loader for WKB (Well-Known Binary)\n */\nexport const TWKBLoader = {\n    ...TWKBWorkerLoader,\n    parse: async (arrayBuffer) => parseTWKBGeometry(arrayBuffer),\n    parseSync: parseTWKBGeometry\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/cschwarz/wkx under MIT license, Copyright (c) 2013 Christian Schwarz\nimport { BinaryWriter } from \"./utils/binary-writer.js\";\nimport { WKBGeometryType } from \"./parse-wkb-header.js\";\nexport function encodeTWKB(geometry, options) {\n    const writer = new BinaryWriter(0, true);\n    const context = {\n        ...getTwkbPrecision(5, 0, 0),\n        hasZ: options?.hasZ,\n        hasM: options?.hasM\n    };\n    encodeGeometry(writer, geometry, context);\n    // TODO - we need to slice it?\n    return writer.arrayBuffer;\n}\nfunction encodeGeometry(writer, geometry, context) {\n    switch (geometry.type) {\n        case 'Point':\n            return encodePoint(writer, context, geometry);\n        case 'LineString':\n            return encodeLineString(writer, context, geometry);\n        case 'Polygon':\n            return encodePolygon(writer, context, geometry);\n        case 'MultiPoint':\n            return encodeMultiPoint(writer, context, geometry);\n        case 'MultiLineString':\n            return encodeMultiLineString(writer, context, geometry);\n        case 'MultiPolygon':\n            return encodeMultiPolygon(writer, context, geometry);\n        case 'GeometryCollection':\n            return encodeGeometryCollection(writer, context, geometry);\n        default:\n            throw new Error('unsupported geometry type');\n    }\n}\nfunction encodePoint(writer, context, point) {\n    const isEmpty = point.coordinates.length === 0 || point[0] === 'undefined' || point[1] === 'undefined';\n    writeTwkbHeader(writer, context, WKBGeometryType.Point, isEmpty);\n    if (!isEmpty) {\n        const previousPoint = [0, 0, 0, 0];\n        writeTwkbPoint(writer, context, point.coordinates, previousPoint);\n    }\n}\nfunction encodeLineString(writer, context, lineString) {\n    const points = lineString.coordinates;\n    const isEmpty = points.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.LineString, isEmpty);\n    if (!isEmpty) {\n        writer.writeVarInt(points.length);\n        const previousPoint = [0, 0, 0, 0];\n        for (const point of points) {\n            writeTwkbPoint(writer, context, point, previousPoint);\n        }\n    }\n    return writer.arrayBuffer;\n}\nfunction encodePolygon(writer, context, polygon) {\n    const polygonRings = polygon.coordinates;\n    const isEmpty = polygonRings.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.Polygon, isEmpty);\n    if (!isEmpty) {\n        writer.writeVarInt(polygonRings.length);\n        const previousPoint = [0, 0, 0, 0];\n        for (const ring of polygonRings) {\n            writer.writeVarInt(ring.length);\n            for (const point of ring) {\n                writeTwkbPoint(writer, context, previousPoint, point);\n            }\n        }\n    }\n    return writer.arrayBuffer;\n}\nfunction encodeMultiPoint(writer, context, multiPoint) {\n    const points = multiPoint.coordinates;\n    const isEmpty = points.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.MultiPoint, isEmpty);\n    if (!isEmpty) {\n        writer.writeVarInt(points.length);\n        const previousPoint = [0, 0, 0, 0];\n        for (let i = 0; i < points.length; i++) {\n            writeTwkbPoint(writer, context, previousPoint, points[i]);\n        }\n    }\n}\nfunction encodeMultiLineString(writer, context, multiLineStrings) {\n    const lineStrings = multiLineStrings.coordinates;\n    const isEmpty = lineStrings.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.MultiLineString, isEmpty);\n    if (!isEmpty) {\n        writer.writeVarInt(lineStrings.length);\n        const previousPoint = [0, 0, 0, 0];\n        for (const lineString of lineStrings) {\n            writer.writeVarInt(lineString.length);\n            for (const point of lineString) {\n                writeTwkbPoint(writer, context, previousPoint, point);\n            }\n        }\n    }\n    return writer.arrayBuffer;\n}\nfunction encodeMultiPolygon(writer, context, multiPolygon) {\n    const { coordinates } = multiPolygon;\n    const isEmpty = coordinates.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.MultiPolygon, isEmpty);\n    if (!isEmpty) {\n        const polygons = coordinates;\n        writer.writeVarInt(polygons.length);\n        const previousPoint = [0, 0, 0, 0];\n        for (const polygonRings of polygons) {\n            writer.writeVarInt(polygonRings.length);\n            for (const ring of polygonRings) {\n                writer.writeVarInt(ring.length);\n                for (const point of ring) {\n                    writeTwkbPoint(writer, context, previousPoint, point);\n                }\n            }\n        }\n    }\n}\nfunction encodeGeometryCollection(writer, context, geometryCollection) {\n    const { geometries } = geometryCollection;\n    const isEmpty = geometries.length === 0;\n    writeTwkbHeader(writer, context, WKBGeometryType.GeometryCollection, isEmpty);\n    if (geometries.length > 0) {\n        writer.writeVarInt(geometries.length);\n        for (const geometry of geometries) {\n            encodeGeometry(writer, geometry, context);\n        }\n    }\n}\n/**\n *\n * @param writer\n * @param context\n * @param geometryType\n * @param isEmpty\n */\nfunction writeTwkbHeader(writer, context, geometryType, isEmpty) {\n    const type = (zigZagEncode(context.xy) << 4) + geometryType;\n    let metadataHeader = context.hasZ || context.hasM ? 1 << 3 : 0;\n    metadataHeader += isEmpty ? 1 << 4 : 0;\n    writer.writeUInt8(type);\n    writer.writeUInt8(metadataHeader);\n    if (context.hasZ || context.hasM) {\n        let extendedPrecision = 0;\n        if (context.hasZ) {\n            extendedPrecision |= 0x1;\n        }\n        if (context.hasM) {\n            extendedPrecision |= 0x2;\n        }\n        writer.writeUInt8(extendedPrecision);\n    }\n}\n/**\n * Write one point to array buffer. ZigZagEncoding the delta fdrom the previous point. Mutates previousPoint.\n * @param writer\n * @param context\n * @param previousPoint - Mutated by this function\n * @param point\n */\nfunction writeTwkbPoint(writer, context, point, previousPoint) {\n    const x = point[0] * context.xyFactor;\n    const y = point[1] * context.xyFactor;\n    const z = point[2] * context.zFactor;\n    const m = point[3] * context.mFactor;\n    writer.writeVarInt(zigZagEncode(x - previousPoint[0]));\n    writer.writeVarInt(zigZagEncode(y - previousPoint[1]));\n    if (context.hasZ) {\n        writer.writeVarInt(zigZagEncode(z - previousPoint[2]));\n    }\n    if (context.hasM) {\n        writer.writeVarInt(zigZagEncode(m - previousPoint[3]));\n    }\n    previousPoint[0] = x;\n    previousPoint[1] = y;\n    previousPoint[2] = z;\n    previousPoint[3] = m;\n}\n// HELPERS\nfunction zigZagEncode(value) {\n    return (value << 1) ^ (value >> 31);\n}\nfunction getTwkbPrecision(xyPrecision, zPrecision, mPrecision) {\n    return {\n        xy: xyPrecision,\n        z: zPrecision,\n        m: mPrecision,\n        xyFactor: Math.pow(10, xyPrecision),\n        zFactor: Math.pow(10, zPrecision),\n        mFactor: Math.pow(10, mPrecision)\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { encodeTWKB } from \"./lib/encode-twkb.js\";\n/**\n * WKB exporter\n */\nexport const TWKBWriter = {\n    name: 'TWKB (Tiny Well Known Binary)',\n    id: 'twkb',\n    module: 'wkt',\n    version: VERSION,\n    extensions: ['twkb'],\n    encode: async (geometry, options) => encodeTWKB(geometry, options?.twkb),\n    encodeSync: (geometry, options) => encodeTWKB(geometry, options?.twkb),\n    options: {\n        twkb: {\n            hasZ: false,\n            hasM: false\n        }\n    }\n};\n"],
  "mappings": "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",
  "names": ["data", "WKBGeometryType", "parsePoint", "parseLineString", "parsePolygon", "parseMultiPoint", "parseMultiLineString", "parseMultiPolygon", "primitivePolygonIndices", "WKB", "parseGeometry", "parsePoint", "parseLineString", "parsePolygon", "parseMultiPoint", "parseMultiLineString", "parseMultiPolygon", "parseGeometryCollection", "encodePoint", "encodeLineString", "encodePolygon", "encodeMultiPoint", "encodeMultiLineString", "encodeMultiPolygon", "encodeGeometryCollection"]
}
