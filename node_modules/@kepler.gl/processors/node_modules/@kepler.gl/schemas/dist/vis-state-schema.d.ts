import Schema from './schema';
import { AddDataToMapOptions, AnimationConfig, Editor, FileLoading, FileLoadingProgress, Filter, InteractionConfig, MapInfo, ParsedFilter, ParsedLayer, ParsedVisState, SavedFilter, MinSavedFilter, SavedInteractionConfig, SavedLayer, MinSavedLayer, SavedVisState, SplitMap, ValueOf, Effect } from '@kepler.gl/types';
import { Datasets } from '@kepler.gl/table';
import { Layer, LayerClassesType } from '@kepler.gl/layers';
import { Loader } from '@loaders.gl/loader-utils';
import KeplerGLSchema from './schema-manager';
/**
 * V0 Schema
 */
export declare const dimensionPropsV0: string[];
export declare type modifiedType = {
    strokeColor?: any;
    strokeColorRange?: any;
    filled?: boolean;
    stroked?: boolean;
};
export interface VisState {
    mapInfo: MapInfo;
    layers: Layer[];
    layerData: any[];
    layerToBeMerged: any[];
    layerOrder: string[];
    effects: Effect[];
    effectOrder: string[];
    filters: Filter[];
    filterToBeMerged: any[];
    datasets: Datasets;
    editingDataset: string | undefined;
    interactionConfig: InteractionConfig;
    interactionToBeMerged: any;
    layerBlending: string;
    overlayBlending?: string;
    hoverInfo: any;
    clicked: any;
    mousePos: any;
    maxDefaultTooltips: number;
    layerClasses: LayerClassesType;
    animationConfig: AnimationConfig;
    editor: Editor;
    splitMaps: SplitMap[];
    splitMapsToBeMerged: SplitMap[];
    fileLoading: FileLoading | false;
    fileLoadingProgress: FileLoadingProgress;
    loadingIndicatorValue: number;
    loaders: Loader[];
    loadOptions: object;
    initialState?: Partial<VisState>;
    mergers: VisStateMergers<any>;
    schema: typeof KeplerGLSchema;
    preserveLayerOrder?: string[];
    preserveFilterOrder?: string[];
    preserveDatasetOrder?: string[];
    isMergingDatasets: {
        [datasetId: string]: boolean;
    };
}
export declare type PostMergerPayload = {
    newDataIds: string[];
    options?: AddDataToMapOptions;
    layerMergers?: Merger<any>[];
};
export declare type MergerActionPayload<S extends object> = {
    mergers: Merger<S>[];
    postMergerPayload: PostMergerPayload;
};
export declare type MergerMergeFunc<S extends object> = (state: S, config: any, fromConfig: boolean, mergerActionPayload?: MergerActionPayload<S>) => S;
export declare type ReplaceParentDatasetIdsFunc<T> = (item: T, dataId: string, dataIdToReplace: string) => T | null;
export declare type Merger<S extends object> = {
    merge: MergerMergeFunc<S>;
    prop: string | string[];
    toMergeProp?: string | string[];
    preserveOrder?: string;
    waitToFinish?: boolean;
    waitForLayerData?: boolean;
    replaceParentDatasetIds?: ReplaceParentDatasetIdsFunc<ValueOf<S>>;
    saveUnmerged?: (state: S, unmerged: any) => S;
    combineConfigs?: (configs: S[]) => S;
    getChildDatasetIds?: any;
};
export declare type VisStateMergers<S extends object> = Merger<S>[];
declare class DimensionFieldSchemaV0 extends Schema {
    version: "v0";
    save(field: any): {
        [x: string]: any;
    };
    load(field: any, parents: any, accumulated: any): {
        visualChannels: any;
    };
}
declare class DimensionScaleSchemaV0 extends Schema {
    version: "v0";
    save(scale: any): {
        [x: string]: any;
    };
    load(scale: any, parents: any, accumulated: any): {
        visualChannels?: undefined;
    } | {
        visualChannels: any;
    };
}
declare class LayerConfigSchemaV0 extends Schema {
    version: "v0";
    load(saved: any, parents: any, accumulated: any): {
        config: any;
    };
}
declare class LayerColumnsSchemaV0 extends Schema {
    version: "v0";
    load(saved: any, parents: any, accumulated: any): {
        config: any;
    };
}
declare class LayerConfigToVisConfigSchemaV0 extends Schema {
    version: "v0";
    load(saved: any, parents: any, accumulated: any): {
        config: any;
    };
}
declare class LayerVisConfigSchemaV0 extends Schema {
    version: "v0";
    key: string;
    load(visConfig: any, parents: any, accumulator: any): {
        config: any;
    };
}
declare class LayerConfigSchemaDeleteV0 extends Schema {
    version: "v0";
    load(): {};
}
/**
 * V0 -> V1 Changes
 * - layer is now a class
 * - config saved in a config object
 * - id, type, isAggregated is outside layer.config
 * - visualChannels is outside config, it defines available visual channel and
 *   property names for field, scale, domain and range of each visual chanel.
 * - enable3d, colorAggregation and sizeAggregation are moved into visConfig
 * - GeojsonLayer - added height, radius specific properties
 */
export declare const layerPropsV0: {
    id: null;
    type: null;
    dataId: LayerConfigSchemaV0;
    label: LayerConfigSchemaV0;
    color: LayerConfigSchemaV0;
    isVisible: LayerConfigSchemaV0;
    hidden: LayerConfigSchemaV0;
    visConfig: LayerVisConfigSchemaV0;
    columns: LayerColumnsSchemaV0;
    colorField: DimensionFieldSchemaV0;
    colorScale: DimensionScaleSchemaV0;
    sizeField: DimensionFieldSchemaV0;
    sizeScale: DimensionScaleSchemaV0;
    enable3d: LayerConfigToVisConfigSchemaV0;
    colorAggregation: LayerConfigToVisConfigSchemaV0;
    sizeAggregation: LayerConfigToVisConfigSchemaV0;
    isAggregated: LayerConfigSchemaDeleteV0;
};
/**
 * V1: save [field]: {name, type}, [scale]: '' for each channel
 */
declare class VisualChannelSchemaV1 extends Schema {
    save(visualChannels: any, parents: any): {
        [x: string]: {};
    };
    load(vc: any, parents: any, accumulator: any): any;
}
export declare const layerPropsV1: {
    id: null;
    type: null;
    config: Schema;
    visualChannels: VisualChannelSchemaV1;
};
export declare class LayerSchemaV0 extends Schema {
    key: string;
    save(layers: Layer[], parents: [VisState]): {
        layers: SavedLayer[];
    };
    load(layers: SavedLayer[] | MinSavedLayer[] | undefined): {
        layers: ParsedLayer[] | undefined;
    };
}
export declare class FilterSchemaV0 extends Schema {
    key: string;
    save(filters: Filter[]): {
        filters: SavedFilter[];
    };
    load(filters: SavedFilter[] | MinSavedFilter[] | undefined): {
        filters: ParsedFilter[] | undefined;
    };
}
declare class InteractionSchemaV0 extends Schema {
    key: string;
    save(interactionConfig: any): {
        [x: string]: {};
    };
    load(interactionConfig: any): {
        [x: string]: {};
    };
}
export declare class InteractionSchemaV1 extends Schema {
    key: string;
    save(interactionConfig: InteractionConfig): {
        interactionConfig: SavedInteractionConfig;
    } | Record<string, any>;
    load(interactionConfig: SavedInteractionConfig): {
        interactionConfig: Partial<SavedInteractionConfig>;
    };
}
export declare const filterPropsV0: {
    dataId: null;
    id: null;
    name: null;
    type: null;
    value: null;
    enlarged: null;
};
export declare class DimensionFieldSchema extends Schema {
    save(field: any): {
        [x: string]: any;
    };
    load(field: any): {
        [x: string]: any;
    };
}
export declare class SplitMapsSchema extends Schema {
    convertLayerSettings(accu: any, [key, value]: [any, any]): any;
    load(splitMaps: any): {
        splitMaps: any[];
    };
}
export declare class PlotTypeSchema extends Schema {
    key: string;
    load(plotType: any): {
        plotType: any;
    };
}
export declare const effectPropsV1: {
    id: null;
    type: null;
    isEnabled: null;
    parameters: null;
};
export declare class EffectsSchema extends Schema {
    key: string;
    save(effects: any, parents: any): {
        [x: string]: any;
    };
    load(effects: any): {
        [x: string]: any;
    };
}
export declare const filterPropsV1: {
    plotType: PlotTypeSchema;
    animationWindow: null;
    yAxis: DimensionFieldSchema;
    view: null;
    layerId: null;
    speed: null;
    syncedWithLayerTimeline: null;
    syncTimelineMode: null;
    enabled: null;
    invertTrendColor: null;
    timezone: null;
    dataId: null;
    id: null;
    name: null;
    type: null;
    value: null;
    enlarged: null;
};
export declare const propertiesV0: {
    filters: FilterSchemaV0;
    layers: LayerSchemaV0;
    interactionConfig: InteractionSchemaV0;
    layerBlending: null;
    overlayBlending: null;
};
export declare const propertiesV1: {
    filters: FilterSchemaV0;
    layers: LayerSchemaV0;
    effects: EffectsSchema;
    interactionConfig: InteractionSchemaV1;
    layerBlending: null;
    overlayBlending: null;
    splitMaps: SplitMapsSchema;
    animationConfig: Schema;
    editor: Schema;
};
export declare class VisStateSchemaV1 extends Schema {
    save(node: VisState, parents?: any[], accumulator?: any): {
        visState: SavedVisState;
    };
    load(node?: SavedVisState): {
        visState: ParsedVisState | undefined;
    };
}
export declare const visStateSchemaV0: Schema;
export declare const visStateSchemaV1: VisStateSchemaV1;
export declare const visStateSchema: {
    v0: typeof visStateSchemaV0;
    v1: typeof visStateSchemaV1;
};
export default visStateSchema;
