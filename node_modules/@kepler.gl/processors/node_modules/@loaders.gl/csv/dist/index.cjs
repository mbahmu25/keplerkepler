"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  CSVLoader: () => CSVLoader,
  CSVWriter: () => CSVWriter
});
module.exports = __toCommonJS(dist_exports);

// dist/csv-loader.js
var import_schema = require("@loaders.gl/schema");

// dist/papaparse/papaparse.js
var BYTE_ORDER_MARK = "\uFEFF";
function CsvToJson(_input, _config = {}, Streamer = StringStreamer) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;
  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    dynamicTyping = {};
  }
  _config.dynamicTyping = dynamicTyping;
  _config.transform = isFunction(_config.transform) ? _config.transform : false;
  var streamer = new Streamer(_config);
  return streamer.stream(_input);
}
function JsonToCsv(_input, _config) {
  var _quotes = false;
  var _writeHeader = true;
  var _delimiter = ",";
  var _newline = "\r\n";
  var _quoteChar = '"';
  var _escapedQuote = _quoteChar + _quoteChar;
  var _skipEmptyLines = false;
  var _columns = null;
  unpackConfig();
  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), "g");
  if (typeof _input === "string")
    _input = JSON.parse(_input);
  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0]))
      return serialize(null, _input, _skipEmptyLines);
    else if (typeof _input[0] === "object")
      return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);
  } else if (typeof _input === "object") {
    if (typeof _input.data === "string")
      _input.data = JSON.parse(_input.data);
    if (Array.isArray(_input.data)) {
      if (!_input.fields)
        _input.fields = _input.meta && _input.meta.fields;
      if (!_input.fields)
        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : Object.keys(_input.data[0]);
      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== "object")
        _input.data = [_input.data];
    }
    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }
  throw new Error("Unable to serialize unrecognized input");
  function unpackConfig() {
    if (typeof _config !== "object")
      return;
    if (typeof _config.delimiter === "string" && !Papa.BAD_DELIMITERS.filter(function(value) {
      return _config.delimiter.indexOf(value) !== -1;
    }).length) {
      _delimiter = _config.delimiter;
    }
    if (typeof _config.quotes === "boolean" || Array.isArray(_config.quotes))
      _quotes = _config.quotes;
    if (typeof _config.skipEmptyLines === "boolean" || typeof _config.skipEmptyLines === "string")
      _skipEmptyLines = _config.skipEmptyLines;
    if (typeof _config.newline === "string")
      _newline = _config.newline;
    if (typeof _config.quoteChar === "string")
      _quoteChar = _config.quoteChar;
    if (typeof _config.header === "boolean")
      _writeHeader = _config.header;
    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0)
        throw new Error("Option columns is empty");
      _columns = _config.columns;
    }
    if (_config.escapeChar !== void 0) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }
  function serialize(fields, data, skipEmptyLines) {
    var csv = "";
    if (typeof fields === "string")
      fields = JSON.parse(fields);
    if (typeof data === "string")
      data = JSON.parse(data);
    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);
    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0)
          csv += _delimiter;
        csv += safe(fields[i], i);
      }
      if (data.length > 0)
        csv += _newline;
    }
    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;
      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
      if (skipEmptyLines && !hasHeader) {
        emptyLine = skipEmptyLines === "greedy" ? data[row].join("").trim() === "" : data[row].length === 1 && data[row][0].length === 0;
      }
      if (skipEmptyLines === "greedy" && hasHeader) {
        var line = [];
        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }
        emptyLine = line.join("").trim() === "";
      }
      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine)
            csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }
        if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {
          csv += _newline;
        }
      }
    }
    return csv;
  }
  function safe(str, col) {
    if (typeof str === "undefined" || str === null)
      return "";
    if (str.constructor === Date)
      return JSON.stringify(str).slice(1, 25);
    str = str.toString().replace(quoteCharRegex, _escapedQuote);
    var needsQuotes = typeof _quotes === "boolean" && _quotes || Array.isArray(_quotes) && _quotes[col] || hasAny(str, Papa.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) === " " || str.charAt(str.length - 1) === " ";
    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }
  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++)
      if (str.indexOf(substrings[i]) > -1)
        return true;
    return false;
  }
}
var ChunkStreamer = class {
  _handle;
  _config;
  _finished = false;
  _completed = false;
  _input = null;
  _baseIndex = 0;
  _partialLine = "";
  _rowCount = 0;
  _start = 0;
  isFirstChunk = true;
  _completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  constructor(config) {
    var configCopy = { ...config };
    configCopy.chunkSize = parseInt(configCopy.chunkSize);
    if (!config.step && !config.chunk) {
      configCopy.chunkSize = null;
    }
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy;
  }
  parseChunk(chunk, isFakeChunk) {
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);
      if (modifiedChunk !== void 0)
        chunk = modifiedChunk;
    }
    this.isFirstChunk = false;
    var aggregate = this._partialLine + chunk;
    this._partialLine = "";
    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
    if (this._handle.paused() || this._handle.aborted())
      return;
    var lastIndex = results.meta.cursor;
    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }
    if (results && results.data)
      this._rowCount += results.data.length;
    var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;
    if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);
      if (this._handle.paused() || this._handle.aborted())
        return;
      results = void 0;
      this._completeResults = void 0;
    }
    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }
    if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
      this._config.complete(this._completeResults, this._input);
      this._completed = true;
    }
    return results;
  }
  _sendError(error) {
    if (isFunction(this._config.error))
      this._config.error(error);
  }
};
var StringStreamer = class extends ChunkStreamer {
  remaining;
  constructor(config = {}) {
    super(config);
  }
  stream(s) {
    this.remaining = s;
    return this._nextChunk();
  }
  _nextChunk() {
    if (this._finished)
      return;
    var size = this._config.chunkSize;
    var chunk = size ? this.remaining.substr(0, size) : this.remaining;
    this.remaining = size ? this.remaining.substr(size) : "";
    this._finished = !this.remaining;
    return this.parseChunk(chunk);
  }
};
var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var ParserHandle = class {
  _config;
  /** Number of times step was called (number of rows parsed) */
  _stepCounter = 0;
  /** Number of rows that have been parsed so far */
  _rowCounter = 0;
  /** The input being parsed */
  _input;
  /** The core parser being used */
  _parser;
  /** Whether we are paused or not */
  _paused = false;
  /** Whether the parser has aborted or not */
  _aborted = false;
  /** Temporary state between delimiter detection and processing results */
  _delimiterError = false;
  /** Fields are from the header row of the input, if there is one */
  _fields = [];
  /** The last results returned from the parser */
  _results = {
    data: [],
    errors: [],
    meta: {}
  };
  constructor(_config) {
    if (isFunction(_config.step)) {
      var userStep = _config.step;
      _config.step = (results) => {
        this._results = results;
        if (this.needsHeaderRow()) {
          this.processResults();
        } else {
          this.processResults();
          if (!this._results.data || this._results.data.length === 0)
            return;
          this._stepCounter += results.data.length;
          if (_config.preview && this._stepCounter > _config.preview) {
            this._parser.abort();
          } else {
            userStep(this._results, this);
          }
        }
      };
    }
    this._config = _config;
  }
  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  parse(input, baseIndex, ignoreLastRow) {
    var quoteChar = this._config.quoteChar || '"';
    if (!this._config.newline)
      this._config.newline = guessLineEndings(input, quoteChar);
    this._delimiterError = false;
    if (!this._config.delimiter) {
      var delimGuess = this.guessDelimiter(input, this._config.newline, this._config.skipEmptyLines, this._config.comments, this._config.delimitersToGuess);
      if (delimGuess.successful) {
        this._config.delimiter = delimGuess.bestDelimiter;
      } else {
        this._delimiterError = true;
        this._config.delimiter = Papa.DefaultDelimiter;
      }
      this._results.meta.delimiter = this._config.delimiter;
    } else if (isFunction(this._config.delimiter)) {
      this._config.delimiter = this._config.delimiter(input);
      this._results.meta.delimiter = this._config.delimiter;
    }
    var parserConfig = copy(this._config);
    if (this._config.preview && this._config.header)
      parserConfig.preview++;
    this._input = input;
    this._parser = new Parser(parserConfig);
    this._results = this._parser.parse(this._input, baseIndex, ignoreLastRow);
    this.processResults();
    return this._paused ? { meta: { paused: true } } : this._results || { meta: { paused: false } };
  }
  paused() {
    return this._paused;
  }
  pause() {
    this._paused = true;
    this._parser.abort();
    this._input = this._input.substr(this._parser.getCharIndex());
  }
  resume() {
    this._paused = false;
    this.streamer.parseChunk(this._input, true);
  }
  aborted() {
    return this._aborted;
  }
  abort() {
    this._aborted = true;
    this._parser.abort();
    this._results.meta.aborted = true;
    if (isFunction(this._config.complete)) {
      this._config.complete(this._results);
    }
    this._input = "";
  }
  testEmptyLine(s) {
    return this._config.skipEmptyLines === "greedy" ? s.join("").trim() === "" : s.length === 1 && s[0].length === 0;
  }
  processResults() {
    if (this._results && this._delimiterError) {
      this.addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'");
      this._delimiterError = false;
    }
    if (this._config.skipEmptyLines) {
      for (var i = 0; i < this._results.data.length; i++)
        if (this.testEmptyLine(this._results.data[i]))
          this._results.data.splice(i--, 1);
    }
    if (this.needsHeaderRow()) {
      this.fillHeaderFields();
    }
    return this.applyHeaderAndDynamicTypingAndTransformation();
  }
  needsHeaderRow() {
    return this._config.header && this._fields.length === 0;
  }
  fillHeaderFields() {
    if (!this._results)
      return;
    const addHeder = (header) => {
      if (isFunction(this._config.transformHeader))
        header = this._config.transformHeader(header);
      this._fields.push(header);
    };
    if (Array.isArray(this._results.data[0])) {
      for (var i = 0; this.needsHeaderRow() && i < this._results.data.length; i++)
        this._results.data[i].forEach(addHeder);
      this._results.data.splice(0, 1);
    } else {
      this._results.data.forEach(addHeder);
    }
  }
  shouldApplyDynamicTyping(field) {
    if (this._config.dynamicTypingFunction && this._config.dynamicTyping[field] === void 0) {
      this._config.dynamicTyping[field] = this._config.dynamicTypingFunction(field);
    }
    return (this._config.dynamicTyping[field] || this._config.dynamicTyping) === true;
  }
  parseDynamic(field, value) {
    if (this.shouldApplyDynamicTyping(field)) {
      if (value === "true" || value === "TRUE")
        return true;
      else if (value === "false" || value === "FALSE")
        return false;
      else if (FLOAT.test(value))
        return parseFloat(value);
      else if (ISO_DATE.test(value))
        return new Date(value);
      else
        return value === "" ? null : value;
    }
    return value;
  }
  applyHeaderAndDynamicTypingAndTransformation() {
    if (!this._results || !this._results.data || !this._config.header && !this._config.dynamicTyping && !this._config.transform) {
      return this._results;
    }
    var incrementBy = 1;
    if (!this._results.data[0] || Array.isArray(this._results.data[0])) {
      this._results.data = this._results.data.map(this.processRow.bind(this));
      incrementBy = this._results.data.length;
    } else {
      this._results.data = this.processRow(this._results.data, 0);
    }
    if (this._config.header && this._results.meta)
      this._results.meta.fields = this._fields;
    this._rowCounter += incrementBy;
    return this._results;
  }
  processRow(rowSource, i) {
    var row = this._config.header ? {} : [];
    var j;
    for (j = 0; j < rowSource.length; j++) {
      var field = j;
      var value = rowSource[j];
      if (this._config.header)
        field = j >= this._fields.length ? "__parsed_extra" : this._fields[j];
      if (this._config.transform)
        value = this._config.transform(value, field);
      value = this.parseDynamic(field, value);
      if (field === "__parsed_extra") {
        row[field] = row[field] || [];
        row[field].push(value);
      } else
        row[field] = value;
    }
    if (this._config.header) {
      if (j > this._fields.length)
        this.addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + this._fields.length + " fields but parsed " + j, this._rowCounter + i);
      else if (j < this._fields.length)
        this.addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + this._fields.length + " fields but parsed " + j, this._rowCounter + i);
    }
    return row;
  }
  guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;
    delimitersToGuess = delimitersToGuess || [",", "	", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
      fieldCountPrevRow = void 0;
      var preview = new Parser({
        comments,
        delimiter: delim,
        newline,
        preview: 10
      }).parse(input);
      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && this.testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }
        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;
        if (typeof fieldCountPrevRow === "undefined") {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }
      if (preview.data.length > 0)
        avgFieldCount /= preview.data.length - emptyLinesCount;
      if ((typeof bestDelta === "undefined" || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }
    this._config.delimiter = bestDelim;
    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }
  addError(type, code, msg, row) {
    this._results.errors.push({
      type,
      code,
      message: msg,
      row
    });
  }
};
function guessLineEndings(input, quoteChar) {
  input = input.substr(0, 1024 * 1024);
  var re = new RegExp(escapeRegExp(quoteChar) + "([^]*?)" + escapeRegExp(quoteChar), "gm");
  input = input.replace(re, "");
  var r = input.split("\r");
  var n = input.split("\n");
  var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;
  if (r.length === 1 || nAppearsFirst)
    return "\n";
  var numWithN = 0;
  for (var i = 0; i < r.length; i++) {
    if (r[i][0] === "\n")
      numWithN++;
  }
  return numWithN >= r.length / 2 ? "\r\n" : "\r";
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Parser(config) {
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;
  if (config.quoteChar === void 0) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }
  var escapeChar = quoteChar;
  if (config.escapeChar !== void 0) {
    escapeChar = config.escapeChar;
  }
  if (typeof delim !== "string" || Papa.BAD_DELIMITERS.indexOf(delim) > -1)
    delim = ",";
  if (comments === delim)
    throw new Error("Comment character same as delimiter");
  else if (comments === true)
    comments = "#";
  else if (typeof comments !== "string" || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
    comments = false;
  if (newline !== "\n" && newline !== "\r" && newline !== "\r\n")
    newline = "\n";
  var cursor = 0;
  var aborted = false;
  this.parse = function(input, baseIndex, ignoreLastRow) {
    if (typeof input !== "string")
      throw new Error("Input must be a string");
    var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;
    var stepIsFunction = isFunction(step);
    cursor = 0;
    var data = [], errors = [], row = [], lastCursor = 0;
    if (!input)
      return returnable();
    if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {
      var rows = input.split(newline);
      for (var i = 0; i < rows.length; i++) {
        const row2 = rows[i];
        cursor += row2.length;
        if (i !== rows.length - 1)
          cursor += newline.length;
        else if (ignoreLastRow)
          return returnable();
        if (comments && row2.substr(0, commentsLen) === comments)
          continue;
        if (stepIsFunction) {
          data = [];
          pushRow(row2.split(delim));
          doStep();
          if (aborted)
            return returnable();
        } else
          pushRow(row2.split(delim));
        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }
      return returnable();
    }
    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), "g");
    var quoteSearch;
    for (; ; ) {
      if (input[cursor] === quoteChar) {
        quoteSearch = cursor;
        cursor++;
        for (; ; ) {
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);
          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              errors.push({
                type: "Quotes",
                code: "MissingQuotes",
                message: "Quoted field unterminated",
                row: data.length,
                // row has yet to be inserted
                index: cursor
              });
            }
            return finish();
          }
          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }
          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }
          if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {
            continue;
          }
          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);
          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);
            if (stepIsFunction) {
              doStep();
              if (aborted)
                return returnable();
            }
            if (preview && data.length >= preview)
              return returnable(true);
            break;
          }
          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);
          if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor);
            if (stepIsFunction) {
              doStep();
              if (aborted)
                return returnable();
            }
            if (preview && data.length >= preview)
              return returnable(true);
            break;
          }
          errors.push({
            type: "Quotes",
            code: "InvalidQuotes",
            message: "Trailing quote on quoted field is malformed",
            row: data.length,
            // row has yet to be inserted
            index: cursor
          });
          quoteSearch++;
          continue;
        }
        if (stepIsFunction) {
          doStep();
          if (aborted)
            return returnable();
        }
        if (preview && data.length >= preview)
          return returnable(true);
        continue;
      }
      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1)
          return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }
      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }
      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);
        if (stepIsFunction) {
          doStep();
          if (aborted)
            return returnable();
        }
        if (preview && data.length >= preview)
          return returnable(true);
        continue;
      }
      break;
    }
    return finish();
    function pushRow(row2) {
      data.push(row2);
      lastCursor = cursor;
    }
    function extraSpaces(index) {
      var spaceLength = 0;
      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === "") {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }
      return spaceLength;
    }
    function finish(value2) {
      if (ignoreLastRow)
        return returnable();
      if (typeof value2 === "undefined")
        value2 = input.substr(cursor);
      row.push(value2);
      cursor = inputLen;
      pushRow(row);
      if (stepIsFunction)
        doStep();
      return returnable();
    }
    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }
    function returnable(stopped, step2) {
      var isStep = step2 || false;
      return {
        data: isStep ? data[0] : data,
        errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }
    function doStep() {
      step(returnable(void 0, true));
      data = [];
      errors = [];
    }
  };
  this.abort = function() {
    aborted = true;
  };
  this.getCharIndex = function() {
    return cursor;
  };
}
function copy(obj) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  var cpy = Array.isArray(obj) ? [] : {};
  for (var key in obj)
    cpy[key] = copy(obj[key]);
  return cpy;
}
function isFunction(func) {
  return typeof func === "function";
}
var Papa = {
  parse: CsvToJson,
  unparse: JsonToCsv,
  RECORD_SEP: String.fromCharCode(30),
  UNIT_SEP: String.fromCharCode(31),
  BYTE_ORDER_MARK,
  BAD_DELIMITERS: ["\r", "\n", '"', BYTE_ORDER_MARK],
  WORKERS_SUPPORTED: false,
  // !IS_WORKER && !!globalThis.Worker
  NODE_STREAM_INPUT: 1,
  // Configurable chunk sizes for local and remote files, respectively
  LocalChunkSize: 1024 * 1024 * 10,
  // 10 M,
  RemoteChunkSize: 1024 * 1024 * 5,
  // 5 M,
  DefaultDelimiter: ",",
  // Used if not specified and detection fail,
  // Exposed for testing and development only
  Parser,
  ParserHandle,
  // BEGIN FORK
  ChunkStreamer
};
var papaparse_default = Papa;

// dist/papaparse/async-iterator-streamer.js
var { ChunkStreamer: ChunkStreamer2 } = papaparse_default;
var AsyncIteratorStreamer = class extends ChunkStreamer2 {
  textDecoder = new TextDecoder(this._config.encoding);
  constructor(config = {}) {
    super(config);
  }
  // Implement ChunkStreamer base class methods
  // this.pause = function() {
  //   ChunkStreamer.prototype.pause.apply(this, arguments);
  // };
  // this.resume = function() {
  //   ChunkStreamer.prototype.resume.apply(this, arguments);
  //   this._input.resume();
  // };
  async stream(asyncIterator) {
    this._input = asyncIterator;
    try {
      for await (const chunk of asyncIterator) {
        this.parseChunk(this.getStringChunk(chunk));
      }
      this._finished = true;
      this.parseChunk("");
    } catch (error) {
      this._sendError(error);
    }
  }
  _nextChunk() {
  }
  // HELPER METHODS
  getStringChunk(chunk) {
    return typeof chunk === "string" ? chunk : this.textDecoder.decode(chunk, { stream: true });
  }
};

// dist/csv-loader.js
var VERSION = true ? "4.3.3" : "latest";
var DEFAULT_CSV_SHAPE = "object-row-table";
var CSVLoader = {
  dataType: null,
  batchType: null,
  id: "csv",
  module: "csv",
  name: "CSV",
  version: VERSION,
  extensions: ["csv", "tsv", "dsv"],
  mimeTypes: ["text/csv", "text/tab-separated-values", "text/dsv"],
  category: "table",
  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),
  parseText: (text, options) => parseCSV(text, options),
  parseInBatches: parseCSVInBatches,
  // @ts-ignore
  // testText: null,
  options: {
    csv: {
      shape: DEFAULT_CSV_SHAPE,
      // 'object-row-table'
      optimizeMemoryUsage: false,
      // CSV options
      header: "auto",
      columnPrefix: "column",
      // delimiter: auto
      // newline: auto
      quoteChar: '"',
      escapeChar: '"',
      dynamicTyping: true,
      comments: false,
      skipEmptyLines: true,
      // transform: null?
      delimitersToGuess: [",", "	", "|", ";"]
      // fastMode: auto
    }
  }
};
async function parseCSV(csvText, options) {
  const csvOptions = { ...CSVLoader.options.csv, ...options == null ? void 0 : options.csv };
  const firstRow = readFirstRow(csvText);
  const header = csvOptions.header === "auto" ? isHeaderRow(firstRow) : Boolean(csvOptions.header);
  const parseWithHeader = header;
  const papaparseConfig = {
    // dynamicTyping: true,
    ...csvOptions,
    header: parseWithHeader,
    download: false,
    // We handle loading, no need for papaparse to do it for us
    transformHeader: parseWithHeader ? duplicateColumnTransformer() : void 0,
    error: (e) => {
      throw new Error(e);
    }
  };
  const result = papaparse_default.parse(csvText, papaparseConfig);
  const rows = result.data;
  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);
  const shape = csvOptions.shape || DEFAULT_CSV_SHAPE;
  switch (shape) {
    case "object-row-table":
      return {
        shape: "object-row-table",
        data: rows.map((row) => Array.isArray(row) ? (0, import_schema.convertToObjectRow)(row, headerRow) : row)
      };
    case "array-row-table":
      return {
        shape: "array-row-table",
        data: rows.map((row) => Array.isArray(row) ? row : (0, import_schema.convertToArrayRow)(row, headerRow))
      };
    default:
      throw new Error(shape);
  }
}
function parseCSVInBatches(asyncIterator, options) {
  options = { ...options };
  if (options.batchSize === "auto") {
    options.batchSize = 4e3;
  }
  const csvOptions = { ...CSVLoader.options.csv, ...options == null ? void 0 : options.csv };
  const asyncQueue = new import_schema.AsyncQueue();
  let isFirstRow = true;
  let headerRow = null;
  let tableBatchBuilder = null;
  let schema = null;
  const config = {
    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,
    ...csvOptions,
    header: false,
    // Unfortunately, header detection is not automatic and does not infer shapes
    download: false,
    // We handle loading, no need for papaparse to do it for us
    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the
    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.
    // See https://github.com/mholt/PapaParse/issues/465
    chunkSize: 1024 * 1024 * 5,
    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true
    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if
    // both of the skipEmptyLines and step callback options are provided:
    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465
    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825
    skipEmptyLines: false,
    // step is called on every row
    // eslint-disable-next-line complexity, max-statements
    step(results) {
      let row = results.data;
      if (csvOptions.skipEmptyLines) {
        const collapsedRow = row.flat().join("").trim();
        if (collapsedRow === "") {
          return;
        }
      }
      const bytesUsed = results.meta.cursor;
      if (isFirstRow && !headerRow) {
        const header = csvOptions.header === "auto" ? isHeaderRow(row) : Boolean(csvOptions.header);
        if (header) {
          headerRow = row.map(duplicateColumnTransformer());
          return;
        }
      }
      if (isFirstRow) {
        isFirstRow = false;
        if (!headerRow) {
          headerRow = generateHeader(csvOptions.columnPrefix, row.length);
        }
        schema = deduceSchema(row, headerRow);
      }
      if (csvOptions.optimizeMemoryUsage) {
        row = JSON.parse(JSON.stringify(row));
      }
      const shape = csvOptions.shape || DEFAULT_CSV_SHAPE;
      tableBatchBuilder = tableBatchBuilder || new import_schema.TableBatchBuilder(
        // @ts-expect-error TODO this is not a proper schema
        schema,
        {
          shape,
          ...options
        }
      );
      try {
        tableBatchBuilder.addRow(row);
        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({ bytesUsed });
        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
    },
    // complete is called when all rows have been read
    complete(results) {
      try {
        const bytesUsed = results.meta.cursor;
        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({ bytesUsed });
        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
      asyncQueue.close();
    }
  };
  papaparse_default.parse(asyncIterator, config, AsyncIteratorStreamer);
  return asyncQueue;
}
function isHeaderRow(row) {
  return row && row.every((value) => typeof value === "string");
}
function readFirstRow(csvText) {
  const result = papaparse_default.parse(csvText, {
    dynamicTyping: true,
    preview: 1
  });
  return result.data[0];
}
function duplicateColumnTransformer() {
  const observedColumns = /* @__PURE__ */ new Set();
  return (col) => {
    let colName = col;
    let counter = 1;
    while (observedColumns.has(colName)) {
      colName = `${col}.${counter}`;
      counter++;
    }
    observedColumns.add(colName);
    return colName;
  };
}
function generateHeader(columnPrefix, count = 0) {
  const headers = [];
  for (let i = 0; i < count; i++) {
    headers.push(`${columnPrefix}${i + 1}`);
  }
  return headers;
}
function deduceSchema(row, headerRow) {
  const schema = headerRow ? {} : [];
  for (let i = 0; i < row.length; i++) {
    const columnName = headerRow && headerRow[i] || i;
    const value = row[i];
    switch (typeof value) {
      case "number":
      case "boolean":
        schema[columnName] = { name: String(columnName), index: i, type: Float32Array };
        break;
      case "string":
      default:
        schema[columnName] = { name: String(columnName), index: i, type: Array };
    }
  }
  return schema;
}

// dist/lib/encoders/encode-csv.js
var import_schema2 = require("@loaders.gl/schema");
var import_d3_dsv = require("d3-dsv");
function encodeTableAsCSV(table, options = { csv: { useDisplayNames: true } }) {
  var _a, _b;
  const useDisplayNames = options.useDisplayNames || ((_a = options.csv) == null ? void 0 : _a.useDisplayNames);
  const fields = ((_b = table.schema) == null ? void 0 : _b.fields) || [];
  const columnNames = fields.map((f) => {
    var _a2;
    const displayName = (_a2 = f.metadata) == null ? void 0 : _a2.displayName;
    return useDisplayNames && typeof displayName === "string" ? displayName : f.name;
  });
  const formattedData = [columnNames];
  for (const row of (0, import_schema2.makeArrayRowIterator)(table)) {
    const formattedRow = [];
    for (let columnIndex = 0; columnIndex < (0, import_schema2.getTableNumCols)(table); ++columnIndex) {
      const value = row[columnIndex];
      formattedRow[columnIndex] = preformatFieldValue(value);
    }
    formattedData.push(formattedRow);
  }
  return (0, import_d3_dsv.csvFormatRows)(formattedData);
}
var preformatFieldValue = (value) => {
  if (value === null || value === void 0) {
    return null;
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (typeof value === "object") {
    return JSON.stringify(value);
  }
  return String(value);
};

// dist/csv-writer.js
var CSVWriter = {
  id: "csv",
  version: "latest",
  module: "csv",
  name: "CSV",
  extensions: ["csv"],
  mimeTypes: ["text/csv"],
  options: {
    csv: {
      useDisplayNames: false
    }
  },
  text: true,
  encode: async (table, options) => new TextEncoder().encode(encodeTableAsCSV(table, options)).buffer,
  encodeTextSync: (table, options) => encodeTableAsCSV(table, options)
};
/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
//# sourceMappingURL=index.cjs.map
