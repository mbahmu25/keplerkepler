{
  "version": 3,
  "sources": ["index.js", "lib/types.js", "schema/arrow-table-batch.js", "exports/arrow-loader.js", "lib/parsers/parse-arrow.js", "lib/tables/convert-arrow-to-table.js", "lib/tables/convert-arrow-schema.js", "lib/geoarrow/convert-geoarrow-to-geojson-geometry.js", "arrow-loader.js", "lib/encoders/encode-arrow.js", "arrow-writer.js", "exports/geoarrow-loader.js", "lib/parsers/parse-geoarrow.js", "geoarrow-loader.js", "lib/tables/convert-table-to-arrow.js", "lib/geoarrow/convert-geoarrow-to-binary-geometry.js", "lib/geoarrow/get-arrow-bounds.js", "workers/hard-clone.js", "triangulate-on-worker.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { VECTOR_TYPES } from \"./lib/types.js\";\nimport { ArrowTableBatchAggregator } from \"./schema/arrow-table-batch.js\";\n// Make the ArrowBatch type available\nimport { TableBatchBuilder } from '@loaders.gl/schema';\nTableBatchBuilder.ArrowBatch = ArrowTableBatchAggregator;\nexport { ArrowWorkerLoader } from \"./exports/arrow-loader.js\";\nexport { ArrowLoader } from \"./arrow-loader.js\";\nexport { ArrowWriter } from \"./arrow-writer.js\";\n// Geoarrow loader\nexport { GeoArrowWorkerLoader } from \"./exports/geoarrow-loader.js\";\nexport { GeoArrowLoader } from \"./geoarrow-loader.js\";\n// Schema utils\nexport { convertArrowToSchema, convertSchemaToArrow, \n// DETAILED FUNCTIONS\nserializeArrowSchema, deserializeArrowSchema, serializeArrowMetadata, deserializeArrowMetadata, serializeArrowField, deserializeArrowField, serializeArrowType, deserializeArrowType } from \"./lib//tables/convert-arrow-schema.js\";\n// Table utils\nexport { convertArrowToTable } from \"./lib/tables/convert-arrow-to-table.js\";\nexport { convertTableToArrow } from \"./lib/tables/convert-table-to-arrow.js\";\nexport { getBinaryGeometryTemplate, getBinaryGeometriesFromArrow, getTriangleIndices, getMeanCentersFromBinaryGeometries } from \"./lib/geoarrow/convert-geoarrow-to-binary-geometry.js\";\nexport { updateBoundsFromGeoArrowSamples } from \"./lib/geoarrow/get-arrow-bounds.js\";\nexport { parseGeometryFromArrow } from \"./lib/geoarrow/convert-geoarrow-to-geojson-geometry.js\";\n// EXPERIMENTAL WORKER\nexport { hardClone } from \"./workers/hard-clone.js\";\nexport { TriangulationWorker, triangulateOnWorker, parseGeoArrowOnWorker } from \"./triangulate-on-worker.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport var VECTOR_TYPES;\n(function (VECTOR_TYPES) {\n    VECTOR_TYPES[VECTOR_TYPES[\"FLOAT\"] = 0] = \"FLOAT\";\n    VECTOR_TYPES[VECTOR_TYPES[\"DATE\"] = 1] = \"DATE\";\n})(VECTOR_TYPES || (VECTOR_TYPES = {}));\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ColumnarTableBatchAggregator } from '@loaders.gl/schema';\nimport * as arrow from 'apache-arrow';\n/** @note Should be part of @loaders.gl/schema - kept separate to avoid hard arrow dependency */\nexport class ArrowTableBatchAggregator extends ColumnarTableBatchAggregator {\n    arrowSchema;\n    constructor(schema, options) {\n        super(schema, options);\n        this.arrowSchema = null;\n    }\n    getBatch() {\n        const batch = super.getBatch();\n        if (batch) {\n            // Get the arrow schema\n            this.arrowSchema = this.arrowSchema || getArrowSchema(batch.schema);\n            // Get arrow format vectors\n            const arrowVectors = getArrowVectors(this.arrowSchema, batch.data);\n            // Create the record batch\n            const recordBatch = new arrow.RecordBatch(this.arrowSchema, arrow.makeData({\n                type: new arrow.Struct(this.arrowSchema.fields),\n                children: arrowVectors.map(({ data }) => data[0])\n            }));\n            return {\n                shape: 'arrow-table',\n                batchType: 'data',\n                data: new arrow.Table([recordBatch]),\n                length: batch.length\n            };\n        }\n        return null;\n    }\n}\n// Convert from a simple loaders.gl schema to an Arrow schema\nfunction getArrowSchema(schema) {\n    const arrowFields = [];\n    for (const key in schema) {\n        const field = schema[key];\n        if (field.type === Float32Array) {\n            // TODO - just store the original field as metadata?\n            const metadata = new Map(); // field;\n            // arrow: new arrow.Field(name, nullable, metadata)\n            const arrowField = new arrow.Field(field.name, new arrow.Float32(), field.nullable, metadata);\n            arrowFields.push(arrowField);\n        }\n    }\n    if (arrowFields.length === 0) {\n        throw new Error('No arrow convertible fields');\n    }\n    return new arrow.Schema(arrowFields);\n}\n// Convert from simple loaders.gl arrays to arrow vectors\nfunction getArrowVectors(arrowSchema, data) {\n    const arrowVectors = [];\n    for (const field of arrowSchema.fields) {\n        const vector = data[field.name];\n        if (vector instanceof Float32Array) {\n            const arrowVector = arrow.makeVector(vector);\n            arrowVectors.push(arrowVector);\n        }\n    }\n    if (arrowSchema.fields.length !== arrowVectors.length) {\n        throw new Error('Some columns not arrow convertible');\n    }\n    return arrowVectors;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/** ArrowJS table loader */\nexport const ArrowWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Apache Arrow',\n    id: 'arrow',\n    module: 'arrow',\n    version: VERSION,\n    // worker: true,\n    category: 'table',\n    extensions: ['arrow', 'feather'],\n    mimeTypes: [\n        'application/vnd.apache.arrow.file',\n        'application/vnd.apache.arrow.stream',\n        'application/octet-stream'\n    ],\n    binary: true,\n    tests: ['ARROW'],\n    options: {\n        arrow: {\n            shape: 'columnar-table'\n        }\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as arrow from 'apache-arrow';\nimport { convertArrowToTable } from \"../tables/convert-arrow-to-table.js\";\n/** Parses arrow to a loaders.gl table. Defaults to `arrow-table` */\nexport function parseArrowSync(arrayBuffer, options) {\n    const shape = options?.shape || 'arrow-table';\n    const arrowTable = arrow.tableFromIPC([new Uint8Array(arrayBuffer)]);\n    return convertArrowToTable(arrowTable, shape);\n}\nexport function parseArrowInBatches(asyncIterator, options) {\n    // Creates the appropriate arrow.RecordBatchReader subclasses from the input\n    // This will also close the underlying source in case of early termination or errors\n    // As an optimization, return a non-async iterator\n    /*\n    if (isIterable(readers)) {\n      function* makeArrowIterator() {\n        for (const reader of readers) {\n          for (const batch of reader) {\n            yield processBatch(batch, reader);\n          }\n          break; // only processing one stream of batches\n        }\n      }\n      const arrowIterator = makeArrowIterator();\n    }\n    */\n    async function* makeArrowAsyncIterator() {\n        // @ts-ignore\n        const readers = arrow.RecordBatchReader.readAll(asyncIterator);\n        for await (const reader of readers) {\n            for await (const recordBatch of reader) {\n                // use options.batchDebounceMs to add a delay between batches if needed (use case: incremental loading)\n                if (options?.arrow?.batchDebounceMs !== undefined && options?.arrow?.batchDebounceMs > 0) {\n                    await new Promise((resolve) => setTimeout(resolve, options.arrow?.batchDebounceMs || 0));\n                }\n                const arrowTabledBatch = {\n                    shape: 'arrow-table',\n                    batchType: 'data',\n                    data: new arrow.Table([recordBatch]),\n                    length: recordBatch.data.length\n                };\n                // processBatch(recordBatch);\n                yield arrowTabledBatch;\n            }\n            break; // only processing one stream of batches\n        }\n    }\n    return makeArrowAsyncIterator(); // as AsyncIterator<ArrowTableBatch>;\n}\n// function processBatch(batch: RecordBatch): ArrowTableBatch {\n//   const values = {};\n//   batch.schema.fields.forEach(({name}, index) => {\n//     values[name] = batch.getChildAt(index)?.toArray();\n//   });\n//   return {\n//   };\n// }\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { convertTable } from '@loaders.gl/schema';\nimport { getGeometryColumnsFromSchema } from '@loaders.gl/gis';\nimport { convertArrowToSchema } from \"../tables/convert-arrow-schema.js\";\nimport { parseGeometryFromArrow } from \"../geoarrow/convert-geoarrow-to-geojson-geometry.js\";\n/**\n * Convert an Apache Arrow table to a loaders.gl Table\n * @note Currently does not convert schema\n */\nexport function convertArrowToTable(arrowTable, shape) {\n    switch (shape) {\n        case 'arrow-table':\n            return convertArrowToArrowTable(arrowTable);\n        case 'array-row-table':\n            return convertArrowToArrayRowTable(arrowTable);\n        case 'object-row-table':\n            return convertArrowToObjectRowTable(arrowTable);\n        case 'columnar-table':\n            return convertArrowToColumnarTable(arrowTable);\n        case 'geojson-table':\n            return convertArrowToGeoJSONTable(arrowTable);\n        default:\n            throw new Error(shape);\n    }\n}\n/**\n * Wrap an apache arrow table in a loaders.gl table wrapper.\n * From this additional conversions are available.\n * @param arrowTable\n * @returns\n */\nfunction convertArrowToArrowTable(arrowTable) {\n    return {\n        shape: 'arrow-table',\n        schema: convertArrowToSchema(arrowTable.schema),\n        data: arrowTable\n    };\n}\nfunction convertArrowToArrayRowTable(arrowTable) {\n    const columnarTable = convertArrowToColumnarTable(arrowTable);\n    return convertTable(columnarTable, 'array-row-table');\n}\nfunction convertArrowToObjectRowTable(arrowTable) {\n    const columnarTable = convertArrowToColumnarTable(arrowTable);\n    return convertTable(columnarTable, 'object-row-table');\n}\n/**\n * Convert an Apache Arrow table to a ColumnarTable\n * @note Currently does not convert schema\n */\nfunction convertArrowToColumnarTable(arrowTable) {\n    // TODO - avoid calling `getColumn` on columns we are not interested in?\n    // Add options object?\n    const columns = {};\n    for (const field of arrowTable.schema.fields) {\n        // This (is intended to) coalesce all record batches into a single typed array\n        const arrowColumn = arrowTable.getChild(field.name);\n        const values = arrowColumn?.toArray();\n        columns[field.name] = values;\n    }\n    const schema = convertArrowToSchema(arrowTable.schema);\n    return {\n        shape: 'columnar-table',\n        schema,\n        data: columns\n    };\n}\n/**\n * Convert an Apache Arrow table to a GeoJSONTable\n * @note Currently does not convert schema\n */\nfunction convertArrowToGeoJSONTable(arrowTable) {\n    const schema = convertArrowToSchema(arrowTable.schema);\n    const geometryColumns = getGeometryColumnsFromSchema(schema);\n    // get encoding from geometryColumns['geometry']\n    const encoding = geometryColumns.geometry.encoding;\n    const features = [];\n    // Remove geometry columns\n    const propertyColumnNames = arrowTable.schema.fields\n        .map((field) => field.name)\n        // TODO - this deletes all geometry columns\n        .filter((name) => !(name in geometryColumns));\n    const propertiesTable = arrowTable.select(propertyColumnNames);\n    const arrowGeometryColumn = arrowTable.getChild('geometry');\n    for (let row = 0; row < arrowTable.numRows; row++) {\n        // get the geometry value from arrow geometry column\n        // Note that type can vary\n        const arrowGeometry = arrowGeometryColumn?.get(row);\n        // parse arrow geometry to geojson feature\n        const feature = parseGeometryFromArrow(arrowGeometry, encoding);\n        if (feature) {\n            const properties = propertiesTable.get(row)?.toJSON() || {};\n            features.push({ type: 'Feature', geometry: feature, properties });\n        }\n    }\n    return {\n        shape: 'geojson-table',\n        type: 'FeatureCollection',\n        schema,\n        features\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as arrow from 'apache-arrow';\n/** Convert Apache Arrow Schema (class instance) to a serialized Schema (plain data) */\nexport function convertArrowToSchema(arrowSchema) {\n    return serializeArrowSchema(arrowSchema);\n}\n/** Convert Apache Arrow Schema (class instance) to a serialized Schema (plain data) */\nexport function convertSchemaToArrow(schema) {\n    return deserializeArrowSchema(schema);\n}\n/** Convert Apache Arrow Schema (class instance) to a serialized Schema (plain data) */\nexport function serializeArrowSchema(arrowSchema) {\n    return {\n        fields: arrowSchema.fields.map((arrowField) => serializeArrowField(arrowField)),\n        metadata: serializeArrowMetadata(arrowSchema.metadata)\n    };\n}\n/** Convert a serialized Schema (plain data) to an Apache Arrow Schema (class instance) */\nexport function deserializeArrowSchema(schema) {\n    return new arrow.Schema(schema.fields.map((field) => deserializeArrowField(field)), deserializeArrowMetadata(schema.metadata));\n}\n/** Convert Apache Arrow Schema metadata (Map<string, string>) to serialized metadata (Record<string, string> */\nexport function serializeArrowMetadata(arrowMetadata) {\n    return Object.fromEntries(arrowMetadata);\n}\n/** Convert serialized metadata (Record<string, string> to Apache Arrow Schema metadata (Map<string, string>) to */\nexport function deserializeArrowMetadata(metadata) {\n    return metadata ? new Map(Object.entries(metadata)) : new Map();\n}\n/** Convert Apache Arrow Field (class instance) to serialized Field (plain data) */\nexport function serializeArrowField(field) {\n    return {\n        name: field.name,\n        type: serializeArrowType(field.type),\n        nullable: field.nullable,\n        metadata: serializeArrowMetadata(field.metadata)\n    };\n}\n/** Convert a serialized Field (plain data) to an Apache Arrow Field (class instance)*/\nexport function deserializeArrowField(field) {\n    return new arrow.Field(field.name, deserializeArrowType(field.type), field.nullable, deserializeArrowMetadata(field.metadata));\n}\n/** Converts a serializable loaders.gl data type to hydrated arrow data type */\n// eslint-disable-next-line complexity\nexport function serializeArrowType(arrowType) {\n    switch (arrowType.constructor) {\n        case arrow.Null:\n            return 'null';\n        case arrow.Binary:\n            return 'binary';\n        case arrow.Bool:\n            return 'bool';\n        case arrow.Int:\n            const intType = arrowType;\n            return `${intType.isSigned ? 'u' : ''}int${intType.bitWidth}`;\n        case arrow.Int8:\n            return 'int8';\n        case arrow.Int16:\n            return 'int16';\n        case arrow.Int32:\n            return 'int32';\n        case arrow.Int64:\n            return 'int64';\n        case arrow.Uint8:\n            return 'uint8';\n        case arrow.Uint16:\n            return 'uint16';\n        case arrow.Uint32:\n            return 'uint32';\n        case arrow.Uint64:\n            return 'uint64';\n        case arrow.Float:\n            const precision = arrowType.precision;\n            // return `float(precision + 1) * 16`;\n            switch (precision) {\n                case arrow.Precision.HALF:\n                    return 'float16';\n                case arrow.Precision.SINGLE:\n                    return 'float32';\n                case arrow.Precision.DOUBLE:\n                    return 'float64';\n                default:\n                    return 'float16';\n            }\n        case arrow.Float16:\n            return 'float16';\n        case arrow.Float32:\n            return 'float32';\n        case arrow.Float64:\n            return 'float64';\n        case arrow.Utf8:\n            return 'utf8';\n        case arrow.Decimal:\n            const decimal = arrowType;\n            return {\n                type: 'decimal',\n                bitWidth: decimal.bitWidth,\n                precision: decimal.precision,\n                scale: decimal.scale\n            };\n        case arrow.Date_:\n            const dateUnit = arrowType.unit;\n            return dateUnit === arrow.DateUnit.DAY ? 'date-day' : 'date-millisecond';\n        case arrow.DateDay:\n            return 'date-day';\n        case arrow.DateMillisecond:\n            return 'date-millisecond';\n        case arrow.Time:\n            const timeUnit = arrowType.unit;\n            switch (timeUnit) {\n                case arrow.TimeUnit.SECOND:\n                    return 'time-second';\n                case arrow.TimeUnit.MILLISECOND:\n                    return 'time-millisecond';\n                case arrow.TimeUnit.MICROSECOND:\n                    return 'time-microsecond';\n                case arrow.TimeUnit.NANOSECOND:\n                    return 'time-nanosecond';\n                default:\n                    return 'time-second';\n            }\n        case arrow.TimeMillisecond:\n            return 'time-millisecond';\n        case arrow.TimeSecond:\n            return 'time-second';\n        case arrow.TimeMicrosecond:\n            return 'time-microsecond';\n        case arrow.TimeNanosecond:\n            return 'time-nanosecond';\n        case arrow.Timestamp:\n            const timeStampUnit = arrowType.unit;\n            switch (timeStampUnit) {\n                case arrow.TimeUnit.SECOND:\n                    return 'timestamp-second';\n                case arrow.TimeUnit.MILLISECOND:\n                    return 'timestamp-millisecond';\n                case arrow.TimeUnit.MICROSECOND:\n                    return 'timestamp-microsecond';\n                case arrow.TimeUnit.NANOSECOND:\n                    return 'timestamp-nanosecond';\n                default:\n                    return 'timestamp-second';\n            }\n        case arrow.TimestampSecond:\n            return 'timestamp-second';\n        case arrow.TimestampMillisecond:\n            return 'timestamp-millisecond';\n        case arrow.TimestampMicrosecond:\n            return 'timestamp-microsecond';\n        case arrow.TimestampNanosecond:\n            return 'timestamp-nanosecond';\n        case arrow.Interval:\n            const intervalUnit = arrowType.unit;\n            switch (intervalUnit) {\n                case arrow.IntervalUnit.DAY_TIME:\n                    return 'interval-daytime';\n                case arrow.IntervalUnit.YEAR_MONTH:\n                    return 'interval-yearmonth';\n                default:\n                    return 'interval-daytime';\n            }\n        case arrow.IntervalDayTime:\n            return 'interval-daytime';\n        case arrow.IntervalYearMonth:\n            return 'interval-yearmonth';\n        case arrow.Map_:\n            const mapType = arrowType;\n            return {\n                type: 'map',\n                keysSorted: mapType.keysSorted,\n                children: mapType.children.map((arrowField) => serializeArrowField(arrowField))\n            };\n        case arrow.List:\n            const listType = arrowType;\n            const listField = listType.valueField;\n            return {\n                type: 'list',\n                children: [serializeArrowField(listField)]\n            };\n        case arrow.FixedSizeList:\n            const fixedSizeList = arrowType;\n            return {\n                type: 'fixed-size-list',\n                listSize: fixedSizeList.listSize,\n                children: [serializeArrowField(fixedSizeList.children[0])]\n            };\n        case arrow.Struct:\n            const structType = arrowType;\n            return {\n                type: 'struct',\n                children: structType.children.map((arrowField) => serializeArrowField(arrowField))\n            };\n        default:\n            throw new Error(`arrow type not supported: ${arrowType.constructor.name}`);\n    }\n}\n/** Converts a serializable loaders.gl data type to hydrated arrow data type */\n// eslint-disable-next-line complexity\nexport function deserializeArrowType(dataType) {\n    if (typeof dataType === 'object') {\n        switch (dataType.type) {\n            case 'decimal':\n                return new arrow.Decimal(dataType.precision, dataType.scale, dataType.bitWidth);\n            case 'map':\n                let children = dataType.children.map((arrowField) => deserializeArrowField(arrowField));\n                return new arrow.Map_(children, dataType.keysSorted);\n            case 'list':\n                const field = deserializeArrowField(dataType.children[0]);\n                return new arrow.List(field);\n            case 'fixed-size-list':\n                const child = deserializeArrowField(dataType.children[0]);\n                return new arrow.FixedSizeList(dataType.listSize, child);\n            case 'struct':\n                children = dataType.children.map((arrowField) => deserializeArrowField(arrowField));\n                return new arrow.Struct(children);\n            default:\n                throw new Error('array type not supported');\n        }\n    }\n    switch (dataType) {\n        case 'null':\n            return new arrow.Null();\n        case 'binary':\n            return new arrow.Binary();\n        case 'bool':\n            return new arrow.Bool();\n        case 'int8':\n            return new arrow.Int8();\n        case 'int16':\n            return new arrow.Int16();\n        case 'int32':\n            return new arrow.Int32();\n        case 'int64':\n            return new arrow.Int64();\n        case 'uint8':\n            return new arrow.Uint8();\n        case 'uint16':\n            return new arrow.Uint16();\n        case 'uint32':\n            return new arrow.Uint32();\n        case 'uint64':\n            return new arrow.Uint64();\n        case 'float16':\n            return new arrow.Float16();\n        case 'float32':\n            return new arrow.Float32();\n        case 'float64':\n            return new arrow.Float64();\n        case 'utf8':\n            return new arrow.Utf8();\n        case 'date-day':\n            return new arrow.DateDay();\n        case 'date-millisecond':\n            return new arrow.DateMillisecond();\n        case 'time-second':\n            return new arrow.TimeSecond();\n        case 'time-millisecond':\n            return new arrow.TimeMillisecond();\n        case 'time-microsecond':\n            return new arrow.TimeMicrosecond();\n        case 'time-nanosecond':\n            return new arrow.TimeNanosecond();\n        case 'timestamp-second':\n            return new arrow.TimestampSecond();\n        case 'timestamp-millisecond':\n            return new arrow.TimestampMillisecond();\n        case 'timestamp-microsecond':\n            return new arrow.TimestampMicrosecond();\n        case 'timestamp-nanosecond':\n            return new arrow.TimestampNanosecond();\n        case 'interval-daytime':\n            return new arrow.IntervalDayTime();\n        case 'interval-yearmonth':\n            return new arrow.IntervalYearMonth();\n        default:\n            throw new Error('array type not supported');\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { binaryToGeometry } from '@loaders.gl/gis';\nimport { WKBLoader, WKTLoader } from '@loaders.gl/wkt';\n/**\n * parse geometry from arrow data that is returned from processArrowData()\n * NOTE: this function could be deduplicated with the binaryToFeature() in deck.gl,\n * it is currently used for deck.gl picking because currently deck.gl returns only the index of the feature\n *\n * @param data data extraced from arrow vector representing a geometry\n * @param encoding the geoarrow encoding of the geometry column\n * @returns Feature or null\n */\nexport function parseGeometryFromArrow(arrowCellValue, encoding) {\n    // sanity\n    encoding = encoding?.toLowerCase();\n    if (!encoding || !arrowCellValue) {\n        return null;\n    }\n    let geometry;\n    switch (encoding) {\n        case 'geoarrow.multipolygon':\n            geometry = arrowMultiPolygonToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.polygon':\n            geometry = arrowPolygonToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.multipoint':\n            geometry = arrowMultiPointToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.point':\n            geometry = arrowPointToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.multilinestring':\n            geometry = arrowMultiLineStringToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.linestring':\n            geometry = arrowLineStringToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.wkb':\n            geometry = arrowWKBToFeature(arrowCellValue);\n            break;\n        case 'geoarrow.wkt':\n            geometry = arrowWKTToFeature(arrowCellValue);\n            break;\n        default: {\n            throw Error(`GeoArrow encoding not supported ${encoding}`);\n        }\n    }\n    return geometry;\n}\nfunction arrowWKBToFeature(arrowCellValue) {\n    // The actual WKB array buffer starts from byteOffset and ends at byteOffset + byteLength\n    const arrayBuffer = arrowCellValue.buffer.slice(arrowCellValue.byteOffset, arrowCellValue.byteOffset + arrowCellValue.byteLength);\n    const binaryGeometry = WKBLoader.parseSync?.(arrayBuffer);\n    const geometry = binaryToGeometry(binaryGeometry);\n    return geometry;\n}\nfunction arrowWKTToFeature(arrowCellValue) {\n    const string = arrowCellValue;\n    return WKTLoader.parseTextSync?.(string);\n}\n/**\n * convert Arrow MultiPolygon to geojson Feature\n */\nfunction arrowMultiPolygonToFeature(arrowMultiPolygon) {\n    const multiPolygon = [];\n    for (let m = 0; m < arrowMultiPolygon.length; m++) {\n        const arrowPolygon = arrowMultiPolygon.get(m);\n        const polygon = [];\n        for (let i = 0; arrowPolygon && i < arrowPolygon?.length; i++) {\n            const arrowRing = arrowPolygon?.get(i);\n            const ring = [];\n            for (let j = 0; arrowRing && j < arrowRing.length; j++) {\n                const arrowCoord = arrowRing.get(j);\n                const coord = Array.from(arrowCoord);\n                ring.push(coord);\n            }\n            polygon.push(ring);\n        }\n        multiPolygon.push(polygon);\n    }\n    const geometry = {\n        type: 'MultiPolygon',\n        coordinates: multiPolygon\n    };\n    return geometry;\n}\n/**\n * convert Arrow Polygon to geojson Feature\n */\nfunction arrowPolygonToFeature(arrowPolygon) {\n    const polygon = [];\n    for (let i = 0; arrowPolygon && i < arrowPolygon.length; i++) {\n        const arrowRing = arrowPolygon.get(i);\n        const ring = [];\n        for (let j = 0; arrowRing && j < arrowRing.length; j++) {\n            const arrowCoord = arrowRing.get(j);\n            const coords = Array.from(arrowCoord);\n            ring.push(coords);\n        }\n        polygon.push(ring);\n    }\n    const geometry = {\n        type: 'Polygon',\n        coordinates: polygon\n    };\n    return geometry;\n}\n/**\n * convert Arrow MultiPoint to geojson MultiPoint\n */\nfunction arrowMultiPointToFeature(arrowMultiPoint) {\n    const multiPoint = [];\n    for (let i = 0; arrowMultiPoint && i < arrowMultiPoint.length; i++) {\n        const arrowPoint = arrowMultiPoint.get(i);\n        if (arrowPoint) {\n            const coord = Array.from(arrowPoint);\n            multiPoint.push(coord);\n        }\n    }\n    return {\n        type: 'MultiPoint',\n        coordinates: multiPoint\n    };\n}\n/**\n * convert Arrow Point to geojson Point\n */\nfunction arrowPointToFeature(arrowPoint) {\n    const point = Array.from(arrowPoint);\n    return {\n        type: 'Point',\n        coordinates: point\n    };\n}\n/**\n * convert Arrow MultiLineString to geojson MultiLineString\n */\nfunction arrowMultiLineStringToFeature(arrowMultiLineString) {\n    const multiLineString = [];\n    for (let i = 0; arrowMultiLineString && i < arrowMultiLineString.length; i++) {\n        const arrowLineString = arrowMultiLineString.get(i);\n        const lineString = [];\n        for (let j = 0; arrowLineString && j < arrowLineString.length; j++) {\n            const arrowCoord = arrowLineString.get(j);\n            if (arrowCoord) {\n                const coords = Array.from(arrowCoord);\n                lineString.push(coords);\n            }\n        }\n        multiLineString.push(lineString);\n    }\n    return {\n        type: 'MultiLineString',\n        coordinates: multiLineString\n    };\n}\n/**\n * convert Arrow LineString to geojson LineString\n */\nfunction arrowLineStringToFeature(arrowLineString) {\n    const lineString = [];\n    for (let i = 0; arrowLineString && i < arrowLineString.length; i++) {\n        const arrowCoord = arrowLineString.get(i);\n        if (arrowCoord) {\n            const coords = Array.from(arrowCoord);\n            lineString.push(coords);\n        }\n    }\n    return {\n        type: 'LineString',\n        coordinates: lineString\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseArrowSync, parseArrowInBatches } from \"./lib/parsers/parse-arrow.js\";\nimport { ArrowWorkerLoader } from \"./exports/arrow-loader.js\";\n/** ArrowJS table loader */\nexport const ArrowLoader = {\n    ...ArrowWorkerLoader,\n    parse: async (arraybuffer, options) => parseArrowSync(arraybuffer, options?.arrow),\n    parseSync: (arraybuffer, options) => parseArrowSync(arraybuffer, options?.arrow),\n    parseInBatches: parseArrowInBatches\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as arrow from 'apache-arrow';\nimport { VECTOR_TYPES } from \"../types.js\";\n/**\n * Encodes set of arrays into the Apache Arrow columnar format\n * https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format\n * @param data - columns data\n * @param options - the writer options\n * @returns - encoded ArrayBuffer\n */\nexport function encodeArrowSync(data) {\n    const vectors = {};\n    for (const arrayData of data) {\n        const arrayVector = createVector(arrayData.array, arrayData.type);\n        vectors[arrayData.name] = arrayVector;\n    }\n    const table = new arrow.Table(vectors);\n    const arrowBuffer = arrow.tableToIPC(table);\n    return arrowBuffer;\n}\n/**\n * Create Arrow arrow.Vector from given data and vector type\n * @param array {import('../types').AnyArrayType} - columns data\n * @param type {number} - the writer options\n * @return a vector of one of vector's types defined in the Apache Arrow library\n */\nfunction createVector(array, type) {\n    switch (type) {\n        case VECTOR_TYPES.DATE:\n            return arrow.vectorFromArray(array);\n        case VECTOR_TYPES.FLOAT:\n        default:\n            return arrow.vectorFromArray(array);\n    }\n}\n", "// import type {} from '@loaders.gl/loader-utils';\nimport { encodeArrowSync } from \"./lib/encoders/encode-arrow.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/** Apache Arrow writer */\nexport const ArrowWriter = {\n    name: 'Apache Arrow',\n    id: 'arrow',\n    module: 'arrow',\n    version: VERSION,\n    extensions: ['arrow', 'feather'],\n    mimeTypes: [\n        'application/vnd.apache.arrow.file',\n        'application/vnd.apache.arrow.stream',\n        'application/octet-stream'\n    ],\n    binary: true,\n    options: {},\n    encode: async function encodeArrow(data, options) {\n        return encodeArrowSync(data);\n    },\n    encodeSync(data, options) {\n        return encodeArrowSync(data);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ArrowWorkerLoader } from \"./arrow-loader.js\";\n/** ArrowJS table loader */\nexport const GeoArrowWorkerLoader = {\n    ...ArrowWorkerLoader,\n    options: {\n        arrow: {\n            shape: 'arrow-table'\n        }\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseArrowSync, parseArrowInBatches } from \"./parse-arrow.js\";\nimport { convertArrowToTable } from \"../tables/convert-arrow-to-table.js\";\n// Parses arrow to a columnar table\nexport function parseGeoArrowSync(arrayBuffer, options) {\n    // | BinaryGeometry\n    const table = parseArrowSync(arrayBuffer, { shape: 'arrow-table' });\n    switch (options?.shape) {\n        case 'geojson-table':\n            return convertArrowToTable(table.data, 'geojson-table');\n        default:\n            return table;\n    }\n}\n/**\n */\nexport function parseGeoArrowInBatches(asyncIterator) {\n    // | BinaryGeometry\n    return parseArrowInBatches(asyncIterator);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseGeoArrowSync, parseGeoArrowInBatches } from \"./lib/parsers/parse-geoarrow.js\";\nimport { GeoArrowWorkerLoader } from \"./exports/geoarrow-loader.js\";\n/**\n * GeoArrowLoader loads an Apache Arrow table, parses GeoArrow type extension data\n * to convert it to a GeoJSON table or a BinaryGeometry\n */\nexport const GeoArrowLoader = {\n    ...GeoArrowWorkerLoader,\n    parse: async (arraybuffer, options) => parseGeoArrowSync(arraybuffer, options?.arrow),\n    parseSync: (arraybuffer, options) => parseGeoArrowSync(arraybuffer, options?.arrow),\n    parseInBatches: parseGeoArrowInBatches\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as arrow from 'apache-arrow';\nimport { getTableLength, getTableNumCols, getTableCellAt } from '@loaders.gl/schema';\nimport { deserializeArrowSchema } from \"../tables/convert-arrow-schema.js\";\n/**\n * * Convert a loaders.gl Table to an Apache Arrow Table\n * @param mesh\n * @param metadata\n * @param batchSize\n * @returns\n */\nexport function convertTableToArrow(table, options) {\n    switch (table.shape) {\n        case 'arrow-table':\n            return table.data;\n        case 'columnar-table':\n        // TODO - optimized implementation is possible\n        // return convertColumnarTableToArrow(table, options);\n        // fall through\n        default:\n            const arrowBatchIterator = makeTableToArrowBatchesIterator(table, options);\n            return new arrow.Table(arrowBatchIterator);\n    }\n}\nexport function* makeTableToArrowBatchesIterator(table, options) {\n    const arrowSchema = deserializeArrowSchema(table.schema);\n    const length = getTableLength(table);\n    const numColumns = getTableNumCols(table);\n    const batchSize = options?.batchSize || length;\n    const builders = arrowSchema?.fields.map((arrowField) => arrow.makeBuilder(arrowField));\n    const structField = new arrow.Struct(arrowSchema.fields);\n    let batchLength = 0;\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        for (let columnIndex = 0; columnIndex < numColumns; ++columnIndex) {\n            const value = getTableCellAt(table, rowIndex, columnIndex);\n            const builder = builders[columnIndex];\n            builder.append(value);\n            batchLength++;\n            if (batchLength >= batchSize) {\n                const datas = builders.map((builder) => builder.flush());\n                const structData = new arrow.Data(structField, 0, batchLength, 0, undefined, datas);\n                yield new arrow.RecordBatch(arrowSchema, structData);\n                batchLength = 0;\n            }\n        }\n    }\n    if (batchLength > 0) {\n        const datas = builders.map((builder) => builder.flush());\n        const structData = new arrow.Data(structField, 0, batchLength, 0, undefined, datas);\n        yield new arrow.RecordBatch(arrowSchema, structData);\n        batchLength = 0;\n    }\n    builders.map((builder) => builder.finish());\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { earcut } from '@math.gl/polygon';\nimport { updateBoundsFromGeoArrowSamples } from \"./get-arrow-bounds.js\";\n/**\n * Binary geometry type\n */\nvar BinaryGeometryType;\n(function (BinaryGeometryType) {\n    BinaryGeometryType[\"points\"] = \"points\";\n    BinaryGeometryType[\"lines\"] = \"lines\";\n    BinaryGeometryType[\"polygons\"] = \"polygons\";\n})(BinaryGeometryType || (BinaryGeometryType = {}));\n/**\n * binary geometry template, see deck.gl BinaryGeometry\n */\nexport function getBinaryGeometryTemplate() {\n    return {\n        globalFeatureIds: { value: new Uint32Array(0), size: 1 },\n        positions: { value: new Float32Array(0), size: 2 },\n        properties: [],\n        numericProps: {},\n        featureIds: { value: new Uint32Array(0), size: 1 }\n    };\n}\n/**\n * get binary geometries from geoarrow column\n *\n * @param geoColumn the geoarrow column, e.g. arrowTable.getChildAt(geoColumnIndex)\n * @param geoEncoding the geo encoding of the geoarrow column, e.g. getGeoArrowEncoding(arrowTable.schema, geoColumnName)\n * @param options options for getting binary geometries {meanCenter: boolean}\n * @returns BinaryDataFromGeoArrow\n */\nexport function getBinaryGeometriesFromArrow(geoColumn, geoEncoding, options) {\n    const featureTypes = {\n        polygon: geoEncoding === 'geoarrow.multipolygon' || geoEncoding === 'geoarrow.polygon',\n        point: geoEncoding === 'geoarrow.multipoint' || geoEncoding === 'geoarrow.point',\n        line: geoEncoding === 'geoarrow.multilinestring' || geoEncoding === 'geoarrow.linestring'\n    };\n    const chunks = options?.chunkIndex !== undefined && options?.chunkIndex >= 0\n        ? [geoColumn.data[options?.chunkIndex]]\n        : geoColumn.data;\n    let bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    let globalFeatureIdOffset = options?.chunkOffset || 0;\n    const binaryGeometries = [];\n    chunks.forEach((chunk) => {\n        const { featureIds, flatCoordinateArray, nDim, geomOffset, triangles } = getBinaryGeometriesFromChunk(chunk, geoEncoding, options);\n        const globalFeatureIds = new Uint32Array(featureIds.length);\n        for (let i = 0; i < featureIds.length; i++) {\n            globalFeatureIds[i] = featureIds[i] + globalFeatureIdOffset;\n        }\n        const binaryContent = {\n            globalFeatureIds: { value: globalFeatureIds, size: 1 },\n            positions: {\n                value: flatCoordinateArray,\n                size: nDim\n            },\n            featureIds: { value: featureIds, size: 1 },\n            // eslint-disable-next-line no-loop-func\n            properties: [...Array(chunk.length).keys()].map((i) => ({\n                index: i + globalFeatureIdOffset\n            }))\n        };\n        // TODO: check if chunks are sequentially accessed\n        globalFeatureIdOffset += chunk.length;\n        // NOTE: deck.gl defines the BinaryFeatures structure must have points, lines, polygons even if they are empty\n        binaryGeometries.push({\n            shape: 'binary-feature-collection',\n            points: {\n                type: 'Point',\n                ...getBinaryGeometryTemplate(),\n                ...(featureTypes.point ? binaryContent : {})\n            },\n            lines: {\n                type: 'LineString',\n                ...getBinaryGeometryTemplate(),\n                ...(featureTypes.line ? binaryContent : {}),\n                pathIndices: { value: featureTypes.line ? geomOffset : new Uint16Array(0), size: 1 }\n            },\n            polygons: {\n                type: 'Polygon',\n                ...getBinaryGeometryTemplate(),\n                ...(featureTypes.polygon ? binaryContent : {}),\n                polygonIndices: {\n                    // use geomOffset as polygonIndices same as primitivePolygonIndices since we are using earcut to get triangule indices\n                    value: featureTypes.polygon ? geomOffset : new Uint16Array(0),\n                    size: 1\n                },\n                primitivePolygonIndices: {\n                    value: featureTypes.polygon ? geomOffset : new Uint16Array(0),\n                    size: 1\n                },\n                ...(triangles ? { triangles: { value: triangles, size: 1 } } : {})\n            }\n        });\n        bounds = updateBoundsFromGeoArrowSamples(flatCoordinateArray, nDim, bounds);\n    });\n    return {\n        binaryGeometries,\n        bounds,\n        featureTypes,\n        ...(options?.calculateMeanCenters\n            ? { meanCenters: getMeanCentersFromBinaryGeometries(binaryGeometries) }\n            : {})\n    };\n}\n/**\n * Get mean centers from binary geometries\n * @param binaryGeometries binary geometries from geoarrow column, an array of BinaryFeatureCollection\n * @returns mean centers of the binary geometries\n */\nexport function getMeanCentersFromBinaryGeometries(binaryGeometries) {\n    const globalMeanCenters = [];\n    binaryGeometries.forEach((binaryGeometry) => {\n        let binaryGeometryType = null;\n        if (binaryGeometry.points && binaryGeometry.points.positions.value.length > 0) {\n            binaryGeometryType = BinaryGeometryType.points;\n        }\n        else if (binaryGeometry.lines && binaryGeometry.lines.positions.value.length > 0) {\n            binaryGeometryType = BinaryGeometryType.lines;\n        }\n        else if (binaryGeometry.polygons && binaryGeometry.polygons.positions.value.length > 0) {\n            binaryGeometryType = BinaryGeometryType.polygons;\n        }\n        const binaryContent = binaryGeometryType ? binaryGeometry[binaryGeometryType] : null;\n        if (binaryContent && binaryGeometryType !== null) {\n            const featureIds = binaryContent.featureIds.value;\n            const flatCoordinateArray = binaryContent.positions.value;\n            const nDim = binaryContent.positions.size;\n            const primitivePolygonIndices = binaryContent.type === 'Polygon' ? binaryContent.primitivePolygonIndices?.value : undefined;\n            const meanCenters = getMeanCentersFromGeometry(featureIds, flatCoordinateArray, nDim, binaryGeometryType, primitivePolygonIndices);\n            meanCenters.forEach((center) => {\n                globalMeanCenters.push(center);\n            });\n        }\n    });\n    return globalMeanCenters;\n}\n/**\n * Get mean centers from raw coordinates and feature ids\n * @param featureIds Array of feature ids indexes by vertex\n * @param flatCoordinateArray  Array of vertex, e.g. x, y or x, y, z, positions\n * @param nDim number of dimensions per position\n * @returns - mean centers of each polygon\n */\nfunction getMeanCentersFromGeometry(featureIds, flatCoordinateArray, nDim, geometryType, primitivePolygonIndices) {\n    const meanCenters = [];\n    const vertexCount = flatCoordinateArray.length;\n    let vertexIndex = 0;\n    let coordIdx = 0;\n    let primitiveIdx = 0;\n    while (vertexIndex < vertexCount) {\n        const featureId = featureIds[vertexIndex / nDim];\n        const center = [0, 0];\n        let vertexCountInFeature = 0;\n        while (vertexIndex < vertexCount && featureIds[coordIdx] === featureId) {\n            if (geometryType === BinaryGeometryType.polygons &&\n                primitivePolygonIndices?.[primitiveIdx] === coordIdx) {\n                // skip the first point since it is the same as the last point in each ring for polygons\n                vertexIndex += nDim;\n                primitiveIdx++;\n            }\n            else {\n                center[0] += flatCoordinateArray[vertexIndex];\n                center[1] += flatCoordinateArray[vertexIndex + 1];\n                vertexIndex += nDim;\n                vertexCountInFeature++;\n            }\n            coordIdx += 1;\n        }\n        center[0] /= vertexCountInFeature;\n        center[1] /= vertexCountInFeature;\n        meanCenters.push(center);\n    }\n    return meanCenters;\n}\n/**\n * get binary geometries from geoarrow column\n * @param chunk one chunk/batch of geoarrow column\n * @param geoEncoding geo encoding of the geoarrow column\n * @param options options for getting binary geometries\n * @returns BinaryGeometryContent\n */\nfunction getBinaryGeometriesFromChunk(chunk, geoEncoding, options) {\n    switch (geoEncoding) {\n        case 'geoarrow.point':\n        case 'geoarrow.multipoint':\n            return getBinaryPointsFromChunk(chunk, geoEncoding);\n        case 'geoarrow.linestring':\n        case 'geoarrow.multilinestring':\n            return getBinaryLinesFromChunk(chunk, geoEncoding);\n        case 'geoarrow.polygon':\n        case 'geoarrow.multipolygon':\n            return getBinaryPolygonsFromChunk(chunk, geoEncoding, options);\n        default:\n            throw Error('invalid geoarrow encoding');\n    }\n}\n/**\n * get triangle indices. Allows deck.gl to skip performing costly triangulation on main thread.\n * @param polygonIndices Indices within positions of the start of each simple Polygon\n * @param primitivePolygonIndices Indices within positions of the start of each primitive Polygon/ring\n * @param flatCoordinateArray Array of x, y or x, y, z positions\n * @param nDim - number of dimensions per position\n * @returns triangle indices or null if invalid polygon and earcut fails\n */\nexport function getTriangleIndices(polygonIndices, primitivePolygonIndices, flatCoordinateArray, nDim) {\n    try {\n        let primitiveIndex = 0;\n        const triangles = [];\n        // loop polygonIndices to get triangles\n        for (let i = 0; i < polygonIndices.length - 1; i++) {\n            const startIdx = polygonIndices[i];\n            const endIdx = polygonIndices[i + 1];\n            // get subarray of flatCoordinateArray\n            const slicedFlatCoords = flatCoordinateArray.subarray(startIdx * nDim, endIdx * nDim);\n            // get holeIndices for earcut\n            const holeIndices = [];\n            while (primitivePolygonIndices[primitiveIndex] < endIdx) {\n                if (primitivePolygonIndices[primitiveIndex] > startIdx) {\n                    holeIndices.push(primitivePolygonIndices[primitiveIndex] - startIdx);\n                }\n                primitiveIndex++;\n            }\n            // TODO check if each ring is closed\n            const triangleIndices = earcut(slicedFlatCoords, holeIndices.length > 0 ? holeIndices : undefined, nDim);\n            if (triangleIndices.length === 0) {\n                throw Error('earcut failed e.g. invalid polygon');\n            }\n            for (let j = 0; j < triangleIndices.length; j++) {\n                triangles.push(triangleIndices[j] + startIdx);\n            }\n        }\n        // convert traingles to Uint32Array\n        const trianglesUint32 = new Uint32Array(triangles.length);\n        for (let i = 0; i < triangles.length; i++) {\n            trianglesUint32[i] = triangles[i];\n        }\n        return trianglesUint32;\n    }\n    catch (error) {\n        // if earcut fails, return null\n        return null;\n    }\n}\n/**\n * get binary polygons from geoarrow polygon column\n * @param chunk one chunk of geoarrow polygon column\n * @param geoEncoding the geo encoding of the geoarrow polygon column\n * @param options options for getting binary geometries\n * @returns BinaryGeometryContent\n */\nfunction getBinaryPolygonsFromChunk(chunk, geoEncoding, options) {\n    const isMultiPolygon = geoEncoding === 'geoarrow.multipolygon';\n    const polygonData = isMultiPolygon ? chunk.children[0] : chunk;\n    const polygonOffset = polygonData.valueOffsets;\n    const partData = isMultiPolygon\n        ? chunk.valueOffsets.map((i) => polygonOffset.at(i) || i)\n        : chunk.valueOffsets;\n    const ringData = polygonData.children[0];\n    const pointData = ringData.children[0];\n    const coordData = pointData.children[0];\n    const nDim = pointData.stride;\n    const geomOffset = ringData.valueOffsets;\n    const flatCoordinateArray = coordData.values;\n    const geometryIndicies = new Uint16Array(polygonOffset.length);\n    for (let i = 0; i < polygonOffset.length; i++) {\n        geometryIndicies[i] = geomOffset[polygonOffset[i]];\n    }\n    const numOfVertices = flatCoordinateArray.length / nDim;\n    const featureIds = new Uint32Array(numOfVertices);\n    for (let i = 0; i < partData.length - 1; i++) {\n        const startIdx = geomOffset[partData[i]];\n        const endIdx = geomOffset[partData[i + 1]];\n        for (let j = startIdx; j < endIdx; j++) {\n            featureIds[j] = i;\n        }\n    }\n    const triangles = options?.triangulate\n        ? getTriangleIndices(geometryIndicies, geomOffset, flatCoordinateArray, nDim)\n        : null;\n    return {\n        featureIds,\n        nDim,\n        flatCoordinateArray,\n        geomOffset,\n        geometryIndicies,\n        ...(options?.triangulate && triangles ? { triangles } : {})\n    };\n}\n/**\n * get binary lines from geoarrow line column\n * @param chunk one chunk/batch of geoarrow column\n * @param geoEncoding the geo encoding of the geoarrow column\n * @returns BinaryGeometryContent\n */\nfunction getBinaryLinesFromChunk(chunk, geoEncoding) {\n    const isMultiLineString = geoEncoding === 'geoarrow.multilinestring';\n    const lineData = isMultiLineString ? chunk.children[0] : chunk;\n    const pointData = lineData.children[0];\n    const coordData = pointData.children[0];\n    const nDim = pointData.stride;\n    const geomOffset = lineData.valueOffsets;\n    const flatCoordinateArray = coordData.values;\n    // geometryIndicies is not needed for line string\n    const geometryIndicies = new Uint16Array(0);\n    const numOfVertices = flatCoordinateArray.length / nDim;\n    const featureIds = new Uint32Array(numOfVertices);\n    if (isMultiLineString) {\n        const partData = chunk.valueOffsets;\n        for (let i = 0; i < partData.length - 1; i++) {\n            const startIdx = geomOffset[partData[i]];\n            const endIdx = geomOffset[partData[i + 1]];\n            for (let j = startIdx; j < endIdx; j++) {\n                featureIds[j] = i;\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < chunk.length; i++) {\n            const startIdx = geomOffset[i];\n            const endIdx = geomOffset[i + 1];\n            for (let j = startIdx; j < endIdx; j++) {\n                featureIds[j] = i;\n            }\n        }\n    }\n    return {\n        featureIds,\n        flatCoordinateArray,\n        nDim,\n        geomOffset,\n        geometryIndicies\n    };\n}\n/**\n * get binary points from geoarrow point column\n * @param chunk one chunk/batch of geoarrow column\n * @param geoEncoding  geo encoding of the geoarrow column\n * @returns BinaryGeometryContent\n */\nfunction getBinaryPointsFromChunk(chunk, geoEncoding) {\n    const isMultiPoint = geoEncoding === 'geoarrow.multipoint';\n    const pointData = isMultiPoint ? chunk.children[0] : chunk;\n    const coordData = pointData.children[0];\n    const nDim = pointData.stride;\n    const flatCoordinateArray = coordData.values;\n    // geometryIndices is not needed for point\n    const geometryIndicies = new Uint16Array(0);\n    // geomOffset is not needed for point\n    const geomOffset = new Int32Array(0);\n    const numOfVertices = flatCoordinateArray.length / nDim;\n    const featureIds = new Uint32Array(numOfVertices);\n    if (isMultiPoint) {\n        const partData = chunk.valueOffsets;\n        for (let i = 0; i < partData.length - 1; i++) {\n            const startIdx = partData[i];\n            const endIdx = partData[i + 1];\n            for (let j = startIdx; j < endIdx; j++) {\n                featureIds[j] = i;\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < chunk.length; i++) {\n            featureIds[i] = i;\n        }\n    }\n    return {\n        featureIds,\n        flatCoordinateArray,\n        nDim,\n        geomOffset,\n        geometryIndicies\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n *  Update bounds from geoarrow sample data\n *\n * @param flatCoords the flattend coordinates array from one chunk of geoarrow column\n * @param nDim the number of dimensions of the coordinates\n * @param bounds the bounds to be updated\n * @param sampleSize how many samples to be used to update the bounds, default is 1000 per chunk\n * @returns the updated bounds\n */\nexport function updateBoundsFromGeoArrowSamples(flatCoords, nDim, bounds, sampleSize = 100) {\n    const numberOfFeatures = flatCoords.length / nDim;\n    const sampleStep = Math.max(Math.floor(numberOfFeatures / sampleSize), 1);\n    const newBounds = [...bounds];\n    for (let i = 0; i < numberOfFeatures; i += sampleStep) {\n        const lng = flatCoords[i * nDim];\n        const lat = flatCoords[i * nDim + 1];\n        if (lng < newBounds[0]) {\n            newBounds[0] = lng;\n        }\n        if (lat < newBounds[1]) {\n            newBounds[1] = lat;\n        }\n        if (lng > newBounds[2]) {\n            newBounds[2] = lng;\n        }\n        if (lat > newBounds[3]) {\n            newBounds[3] = lat;\n        }\n    }\n    return newBounds;\n}\n", "import * as arrow from 'apache-arrow';\nexport function hardClone(data, force = false) {\n    // Check if `data` is an arrow.Vector\n    if ('data' in data) {\n        return new arrow.Vector(data.data.map((data) => hardClone(data, force)));\n    }\n    // Clone each of the children, recursively\n    const clonedChildren = [];\n    for (const childData of data.children) {\n        clonedChildren.push(hardClone(childData, force));\n    }\n    // Clone the dictionary if there is one\n    let clonedDictionary;\n    if (data.dictionary !== undefined) {\n        clonedDictionary = hardClone(data.dictionary, force);\n    }\n    // Buffers can have up to four entries. Each of these can be `undefined` for\n    // one or more array types.\n    //\n    // - OFFSET: value offsets for variable size list types\n    // - DATA: the underlying data\n    // - VALIDITY: the null buffer. This may be empty or undefined if all elements\n    //   are non-null/valid.\n    // - TYPE: type ids for a union type.\n    const clonedBuffers = {\n        [arrow.BufferType.OFFSET]: cloneBuffer(data.buffers[arrow.BufferType.OFFSET], force),\n        [arrow.BufferType.DATA]: cloneBuffer(data.buffers[arrow.BufferType.DATA], force),\n        [arrow.BufferType.VALIDITY]: cloneBuffer(data.buffers[arrow.BufferType.VALIDITY], force),\n        [arrow.BufferType.TYPE]: cloneBuffer(data.buffers[arrow.BufferType.TYPE], force)\n    };\n    // Note: the data.offset is passed on so that a sliced Data instance will not\n    // be \"un-sliced\". However keep in mind that this means we're cloning the\n    // _original backing buffer_, not only the portion of the Data that was\n    // sliced.\n    return new arrow.Data(data.type, data.offset, data.length, \n    // @ts-expect-error _nullCount is protected. We're using it here to mimic\n    // `Data.clone`\n    data._nullCount, clonedBuffers, clonedChildren, clonedDictionary);\n}\n/**\n * Test whether an arrow.Data instance is a slice of a larger `ArrayBuffer`.\n */\nexport function isShared(data) {\n    // Loop over arrow.Vector\n    if ('data' in data) {\n        return data.data.some((data) => isShared(data));\n    }\n    // Check child data\n    for (const childData of data.children) {\n        if (isShared(childData)) {\n            return true;\n        }\n    }\n    // Check dictionary\n    if (data.dictionary !== undefined) {\n        if (isShared(data.dictionary)) {\n            return true;\n        }\n    }\n    const bufferTypes = [\n        arrow.BufferType.OFFSET,\n        arrow.BufferType.DATA,\n        arrow.BufferType.VALIDITY,\n        arrow.BufferType.TYPE\n    ];\n    for (const bufferType of bufferTypes) {\n        if (data.buffers[bufferType] !== undefined && isTypedArraySliced(data.buffers[bufferType])) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Returns true if the current typed array is a partial slice on a larger\n * ArrayBuffer\n */\nfunction isTypedArraySliced(arr) {\n    return !(arr.byteOffset === 0 && arr.byteLength === arr.buffer.byteLength);\n}\n/**\n * If a slice of a larger ArrayBuffer, clone to a fresh `ArrayBuffer`.\n *\n * If `force` is `true`, always clone the array, even if not shared.\n */\nfunction cloneBuffer(arr, force) {\n    // Not all buffer types are defined for every type of Arrow array. E.g.\n    // `arrow.BufferType.TYPE` is only defined for the Union type.\n    if (arr === undefined) {\n        return arr;\n    }\n    // The current array is not a part of a larger ArrayBuffer, don't clone it\n    if (!force && !isTypedArraySliced(arr)) {\n        return arr;\n    }\n    // Note: TypedArray.slice() **copies** into a new ArrayBuffer\n    // @ts-expect-error 'Uint8Array' is assignable to the constraint of type 'A',\n    // but 'A' could be instantiated with a different subtype of constraint\n    // 'TypedArray'\n    // We know from arr.slice that it will always return the same\n    return arr.slice();\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { processOnWorker } from '@loaders.gl/worker-utils';\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Worker for tessellating geometries. Normally called through triangulateOnWorker\n */\nexport const TriangulationWorker = {\n    id: 'triangulation',\n    name: 'Triangulate',\n    module: 'arrow',\n    version: VERSION,\n    options: {}\n};\n/**\n * Triangulate a set of polygons on worker, type safe API\n */\nexport function triangulateOnWorker(data, options = {}) {\n    return processOnWorker(TriangulationWorker, { ...data, operation: 'triangulate' }, options);\n}\n/**\n * Parse GeoArrow geometry colum on worker, type safe API\n */\nexport function parseGeoArrowOnWorker(data, options = {}) {\n    return processOnWorker(TriangulationWorker, { ...data, operation: 'parse-geoarrow' }, options);\n}\n"],
  "mappings": "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",
  "names": ["VECTOR_TYPES", "import_schema", "arrow", "import_schema", "import_gis", "arrow", "_a", "arrow", "VERSION", "arrow", "import_schema", "builder", "BinaryGeometryType", "arrow", "data", "VERSION"]
}
