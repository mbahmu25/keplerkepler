"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteTileFormat = exports.RasterTileType = exports.REMOTE_TILE = exports.PMTilesType = exports.DatasetType = void 0;
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var DatasetType = exports.DatasetType = /*#__PURE__*/function (DatasetType) {
  DatasetType["LOCAL"] = "local";
  DatasetType["VECTOR_TILE"] = "vector-tile";
  DatasetType["RASTER_TILE"] = "raster-tile";
  DatasetType["WMS_TILE"] = "wms-tile";
  return DatasetType;
}({});
var RemoteTileFormat = exports.RemoteTileFormat = /*#__PURE__*/function (RemoteTileFormat) {
  RemoteTileFormat["MVT"] = "mvt";
  RemoteTileFormat["PMTILES"] = "pmtiles";
  RemoteTileFormat["WMS"] = "wms";
  return RemoteTileFormat;
}({});
var PMTilesType = exports.PMTilesType = /*#__PURE__*/function (PMTilesType) {
  PMTilesType["RASTER"] = "raster";
  PMTilesType["MVT"] = "mvt";
  return PMTilesType;
}({});
var REMOTE_TILE = exports.REMOTE_TILE = 'remote';

/**
 * Raster tileset metadata in STAC Item format. STAC version must be >= 1.0.0,
 * and the EO and Raster STAC extensions are required. This metadata shape can
 * be passed to the map to synchronously add a raster tileset.
 * @see https://github.com/radiantearth/stac-spec/blob/master/item-spec/item-spec.md
 */

/**
 * Raster tileset metadata with a remote metadata URL. This metadata can
 * be passed to the map to asynchronously load a raster tileset.
 */
var RasterTileType = exports.RasterTileType = /*#__PURE__*/function (RasterTileType) {
  RasterTileType["STAC"] = "stac";
  RasterTileType["PMTILES"] = "pmtiles";
  return RasterTileType;
}({});
/**
 * Raster tileset metadata.
 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJEYXRhc2V0VHlwZSIsImV4cG9ydHMiLCJSZW1vdGVUaWxlRm9ybWF0IiwiUE1UaWxlc1R5cGUiLCJSRU1PVEVfVElMRSIsIlJhc3RlclRpbGVUeXBlIl0sInNvdXJjZXMiOlsiLi4vc3JjL2RhdGFzZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuLy8gQ29weXJpZ2h0IGNvbnRyaWJ1dG9ycyB0byB0aGUga2VwbGVyLmdsIHByb2plY3RcblxuZXhwb3J0IGVudW0gRGF0YXNldFR5cGUge1xuICBMT0NBTCA9ICdsb2NhbCcsXG4gIFZFQ1RPUl9USUxFID0gJ3ZlY3Rvci10aWxlJyxcbiAgUkFTVEVSX1RJTEUgPSAncmFzdGVyLXRpbGUnLFxuICBXTVNfVElMRSA9ICd3bXMtdGlsZSdcbn1cblxuZXhwb3J0IGVudW0gUmVtb3RlVGlsZUZvcm1hdCB7XG4gIE1WVCA9ICdtdnQnLFxuICBQTVRJTEVTID0gJ3BtdGlsZXMnLFxuICBXTVMgPSAnd21zJ1xufVxuXG5leHBvcnQgZW51bSBQTVRpbGVzVHlwZSB7XG4gIFJBU1RFUiA9ICdyYXN0ZXInLFxuICBNVlQgPSAnbXZ0J1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1RFX1RJTEUgPSAncmVtb3RlJztcblxuZXhwb3J0IHR5cGUgVmVjdG9yVGlsZURhdGFzZXRNZXRhZGF0YSA9IHtcbiAgdHlwZTogdHlwZW9mIFJFTU9URV9USUxFO1xuICByZW1vdGVUaWxlRm9ybWF0OiBSZW1vdGVUaWxlRm9ybWF0O1xuICB0aWxlc2V0RGF0YVVybDogc3RyaW5nO1xuICB0aWxlc2V0TWV0YWRhdGFVcmw/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIFJhc3RlciB0aWxlc2V0IG1ldGFkYXRhIGluIFNUQUMgSXRlbSBmb3JtYXQuIFNUQUMgdmVyc2lvbiBtdXN0IGJlID49IDEuMC4wLFxuICogYW5kIHRoZSBFTyBhbmQgUmFzdGVyIFNUQUMgZXh0ZW5zaW9ucyBhcmUgcmVxdWlyZWQuIFRoaXMgbWV0YWRhdGEgc2hhcGUgY2FuXG4gKiBiZSBwYXNzZWQgdG8gdGhlIG1hcCB0byBzeW5jaHJvbm91c2x5IGFkZCBhIHJhc3RlciB0aWxlc2V0LlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFkaWFudGVhcnRoL3N0YWMtc3BlYy9ibG9iL21hc3Rlci9pdGVtLXNwZWMvaXRlbS1zcGVjLm1kXG4gKi9cbmV4cG9ydCB0eXBlIFJhc3RlclRpbGVMb2NhbE1ldGFkYXRhID0ge1xuICB0eXBlOiAnRmVhdHVyZSc7XG5cbiAgLyoqIFVSTCBmb3IgdGlsZXNldCBtZXRhZGF0YS4gKi9cbiAgbWV0YWRhdGFVcmw/OiBzdHJpbmc7XG4gIHN0YWNfdmVyc2lvbjogc3RyaW5nO1xuICBzdGFjX2V4dGVuc2lvbnM6IHN0cmluZ1tdO1xuICBhc3NldHM6IFJlY29yZDxzdHJpbmcsIGFueT47XG59O1xuXG4vKipcbiAqIFJhc3RlciB0aWxlc2V0IG1ldGFkYXRhIHdpdGggYSByZW1vdGUgbWV0YWRhdGEgVVJMLiBUaGlzIG1ldGFkYXRhIGNhblxuICogYmUgcGFzc2VkIHRvIHRoZSBtYXAgdG8gYXN5bmNocm9ub3VzbHkgbG9hZCBhIHJhc3RlciB0aWxlc2V0LlxuICovXG5leHBvcnQgdHlwZSBSYXN0ZXJUaWxlUmVtb3RlTWV0YWRhdGEgPSB7XG4gIG1ldGFkYXRhVXJsOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZW51bSBSYXN0ZXJUaWxlVHlwZSB7XG4gIFNUQUMgPSAnc3RhYycsXG4gIFBNVElMRVMgPSAncG10aWxlcydcbn1cblxuZXhwb3J0IHR5cGUgUmFzdGVyVGlsZU1ldGFkYXRhU291cmNlVHlwZSA9IHtcbiAgcG10aWxlc1R5cGU/OiBQTVRpbGVzVHlwZTtcbn07XG5cbi8qKlxuICogUmFzdGVyIHRpbGVzZXQgbWV0YWRhdGEuXG4gKi9cbmV4cG9ydCB0eXBlIFJhc3RlclRpbGVEYXRhc2V0TWV0YWRhdGEgPSAoUmFzdGVyVGlsZUxvY2FsTWV0YWRhdGEgfCBSYXN0ZXJUaWxlUmVtb3RlTWV0YWRhdGEpICZcbiAgUmFzdGVyVGlsZU1ldGFkYXRhU291cmNlVHlwZTtcblxuZXhwb3J0IHR5cGUgV01TRGF0YXNldE1ldGFkYXRhID0ge1xuICB0eXBlOiB0eXBlb2YgUkVNT1RFX1RJTEU7XG4gIHJlbW90ZVRpbGVGb3JtYXQ6IFJlbW90ZVRpbGVGb3JtYXQuV01TO1xuICB0aWxlc2V0RGF0YVVybDogc3RyaW5nO1xuICB0aWxlc2V0TWV0YWRhdGFVcmw6IHN0cmluZztcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBsYXllcnM6IHtuYW1lOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmc7IGJvdW5kaW5nQm94OiBudW1iZXJbXSB8IG51bGx9W107XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQUEsSUFFWUEsV0FBVyxHQUFBQyxPQUFBLENBQUFELFdBQUEsMEJBQVhBLFdBQVc7RUFBWEEsV0FBVztFQUFYQSxXQUFXO0VBQVhBLFdBQVc7RUFBWEEsV0FBVztFQUFBLE9BQVhBLFdBQVc7QUFBQTtBQUFBLElBT1hFLGdCQUFnQixHQUFBRCxPQUFBLENBQUFDLGdCQUFBLDBCQUFoQkEsZ0JBQWdCO0VBQWhCQSxnQkFBZ0I7RUFBaEJBLGdCQUFnQjtFQUFoQkEsZ0JBQWdCO0VBQUEsT0FBaEJBLGdCQUFnQjtBQUFBO0FBQUEsSUFNaEJDLFdBQVcsR0FBQUYsT0FBQSxDQUFBRSxXQUFBLDBCQUFYQSxXQUFXO0VBQVhBLFdBQVc7RUFBWEEsV0FBVztFQUFBLE9BQVhBLFdBQVc7QUFBQTtBQUtoQixJQUFNQyxXQUFXLEdBQUFILE9BQUEsQ0FBQUcsV0FBQSxHQUFHLFFBQVE7O0FBU25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBUVlDLGNBQWMsR0FBQUosT0FBQSxDQUFBSSxjQUFBLDBCQUFkQSxjQUFjO0VBQWRBLGNBQWM7RUFBZEEsY0FBYztFQUFBLE9BQWRBLGNBQWM7QUFBQTtBQVMxQjtBQUNBO0FBQ0EiLCJpZ25vcmVMaXN0IjpbXX0=