{
  "version": 3,
  "sources": ["index.js", "polyfills/buffer/buffer.js", "polyfills/buffer/buffer-polyfill.browser.js", "polyfills/buffer/install-buffer-polyfill.js", "parquet-loader.js", "lib/parsers/parse-parquet.js", "parquetjs/codecs/plain.js", "parquetjs/codecs/rle.js", "parquetjs/codecs/dictionary.js", "parquetjs/codecs/index.js", "parquetjs/compression.js", "parquetjs/schema/types.js", "parquetjs/schema/shred.js", "parquetjs/schema/schema.js", "parquetjs/parquet-thrift/index.js", "parquetjs/parquet-thrift/Type.js", "parquetjs/parquet-thrift/ConvertedType.js", "parquetjs/parquet-thrift/FieldRepetitionType.js", "parquetjs/parquet-thrift/Encoding.js", "parquetjs/parquet-thrift/CompressionCodec.js", "parquetjs/parquet-thrift/PageType.js", "parquetjs/parquet-thrift/Statistics.js", "parquetjs/parquet-thrift/StringType.js", "parquetjs/parquet-thrift/UUIDType.js", "parquetjs/parquet-thrift/MapType.js", "parquetjs/parquet-thrift/ListType.js", "parquetjs/parquet-thrift/EnumType.js", "parquetjs/parquet-thrift/DateType.js", "parquetjs/parquet-thrift/NullType.js", "parquetjs/parquet-thrift/DecimalType.js", "parquetjs/parquet-thrift/MilliSeconds.js", "parquetjs/parquet-thrift/MicroSeconds.js", "parquetjs/parquet-thrift/TimestampType.js", "parquetjs/parquet-thrift/TimeUnit.js", "parquetjs/parquet-thrift/TimeType.js", "parquetjs/parquet-thrift/IntType.js", "parquetjs/parquet-thrift/JsonType.js", "parquetjs/parquet-thrift/BsonType.js", "parquetjs/parquet-thrift/SchemaElement.js", "parquetjs/parquet-thrift/LogicalType.js", "parquetjs/parquet-thrift/DataPageHeader.js", "parquetjs/parquet-thrift/IndexPageHeader.js", "parquetjs/parquet-thrift/DictionaryPageHeader.js", "parquetjs/parquet-thrift/DataPageHeaderV2.js", "parquetjs/parquet-thrift/PageHeader.js", "parquetjs/parquet-thrift/KeyValue.js", "parquetjs/parquet-thrift/SortingColumn.js", "parquetjs/parquet-thrift/PageEncodingStats.js", "parquetjs/parquet-thrift/ColumnMetaData.js", "parquetjs/parquet-thrift/ColumnChunk.js", "parquetjs/parquet-thrift/RowGroup.js", "parquetjs/parquet-thrift/TypeDefinedOrder.js", "parquetjs/parquet-thrift/FileMetaData.js", "parquetjs/parquet-thrift/ColumnOrder.js", "lib/constants.js", "parquetjs/utils/read-utils.js", "parquetjs/parser/decoders.js", "parquetjs/parser/parquet-reader.js", "lib/arrow/convert-schema-from-parquet.js", "lib/parsers/get-parquet-schema.js", "lib/parsers/parse-geoparquet.js", "lib/parsers/parse-parquet-to-columns.js", "parquet-writer.js", "parquet-wasm-loader.js", "lib/parsers/parse-parquet-wasm.js", "lib/utils/load-wasm.js", "lib/utils/make-stream-iterator.js", "lib/encoders/encode-parquet-wasm.js", "parquet-wasm-writer.js", "parquetjs/utils/file-utils.js", "parquetjs/encoder/parquet-encoder.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { Buffer } from \"./polyfills/buffer/install-buffer-polyfill.js\";\n// import {ArrowTable, ArrowTableBatch} from '@loaders.gl/arrow';\nexport { ParquetWorkerLoader, ParquetLoader, GeoParquetWorkerLoader, GeoParquetLoader, ParquetColumnarWorkerLoader, ParquetColumnarLoader } from \"./parquet-loader.js\";\nexport { ParquetWriter as _ParquetWriter } from \"./parquet-writer.js\";\nexport { ParquetWasmLoader, ParquetWasmWorkerLoader } from \"./parquet-wasm-loader.js\";\nexport { ParquetWasmWriter } from \"./parquet-wasm-writer.js\";\n// EXPERIMENTAL - expose the internal parquetjs API\nexport { preloadCompressions } from \"./parquetjs/compression.js\";\nexport { ParquetSchema } from \"./parquetjs/schema/schema.js\";\nexport { ParquetReader } from \"./parquetjs/parser/parquet-reader.js\";\nexport { ParquetEncoder } from \"./parquetjs/encoder/parquet-encoder.js\";\nexport { convertParquetSchema, convertParquetSchema as convertParquetToArrowSchema } from \"./lib/arrow/convert-schema-from-parquet.js\";\n// Experimental\nexport { BufferPolyfill, installBufferPolyfill } from \"./polyfills/buffer/index.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is forked from https://github.com/feross/buffer under MIT license\n// The code has primarily been converted to TypeScript.\n/* !\n * The buffer module from node.js, for the browser.\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n * https://github.com/feross/buffer/blob/master/AUTHORS.md\n */\n/**\n * The decision to include this polyfill in loaders.gl may seem controversial.\n *\n * It is based on the following reasoning:\n * - The Buffer API is used in the parquetjs library and likely other Node.js\n *   libraries we will use in the future.\n * - While the goal is to convert code from Buffer to ArrayBuffer, the Thrift\n *   code in Parquet may be autogenerated.\n * - Bundlers often require a polyfill to be included, this extra step is not\n *   a great experience for loaders.gl users.\n * - The forked buffer polyfill module had old and generated some type errors.\n */\n/* eslint-disable */ // no-proto, max-statements, max-depth, complexity, no-continue, prefer-spread, no-constant-condition, consistent-return */\n// @ts-nocheck - this references don't work well in prototype assignment\nimport base64 from 'base64-js';\nimport ieee754 from 'ieee754';\nexport const kMaxLength = 0x7fffffff;\nexport const INSPECT_MAX_BYTES = 50;\n// const customInspectSymbol =\n//   typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n//     ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n//     : null;\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nexport class Buffer extends Uint8Array {\n    static poolSize = 8192; // not used by this implementation\n    // length: number; inherited\n    get parent() {\n        if (!Buffer.isBuffer(this))\n            return undefined;\n        return this.buffer;\n    }\n    get offset() {\n        if (!Buffer.isBuffer(this))\n            return undefined;\n        return this.byteOffset;\n    }\n    /** This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n     * to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n     * reliably in a browserify context because there could be multiple different\n     * copies of the 'buffer' package in use. This method works even for Buffer\n     * instances that were created from another copy of the `buffer` package.\n     * @see: https://github.com/feross/buffer/issues/154\n     */\n    _isBuffer = true;\n    constructor(arg, encodingOrOffset, length) {\n        if (typeof arg !== 'number') {\n            return Buffer.from(arg, encodingOrOffset, length);\n        }\n        // Basic case, just a length\n        const size = arg;\n        if (size > kMaxLength) {\n            throw new RangeError(`The value \"${size}\" is invalid for option \"size\"`);\n        }\n        if (typeof encodingOrOffset === 'string') {\n            throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        }\n        super(size < 0 ? 0 : checked(size) | 0);\n        return;\n    }\n    static from(value, encodingOrOffset, length) {\n        if (typeof value === 'string') {\n            return fromString(value, encodingOrOffset);\n        }\n        if (ArrayBuffer.isView(value)) {\n            return fromArrayView(value);\n        }\n        if (value == null) {\n            throw new TypeError(`${'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n                'or Array-like Object. Received type '}${typeof value}`);\n        }\n        if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {\n            return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof SharedArrayBuffer !== 'undefined' &&\n            (isInstance(value, SharedArrayBuffer) ||\n                (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n            return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n        if (typeof value === 'number') {\n            throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n        }\n        const valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n            return Buffer.from(valueOf, encodingOrOffset, length);\n        }\n        const b = fromObject(value);\n        if (b)\n            return b;\n        if (typeof Symbol !== 'undefined' &&\n            Symbol.toPrimitive != null &&\n            typeof value[Symbol.toPrimitive] === 'function') {\n            return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n        }\n        throw new TypeError(`${'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n            'or Array-like Object. Received type '}${typeof value}`);\n    }\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    static isBuffer(b) {\n        return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n    }\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    static compare(a, b) {\n        if (!Buffer.isBuffer(a) && isInstance(a, Uint8Array))\n            a = Buffer.from(a, a.offset, a.byteLength);\n        if (!Buffer.isBuffer(b) && isInstance(b, Uint8Array))\n            b = Buffer.from(b, b.offset, b.byteLength);\n        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n            throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n        }\n        if (a === b)\n            return 0;\n        let x = a.length;\n        let y = b.length;\n        for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n            if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n            }\n        }\n        if (x < y)\n            return -1;\n        if (y < x)\n            return 1;\n        return 0;\n    }\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    static isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n            case 'hex':\n            case 'utf8':\n            case 'utf-8':\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n            case 'base64':\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    static concat(list, length) {\n        if (!Array.isArray(list)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        if (list.length === 0) {\n            return Buffer.alloc(0);\n        }\n        let i;\n        if (length === undefined) {\n            length = 0;\n            for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n            }\n        }\n        const buffer = Buffer.allocUnsafe(length);\n        let pos = 0;\n        for (i = 0; i < list.length; ++i) {\n            let buf = list[i];\n            if (isInstance(buf, Uint8Array)) {\n                if (pos + buf.length > buffer.length) {\n                    if (!Buffer.isBuffer(buf)) {\n                        buf = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    }\n                    buf.copy(buffer, pos);\n                }\n                else {\n                    Uint8Array.prototype.set.call(buffer, buf, pos);\n                }\n            }\n            else if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n            else {\n                buf.copy(buffer, pos);\n            }\n            pos += buf.length;\n        }\n        return buffer;\n    }\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initializing\n     */\n    static alloc(size, fill, encoding) {\n        return alloc(size, fill, encoding);\n    }\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafe(size) {\n        assertSize(size);\n        return new Buffer(size);\n    }\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafeSlow(size) {\n        return allocUnsafe(size);\n    }\n    includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n    }\n    indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    }\n    lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    }\n    readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 0x80))\n            return this[offset];\n        return (0xff - this[offset] + 1) * -1;\n    }\n    readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 2, this.length);\n        const val = this[offset] | (this[offset + 1] << 8);\n        return val & 0x8000 ? val | 0xffff0000 : val;\n    }\n    readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 2, this.length);\n        const val = this[offset + 1] | (this[offset] << 8);\n        return val & 0x8000 ? val | 0xffff0000 : val;\n    }\n    readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24));\n    }\n    readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return ((this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);\n    }\n    readIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert)\n            checkOffset(offset, byteLength, this.length);\n        let i = byteLength;\n        let mul = 1;\n        let val = this[offset + --i];\n        while (i > 0 && (mul *= 0x100)) {\n            val += this[offset + --i] * mul;\n        }\n        mul *= 0x80;\n        if (val >= mul)\n            val -= Math.pow(2, 8 * byteLength);\n        return val;\n    }\n    readIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert)\n            checkOffset(offset, byteLength, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n        }\n        mul *= 0x80;\n        if (val >= mul)\n            val -= Math.pow(2, 8 * byteLength);\n        return val;\n    }\n    readBigInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, 'offset');\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === undefined || last === undefined) {\n            boundsError(offset, this.length - 8);\n        }\n        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow\n        return ((BigInt(val) << BigInt(32)) +\n            BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24));\n    }\n    readBigInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, 'offset');\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === undefined || last === undefined) {\n            boundsError(offset, this.length - 8);\n        }\n        const val = (first << 24) + // Overflow\n            this[++offset] * 2 ** 16 +\n            this[++offset] * 2 ** 8 +\n            this[++offset];\n        return ((BigInt(val) << BigInt(32)) +\n            BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last));\n    }\n    readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 1, this.length);\n        return this[offset];\n    }\n    readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 2, this.length);\n        return this[offset] | (this[offset + 1] << 8);\n    }\n    readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 2, this.length);\n        return (this[offset] << 8) | this[offset + 1];\n    }\n    readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return ((this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +\n            this[offset + 3] * 0x1000000);\n    }\n    readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return (this[offset] * 0x1000000 +\n            ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]));\n    }\n    readUIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert)\n            checkOffset(offset, byteLength, this.length);\n        let val = this[offset];\n        let mul = 1;\n        let i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n        }\n        return val;\n    }\n    readUIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n            checkOffset(offset, byteLength, this.length);\n        }\n        let val = this[offset + --byteLength];\n        let mul = 1;\n        while (byteLength > 0 && (mul *= 0x100)) {\n            val += this[offset + --byteLength] * mul;\n        }\n        return val;\n    }\n    readBigUInt64LE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, 'offset');\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === undefined || last === undefined) {\n            boundsError(offset, this.length - 8);\n        }\n        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n        return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    }\n    readBigUInt64BE(offset) {\n        offset = offset >>> 0;\n        validateNumber(offset, 'offset');\n        const first = this[offset];\n        const last = this[offset + 7];\n        if (first === undefined || last === undefined) {\n            boundsError(offset, this.length - 8);\n        }\n        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    }\n    readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n    }\n    readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n    }\n    readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n    }\n    readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n    }\n    writeUInt8(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 1, 0xff, 0);\n        this[offset] = value & 0xff;\n        return offset + 1;\n    }\n    writeUInt16LE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n    }\n    writeUInt16BE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n    }\n    writeUInt32LE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n        return offset + 4;\n    }\n    writeUInt32BE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n    }\n    writeUIntLE(value, offset, byteLength, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n            const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n        let mul = 1;\n        let i = 0;\n        this[offset] = value & 0xff;\n        while (++i < byteLength && (mul *= 0x100)) {\n            this[offset + i] = (value / mul) & 0xff;\n        }\n        return offset + byteLength;\n    }\n    writeUIntBE(value, offset, byteLength, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n            const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n        let i = byteLength - 1;\n        let mul = 1;\n        this[offset + i] = value & 0xff;\n        while (--i >= 0 && (mul *= 0x100)) {\n            this[offset + i] = (value / mul) & 0xff;\n        }\n        return offset + byteLength;\n    }\n    writeBigUInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n    }\n    writeBigUInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n    }\n    writeIntLE(value, offset, byteLength, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert) {\n            const limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n        let i = 0;\n        let mul = 1;\n        let sub = 0;\n        this[offset] = value & 0xff;\n        while (++i < byteLength && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n            }\n            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;\n        }\n        return offset + byteLength;\n    }\n    writeIntBE(value, offset, byteLength, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert) {\n            const limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n        let i = byteLength - 1;\n        let mul = 1;\n        let sub = 0;\n        this[offset + i] = value & 0xff;\n        while (--i >= 0 && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n            }\n            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;\n        }\n        return offset + byteLength;\n    }\n    writeInt8(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 1, 0x7f, -0x80);\n        if (value < 0)\n            value = 0xff + value + 1;\n        this[offset] = value & 0xff;\n        return offset + 1;\n    }\n    writeInt16LE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n    }\n    writeInt16BE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n    }\n    writeInt32LE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n    }\n    writeInt32BE(value, offset, noAssert) {\n        value = Number(value);\n        offset = offset >>> 0;\n        if (!noAssert)\n            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        if (value < 0)\n            value = 0xffffffff + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n    }\n    writeBigInt64LE(value, offset = 0) {\n        return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n    }\n    writeBigInt64BE(value, offset = 0) {\n        return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n    }\n    writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n    }\n    writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n    }\n    writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n    }\n    writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n    }\n    write(string, offset, length, encoding) {\n        // Buffer#write(string)\n        if (offset === undefined) {\n            encoding = 'utf8';\n            length = this.length;\n            offset = 0;\n            // Buffer#write(string, encoding)\n        }\n        else if (length === undefined && typeof offset === 'string') {\n            encoding = offset;\n            length = this.length;\n            offset = 0;\n            // Buffer#write(string, offset[, length][, encoding])\n        }\n        else if (isFinite(offset)) {\n            offset = offset >>> 0;\n            if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined)\n                    encoding = 'utf8';\n            }\n            else {\n                encoding = length;\n                length = undefined;\n            }\n        }\n        else {\n            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n        }\n        const remaining = this.length - offset;\n        if (length === undefined || length > remaining)\n            length = remaining;\n        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n            throw new RangeError('Attempt to write outside buffer bounds');\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        let loweredCase = false;\n        for (;;) {\n            switch (encoding) {\n                case 'hex':\n                    return hexWrite(this, string, offset, length);\n                case 'utf8':\n                case 'utf-8':\n                    return utf8Write(this, string, offset, length);\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                    return asciiWrite(this, string, offset, length);\n                case 'base64':\n                    // Warning: maxLength not taken into account in base64Write\n                    return base64Write(this, string, offset, length);\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                    return ucs2Write(this, string, offset, length);\n                default:\n                    if (loweredCase)\n                        throw new TypeError(`Unknown encoding: ${encoding}`);\n                    encoding = `${encoding}`.toLowerCase();\n                    loweredCase = true;\n            }\n        }\n    }\n    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n    copy(target, targetStart, start, end) {\n        if (!Buffer.isBuffer(target))\n            throw new TypeError('argument should be a Buffer');\n        if (!start)\n            start = 0;\n        if (!end && end !== 0)\n            end = this.length;\n        if (targetStart >= target.length)\n            targetStart = target.length;\n        if (!targetStart)\n            targetStart = 0;\n        if (end > 0 && end < start)\n            end = start;\n        // Copy 0 bytes; we're done\n        if (end === start)\n            return 0;\n        if (target.length === 0 || this.length === 0)\n            return 0;\n        // Fatal error conditions\n        if (targetStart < 0) {\n            throw new RangeError('targetStart out of bounds');\n        }\n        if (start < 0 || start >= this.length)\n            throw new RangeError('Index out of range');\n        if (end < 0)\n            throw new RangeError('sourceEnd out of bounds');\n        // Are we oob?\n        if (end > this.length)\n            end = this.length;\n        if (target.length - targetStart < end - start) {\n            end = target.length - targetStart + start;\n        }\n        const len = end - start;\n        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n            // Use built-in when available, missing from IE11\n            this.copyWithin(targetStart, start, end);\n        }\n        else {\n            Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n        }\n        return len;\n    }\n    // Usage:\n    //    buffer.fill(number[, offset[, end]])\n    //    buffer.fill(buffer[, offset[, end]])\n    //    buffer.fill(string[, offset[, end]][, encoding])\n    fill(val, start, end, encoding) {\n        // Handle string cases:\n        if (typeof val === 'string') {\n            if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n            }\n            else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n            }\n            if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n            }\n            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError(`Unknown encoding: ${encoding}`);\n            }\n            if (val.length === 1) {\n                const code = val.charCodeAt(0);\n                if ((encoding === 'utf8' && code < 128) || encoding === 'latin1') {\n                    // Fast path: If `val` fits into a single byte, use that numeric value.\n                    val = code;\n                }\n            }\n        }\n        else if (typeof val === 'number') {\n            val = val & 255;\n        }\n        else if (typeof val === 'boolean') {\n            val = Number(val);\n        }\n        // Invalid ranges are not set to a default, so can range check early.\n        if (start < 0 || this.length < start || this.length < end) {\n            throw new RangeError('Out of range index');\n        }\n        if (end <= start) {\n            return this;\n        }\n        start = start >>> 0;\n        end = end === undefined ? this.length : end >>> 0;\n        if (!val)\n            val = 0;\n        let i;\n        if (typeof val === 'number') {\n            for (i = start; i < end; ++i) {\n                this[i] = val;\n            }\n        }\n        else {\n            const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n            const len = bytes.length;\n            if (len === 0) {\n                throw new TypeError(`The value \"${val}\" is invalid for argument \"value\"`);\n            }\n            for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n            }\n        }\n        return this;\n    }\n    swap16() {\n        const len = this.length;\n        if (len % 2 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 16-bits');\n        }\n        for (let i = 0; i < len; i += 2) {\n            swap(this, i, i + 1);\n        }\n        return this;\n    }\n    swap32() {\n        const len = this.length;\n        if (len % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n        for (let i = 0; i < len; i += 4) {\n            swap(this, i, i + 3);\n            swap(this, i + 1, i + 2);\n        }\n        return this;\n    }\n    swap64() {\n        const len = this.length;\n        if (len % 8 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 64-bits');\n        }\n        for (let i = 0; i < len; i += 8) {\n            swap(this, i, i + 7);\n            swap(this, i + 1, i + 6);\n            swap(this, i + 2, i + 5);\n            swap(this, i + 3, i + 4);\n        }\n        return this;\n    }\n    toString(encoding, start, end) {\n        const length = this.length;\n        if (length === 0)\n            return '';\n        if (arguments.length === 0)\n            return utf8Slice(this, 0, length);\n        return this._slowToString(...arguments);\n    }\n    // toLocaleString(b) {\n    //   if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n    //   if (this === b) return true;\n    //   return Buffer.compare(this, b) === 0;\n    // }\n    inspect() {\n        let str = '';\n        const max = INSPECT_MAX_BYTES;\n        str = this.toString('hex', 0, max)\n            .replace(/(.{2})/g, '$1 ')\n            .trim();\n        if (this.length > max)\n            str += ' ... ';\n        return `<Buffer ${str}>`;\n    }\n    // if (customInspectSymbol) {\n    //   Buffer.prototype[customInspectSymbol] =  Buffer.prototype.inspect;\n    // }\n    // }\n    equals(b) {\n        if (!Buffer.isBuffer(b))\n            throw new TypeError('Argument must be a Buffer');\n        if (this === b)\n            return true;\n        return Buffer.compare(this, b) === 0;\n    }\n    compare(target, start, end, thisStart, thisEnd) {\n        if (!Buffer.isBuffer(target) && isInstance(target, Uint8Array)) {\n            target = Buffer.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer.isBuffer(target)) {\n            throw new TypeError(`${'The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type '}${typeof target}`);\n        }\n        if (start === undefined) {\n            start = 0;\n        }\n        if (end === undefined) {\n            end = target ? target.length : 0;\n        }\n        if (thisStart === undefined) {\n            thisStart = 0;\n        }\n        if (thisEnd === undefined) {\n            thisEnd = this.length;\n        }\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n            throw new RangeError('out of range index');\n        }\n        if (thisStart >= thisEnd && start >= end) {\n            return 0;\n        }\n        if (thisStart >= thisEnd) {\n            return -1;\n        }\n        if (start >= end) {\n            return 1;\n        }\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target)\n            return 0;\n        let x = thisEnd - thisStart;\n        let y = end - start;\n        const len = Math.min(x, y);\n        const thisCopy = this.slice(thisStart, thisEnd);\n        const targetCopy = target.slice(start, end);\n        for (let i = 0; i < len; ++i) {\n            if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n            }\n        }\n        if (x < y)\n            return -1;\n        if (y < x)\n            return 1;\n        return 0;\n    }\n    toJSON() {\n        return {\n            type: 'Buffer',\n            data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n    }\n    slice(start, end) {\n        const len = this.length;\n        start = ~~start;\n        end = end === undefined ? len : ~~end;\n        if (start < 0) {\n            start += len;\n            if (start < 0)\n                start = 0;\n        }\n        else if (start > len) {\n            start = len;\n        }\n        if (end < 0) {\n            end += len;\n            if (end < 0)\n                end = 0;\n        }\n        else if (end > len) {\n            end = len;\n        }\n        if (end < start)\n            end = start;\n        const newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        Object.setPrototypeOf(newBuf, Buffer.prototype);\n        return newBuf;\n    }\n    // Typo support?\n    // readUint8(offset: number, noAssert?: boolean): number {\n    //   return this.readUInt8(...arguments);\n    // }\n    // readUint16LE(offset: number, noAssert?: boolean): number {\n    //   return this.readUInt16LE(...arguments);\n    // }\n    // readUint16BE(offset: number, noAssert?: boolean): number {\n    //   return this.readUInt16BE(...arguments);\n    // }\n    // readUint32LE(offset: number, noAssert?: boolean): number {\n    //   return this.readUInt32LE(...arguments);\n    // }\n    // readUint32BE(offset: number, noAssert?: boolean): number {\n    //   return this.readUInt32BE(...arguments);\n    // }\n    // writeUint8() {\n    //   return this.writeUInt8(...arguments);\n    // }\n    // writeUint16LE\n    // writeUint16LE\n    // writeUint32LE = Buffer.prototype.\n    // Buffer.prototype.writeUint32BE\n    _slowToString(encoding, start, end) {\n        let loweredCase = false;\n        // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n        // property of a typed array.\n        // This behaves neither like String nor Uint8Array in that we set start/end\n        // to their upper/lower bounds if the value passed is out of range.\n        // undefined is handled specially as per ECMA-262 6th Edition,\n        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n        if (start === undefined || start < 0) {\n            start = 0;\n        }\n        // Return early if start > this.length. Done here to prevent potential uint32\n        // coercion fail below.\n        if (start > this.length) {\n            return '';\n        }\n        if (end === undefined || end > this.length) {\n            end = this.length;\n        }\n        if (end <= 0) {\n            return '';\n        }\n        // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n        end >>>= 0;\n        start >>>= 0;\n        if (end <= start) {\n            return '';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        while (true) {\n            switch (encoding) {\n                case 'hex':\n                    return hexSlice(this, start, end);\n                case 'utf8':\n                case 'utf-8':\n                    return utf8Slice(this, start, end);\n                case 'ascii':\n                    return asciiSlice(this, start, end);\n                case 'latin1':\n                case 'binary':\n                    return latin1Slice(this, start, end);\n                case 'base64':\n                    return base64Slice(this, start, end);\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                    return utf16leSlice(this, start, end);\n                default:\n                    if (loweredCase)\n                        throw new TypeError(`Unknown encoding: ${encoding}`);\n                    encoding = `${encoding}`.toLowerCase();\n                    loweredCase = true;\n            }\n        }\n    }\n}\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n}\nfunction wrtBigUInt64LE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number((value >> BigInt(32)) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction wrtBigUInt64BE(buf, value, offset, min, max) {\n    checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number((value >> BigInt(32)) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\n// Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n// Object.setPrototypeOf(Buffer, Uint8Array);\nfunction assertSize(size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be of type number');\n    }\n    else if (size < 0) {\n        throw new RangeError(`The value \"${size}\" is invalid for option \"size\"`);\n    }\n}\nfunction alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return new Buffer(size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpreted as a start offset.\n        return typeof encoding === 'string'\n            ? new Buffer(size).fill(fill, encoding)\n            : new Buffer(size).fill(fill);\n    }\n    return new Buffer(size);\n}\nfunction fromString(string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8';\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError(`Unknown encoding: ${encoding}`);\n    }\n    const length = byteLength(string, encoding) | 0;\n    let buf = new Buffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}\nfunction fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : checked(array.length) | 0;\n    const buf = new Buffer(length);\n    for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}\nfunction fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return fromArrayLike(arrayView);\n}\nfunction fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    let buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    }\n    else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, Buffer.prototype);\n    return buf;\n}\nfunction fromObject(obj) {\n    if (Buffer.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = new Buffer(len);\n        if (buf.length === 0) {\n            return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n            return new Buffer(0);\n        }\n        return fromArrayLike(obj);\n    }\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n    }\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength) {\n        throw new RangeError(`${'Attempt to allocate Buffer larger than maximum ' + 'size: 0x'}${kMaxLength.toString(16)} bytes`);\n    }\n    return length | 0;\n}\nfunction byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        throw new TypeError(`${'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n            'Received type '}${typeof string}`);\n    }\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0)\n        return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len;\n            case 'utf8':\n            case 'utf-8':\n                return utf8ToBytes(string).length;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2;\n            case 'hex':\n                return len >>> 1;\n            case 'base64':\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                }\n                encoding = `${encoding}`.toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// Buffer.byteLength = byteLength;\nfunction swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0)\n        return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    }\n    else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    }\n    else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = Number(byteOffset); // Coerce to Number.\n    if (numberIsNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir)\n            return -1;\n        byteOffset = buffer.length - 1;\n    }\n    else if (byteOffset < 0) {\n        if (dir)\n            byteOffset = 0;\n        else\n            return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    }\n    else if (typeof val === 'number') {\n        val = val & 0xff; // Search for a byte value [0-255]\n        if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            }\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' ||\n            encoding === 'ucs-2' ||\n            encoding === 'utf16le' ||\n            encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        }\n        return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1)\n                    foundIndex = i;\n                if (i - foundIndex + 1 === valLength)\n                    return foundIndex * indexSize;\n            }\n            else {\n                if (foundIndex !== -1)\n                    i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    }\n    else {\n        if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            let found = true;\n            for (let j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found)\n                return i;\n        }\n    }\n    return -1;\n}\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    }\n    else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    let i;\n    for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed))\n            return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n    }\n    return base64.fromByteArray(buf.slice(start, end));\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let fourthByte;\n            let secondByte;\n            let tempCodePoint;\n            let thirdByte;\n            switch (bytesPerSequence) {\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xc0) === 0x80) {\n                        tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);\n                        if (tempCodePoint > 0x7f) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);\n                        if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xc0) === 0x80 &&\n                        (thirdByte & 0xc0) === 0x80 &&\n                        (fourthByte & 0xc0) === 0x80) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0x12) |\n                                ((secondByte & 0x3f) << 0xc) |\n                                ((thirdByte & 0x3f) << 0x6) |\n                                (fourthByte & 0x3f);\n                        if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xfffd;\n            bytesPerSequence = 1;\n        }\n        else if (codePoint > 0xffff) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = '';\n    let i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7f);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0)\n        start = 0;\n    if (!end || end < 0 || end > len)\n        end = len;\n    let out = '';\n    for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = '';\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError('offset is not uint');\n    if (offset + ext > length)\n        throw new RangeError('Trying to access beyond buffer length');\n}\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n    if (offset < 0)\n        throw new RangeError('Index out of range');\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = Number(value);\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = Number(value);\n    offset = offset >>> 0;\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n// CUSTOM ERRORS\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {};\nfunction E(sym, getMessage, Base) {\n    errors[sym] = class NodeError extends Base {\n        constructor() {\n            super();\n            Object.defineProperty(this, 'message', {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack; // eslint-disable-line no-unused-expressions\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, 'code', {\n                configurable: true,\n                enumerable: true,\n                value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\nE('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {\n    if (name) {\n        return `${name} is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\nE('ERR_INVALID_ARG_TYPE', function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\nE('ERR_OUT_OF_RANGE', function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n        received = addNumericalSeparator(String(input));\n    }\n    else if (typeof input === 'bigint') {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n        }\n        received += 'n';\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction addNumericalSeparator(val) {\n    let res = '';\n    let i = val.length;\n    const start = val[0] === '-' ? 1 : 0;\n    for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n    }\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\nfunction checkBounds(buf, offset, byteLength) {\n    validateNumber(offset, 'offset');\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n        boundsError(offset, buf.length - (byteLength + 1));\n    }\n}\nfunction checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === 'bigint' ? 'n' : '';\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) {\n                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            }\n            else {\n                range =\n                    `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                        `${(byteLength + 1) * 8 - 1}${n}`;\n            }\n        }\n        else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE('value', range, value);\n    }\n    checkBounds(buf, offset, byteLength);\n}\nfunction validateNumber(value, name) {\n    if (typeof value !== 'number') {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n    }\n}\nfunction boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n    }\n    if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split('=')[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace(INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2)\n        return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n        str = `${str}=`;\n    }\n    return str;\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xd7ff && codePoint < 0xe000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xdbff) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xef, 0xbf, 0xbd);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xef, 0xbf, 0xbd);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xdc00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xef, 0xbf, 0xbd);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xef, 0xbf, 0xbd);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push((codePoint >> 0x12) | 0xf0, ((codePoint >> 0xc) & 0x3f) | 0x80, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    const byteArray = [];\n    for (let i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xff);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    let c;\n    let hi;\n    let lo;\n    const byteArray = [];\n    for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n            break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    let i;\n    for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length)\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance(obj, type) {\n    return (obj instanceof type ||\n        (obj != null &&\n            obj.constructor != null &&\n            obj.constructor.name != null &&\n            obj.constructor.name === type.name));\n}\nfunction numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj; // eslint-disable-line no-self-compare\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n    const alphabet = '0123456789abcdef';\n    const table = new Array(256);\n    for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n            table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n    }\n    return table;\n})();\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Buffer as BufferPolyfill } from \"./buffer.js\";\n/** Install Node.js Buffer polyfill (NO-OP in Node.js) */\nexport function installBufferPolyfill() {\n    // @ts-ignore\n    globalThis.Buffer = globalThis.Buffer || BufferPolyfill;\n    // @ts-ignore\n    return globalThis.Buffer;\n}\n", "import { installBufferPolyfill } from \"./buffer-polyfill.node.js\";\n// @ts-ignore\nglobalThis.process = globalThis.process || {};\n// @ts-ignore\nglobalThis.process.env = globalThis.process.env || {};\nexport const Buffer = installBufferPolyfill();\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BlobFile } from '@loaders.gl/loader-utils';\nimport { parseParquetFile, parseParquetFileInBatches } from \"./lib/parsers/parse-parquet.js\";\nimport { parseGeoParquetFile, parseGeoParquetFileInBatches } from \"./lib/parsers/parse-geoparquet.js\";\nimport { parseParquetFileInColumns, parseParquetFileInColumnarBatches } from \"./lib/parsers/parse-parquet-to-columns.js\";\n// Note: The Buffer polyfill is quite fragile\n// For some reason, just exporting directly fails with some bundlers\n// export {Buffer} from './polyfills/buffer/install-buffer-polyfill';\nimport { Buffer } from \"./polyfills/buffer/install-buffer-polyfill.js\";\nexport { Buffer };\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * ParquetJS table loader\n */\nexport const ParquetWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Apache Parquet',\n    id: 'parquet',\n    module: 'parquet',\n    version: VERSION,\n    worker: false,\n    category: 'table',\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['PAR1', 'PARE'],\n    options: {\n        parquet: {\n            shape: 'object-row-table',\n            columnList: [],\n            geoparquet: true,\n            url: undefined,\n            preserveBinary: false\n        }\n    }\n};\n/** ParquetJS table loader */\nexport const ParquetLoader = {\n    ...ParquetWorkerLoader,\n    dataType: null,\n    batchType: null,\n    parse: (arrayBuffer, options) => parseParquetFile(new BlobFile(arrayBuffer), options),\n    parseFile: parseParquetFile,\n    parseFileInBatches: parseParquetFileInBatches\n};\n// Defeat tree shaking\n// @ts-ignore\nParquetLoader.Buffer = Buffer;\nexport const GeoParquetWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Apache Parquet',\n    id: 'parquet',\n    module: 'parquet',\n    version: VERSION,\n    worker: true,\n    category: 'table',\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['PAR1', 'PARE'],\n    options: {\n        parquet: {\n            shape: 'geojson-table',\n            columnList: [],\n            geoparquet: true,\n            url: undefined,\n            preserveBinary: false\n        }\n    }\n};\n/** ParquetJS table loader */\nexport const GeoParquetLoader = {\n    ...GeoParquetWorkerLoader,\n    parse(arrayBuffer, options) {\n        return parseGeoParquetFile(new BlobFile(arrayBuffer), options);\n    },\n    parseFile: parseGeoParquetFile,\n    parseFileInBatches: parseGeoParquetFileInBatches\n};\n/** @deprecated Test to see if we can improve perf of parquetjs loader */\nexport const ParquetColumnarWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Apache Parquet',\n    id: 'parquet',\n    module: 'parquet',\n    version: VERSION,\n    worker: true,\n    category: 'table',\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['PAR1', 'PARE'],\n    options: ParquetLoader.options\n};\n/** @deprecated Test to see if we can improve perf of parquetjs loader */\nexport const ParquetColumnarLoader = {\n    ...ParquetColumnarWorkerLoader,\n    parse(arrayBuffer, options) {\n        return parseParquetFileInColumns(new BlobFile(arrayBuffer), options);\n    },\n    parseFile: parseParquetFileInColumns,\n    parseFileInBatches: parseParquetFileInColumnarBatches\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { default as log } from '@probe.gl/log';\nimport { ParquetReader } from \"../../parquetjs/parser/parquet-reader.js\";\nimport { getSchemaFromParquetReader } from \"./get-parquet-schema.js\";\nimport { installBufferPolyfill } from \"../../polyfills/buffer/index.js\";\nimport { preloadCompressions } from \"../../parquetjs/compression.js\";\n/**\n *  * Parse a parquet file using parquetjs\n * @param file\n * @param options\n * @returns\n */\nexport async function parseParquetFile(file, options) {\n    installBufferPolyfill();\n    await preloadCompressions(options);\n    const reader = new ParquetReader(file, {\n        preserveBinary: options?.parquet?.preserveBinary\n    });\n    const schema = await getSchemaFromParquetReader(reader);\n    const rows = [];\n    const rowBatches = reader.rowBatchIterator(options?.parquet);\n    for await (const rowBatch of rowBatches) {\n        let limitHasReached = false;\n        // we have only one input batch so return\n        for (const row of rowBatch) {\n            if (options?.limit && rows.length >= options?.limit) {\n                limitHasReached = true;\n                break;\n            }\n            rows.push(row);\n        }\n        if (limitHasReached) {\n            log.warn(`Rows number limit has been reached. Only first ${options?.limit} are loaded`)();\n            break;\n        }\n    }\n    const objectRowTable = {\n        shape: 'object-row-table',\n        schema,\n        data: rows\n    };\n    const shape = options?.parquet?.shape;\n    return convertTable(objectRowTable, shape);\n}\n/**\n * Parse a parquet file in batches using parquetjs\n * @param file\n * @param options\n */\nexport async function* parseParquetFileInBatches(file, options) {\n    installBufferPolyfill();\n    await preloadCompressions(options);\n    const reader = new ParquetReader(file, {\n        preserveBinary: options?.parquet?.preserveBinary\n    });\n    const schema = await getSchemaFromParquetReader(reader);\n    const rowBatches = reader.rowBatchIterator(options?.parquet);\n    for await (const rows of rowBatches) {\n        const objectRowTable = {\n            shape: 'object-row-table',\n            schema,\n            data: rows\n        };\n        const shape = options?.parquet?.shape;\n        const table = convertTable(objectRowTable, shape);\n        yield {\n            batchType: 'data',\n            schema,\n            ...table,\n            length: rows.length\n        };\n    }\n}\nfunction convertTable(objectRowTable, shape) {\n    switch (shape) {\n        case 'object-row-table':\n            return objectRowTable;\n        // Hack until geoparquet fixes up forwarded shape\n        case 'geojson-table':\n            return objectRowTable;\n        default:\n            throw new Error(shape);\n    }\n}\n", "import INT53 from 'int53';\nexport function encodeValues(type, values, opts) {\n    switch (type) {\n        case 'BOOLEAN':\n            return encodeValues_BOOLEAN(values);\n        case 'INT32':\n            return encodeValues_INT32(values);\n        case 'INT64':\n            return encodeValues_INT64(values);\n        case 'INT96':\n            return encodeValues_INT96(values);\n        case 'FLOAT':\n            return encodeValues_FLOAT(values);\n        case 'DOUBLE':\n            return encodeValues_DOUBLE(values);\n        case 'BYTE_ARRAY':\n            return encodeValues_BYTE_ARRAY(values);\n        case 'FIXED_LEN_BYTE_ARRAY':\n            return encodeValues_FIXED_LEN_BYTE_ARRAY(values, opts);\n        default:\n            throw new Error(`unsupported type: ${type}`);\n    }\n}\nexport function decodeValues(type, cursor, count, opts) {\n    switch (type) {\n        case 'BOOLEAN':\n            return decodeValues_BOOLEAN(cursor, count);\n        case 'INT32':\n            return decodeValues_INT32(cursor, count);\n        case 'INT64':\n            return decodeValues_INT64(cursor, count);\n        case 'INT96':\n            return decodeValues_INT96(cursor, count);\n        case 'FLOAT':\n            return decodeValues_FLOAT(cursor, count);\n        case 'DOUBLE':\n            return decodeValues_DOUBLE(cursor, count);\n        case 'BYTE_ARRAY':\n            return decodeValues_BYTE_ARRAY(cursor, count);\n        case 'FIXED_LEN_BYTE_ARRAY':\n            return decodeValues_FIXED_LEN_BYTE_ARRAY(cursor, count, opts);\n        default:\n            throw new Error(`unsupported type: ${type}`);\n    }\n}\nfunction encodeValues_BOOLEAN(values) {\n    const buf = Buffer.alloc(Math.ceil(values.length / 8));\n    buf.fill(0);\n    for (let i = 0; i < values.length; i++) {\n        if (values[i]) {\n            buf[Math.floor(i / 8)] |= 1 << i % 8;\n        }\n    }\n    return buf;\n}\nfunction decodeValues_BOOLEAN(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        const b = cursor.buffer[cursor.offset + Math.floor(i / 8)];\n        values.push((b & (1 << i % 8)) > 0);\n    }\n    cursor.offset += Math.ceil(count / 8);\n    return values;\n}\nfunction encodeValues_INT32(values) {\n    const buf = Buffer.alloc(4 * values.length);\n    for (let i = 0; i < values.length; i++) {\n        buf.writeInt32LE(values[i], i * 4);\n    }\n    return buf;\n}\nfunction decodeValues_INT32(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        values.push(cursor.buffer.readInt32LE(cursor.offset));\n        cursor.offset += 4;\n    }\n    return values;\n}\nfunction encodeValues_INT64(values) {\n    const buf = Buffer.alloc(8 * values.length);\n    for (let i = 0; i < values.length; i++) {\n        INT53.writeInt64LE(values[i], buf, i * 8);\n    }\n    return buf;\n}\nfunction decodeValues_INT64(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        values.push(INT53.readInt64LE(cursor.buffer, cursor.offset));\n        cursor.offset += 8;\n    }\n    return values;\n}\nfunction encodeValues_INT96(values) {\n    const buf = Buffer.alloc(12 * values.length);\n    for (let i = 0; i < values.length; i++) {\n        if (values[i] >= 0) {\n            INT53.writeInt64LE(values[i], buf, i * 12);\n            buf.writeUInt32LE(0, i * 12 + 8); // truncate to 64 actual precision\n        }\n        else {\n            INT53.writeInt64LE(~-values[i] + 1, buf, i * 12);\n            buf.writeUInt32LE(0xffffffff, i * 12 + 8); // truncate to 64 actual precision\n        }\n    }\n    return buf;\n}\nfunction decodeValues_INT96(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        const low = INT53.readInt64LE(cursor.buffer, cursor.offset);\n        const high = cursor.buffer.readUInt32LE(cursor.offset + 8);\n        if (high === 0xffffffff) {\n            values.push(~-low + 1); // truncate to 64 actual precision\n        }\n        else {\n            values.push(low); // truncate to 64 actual precision\n        }\n        cursor.offset += 12;\n    }\n    return values;\n}\nfunction encodeValues_FLOAT(values) {\n    const buf = Buffer.alloc(4 * values.length);\n    for (let i = 0; i < values.length; i++) {\n        buf.writeFloatLE(values[i], i * 4);\n    }\n    return buf;\n}\nfunction decodeValues_FLOAT(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        values.push(cursor.buffer.readFloatLE(cursor.offset));\n        cursor.offset += 4;\n    }\n    return values;\n}\nfunction encodeValues_DOUBLE(values) {\n    const buf = Buffer.alloc(8 * values.length);\n    for (let i = 0; i < values.length; i++) {\n        buf.writeDoubleLE(values[i], i * 8);\n    }\n    return buf;\n}\nfunction decodeValues_DOUBLE(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        values.push(cursor.buffer.readDoubleLE(cursor.offset));\n        cursor.offset += 8;\n    }\n    return values;\n}\nfunction encodeValues_BYTE_ARRAY(values) {\n    // tslint:disable-next-line:variable-name\n    let buf_len = 0;\n    for (let i = 0; i < values.length; i++) {\n        values[i] = Buffer.from(values[i]);\n        buf_len += 4 + values[i].length;\n    }\n    const buf = Buffer.alloc(buf_len);\n    // tslint:disable-next-line:variable-name\n    let buf_pos = 0;\n    for (let i = 0; i < values.length; i++) {\n        buf.writeUInt32LE(values[i].length, buf_pos);\n        values[i].copy(buf, buf_pos + 4);\n        buf_pos += 4 + values[i].length;\n    }\n    return buf;\n}\nfunction decodeValues_BYTE_ARRAY(cursor, count) {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n        const len = cursor.buffer.readUInt32LE(cursor.offset);\n        cursor.offset += 4;\n        // values.push(cursor.buffer.buffer.slice(cursor.offset, cursor.offset + len));\n        values.push(cursor.buffer.slice(cursor.offset, cursor.offset + len));\n        cursor.offset += len;\n    }\n    return values;\n}\nfunction encodeValues_FIXED_LEN_BYTE_ARRAY(values, opts) {\n    if (!opts.typeLength) {\n        throw new Error('missing option: typeLength (required for FIXED_LEN_BYTE_ARRAY)');\n    }\n    for (let i = 0; i < values.length; i++) {\n        values[i] = Buffer.from(values[i]);\n        if (values[i].length !== opts.typeLength) {\n            throw new Error(`invalid value for FIXED_LEN_BYTE_ARRAY: ${values[i]}`);\n        }\n    }\n    return Buffer.concat(values);\n}\nfunction decodeValues_FIXED_LEN_BYTE_ARRAY(cursor, count, opts) {\n    const values = [];\n    if (!opts.typeLength) {\n        throw new Error('missing option: typeLength (required for FIXED_LEN_BYTE_ARRAY)');\n    }\n    for (let i = 0; i < count; i++) {\n        values.push(cursor.buffer.slice(cursor.offset, cursor.offset + opts.typeLength));\n        cursor.offset += opts.typeLength;\n    }\n    return values;\n}\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\nimport varint from 'varint';\n// eslint-disable-next-line max-statements, complexity\nexport function encodeValues(type, values, opts) {\n    if (!('bitWidth' in opts)) {\n        throw new Error('bitWidth is required');\n    }\n    switch (type) {\n        case 'BOOLEAN':\n        case 'INT32':\n        case 'INT64':\n            // tslint:disable-next-line:no-parameter-reassignment\n            values = values.map((x) => parseInt(x, 10));\n            break;\n        default:\n            throw new Error(`unsupported type: ${type}`);\n    }\n    let buf = Buffer.alloc(0);\n    let run = [];\n    let repeats = 0;\n    for (let i = 0; i < values.length; i++) {\n        // If we are at the beginning of a run and the next value is same we start\n        // collecting repeated values\n        if (repeats === 0 && run.length % 8 === 0 && values[i] === values[i + 1]) {\n            // If we have any data in runs we need to encode them\n            if (run.length) {\n                buf = Buffer.concat([buf, encodeRunBitpacked(run, opts)]);\n                run = [];\n            }\n            repeats = 1;\n        }\n        else if (repeats > 0 && values[i] === values[i - 1]) {\n            repeats += 1;\n        }\n        else {\n            // If values changes we need to post any previous repeated values\n            if (repeats) {\n                buf = Buffer.concat([buf, encodeRunRepeated(values[i - 1], repeats, opts)]);\n                repeats = 0;\n            }\n            run.push(values[i]);\n        }\n    }\n    if (repeats) {\n        buf = Buffer.concat([buf, encodeRunRepeated(values[values.length - 1], repeats, opts)]);\n    }\n    else if (run.length) {\n        buf = Buffer.concat([buf, encodeRunBitpacked(run, opts)]);\n    }\n    if (opts.disableEnvelope) {\n        return buf;\n    }\n    const envelope = Buffer.alloc(buf.length + 4);\n    // @ts-ignore buffer polyfill\n    envelope.writeUInt32LE(buf.length, undefined);\n    buf.copy(envelope, 4);\n    return envelope;\n}\nexport function decodeValues(type, cursor, count, opts) {\n    if (!('bitWidth' in opts)) {\n        throw new Error('bitWidth is required');\n    }\n    if (!opts.disableEnvelope) {\n        cursor.offset += 4;\n    }\n    let values = [];\n    while (values.length < count) {\n        const header = varint.decode(cursor.buffer, cursor.offset);\n        cursor.offset += varint.encodingLength(header);\n        let decodedValues;\n        if (header & 1) {\n            const count = (header >> 1) * 8;\n            decodedValues = decodeRunBitpacked(cursor, count, opts);\n        }\n        else {\n            const count = header >> 1;\n            decodedValues = decodeRunRepeated(cursor, count, opts);\n        }\n        // strange failure in docusaurus / webpack if we don't cast the type here\n        for (const value of decodedValues) {\n            values.push(value);\n        }\n    }\n    values = values.slice(0, count);\n    if (values.length !== count) {\n        throw new Error('invalid RLE encoding');\n    }\n    return values;\n}\nfunction decodeRunBitpacked(cursor, count, opts) {\n    // @ts-ignore\n    const bitWidth = opts.bitWidth;\n    if (count % 8 !== 0) {\n        throw new Error('must be a multiple of 8');\n    }\n    // tslint:disable-next-line:prefer-array-literal\n    const values = new Array(count).fill(0);\n    for (let b = 0; b < bitWidth * count; b++) {\n        if (cursor.buffer[cursor.offset + Math.floor(b / 8)] & (1 << b % 8)) {\n            values[Math.floor(b / bitWidth)] |= 1 << b % bitWidth;\n        }\n    }\n    cursor.offset += bitWidth * (count / 8);\n    return values;\n}\nfunction decodeRunRepeated(cursor, count, opts) {\n    // @ts-ignore\n    const bitWidth = opts.bitWidth;\n    let value = 0;\n    for (let i = 0; i < Math.ceil(bitWidth / 8); i++) {\n        // eslint-disable-next-line\n        value << 8; //  TODO - this looks wrong\n        value += cursor.buffer[cursor.offset];\n        cursor.offset += 1;\n    }\n    // tslint:disable-next-line:prefer-array-literal\n    return new Array(count).fill(value);\n}\nfunction encodeRunBitpacked(values, opts) {\n    // @ts-ignore\n    const bitWidth = opts.bitWidth;\n    for (let i = 0; i < values.length % 8; i++) {\n        values.push(0);\n    }\n    const buf = Buffer.alloc(Math.ceil(bitWidth * (values.length / 8)));\n    for (let b = 0; b < bitWidth * values.length; b++) {\n        if ((values[Math.floor(b / bitWidth)] & (1 << b % bitWidth)) > 0) {\n            buf[Math.floor(b / 8)] |= 1 << b % 8;\n        }\n    }\n    return Buffer.concat([Buffer.from(varint.encode(((values.length / 8) << 1) | 1)), buf]);\n}\nfunction encodeRunRepeated(value, count, opts) {\n    // @ts-ignore\n    const bitWidth = opts.bitWidth;\n    const buf = Buffer.alloc(Math.ceil(bitWidth / 8));\n    for (let i = 0; i < buf.length; i++) {\n        buf.writeUInt8(value & 0xff, i);\n        // eslint-disable-next-line\n        value >> 8; //  TODO - this looks wrong\n    }\n    return Buffer.concat([Buffer.from(varint.encode(count << 1)), buf]);\n}\n", "import { decodeValues as decodeRleValues } from \"./rle.js\";\nexport function decodeValues(type, cursor, count, opts) {\n    opts.bitWidth = cursor.buffer.slice(cursor.offset, cursor.offset + 1).readInt8(0);\n    cursor.offset += 1;\n    return decodeRleValues(type, cursor, count, { ...opts, disableEnvelope: true });\n}\nexport function encodeValues(type, cursor, count, opts) {\n    throw new Error('Encode dictionary functionality is not supported');\n}\n", "import * as PLAIN from \"./plain.js\";\nimport * as RLE from \"./rle.js\";\nimport * as DICTIONARY from \"./dictionary.js\";\nexport * from \"./declare.js\";\nexport const PARQUET_CODECS = {\n    PLAIN: {\n        encodeValues: PLAIN.encodeValues,\n        decodeValues: PLAIN.decodeValues\n    },\n    RLE: {\n        encodeValues: RLE.encodeValues,\n        decodeValues: RLE.decodeValues\n    },\n    // Using the PLAIN_DICTIONARY enum value is deprecated in the Parquet 2.0 specification.\n    PLAIN_DICTIONARY: {\n        // @ts-ignore\n        encodeValues: DICTIONARY.encodeValues,\n        decodeValues: DICTIONARY.decodeValues\n    },\n    // Prefer using RLE_DICTIONARY in a data page and PLAIN in a dictionary page for Parquet 2.0+ files.\n    RLE_DICTIONARY: {\n        // @ts-ignore\n        encodeValues: DICTIONARY.encodeValues,\n        decodeValues: DICTIONARY.decodeValues\n    }\n};\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\n/* eslint-disable camelcase */\n// Forked from https://github.com/ironSource/parquetjs under MIT license\nimport { NoCompression, GZipCompression, SnappyCompression, BrotliCompression, \n// LZOCompression,\nLZ4Compression, ZstdCompression } from '@loaders.gl/compression';\nimport { registerJSModules } from '@loaders.gl/loader-utils';\n/** We can't use loaders-util buffer handling since we are dependent on buffers even in the browser */\nfunction toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n}\nfunction toArrayBuffer(buffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    if (Buffer.isBuffer(buffer)) {\n        const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);\n        return typedArray.slice().buffer;\n    }\n    return buffer;\n}\n// TODO switch to worker compression to avoid bundling...\n// import brotli from 'brotli'; - brotli has problems with decompress in browsers\n// import brotliDecompress from 'brotli/decompress';\nimport lz4js from 'lz4js';\n// import lzo from 'lzo';\n// import {ZstdCodec} from 'zstd-codec';\n// Inject large dependencies through Compression constructor options\nconst modules = {\n    // brotli has problems with decompress in browsers\n    // brotli: {\n    //   decompress: brotliDecompress,\n    //   compress: () => {\n    //     throw new Error('brotli compress');\n    //   }\n    // },\n    lz4js\n    // lzo\n    // 'zstd-codec': ZstdCodec\n};\n/**\n * See https://github.com/apache/parquet-format/blob/master/Compression.md\n */\n// @ts-expect-error\nexport const PARQUET_COMPRESSION_METHODS = {\n    UNCOMPRESSED: new NoCompression(),\n    GZIP: new GZipCompression(),\n    SNAPPY: new SnappyCompression(),\n    BROTLI: new BrotliCompression({ modules }),\n    // TODO: Understand difference between LZ4 and LZ4_RAW\n    LZ4: new LZ4Compression({ modules }),\n    LZ4_RAW: new LZ4Compression({ modules }),\n    //\n    // LZO: new LZOCompression({modules}),\n    ZSTD: new ZstdCompression({ modules })\n};\n/**\n * Register compressions that have big external libraries\n * @param options.modules External library dependencies\n */\nexport async function preloadCompressions(options) {\n    registerJSModules(options?.modules);\n    const compressions = Object.values(PARQUET_COMPRESSION_METHODS);\n    return await Promise.all(compressions.map((compression) => compression.preload(options?.modules)));\n}\n/**\n * Deflate a value using compression method `method`\n */\nexport async function deflate(method, value) {\n    const compression = PARQUET_COMPRESSION_METHODS[method];\n    if (!compression) {\n        throw new Error(`parquet: invalid compression method: ${method}`);\n    }\n    const inputArrayBuffer = toArrayBuffer(value);\n    const compressedArrayBuffer = await compression.compress(inputArrayBuffer);\n    return toBuffer(compressedArrayBuffer);\n}\n/**\n * Inflate a value using compression method `method`\n */\nexport async function decompress(method, value, size) {\n    const compression = PARQUET_COMPRESSION_METHODS[method];\n    if (!compression) {\n        throw new Error(`parquet: invalid compression method: ${method}`);\n    }\n    const inputArrayBuffer = toArrayBuffer(value);\n    const compressedArrayBuffer = await compression.decompress(inputArrayBuffer, size);\n    return toBuffer(compressedArrayBuffer);\n}\n/*\n * Inflate a value using compression method `method`\n */\nexport function inflate(method, value, size) {\n    if (!(method in PARQUET_COMPRESSION_METHODS)) {\n        throw new Error(`invalid compression method: ${method}`);\n    }\n    // @ts-ignore\n    return PARQUET_COMPRESSION_METHODS[method].inflate(value, size);\n}\n/*\nfunction deflate_identity(value: Buffer): Buffer {\n  return value;\n}\n\nfunction deflate_gzip(value: Buffer): Buffer {\n  return zlib.gzipSync(value);\n}\n\nfunction deflate_snappy(value: Buffer): Buffer {\n  return snappyjs.compress(value);\n}\n\nfunction deflate_lzo(value: Buffer): Buffer {\n  lzo = lzo || Util.load('lzo');\n  return lzo.compress(value);\n}\n\nfunction deflate_brotli(value: Buffer): Buffer {\n  brotli = brotli || Util.load('brotli');\n  const result = brotli.compress(value, {\n    mode: 0,\n    quality: 8,\n    lgwin: 22\n  });\n  return result ? Buffer.from(result) : Buffer.alloc(0);\n}\n\nfunction deflate_lz4(value: Buffer): Buffer {\n  lz4js = lz4js || Util.load('lz4js');\n  try {\n    // let result = Buffer.alloc(lz4js.encodeBound(value.length));\n    // const compressedSize = lz4.encodeBlock(value, result);\n    // // remove unnecessary bytes\n    // result = result.slice(0, compressedSize);\n    // return result;\n    return Buffer.from(lz4js.compress(value));\n  } catch (err) {\n    throw err;\n  }\n}\nfunction inflate_identity(value: Buffer): Buffer {\n  return value;\n}\n\nfunction inflate_gzip(value: Buffer): Buffer {\n  return zlib.gunzipSync(value);\n}\n\nfunction inflate_snappy(value: Buffer): Buffer {\n  return snappyjs.uncompress(value);\n}\n\nfunction inflate_lzo(value: Buffer, size: number): Buffer {\n  lzo = lzo || Util.load('lzo');\n  return lzo.decompress(value, size);\n}\n\nfunction inflate_lz4(value: Buffer, size: number): Buffer {\n  lz4js = lz4js || Util.load('lz4js');\n  try {\n    // let result = Buffer.alloc(size);\n    // const uncompressedSize = lz4js.decodeBlock(value, result);\n    // // remove unnecessary bytes\n    // result = result.slice(0, uncompressedSize);\n    // return result;\n    return Buffer.from(lz4js.decompress(value, size));\n  } catch (err) {\n    throw err;\n  }\n}\n\nfunction inflate_brotli(value: Buffer): Buffer {\n  brotli = brotli || Util.load('brotli');\n  if (!value.length) {\n    return Buffer.alloc(0);\n  }\n  return Buffer.from(brotli.decompress(value));\n}\n*/\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\n/* eslint-disable camelcase */\nimport { BSONLoader, BSONWriter } from '@loaders.gl/bson';\nexport const PARQUET_LOGICAL_TYPES = {\n    BOOLEAN: {\n        primitiveType: 'BOOLEAN',\n        toPrimitive: toPrimitive_BOOLEAN,\n        fromPrimitive: fromPrimitive_BOOLEAN\n    },\n    INT32: {\n        primitiveType: 'INT32',\n        toPrimitive: toPrimitive_INT32\n    },\n    INT64: {\n        primitiveType: 'INT64',\n        toPrimitive: toPrimitive_INT64\n    },\n    INT96: {\n        primitiveType: 'INT96',\n        toPrimitive: toPrimitive_INT96\n    },\n    FLOAT: {\n        primitiveType: 'FLOAT',\n        toPrimitive: toPrimitive_FLOAT\n    },\n    DOUBLE: {\n        primitiveType: 'DOUBLE',\n        toPrimitive: toPrimitive_DOUBLE\n    },\n    BYTE_ARRAY: {\n        primitiveType: 'BYTE_ARRAY',\n        toPrimitive: toPrimitive_BYTE_ARRAY\n    },\n    FIXED_LEN_BYTE_ARRAY: {\n        primitiveType: 'FIXED_LEN_BYTE_ARRAY',\n        toPrimitive: toPrimitive_BYTE_ARRAY\n    },\n    UTF8: {\n        primitiveType: 'BYTE_ARRAY',\n        originalType: 'UTF8',\n        toPrimitive: toPrimitive_UTF8,\n        fromPrimitive: fromPrimitive_UTF8\n    },\n    TIME_MILLIS: {\n        primitiveType: 'INT32',\n        originalType: 'TIME_MILLIS',\n        toPrimitive: toPrimitive_TIME_MILLIS\n    },\n    TIME_MICROS: {\n        primitiveType: 'INT64',\n        originalType: 'TIME_MICROS',\n        toPrimitive: toPrimitive_TIME_MICROS\n    },\n    DATE: {\n        primitiveType: 'INT32',\n        originalType: 'DATE',\n        toPrimitive: toPrimitive_DATE,\n        fromPrimitive: fromPrimitive_DATE\n    },\n    TIMESTAMP_MILLIS: {\n        primitiveType: 'INT64',\n        originalType: 'TIMESTAMP_MILLIS',\n        toPrimitive: toPrimitive_TIMESTAMP_MILLIS,\n        fromPrimitive: fromPrimitive_TIMESTAMP_MILLIS\n    },\n    TIMESTAMP_MICROS: {\n        primitiveType: 'INT64',\n        originalType: 'TIMESTAMP_MICROS',\n        toPrimitive: toPrimitive_TIMESTAMP_MICROS,\n        fromPrimitive: fromPrimitive_TIMESTAMP_MICROS\n    },\n    UINT_8: {\n        primitiveType: 'INT32',\n        originalType: 'UINT_8',\n        toPrimitive: toPrimitive_UINT8\n    },\n    UINT_16: {\n        primitiveType: 'INT32',\n        originalType: 'UINT_16',\n        toPrimitive: toPrimitive_UINT16\n    },\n    UINT_32: {\n        primitiveType: 'INT32',\n        originalType: 'UINT_32',\n        toPrimitive: toPrimitive_UINT32\n    },\n    UINT_64: {\n        primitiveType: 'INT64',\n        originalType: 'UINT_64',\n        toPrimitive: toPrimitive_UINT64\n    },\n    INT_8: {\n        primitiveType: 'INT32',\n        originalType: 'INT_8',\n        toPrimitive: toPrimitive_INT8\n    },\n    INT_16: {\n        primitiveType: 'INT32',\n        originalType: 'INT_16',\n        toPrimitive: toPrimitive_INT16\n    },\n    INT_32: {\n        primitiveType: 'INT32',\n        originalType: 'INT_32',\n        toPrimitive: toPrimitive_INT32\n    },\n    INT_64: {\n        primitiveType: 'INT64',\n        originalType: 'INT_64',\n        toPrimitive: toPrimitive_INT64\n    },\n    JSON: {\n        primitiveType: 'BYTE_ARRAY',\n        originalType: 'JSON',\n        toPrimitive: toPrimitive_JSON,\n        fromPrimitive: fromPrimitive_JSON\n    },\n    BSON: {\n        primitiveType: 'BYTE_ARRAY',\n        originalType: 'BSON',\n        toPrimitive: toPrimitive_BSON,\n        fromPrimitive: fromPrimitive_BSON\n    },\n    INTERVAL: {\n        primitiveType: 'FIXED_LEN_BYTE_ARRAY',\n        originalType: 'INTERVAL',\n        typeLength: 12,\n        toPrimitive: toPrimitive_INTERVAL,\n        fromPrimitive: fromPrimitive_INTERVAL\n    },\n    DECIMAL_INT32: {\n        primitiveType: 'INT32',\n        originalType: 'DECIMAL_INT32',\n        toPrimitive: decimalToPrimitive_INT32,\n        fromPrimitive: decimalFromPrimitive_INT\n    },\n    DECIMAL_INT64: {\n        primitiveType: 'INT64',\n        originalType: 'DECIMAL_INT64',\n        toPrimitive: decimalToPrimitive_INT64,\n        fromPrimitive: decimalFromPrimitive_INT\n    },\n    DECIMAL_BYTE_ARRAY: {\n        primitiveType: 'BYTE_ARRAY',\n        originalType: 'DECIMAL_BYTE_ARRAY',\n        toPrimitive: decimalToPrimitive_BYTE_ARRAY,\n        fromPrimitive: decimalFromPrimitive_BYTE_ARRAY\n    },\n    DECIMAL_FIXED_LEN_BYTE_ARRAY: {\n        primitiveType: 'FIXED_LEN_BYTE_ARRAY',\n        originalType: 'DECIMAL_FIXED_LEN_BYTE_ARRAY',\n        toPrimitive: decimalToPrimitive_BYTE_ARRAY,\n        fromPrimitive: decimalFromPrimitive_BYTE_ARRAY\n    }\n};\n/**\n * Convert a value from it's native representation to the internal/underlying\n * primitive type\n */\nexport function toPrimitive(type, value, field) {\n    if (!(type in PARQUET_LOGICAL_TYPES)) {\n        throw new Error(`invalid type: ${type}`);\n    }\n    return PARQUET_LOGICAL_TYPES[type].toPrimitive(value, field);\n}\n/**\n * Convert a value from it's internal/underlying primitive representation to\n * the native representation\n */\nexport function fromPrimitive(type, value, field) {\n    if (!(type in PARQUET_LOGICAL_TYPES)) {\n        throw new Error(`invalid type: ${type}`);\n    }\n    if ('fromPrimitive' in PARQUET_LOGICAL_TYPES[type]) {\n        return PARQUET_LOGICAL_TYPES[type].fromPrimitive?.(value, field);\n        // tslint:disable-next-line:no-else-after-return\n    }\n    return value;\n}\nfunction toPrimitive_BOOLEAN(value) {\n    return Boolean(value);\n}\nfunction fromPrimitive_BOOLEAN(value) {\n    return Boolean(value);\n}\nfunction toPrimitive_FLOAT(value) {\n    const v = parseFloat(value);\n    if (isNaN(v)) {\n        throw new Error(`invalid value for FLOAT: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_DOUBLE(value) {\n    const v = parseFloat(value);\n    if (isNaN(v)) {\n        throw new Error(`invalid value for DOUBLE: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_INT8(value) {\n    const v = parseInt(value, 10);\n    if (v < -0x80 || v > 0x7f || isNaN(v)) {\n        throw new Error(`invalid value for INT8: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_UINT8(value) {\n    const v = parseInt(value, 10);\n    if (v < 0 || v > 0xff || isNaN(v)) {\n        throw new Error(`invalid value for UINT8: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_INT16(value) {\n    const v = parseInt(value, 10);\n    if (v < -0x8000 || v > 0x7fff || isNaN(v)) {\n        throw new Error(`invalid value for INT16: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_UINT16(value) {\n    const v = parseInt(value, 10);\n    if (v < 0 || v > 0xffff || isNaN(v)) {\n        throw new Error(`invalid value for UINT16: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_INT32(value) {\n    const v = parseInt(value, 10);\n    if (v < -0x80000000 || v > 0x7fffffff || isNaN(v)) {\n        throw new Error(`invalid value for INT32: ${value}`);\n    }\n    return v;\n}\nfunction decimalToPrimitive_INT32(value, field) {\n    const primitiveValue = value * 10 ** (field.scale || 0);\n    const v = Math.round(((primitiveValue * 10 ** -field.presision) % 1) * 10 ** field.presision);\n    if (v < -0x80000000 || v > 0x7fffffff || isNaN(v)) {\n        throw new Error(`invalid value for INT32: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_UINT32(value) {\n    const v = parseInt(value, 10);\n    if (v < 0 || v > 0xffffffffffff || isNaN(v)) {\n        throw new Error(`invalid value for UINT32: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_INT64(value) {\n    const v = parseInt(value, 10);\n    if (isNaN(v)) {\n        throw new Error(`invalid value for INT64: ${value}`);\n    }\n    return v;\n}\nfunction decimalToPrimitive_INT64(value, field) {\n    const primitiveValue = value * 10 ** (field.scale || 0);\n    const v = Math.round(((primitiveValue * 10 ** -field.presision) % 1) * 10 ** field.presision);\n    if (isNaN(v)) {\n        throw new Error(`invalid value for INT64: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_UINT64(value) {\n    const v = parseInt(value, 10);\n    if (v < 0 || isNaN(v)) {\n        throw new Error(`invalid value for UINT64: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_INT96(value) {\n    const v = parseInt(value, 10);\n    if (isNaN(v)) {\n        throw new Error(`invalid value for INT96: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_BYTE_ARRAY(value) {\n    return Buffer.from(value);\n}\nfunction decimalToPrimitive_BYTE_ARRAY(value) {\n    // TBD\n    return Buffer.from(value);\n}\nfunction toPrimitive_UTF8(value) {\n    return Buffer.from(value, 'utf8');\n}\nfunction fromPrimitive_UTF8(value) {\n    return value.toString();\n}\nfunction toPrimitive_JSON(value) {\n    return Buffer.from(JSON.stringify(value));\n}\nfunction fromPrimitive_JSON(value) {\n    return JSON.parse(value);\n}\nfunction toPrimitive_BSON(value) {\n    // @ts-ignore\n    const arrayBuffer = BSONWriter.encodeSync?.(value);\n    return Buffer.from(arrayBuffer);\n}\nfunction fromPrimitive_BSON(value) {\n    return BSONLoader.parseSync?.(value);\n}\nfunction toPrimitive_TIME_MILLIS(value) {\n    const v = parseInt(value, 10);\n    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n    if (v < 0 || v > 0xffffffffffffffff || isNaN(v)) {\n        throw new Error(`invalid value for TIME_MILLIS: ${value}`);\n    }\n    return v;\n}\nfunction toPrimitive_TIME_MICROS(value) {\n    const v = parseInt(value, 10);\n    if (v < 0 || isNaN(v)) {\n        throw new Error(`invalid value for TIME_MICROS: ${value}`);\n    }\n    return v;\n}\nconst kMillisPerDay = 86400000;\nfunction toPrimitive_DATE(value) {\n    /* convert from date */\n    if (value instanceof Date) {\n        return value.getTime() / kMillisPerDay;\n    }\n    /* convert from integer */\n    {\n        const v = parseInt(value, 10);\n        if (v < 0 || isNaN(v)) {\n            throw new Error(`invalid value for DATE: ${value}`);\n        }\n        return v;\n    }\n}\nfunction fromPrimitive_DATE(value) {\n    return new Date(value * kMillisPerDay);\n}\nfunction toPrimitive_TIMESTAMP_MILLIS(value) {\n    /* convert from date */\n    if (value instanceof Date) {\n        return value.getTime();\n    }\n    /* convert from integer */\n    {\n        const v = parseInt(value, 10);\n        if (v < 0 || isNaN(v)) {\n            throw new Error(`invalid value for TIMESTAMP_MILLIS: ${value}`);\n        }\n        return v;\n    }\n}\nfunction fromPrimitive_TIMESTAMP_MILLIS(value) {\n    return new Date(value);\n}\nfunction toPrimitive_TIMESTAMP_MICROS(value) {\n    /* convert from date */\n    if (value instanceof Date) {\n        return value.getTime() * 1000;\n    }\n    /* convert from integer */\n    {\n        const v = parseInt(value, 10);\n        if (v < 0 || isNaN(v)) {\n            throw new Error(`invalid value for TIMESTAMP_MICROS: ${value}`);\n        }\n        return v;\n    }\n}\nfunction fromPrimitive_TIMESTAMP_MICROS(value) {\n    return new Date(value / 1000);\n}\nfunction toPrimitive_INTERVAL(value) {\n    if (!value.months || !value.days || !value.milliseconds) {\n        throw new Error('value for INTERVAL must be object { months: ..., days: ..., milliseconds: ... }');\n    }\n    const buf = Buffer.alloc(12);\n    buf.writeUInt32LE(value.months, 0);\n    buf.writeUInt32LE(value.days, 4);\n    buf.writeUInt32LE(value.milliseconds, 8);\n    return buf;\n}\nfunction fromPrimitive_INTERVAL(value) {\n    const buf = Buffer.from(value);\n    const months = buf.readUInt32LE(0);\n    const days = buf.readUInt32LE(4);\n    const millis = buf.readUInt32LE(8);\n    return { months, days, milliseconds: millis };\n}\nfunction decimalFromPrimitive_INT(value, field) {\n    const presisionInt = Math.round(((value * 10 ** -field.presision) % 1) * 10 ** field.presision);\n    return presisionInt * 10 ** -(field.scale || 0);\n}\nfunction decimalFromPrimitive_BYTE_ARRAY(value, field) {\n    let number = 0;\n    if (value.length <= 4) {\n        // Bytewise operators faster. Use them if it is possible\n        for (let i = 0; i < value.length; i++) {\n            // `value.length - i - 1` bytes have reverse order (big-endian)\n            const component = value[i] << (8 * (value.length - i - 1));\n            number += component;\n        }\n    }\n    else {\n        for (let i = 0; i < value.length; i++) {\n            // `value.length - i - 1` bytes have reverse order (big-endian)\n            const component = value[i] * 2 ** (8 * (value.length - 1 - i));\n            number += component;\n        }\n    }\n    const presisionInt = Math.round(((number * 10 ** -field.presision) % 1) * 10 ** field.presision);\n    return presisionInt * 10 ** -(field.scale || 0);\n}\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\nimport { ParquetRowGroup } from \"./declare.js\";\nimport * as Types from \"./types.js\";\nexport { ParquetRowGroup };\nexport function shredBuffer(schema) {\n    const columnData = {};\n    for (const field of schema.fieldList) {\n        columnData[field.key] = {\n            dlevels: [],\n            rlevels: [],\n            values: [],\n            pageHeaders: [],\n            count: 0\n        };\n    }\n    return { rowCount: 0, columnData };\n}\n/**\n * 'Shred' a record into a list of <value, repetition_level, definition_level>\n * tuples per column using the Google Dremel Algorithm..\n *\n * The rowGroup argument must point to an object into which the shredded record\n * will be returned. You may re-use the rowGroup for repeated calls to this function\n * to append to an existing rowGroup, as long as the schema is unchanged.\n *\n * The format in which the shredded records will be stored in the rowGroup is as\n * follows:\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function shredRecord(schema, record, rowGroup) {\n    /* shred the record, this may raise an exception */\n    const data = shredBuffer(schema).columnData;\n    shredRecordFields(schema.fields, record, data, 0, 0);\n    /* if no error during shredding, add the shredded record to the rowGroup */\n    if (rowGroup.rowCount === 0) {\n        rowGroup.rowCount = 1;\n        rowGroup.columnData = data;\n        return;\n    }\n    rowGroup.rowCount += 1;\n    for (const field of schema.fieldList) {\n        Array.prototype.push.apply(rowGroup.columnData[field.key].rlevels, data[field.key].rlevels);\n        Array.prototype.push.apply(rowGroup.columnData[field.key].dlevels, data[field.key].dlevels);\n        Array.prototype.push.apply(rowGroup.columnData[field.key].values, data[field.key].values);\n        rowGroup.columnData[field.key].count += data[field.key].count;\n    }\n}\n// eslint-disable-next-line max-statements, complexity\nfunction shredRecordFields(fields, record, data, rLevel, dLevel) {\n    for (const name in fields) {\n        const field = fields[name];\n        // fetch values\n        let values = [];\n        if (record &&\n            field.name in record &&\n            record[field.name] !== undefined &&\n            record[field.name] !== null) {\n            if (record[field.name].constructor === Array) {\n                values = record[field.name];\n            }\n            else {\n                values.push(record[field.name]);\n            }\n        }\n        // check values\n        if (values.length === 0 && Boolean(record) && field.repetitionType === 'REQUIRED') {\n            throw new Error(`missing required field: ${field.name}`);\n        }\n        if (values.length > 1 && field.repetitionType !== 'REPEATED') {\n            throw new Error(`too many values for field: ${field.name}`);\n        }\n        // push null\n        if (values.length === 0) {\n            if (field.isNested) {\n                shredRecordFields(field.fields, null, data, rLevel, dLevel);\n            }\n            else {\n                data[field.key].count += 1;\n                data[field.key].rlevels.push(rLevel);\n                data[field.key].dlevels.push(dLevel);\n            }\n            continue; // eslint-disable-line no-continue\n        }\n        // push values\n        for (let i = 0; i < values.length; i++) {\n            const rlvl = i === 0 ? rLevel : field.rLevelMax;\n            if (field.isNested) {\n                shredRecordFields(field.fields, values[i], data, rlvl, field.dLevelMax);\n            }\n            else {\n                data[field.key].count += 1;\n                data[field.key].rlevels.push(rlvl);\n                data[field.key].dlevels.push(field.dLevelMax);\n                data[field.key].values.push(Types.toPrimitive((field.originalType || field.primitiveType), values[i]));\n            }\n        }\n    }\n}\n/**\n * 'Materialize' a list of <value, repetition_level, definition_level>\n * tuples back to nested records (objects/arrays) using the Google Dremel\n * Algorithm..\n *\n * The rowGroup argument must point to an object with the following structure (i.e.\n * the same structure that is returned by shredRecords):\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function materializeRows(schema, rowGroup) {\n    const rows = [];\n    // rows = new Array(rowGroup.rowCount).fill({})'\n    for (let i = 0; i < rowGroup.rowCount; i++) {\n        rows.push({});\n    }\n    for (const key in rowGroup.columnData) {\n        const columnData = rowGroup.columnData[key];\n        if (columnData.count) {\n            materializeColumnAsRows(schema, columnData, key, rows);\n        }\n    }\n    return rows;\n}\n/** Populate record fields for one column */\n// eslint-disable-next-line max-statements, complexity\nfunction materializeColumnAsRows(schema, columnData, key, rows) {\n    const field = schema.findField(key);\n    const branch = schema.findFieldBranch(key);\n    // tslint:disable-next-line:prefer-array-literal\n    const rLevels = new Array(field.rLevelMax + 1).fill(0);\n    let vIndex = 0;\n    for (let i = 0; i < columnData.count; i++) {\n        const dLevel = columnData.dlevels[i];\n        const rLevel = columnData.rlevels[i];\n        rLevels[rLevel]++;\n        rLevels.fill(0, rLevel + 1);\n        let rIndex = 0;\n        let record = rows[rLevels[rIndex++] - 1];\n        // Internal nodes - Build a nested row object\n        for (const step of branch) {\n            if (step === field || dLevel < step.dLevelMax) {\n                break;\n            }\n            switch (step.repetitionType) {\n                case 'REPEATED':\n                    if (!(step.name in record)) {\n                        // eslint-disable max-depth\n                        record[step.name] = [];\n                    }\n                    const ix = rLevels[rIndex++];\n                    while (record[step.name].length <= ix) {\n                        // eslint-disable max-depth\n                        record[step.name].push({});\n                    }\n                    record = record[step.name][ix];\n                    break;\n                default:\n                    record[step.name] = record[step.name] || {};\n                    record = record[step.name];\n            }\n        }\n        // Leaf node - Add the value\n        if (dLevel === field.dLevelMax) {\n            const value = Types.fromPrimitive(\n            // @ts-ignore\n            field.originalType || field.primitiveType, columnData.values[vIndex], field);\n            vIndex++;\n            switch (field.repetitionType) {\n                case 'REPEATED':\n                    if (!(field.name in record)) {\n                        // eslint-disable max-depth\n                        record[field.name] = [];\n                    }\n                    const ix = rLevels[rIndex];\n                    while (record[field.name].length <= ix) {\n                        // eslint-disable max-depth\n                        record[field.name].push(null);\n                    }\n                    record[field.name][ix] = value;\n                    break;\n                default:\n                    record[field.name] = value;\n            }\n        }\n    }\n}\n// Columnar export\n/**\n * 'Materialize' a list of <value, repetition_level, definition_level>\n * tuples back to nested records (objects/arrays) using the Google Dremel\n * Algorithm..\n *\n * The rowGroup argument must point to an object with the following structure (i.e.\n * the same structure that is returned by shredRecords):\n *\n *   rowGroup = {\n *     columnData: [\n *       'my_col': {\n *          dlevels: [d1, d2, .. dN],\n *          rlevels: [r1, r2, .. rN],\n *          values: [v1, v2, .. vN],\n *        }, ...\n *      ],\n *      rowCount: X,\n *   }\n */\nexport function materializeColumns(schema, rowGroup) {\n    const columns = {};\n    for (const key in rowGroup.columnData) {\n        const columnData = rowGroup.columnData[key];\n        if (columnData.count) {\n            materializeColumnAsColumnarArray(schema, columnData, rowGroup.rowCount, key, columns);\n        }\n    }\n    return columns;\n}\n// eslint-disable-next-line max-statements, complexity\nfunction materializeColumnAsColumnarArray(schema, columnData, rowCount, key, columns) {\n    if (columnData.count <= 0) {\n        return;\n    }\n    const field = schema.findField(key);\n    const branch = schema.findFieldBranch(key);\n    const columnName = branch[0].name;\n    let column;\n    const { values } = columnData;\n    if (values.length === rowCount && branch[0].primitiveType) {\n        // if (branch[0].repetitionType === `REQUIRED`) {\n        //   switch (branch[0].primitiveType) {\n        //     case 'INT32': return values instanceof Int32Array ? values : new Int32Array(values);\n        //   }\n        // }\n        column = values;\n    }\n    if (column) {\n        columns[columnName] = column;\n        return;\n    }\n    column = new Array(rowCount);\n    for (let i = 0; i < rowCount; i++) {\n        column[i] = {};\n    }\n    columns[columnName] = column;\n    // tslint:disable-next-line:prefer-array-literal\n    const rLevels = new Array(field.rLevelMax + 1).fill(0);\n    let vIndex = 0;\n    for (let i = 0; i < columnData.count; i++) {\n        const dLevel = columnData.dlevels[i];\n        const rLevel = columnData.rlevels[i];\n        rLevels[rLevel]++;\n        rLevels.fill(0, rLevel + 1);\n        let rIndex = 0;\n        let record = column[rLevels[rIndex++] - 1];\n        // Internal nodes - Build a nested row object\n        for (const step of branch) {\n            if (step === field || dLevel < step.dLevelMax) {\n                break;\n            }\n            switch (step.repetitionType) {\n                case 'REPEATED':\n                    if (!(step.name in record)) {\n                        // eslint-disable max-depth\n                        record[step.name] = [];\n                    }\n                    const ix = rLevels[rIndex++];\n                    while (record[step.name].length <= ix) {\n                        // eslint-disable max-depth\n                        record[step.name].push({});\n                    }\n                    record = record[step.name][ix];\n                    break;\n                default:\n                    record[step.name] = record[step.name] || {};\n                    record = record[step.name];\n            }\n        }\n        // Leaf node - Add the value\n        if (dLevel === field.dLevelMax) {\n            const value = Types.fromPrimitive(\n            // @ts-ignore\n            field.originalType || field.primitiveType, columnData.values[vIndex], field);\n            vIndex++;\n            switch (field.repetitionType) {\n                case 'REPEATED':\n                    if (!(field.name in record)) {\n                        // eslint-disable max-depth\n                        record[field.name] = [];\n                    }\n                    const ix = rLevels[rIndex];\n                    while (record[field.name].length <= ix) {\n                        // eslint-disable max-depth\n                        record[field.name].push(null);\n                    }\n                    record[field.name][ix] = value;\n                    break;\n                default:\n                    record[field.name] = value;\n            }\n        }\n    }\n    // Remove one level of nesting\n    for (let i = 0; i < rowCount; ++i) {\n        if (columnName in column[i]) {\n            column[i] = column[i][columnName];\n        }\n    }\n}\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\nimport { PARQUET_CODECS } from \"../codecs/index.js\";\nimport { PARQUET_COMPRESSION_METHODS } from \"../compression.js\";\nimport { materializeRows, shredBuffer, shredRecord } from \"./shred.js\";\nimport { PARQUET_LOGICAL_TYPES } from \"./types.js\";\n/**\n * A parquet file schema\n */\nexport class ParquetSchema {\n    schema;\n    fields;\n    fieldList;\n    /**\n     * Create a new schema from a JSON schema definition\n     */\n    constructor(schema) {\n        this.schema = schema;\n        this.fields = buildFields(schema, 0, 0, []);\n        this.fieldList = listFields(this.fields);\n    }\n    /**\n     * Retrieve a field definition\n     */\n    findField(path) {\n        if (typeof path === 'string') {\n            // tslint:disable-next-line:no-parameter-reassignment\n            path = path.split(',');\n        }\n        else {\n            // tslint:disable-next-line:no-parameter-reassignment\n            path = path.slice(0); // clone array\n        }\n        let n = this.fields;\n        for (; path.length > 1; path.shift()) {\n            n = n[path[0]].fields;\n        }\n        return n[path[0]];\n    }\n    /**\n     * Retrieve a field definition and all the field's ancestors\n     */\n    findFieldBranch(path) {\n        if (typeof path === 'string') {\n            // tslint:disable-next-line:no-parameter-reassignment\n            path = path.split(',');\n        }\n        const branch = [];\n        let n = this.fields;\n        for (; path.length > 0; path.shift()) {\n            branch.push(n[path[0]]);\n            if (path.length > 1) {\n                n = n[path[0]].fields;\n            }\n        }\n        return branch;\n    }\n    shredRecord(row, rowGroup) {\n        shredRecord(this, row, rowGroup);\n    }\n    materializeRows(rowGroup) {\n        return materializeRows(this, rowGroup);\n    }\n    compress(type) {\n        setCompress(this.schema, type);\n        setCompress(this.fields, type);\n        return this;\n    }\n    rowGroup() {\n        return shredBuffer(this);\n    }\n}\nfunction setCompress(schema, type) {\n    for (const name in schema) {\n        const node = schema[name];\n        if (node.fields) {\n            setCompress(node.fields, type);\n        }\n        else {\n            node.compression = type;\n        }\n    }\n}\n// eslint-disable-next-line max-statements, complexity\nfunction buildFields(schema, rLevelParentMax, dLevelParentMax, path) {\n    const fieldList = {};\n    for (const name in schema) {\n        const opts = schema[name];\n        /* field repetition type */\n        const required = !opts.optional;\n        const repeated = Boolean(opts.repeated);\n        let rLevelMax = rLevelParentMax;\n        let dLevelMax = dLevelParentMax;\n        let repetitionType = 'REQUIRED';\n        if (!required) {\n            repetitionType = 'OPTIONAL';\n            dLevelMax++;\n        }\n        if (repeated) {\n            repetitionType = 'REPEATED';\n            rLevelMax++;\n            if (required)\n                dLevelMax++;\n        }\n        /* nested field */\n        if (opts.fields) {\n            const cpath = path.concat([name]);\n            fieldList[name] = {\n                name,\n                path: cpath,\n                key: cpath.join(),\n                repetitionType,\n                rLevelMax,\n                dLevelMax,\n                isNested: true,\n                fieldCount: Object.keys(opts.fields).length,\n                fields: buildFields(opts.fields, rLevelMax, dLevelMax, cpath)\n            };\n            continue; // eslint-disable-line no-continue\n        }\n        const typeDef = PARQUET_LOGICAL_TYPES[opts.type];\n        if (!typeDef) {\n            throw new Error(`invalid parquet type: ${opts.type}`);\n        }\n        opts.encoding = opts.encoding || 'PLAIN';\n        if (!(opts.encoding in PARQUET_CODECS)) {\n            throw new Error(`unsupported parquet encoding: ${opts.encoding}`);\n        }\n        opts.compression = opts.compression || 'UNCOMPRESSED';\n        if (!(opts.compression in PARQUET_COMPRESSION_METHODS)) {\n            throw new Error(`unsupported compression method: ${opts.compression}`);\n        }\n        /* add to schema */\n        const cpath = path.concat([name]);\n        fieldList[name] = {\n            name,\n            primitiveType: typeDef.primitiveType,\n            originalType: typeDef.originalType,\n            path: cpath,\n            key: cpath.join(),\n            repetitionType,\n            encoding: opts.encoding,\n            compression: opts.compression,\n            typeLength: opts.typeLength || typeDef.typeLength,\n            presision: opts.presision,\n            scale: opts.scale,\n            rLevelMax,\n            dLevelMax\n        };\n    }\n    return fieldList;\n}\nfunction listFields(fields) {\n    let list = [];\n    for (const k in fields) {\n        list.push(fields[k]);\n        if (fields[k].isNested) {\n            list = list.concat(listFields(fields[k].fields));\n        }\n    }\n    return list;\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport { Buffer } from \"../../polyfills/buffer/install-buffer-polyfill.js\";\nexport { TBufferedTransport, TCompactProtocol, TFramedTransport } from 'thrift';\nexport * from \"./Type.js\";\nexport * from \"./ConvertedType.js\";\nexport * from \"./FieldRepetitionType.js\";\nexport * from \"./Encoding.js\";\nexport * from \"./CompressionCodec.js\";\nexport * from \"./PageType.js\";\nexport * from \"./BoundaryOrder.js\";\nexport * from \"./Statistics.js\";\nexport * from \"./StringType.js\";\nexport * from \"./UUIDType.js\";\nexport * from \"./MapType.js\";\nexport * from \"./ListType.js\";\nexport * from \"./EnumType.js\";\nexport * from \"./DateType.js\";\nexport * from \"./NullType.js\";\nexport * from \"./DecimalType.js\";\nexport * from \"./MilliSeconds.js\";\nexport * from \"./MicroSeconds.js\";\nexport * from \"./TimestampType.js\";\nexport * from \"./TimeType.js\";\nexport * from \"./IntType.js\";\nexport * from \"./JsonType.js\";\nexport * from \"./BsonType.js\";\nexport * from \"./SchemaElement.js\";\nexport * from \"./DataPageHeader.js\";\nexport * from \"./IndexPageHeader.js\";\nexport * from \"./DictionaryPageHeader.js\";\nexport * from \"./DataPageHeaderV2.js\";\nexport * from \"./PageHeader.js\";\nexport * from \"./KeyValue.js\";\nexport * from \"./SortingColumn.js\";\nexport * from \"./PageEncodingStats.js\";\nexport * from \"./ColumnMetaData.js\";\nexport * from \"./ColumnChunk.js\";\nexport * from \"./RowGroup.js\";\nexport * from \"./TypeDefinedOrder.js\";\nexport * from \"./PageLocation.js\";\nexport * from \"./OffsetIndex.js\";\nexport * from \"./ColumnIndex.js\";\nexport * from \"./FileMetaData.js\";\nexport * from \"./TimeUnit.js\";\nexport * from \"./LogicalType.js\";\nexport * from \"./ColumnOrder.js\";\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var Type;\n(function (Type) {\n    Type[Type[\"BOOLEAN\"] = 0] = \"BOOLEAN\";\n    Type[Type[\"INT32\"] = 1] = \"INT32\";\n    Type[Type[\"INT64\"] = 2] = \"INT64\";\n    Type[Type[\"INT96\"] = 3] = \"INT96\";\n    Type[Type[\"FLOAT\"] = 4] = \"FLOAT\";\n    Type[Type[\"DOUBLE\"] = 5] = \"DOUBLE\";\n    Type[Type[\"BYTE_ARRAY\"] = 6] = \"BYTE_ARRAY\";\n    Type[Type[\"FIXED_LEN_BYTE_ARRAY\"] = 7] = \"FIXED_LEN_BYTE_ARRAY\";\n})(Type || (Type = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var ConvertedType;\n(function (ConvertedType) {\n    ConvertedType[ConvertedType[\"UTF8\"] = 0] = \"UTF8\";\n    ConvertedType[ConvertedType[\"MAP\"] = 1] = \"MAP\";\n    ConvertedType[ConvertedType[\"MAP_KEY_VALUE\"] = 2] = \"MAP_KEY_VALUE\";\n    ConvertedType[ConvertedType[\"LIST\"] = 3] = \"LIST\";\n    ConvertedType[ConvertedType[\"ENUM\"] = 4] = \"ENUM\";\n    ConvertedType[ConvertedType[\"DECIMAL\"] = 5] = \"DECIMAL\";\n    ConvertedType[ConvertedType[\"DATE\"] = 6] = \"DATE\";\n    ConvertedType[ConvertedType[\"TIME_MILLIS\"] = 7] = \"TIME_MILLIS\";\n    ConvertedType[ConvertedType[\"TIME_MICROS\"] = 8] = \"TIME_MICROS\";\n    ConvertedType[ConvertedType[\"TIMESTAMP_MILLIS\"] = 9] = \"TIMESTAMP_MILLIS\";\n    ConvertedType[ConvertedType[\"TIMESTAMP_MICROS\"] = 10] = \"TIMESTAMP_MICROS\";\n    ConvertedType[ConvertedType[\"UINT_8\"] = 11] = \"UINT_8\";\n    ConvertedType[ConvertedType[\"UINT_16\"] = 12] = \"UINT_16\";\n    ConvertedType[ConvertedType[\"UINT_32\"] = 13] = \"UINT_32\";\n    ConvertedType[ConvertedType[\"UINT_64\"] = 14] = \"UINT_64\";\n    ConvertedType[ConvertedType[\"INT_8\"] = 15] = \"INT_8\";\n    ConvertedType[ConvertedType[\"INT_16\"] = 16] = \"INT_16\";\n    ConvertedType[ConvertedType[\"INT_32\"] = 17] = \"INT_32\";\n    ConvertedType[ConvertedType[\"INT_64\"] = 18] = \"INT_64\";\n    ConvertedType[ConvertedType[\"JSON\"] = 19] = \"JSON\";\n    ConvertedType[ConvertedType[\"BSON\"] = 20] = \"BSON\";\n    ConvertedType[ConvertedType[\"INTERVAL\"] = 21] = \"INTERVAL\";\n})(ConvertedType || (ConvertedType = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var FieldRepetitionType;\n(function (FieldRepetitionType) {\n    FieldRepetitionType[FieldRepetitionType[\"REQUIRED\"] = 0] = \"REQUIRED\";\n    FieldRepetitionType[FieldRepetitionType[\"OPTIONAL\"] = 1] = \"OPTIONAL\";\n    FieldRepetitionType[FieldRepetitionType[\"REPEATED\"] = 2] = \"REPEATED\";\n})(FieldRepetitionType || (FieldRepetitionType = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var Encoding;\n(function (Encoding) {\n    Encoding[Encoding[\"PLAIN\"] = 0] = \"PLAIN\";\n    Encoding[Encoding[\"PLAIN_DICTIONARY\"] = 2] = \"PLAIN_DICTIONARY\";\n    Encoding[Encoding[\"RLE\"] = 3] = \"RLE\";\n    Encoding[Encoding[\"BIT_PACKED\"] = 4] = \"BIT_PACKED\";\n    Encoding[Encoding[\"DELTA_BINARY_PACKED\"] = 5] = \"DELTA_BINARY_PACKED\";\n    Encoding[Encoding[\"DELTA_LENGTH_BYTE_ARRAY\"] = 6] = \"DELTA_LENGTH_BYTE_ARRAY\";\n    Encoding[Encoding[\"DELTA_BYTE_ARRAY\"] = 7] = \"DELTA_BYTE_ARRAY\";\n    Encoding[Encoding[\"RLE_DICTIONARY\"] = 8] = \"RLE_DICTIONARY\";\n})(Encoding || (Encoding = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var CompressionCodec;\n(function (CompressionCodec) {\n    CompressionCodec[CompressionCodec[\"UNCOMPRESSED\"] = 0] = \"UNCOMPRESSED\";\n    CompressionCodec[CompressionCodec[\"SNAPPY\"] = 1] = \"SNAPPY\";\n    CompressionCodec[CompressionCodec[\"GZIP\"] = 2] = \"GZIP\";\n    CompressionCodec[CompressionCodec[\"LZO\"] = 3] = \"LZO\";\n    CompressionCodec[CompressionCodec[\"BROTLI\"] = 4] = \"BROTLI\";\n    CompressionCodec[CompressionCodec[\"LZ4\"] = 5] = \"LZ4\";\n    CompressionCodec[CompressionCodec[\"ZSTD\"] = 6] = \"ZSTD\";\n    CompressionCodec[CompressionCodec[\"LZ4_RAW\"] = 7] = \"LZ4_RAW\"; // Added in 2.9\n})(CompressionCodec || (CompressionCodec = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nexport var PageType;\n(function (PageType) {\n    PageType[PageType[\"DATA_PAGE\"] = 0] = \"DATA_PAGE\";\n    PageType[PageType[\"INDEX_PAGE\"] = 1] = \"INDEX_PAGE\";\n    PageType[PageType[\"DICTIONARY_PAGE\"] = 2] = \"DICTIONARY_PAGE\";\n    PageType[PageType[\"DATA_PAGE_V2\"] = 3] = \"DATA_PAGE_V2\";\n})(PageType || (PageType = {}));\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport Int64 from 'node-int64';\nimport * as thrift from 'thrift';\nexport class Statistics {\n    max;\n    min;\n    null_count;\n    distinct_count;\n    max_value;\n    min_value;\n    constructor(args) {\n        if (args != null && args.max != null) {\n            this.max = args.max;\n        }\n        if (args != null && args.min != null) {\n            this.min = args.min;\n        }\n        if (args != null && args.null_count != null) {\n            if (typeof args.null_count === 'number') {\n                this.null_count = new Int64(args.null_count);\n            }\n            else {\n                this.null_count = args.null_count;\n            }\n        }\n        if (args != null && args.distinct_count != null) {\n            if (typeof args.distinct_count === 'number') {\n                this.distinct_count = new Int64(args.distinct_count);\n            }\n            else {\n                this.distinct_count = args.distinct_count;\n            }\n        }\n        if (args != null && args.max_value != null) {\n            this.max_value = args.max_value;\n        }\n        if (args != null && args.min_value != null) {\n            this.min_value = args.min_value;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('Statistics');\n        if (this.max != null) {\n            output.writeFieldBegin('max', thrift.Thrift.Type.STRING, 1);\n            output.writeBinary(this.max);\n            output.writeFieldEnd();\n        }\n        if (this.min != null) {\n            output.writeFieldBegin('min', thrift.Thrift.Type.STRING, 2);\n            output.writeBinary(this.min);\n            output.writeFieldEnd();\n        }\n        if (this.null_count != null) {\n            output.writeFieldBegin('null_count', thrift.Thrift.Type.I64, 3);\n            output.writeI64(this.null_count);\n            output.writeFieldEnd();\n        }\n        if (this.distinct_count != null) {\n            output.writeFieldBegin('distinct_count', thrift.Thrift.Type.I64, 4);\n            output.writeI64(this.distinct_count);\n            output.writeFieldEnd();\n        }\n        if (this.max_value != null) {\n            output.writeFieldBegin('max_value', thrift.Thrift.Type.STRING, 5);\n            output.writeBinary(this.max_value);\n            output.writeFieldEnd();\n        }\n        if (this.min_value != null) {\n            output.writeFieldBegin('min_value', thrift.Thrift.Type.STRING, 6);\n            output.writeBinary(this.min_value);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_1 = input.readBinary();\n                        _args.max = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_2 = input.readBinary();\n                        _args.min = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_3 = input.readI64();\n                        _args.null_count = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_4 = input.readI64();\n                        _args.distinct_count = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_5 = input.readBinary();\n                        _args.max_value = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_6 = input.readBinary();\n                        _args.min_value = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new Statistics(_args);\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class StringType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('StringType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new StringType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class UUIDType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('UUIDType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new UUIDType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class MapType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('MapType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new MapType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class ListType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('ListType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new ListType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class EnumType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('EnumType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new EnumType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class DateType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('DateType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new DateType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class NullType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('NullType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new NullType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class DecimalType {\n    scale;\n    precision;\n    constructor(args) {\n        if (args != null && args.scale != null) {\n            this.scale = args.scale;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[scale] is unset!');\n        }\n        if (args != null && args.precision != null) {\n            this.precision = args.precision;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[precision] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('DecimalType');\n        if (this.scale != null) {\n            output.writeFieldBegin('scale', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.scale);\n            output.writeFieldEnd();\n        }\n        if (this.precision != null) {\n            output.writeFieldBegin('precision', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.precision);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.scale = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.precision = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.scale !== undefined && _args.precision !== undefined) {\n            return new DecimalType(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read DecimalType from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class MilliSeconds {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('MilliSeconds');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new MilliSeconds();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class MicroSeconds {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('MicroSeconds');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new MicroSeconds();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as TimeUnit from \"./TimeUnit.js\";\nexport class TimestampType {\n    isAdjustedToUTC;\n    unit;\n    constructor(args) {\n        if (args != null && args.isAdjustedToUTC != null) {\n            this.isAdjustedToUTC = args.isAdjustedToUTC;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[isAdjustedToUTC] is unset!');\n        }\n        if (args != null && args.unit != null) {\n            this.unit = args.unit;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[unit] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('TimestampType');\n        if (this.isAdjustedToUTC != null) {\n            output.writeFieldBegin('isAdjustedToUTC', thrift.Thrift.Type.BOOL, 1);\n            output.writeBool(this.isAdjustedToUTC);\n            output.writeFieldEnd();\n        }\n        if (this.unit != null) {\n            output.writeFieldBegin('unit', thrift.Thrift.Type.STRUCT, 2);\n            this.unit.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_1 = input.readBool();\n                        _args.isAdjustedToUTC = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_2 = TimeUnit.TimeUnit.read(input);\n                        _args.unit = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.isAdjustedToUTC !== undefined && _args.unit !== undefined) {\n            return new TimestampType(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read TimestampType from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as MicroSeconds from \"./MicroSeconds.js\";\nimport * as MilliSeconds from \"./MilliSeconds.js\";\nexport class TimeUnit {\n    MILLIS;\n    MICROS;\n    constructor(args) {\n        let _fieldsSet = 0;\n        if (args != null) {\n            if (args.MILLIS != null) {\n                _fieldsSet++;\n                this.MILLIS = args.MILLIS;\n            }\n            if (args.MICROS != null) {\n                _fieldsSet++;\n                this.MICROS = args.MICROS;\n            }\n            if (_fieldsSet > 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n            }\n            else if (_fieldsSet < 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n            }\n        }\n    }\n    static fromMILLIS(MILLIS) {\n        return new TimeUnit({ MILLIS });\n    }\n    static fromMICROS(MICROS) {\n        return new TimeUnit({ MICROS });\n    }\n    write(output) {\n        output.writeStructBegin('TimeUnit');\n        if (this.MILLIS != null) {\n            output.writeFieldBegin('MILLIS', thrift.Thrift.Type.STRUCT, 1);\n            this.MILLIS.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.MICROS != null) {\n            output.writeFieldBegin('MICROS', thrift.Thrift.Type.STRUCT, 2);\n            this.MICROS.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        let _fieldsSet = 0;\n        let _returnValue = null;\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_1 = MilliSeconds.MilliSeconds.read(input);\n                        _returnValue = TimeUnit.fromMILLIS(value_1);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_2 = MicroSeconds.MicroSeconds.read(input);\n                        _returnValue = TimeUnit.fromMICROS(value_2);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_fieldsSet > 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n        }\n        else if (_fieldsSet < 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n        }\n        if (_returnValue !== null) {\n            return _returnValue;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read data for TUnion');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as TimeUnit from \"./TimeUnit.js\";\nexport class TimeType {\n    isAdjustedToUTC;\n    unit;\n    constructor(args) {\n        if (args != null && args.isAdjustedToUTC != null) {\n            this.isAdjustedToUTC = args.isAdjustedToUTC;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[isAdjustedToUTC] is unset!');\n        }\n        if (args != null && args.unit != null) {\n            this.unit = args.unit;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[unit] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('TimeType');\n        if (this.isAdjustedToUTC != null) {\n            output.writeFieldBegin('isAdjustedToUTC', thrift.Thrift.Type.BOOL, 1);\n            output.writeBool(this.isAdjustedToUTC);\n            output.writeFieldEnd();\n        }\n        if (this.unit != null) {\n            output.writeFieldBegin('unit', thrift.Thrift.Type.STRUCT, 2);\n            this.unit.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_1 = input.readBool();\n                        _args.isAdjustedToUTC = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_2 = TimeUnit.TimeUnit.read(input);\n                        _args.unit = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.isAdjustedToUTC !== undefined && _args.unit !== undefined) {\n            return new TimeType(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read TimeType from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class IntType {\n    bitWidth;\n    isSigned;\n    constructor(args) {\n        if (args != null && args.bitWidth != null) {\n            this.bitWidth = args.bitWidth;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[bitWidth] is unset!');\n        }\n        if (args != null && args.isSigned != null) {\n            this.isSigned = args.isSigned;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[isSigned] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('IntType');\n        if (this.bitWidth != null) {\n            output.writeFieldBegin('bitWidth', thrift.Thrift.Type.BYTE, 1);\n            output.writeByte(this.bitWidth);\n            output.writeFieldEnd();\n        }\n        if (this.isSigned != null) {\n            output.writeFieldBegin('isSigned', thrift.Thrift.Type.BOOL, 2);\n            output.writeBool(this.isSigned);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.BYTE) {\n                        const value_1 = input.readByte();\n                        _args.bitWidth = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_2 = input.readBool();\n                        _args.isSigned = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.bitWidth !== undefined && _args.isSigned !== undefined) {\n            return new IntType(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read IntType from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class JsonType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('JsonType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new JsonType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class BsonType {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('BsonType');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new BsonType();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as LogicalType from \"./LogicalType.js\";\nexport class SchemaElement {\n    type;\n    type_length;\n    repetition_type;\n    name;\n    num_children;\n    converted_type;\n    scale;\n    precision;\n    field_id;\n    logicalType;\n    constructor(args) {\n        if (args != null && args.type != null) {\n            this.type = args.type;\n        }\n        if (args != null && args.type_length != null) {\n            this.type_length = args.type_length;\n        }\n        if (args != null && args.repetition_type != null) {\n            this.repetition_type = args.repetition_type;\n        }\n        if (args != null && args.name != null) {\n            this.name = args.name;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[name] is unset!');\n        }\n        if (args != null && args.num_children != null) {\n            this.num_children = args.num_children;\n        }\n        if (args != null && args.converted_type != null) {\n            this.converted_type = args.converted_type;\n        }\n        if (args != null && args.scale != null) {\n            this.scale = args.scale;\n        }\n        if (args != null && args.precision != null) {\n            this.precision = args.precision;\n        }\n        if (args != null && args.field_id != null) {\n            this.field_id = args.field_id;\n        }\n        if (args != null && args.logicalType != null) {\n            this.logicalType = args.logicalType;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('SchemaElement');\n        if (this.type != null) {\n            output.writeFieldBegin('type', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.type);\n            output.writeFieldEnd();\n        }\n        if (this.type_length != null) {\n            output.writeFieldBegin('type_length', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.type_length);\n            output.writeFieldEnd();\n        }\n        if (this.repetition_type != null) {\n            output.writeFieldBegin('repetition_type', thrift.Thrift.Type.I32, 3);\n            output.writeI32(this.repetition_type);\n            output.writeFieldEnd();\n        }\n        if (this.name != null) {\n            output.writeFieldBegin('name', thrift.Thrift.Type.STRING, 4);\n            output.writeString(this.name);\n            output.writeFieldEnd();\n        }\n        if (this.num_children != null) {\n            output.writeFieldBegin('num_children', thrift.Thrift.Type.I32, 5);\n            output.writeI32(this.num_children);\n            output.writeFieldEnd();\n        }\n        if (this.converted_type != null) {\n            output.writeFieldBegin('converted_type', thrift.Thrift.Type.I32, 6);\n            output.writeI32(this.converted_type);\n            output.writeFieldEnd();\n        }\n        if (this.scale != null) {\n            output.writeFieldBegin('scale', thrift.Thrift.Type.I32, 7);\n            output.writeI32(this.scale);\n            output.writeFieldEnd();\n        }\n        if (this.precision != null) {\n            output.writeFieldBegin('precision', thrift.Thrift.Type.I32, 8);\n            output.writeI32(this.precision);\n            output.writeFieldEnd();\n        }\n        if (this.field_id != null) {\n            output.writeFieldBegin('field_id', thrift.Thrift.Type.I32, 9);\n            output.writeI32(this.field_id);\n            output.writeFieldEnd();\n        }\n        if (this.logicalType != null) {\n            output.writeFieldBegin('logicalType', thrift.Thrift.Type.STRUCT, 10);\n            this.logicalType.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.type = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.type_length = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_3 = input.readI32();\n                        _args.repetition_type = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_4 = input.readString();\n                        _args.name = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_5 = input.readI32();\n                        _args.num_children = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_6 = input.readI32();\n                        _args.converted_type = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_7 = input.readI32();\n                        _args.scale = value_7;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 8:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_8 = input.readI32();\n                        _args.precision = value_8;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 9:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_9 = input.readI32();\n                        _args.field_id = value_9;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 10:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_10 = LogicalType.LogicalType.read(input);\n                        _args.logicalType = value_10;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.name !== undefined) {\n            return new SchemaElement(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read SchemaElement from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as BsonType from \"./BsonType.js\";\nimport * as DateType from \"./DateType.js\";\nimport * as DecimalType from \"./DecimalType.js\";\nimport * as EnumType from \"./EnumType.js\";\nimport * as IntType from \"./IntType.js\";\nimport * as JsonType from \"./JsonType.js\";\nimport * as ListType from \"./ListType.js\";\nimport * as MapType from \"./MapType.js\";\nimport * as NullType from \"./NullType.js\";\nimport * as StringType from \"./StringType.js\";\nimport * as TimestampType from \"./TimestampType.js\";\nimport * as TimeType from \"./TimeType.js\";\nimport * as UUIDType from \"./UUIDType.js\";\nexport class LogicalType {\n    STRING;\n    MAP;\n    LIST;\n    ENUM;\n    DECIMAL;\n    DATE;\n    TIME;\n    TIMESTAMP;\n    INTEGER;\n    UNKNOWN;\n    JSON;\n    BSON;\n    UUID;\n    constructor(args) {\n        let _fieldsSet = 0;\n        if (args != null) {\n            if (args.STRING != null) {\n                _fieldsSet++;\n                this.STRING = args.STRING;\n            }\n            if (args.MAP != null) {\n                _fieldsSet++;\n                this.MAP = args.MAP;\n            }\n            if (args.LIST != null) {\n                _fieldsSet++;\n                this.LIST = args.LIST;\n            }\n            if (args.ENUM != null) {\n                _fieldsSet++;\n                this.ENUM = args.ENUM;\n            }\n            if (args.DECIMAL != null) {\n                _fieldsSet++;\n                this.DECIMAL = args.DECIMAL;\n            }\n            if (args.DATE != null) {\n                _fieldsSet++;\n                this.DATE = args.DATE;\n            }\n            if (args.TIME != null) {\n                _fieldsSet++;\n                this.TIME = args.TIME;\n            }\n            if (args.TIMESTAMP != null) {\n                _fieldsSet++;\n                this.TIMESTAMP = args.TIMESTAMP;\n            }\n            if (args.INTEGER != null) {\n                _fieldsSet++;\n                this.INTEGER = args.INTEGER;\n            }\n            if (args.UNKNOWN != null) {\n                _fieldsSet++;\n                this.UNKNOWN = args.UNKNOWN;\n            }\n            if (args.JSON != null) {\n                _fieldsSet++;\n                this.JSON = args.JSON;\n            }\n            if (args.BSON != null) {\n                _fieldsSet++;\n                this.BSON = args.BSON;\n            }\n            if (args.UUID != null) {\n                _fieldsSet++;\n                this.UUID = args.UUID;\n            }\n            if (_fieldsSet > 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n            }\n            else if (_fieldsSet < 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n            }\n        }\n    }\n    static fromSTRING(STRING) {\n        return new LogicalType({ STRING });\n    }\n    static fromMAP(MAP) {\n        return new LogicalType({ MAP });\n    }\n    static fromLIST(LIST) {\n        return new LogicalType({ LIST });\n    }\n    static fromENUM(ENUM) {\n        return new LogicalType({ ENUM });\n    }\n    static fromDECIMAL(DECIMAL) {\n        return new LogicalType({ DECIMAL });\n    }\n    static fromDATE(DATE) {\n        return new LogicalType({ DATE });\n    }\n    static fromTIME(TIME) {\n        return new LogicalType({ TIME });\n    }\n    static fromTIMESTAMP(TIMESTAMP) {\n        return new LogicalType({ TIMESTAMP });\n    }\n    static fromINTEGER(INTEGER) {\n        return new LogicalType({ INTEGER });\n    }\n    static fromUNKNOWN(UNKNOWN) {\n        return new LogicalType({ UNKNOWN });\n    }\n    static fromJSON(JSON) {\n        return new LogicalType({ JSON });\n    }\n    static fromBSON(BSON) {\n        return new LogicalType({ BSON });\n    }\n    static fromUUID(UUID) {\n        return new LogicalType({ UUID });\n    }\n    write(output) {\n        output.writeStructBegin('LogicalType');\n        if (this.STRING != null) {\n            output.writeFieldBegin('STRING', thrift.Thrift.Type.STRUCT, 1);\n            this.STRING.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.MAP != null) {\n            output.writeFieldBegin('MAP', thrift.Thrift.Type.STRUCT, 2);\n            this.MAP.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.LIST != null) {\n            output.writeFieldBegin('LIST', thrift.Thrift.Type.STRUCT, 3);\n            this.LIST.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.ENUM != null) {\n            output.writeFieldBegin('ENUM', thrift.Thrift.Type.STRUCT, 4);\n            this.ENUM.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.DECIMAL != null) {\n            output.writeFieldBegin('DECIMAL', thrift.Thrift.Type.STRUCT, 5);\n            this.DECIMAL.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.DATE != null) {\n            output.writeFieldBegin('DATE', thrift.Thrift.Type.STRUCT, 6);\n            this.DATE.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.TIME != null) {\n            output.writeFieldBegin('TIME', thrift.Thrift.Type.STRUCT, 7);\n            this.TIME.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.TIMESTAMP != null) {\n            output.writeFieldBegin('TIMESTAMP', thrift.Thrift.Type.STRUCT, 8);\n            this.TIMESTAMP.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.INTEGER != null) {\n            output.writeFieldBegin('INTEGER', thrift.Thrift.Type.STRUCT, 10);\n            this.INTEGER.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.UNKNOWN != null) {\n            output.writeFieldBegin('UNKNOWN', thrift.Thrift.Type.STRUCT, 11);\n            this.UNKNOWN.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.JSON != null) {\n            output.writeFieldBegin('JSON', thrift.Thrift.Type.STRUCT, 12);\n            this.JSON.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.BSON != null) {\n            output.writeFieldBegin('BSON', thrift.Thrift.Type.STRUCT, 13);\n            this.BSON.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.UUID != null) {\n            output.writeFieldBegin('UUID', thrift.Thrift.Type.STRUCT, 14);\n            this.UUID.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        let _fieldsSet = 0;\n        let _returnValue = null;\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_1 = StringType.StringType.read(input);\n                        _returnValue = LogicalType.fromSTRING(value_1);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_2 = MapType.MapType.read(input);\n                        _returnValue = LogicalType.fromMAP(value_2);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_3 = ListType.ListType.read(input);\n                        _returnValue = LogicalType.fromLIST(value_3);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_4 = EnumType.EnumType.read(input);\n                        _returnValue = LogicalType.fromENUM(value_4);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_5 = DecimalType.DecimalType.read(input);\n                        _returnValue = LogicalType.fromDECIMAL(value_5);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_6 = DateType.DateType.read(input);\n                        _returnValue = LogicalType.fromDATE(value_6);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_7 = TimeType.TimeType.read(input);\n                        _returnValue = LogicalType.fromTIME(value_7);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 8:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_8 = TimestampType.TimestampType.read(input);\n                        _returnValue = LogicalType.fromTIMESTAMP(value_8);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 10:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_9 = IntType.IntType.read(input);\n                        _returnValue = LogicalType.fromINTEGER(value_9);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 11:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_10 = NullType.NullType.read(input);\n                        _returnValue = LogicalType.fromUNKNOWN(value_10);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 12:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_11 = JsonType.JsonType.read(input);\n                        _returnValue = LogicalType.fromJSON(value_11);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 13:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_12 = BsonType.BsonType.read(input);\n                        _returnValue = LogicalType.fromBSON(value_12);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 14:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_13 = UUIDType.UUIDType.read(input);\n                        _returnValue = LogicalType.fromUUID(value_13);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_fieldsSet > 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n        }\n        else if (_fieldsSet < 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n        }\n        if (_returnValue !== null) {\n            return _returnValue;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read data for TUnion');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as Statistics from \"./Statistics.js\";\nexport class DataPageHeader {\n    num_values;\n    encoding;\n    definition_level_encoding;\n    repetition_level_encoding;\n    statistics;\n    constructor(args) {\n        if (args != null && args.num_values != null) {\n            this.num_values = args.num_values;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_values] is unset!');\n        }\n        if (args != null && args.encoding != null) {\n            this.encoding = args.encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[encoding] is unset!');\n        }\n        if (args != null && args.definition_level_encoding != null) {\n            this.definition_level_encoding = args.definition_level_encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[definition_level_encoding] is unset!');\n        }\n        if (args != null && args.repetition_level_encoding != null) {\n            this.repetition_level_encoding = args.repetition_level_encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[repetition_level_encoding] is unset!');\n        }\n        if (args != null && args.statistics != null) {\n            this.statistics = args.statistics;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('DataPageHeader');\n        if (this.num_values != null) {\n            output.writeFieldBegin('num_values', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.num_values);\n            output.writeFieldEnd();\n        }\n        if (this.encoding != null) {\n            output.writeFieldBegin('encoding', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.encoding);\n            output.writeFieldEnd();\n        }\n        if (this.definition_level_encoding != null) {\n            output.writeFieldBegin('definition_level_encoding', thrift.Thrift.Type.I32, 3);\n            output.writeI32(this.definition_level_encoding);\n            output.writeFieldEnd();\n        }\n        if (this.repetition_level_encoding != null) {\n            output.writeFieldBegin('repetition_level_encoding', thrift.Thrift.Type.I32, 4);\n            output.writeI32(this.repetition_level_encoding);\n            output.writeFieldEnd();\n        }\n        if (this.statistics != null) {\n            output.writeFieldBegin('statistics', thrift.Thrift.Type.STRUCT, 5);\n            this.statistics.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.num_values = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.encoding = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_3 = input.readI32();\n                        _args.definition_level_encoding = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_4 = input.readI32();\n                        _args.repetition_level_encoding = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_5 = Statistics.Statistics.read(input);\n                        _args.statistics = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.num_values !== undefined &&\n            _args.encoding !== undefined &&\n            _args.definition_level_encoding !== undefined &&\n            _args.repetition_level_encoding !== undefined) {\n            return new DataPageHeader(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read DataPageHeader from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class IndexPageHeader {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('IndexPageHeader');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new IndexPageHeader();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class DictionaryPageHeader {\n    num_values;\n    encoding;\n    is_sorted;\n    constructor(args) {\n        if (args != null && args.num_values != null) {\n            this.num_values = args.num_values;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_values] is unset!');\n        }\n        if (args != null && args.encoding != null) {\n            this.encoding = args.encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[encoding] is unset!');\n        }\n        if (args != null && args.is_sorted != null) {\n            this.is_sorted = args.is_sorted;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('DictionaryPageHeader');\n        if (this.num_values != null) {\n            output.writeFieldBegin('num_values', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.num_values);\n            output.writeFieldEnd();\n        }\n        if (this.encoding != null) {\n            output.writeFieldBegin('encoding', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.encoding);\n            output.writeFieldEnd();\n        }\n        if (this.is_sorted != null) {\n            output.writeFieldBegin('is_sorted', thrift.Thrift.Type.BOOL, 3);\n            output.writeBool(this.is_sorted);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.num_values = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.encoding = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_3 = input.readBool();\n                        _args.is_sorted = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.num_values !== undefined && _args.encoding !== undefined) {\n            return new DictionaryPageHeader(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read DictionaryPageHeader from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as Statistics from \"./Statistics.js\";\nexport class DataPageHeaderV2 {\n    num_values;\n    num_nulls;\n    num_rows;\n    encoding;\n    definition_levels_byte_length;\n    repetition_levels_byte_length;\n    is_compressed = true;\n    statistics;\n    constructor(args) {\n        if (args != null && args.num_values != null) {\n            this.num_values = args.num_values;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_values] is unset!');\n        }\n        if (args != null && args.num_nulls != null) {\n            this.num_nulls = args.num_nulls;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_nulls] is unset!');\n        }\n        if (args != null && args.num_rows != null) {\n            this.num_rows = args.num_rows;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_rows] is unset!');\n        }\n        if (args != null && args.encoding != null) {\n            this.encoding = args.encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[encoding] is unset!');\n        }\n        if (args != null && args.definition_levels_byte_length != null) {\n            this.definition_levels_byte_length = args.definition_levels_byte_length;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[definition_levels_byte_length] is unset!');\n        }\n        if (args != null && args.repetition_levels_byte_length != null) {\n            this.repetition_levels_byte_length = args.repetition_levels_byte_length;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[repetition_levels_byte_length] is unset!');\n        }\n        if (args != null && args.is_compressed != null) {\n            this.is_compressed = args.is_compressed;\n        }\n        if (args != null && args.statistics != null) {\n            this.statistics = args.statistics;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('DataPageHeaderV2');\n        if (this.num_values != null) {\n            output.writeFieldBegin('num_values', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.num_values);\n            output.writeFieldEnd();\n        }\n        if (this.num_nulls != null) {\n            output.writeFieldBegin('num_nulls', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.num_nulls);\n            output.writeFieldEnd();\n        }\n        if (this.num_rows != null) {\n            output.writeFieldBegin('num_rows', thrift.Thrift.Type.I32, 3);\n            output.writeI32(this.num_rows);\n            output.writeFieldEnd();\n        }\n        if (this.encoding != null) {\n            output.writeFieldBegin('encoding', thrift.Thrift.Type.I32, 4);\n            output.writeI32(this.encoding);\n            output.writeFieldEnd();\n        }\n        if (this.definition_levels_byte_length != null) {\n            output.writeFieldBegin('definition_levels_byte_length', thrift.Thrift.Type.I32, 5);\n            output.writeI32(this.definition_levels_byte_length);\n            output.writeFieldEnd();\n        }\n        if (this.repetition_levels_byte_length != null) {\n            output.writeFieldBegin('repetition_levels_byte_length', thrift.Thrift.Type.I32, 6);\n            output.writeI32(this.repetition_levels_byte_length);\n            output.writeFieldEnd();\n        }\n        if (this.is_compressed != null) {\n            output.writeFieldBegin('is_compressed', thrift.Thrift.Type.BOOL, 7);\n            output.writeBool(this.is_compressed);\n            output.writeFieldEnd();\n        }\n        if (this.statistics != null) {\n            output.writeFieldBegin('statistics', thrift.Thrift.Type.STRUCT, 8);\n            this.statistics.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.num_values = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.num_nulls = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_3 = input.readI32();\n                        _args.num_rows = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_4 = input.readI32();\n                        _args.encoding = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_5 = input.readI32();\n                        _args.definition_levels_byte_length = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_6 = input.readI32();\n                        _args.repetition_levels_byte_length = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_7 = input.readBool();\n                        _args.is_compressed = value_7;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 8:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_8 = Statistics.Statistics.read(input);\n                        _args.statistics = value_8;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.num_values !== undefined &&\n            _args.num_nulls !== undefined &&\n            _args.num_rows !== undefined &&\n            _args.encoding !== undefined &&\n            _args.definition_levels_byte_length !== undefined &&\n            _args.repetition_levels_byte_length !== undefined) {\n            return new DataPageHeaderV2(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read DataPageHeaderV2 from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as DataPageHeader from \"./DataPageHeader.js\";\nimport * as DataPageHeaderV2 from \"./DataPageHeaderV2.js\";\nimport * as DictionaryPageHeader from \"./DictionaryPageHeader.js\";\nimport * as IndexPageHeader from \"./IndexPageHeader.js\";\nexport class PageHeader {\n    type;\n    uncompressed_page_size;\n    compressed_page_size;\n    crc;\n    data_page_header;\n    index_page_header;\n    dictionary_page_header;\n    data_page_header_v2;\n    constructor(args) {\n        if (args != null && args.type != null) {\n            this.type = args.type;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[type] is unset!');\n        }\n        if (args != null && args.uncompressed_page_size != null) {\n            this.uncompressed_page_size = args.uncompressed_page_size;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[uncompressed_page_size] is unset!');\n        }\n        if (args != null && args.compressed_page_size != null) {\n            this.compressed_page_size = args.compressed_page_size;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[compressed_page_size] is unset!');\n        }\n        if (args != null && args.crc != null) {\n            this.crc = args.crc;\n        }\n        if (args != null && args.data_page_header != null) {\n            this.data_page_header = args.data_page_header;\n        }\n        if (args != null && args.index_page_header != null) {\n            this.index_page_header = args.index_page_header;\n        }\n        if (args != null && args.dictionary_page_header != null) {\n            this.dictionary_page_header = args.dictionary_page_header;\n        }\n        if (args != null && args.data_page_header_v2 != null) {\n            this.data_page_header_v2 = args.data_page_header_v2;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('PageHeader');\n        if (this.type != null) {\n            output.writeFieldBegin('type', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.type);\n            output.writeFieldEnd();\n        }\n        if (this.uncompressed_page_size != null) {\n            output.writeFieldBegin('uncompressed_page_size', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.uncompressed_page_size);\n            output.writeFieldEnd();\n        }\n        if (this.compressed_page_size != null) {\n            output.writeFieldBegin('compressed_page_size', thrift.Thrift.Type.I32, 3);\n            output.writeI32(this.compressed_page_size);\n            output.writeFieldEnd();\n        }\n        if (this.crc != null) {\n            output.writeFieldBegin('crc', thrift.Thrift.Type.I32, 4);\n            output.writeI32(this.crc);\n            output.writeFieldEnd();\n        }\n        if (this.data_page_header != null) {\n            output.writeFieldBegin('data_page_header', thrift.Thrift.Type.STRUCT, 5);\n            this.data_page_header.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.index_page_header != null) {\n            output.writeFieldBegin('index_page_header', thrift.Thrift.Type.STRUCT, 6);\n            this.index_page_header.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.dictionary_page_header != null) {\n            output.writeFieldBegin('dictionary_page_header', thrift.Thrift.Type.STRUCT, 7);\n            this.dictionary_page_header.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.data_page_header_v2 != null) {\n            output.writeFieldBegin('data_page_header_v2', thrift.Thrift.Type.STRUCT, 8);\n            this.data_page_header_v2.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.type = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.uncompressed_page_size = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_3 = input.readI32();\n                        _args.compressed_page_size = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_4 = input.readI32();\n                        _args.crc = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_5 = DataPageHeader.DataPageHeader.read(input);\n                        _args.data_page_header = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_6 = IndexPageHeader.IndexPageHeader.read(input);\n                        _args.index_page_header = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_7 = DictionaryPageHeader.DictionaryPageHeader.read(input);\n                        _args.dictionary_page_header = value_7;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 8:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_8 = DataPageHeaderV2.DataPageHeaderV2.read(input);\n                        _args.data_page_header_v2 = value_8;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.type !== undefined &&\n            _args.uncompressed_page_size !== undefined &&\n            _args.compressed_page_size !== undefined) {\n            return new PageHeader(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read PageHeader from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class KeyValue {\n    key;\n    value;\n    constructor(args) {\n        if (args != null && args.key != null) {\n            this.key = args.key;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[key] is unset!');\n        }\n        if (args != null && args.value != null) {\n            this.value = args.value;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('KeyValue');\n        if (this.key != null) {\n            output.writeFieldBegin('key', thrift.Thrift.Type.STRING, 1);\n            output.writeString(this.key);\n            output.writeFieldEnd();\n        }\n        if (this.value != null) {\n            output.writeFieldBegin('value', thrift.Thrift.Type.STRING, 2);\n            output.writeString(this.value);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_1 = input.readString();\n                        _args.key = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_2 = input.readString();\n                        _args.value = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.key !== undefined) {\n            return new KeyValue(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read KeyValue from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class SortingColumn {\n    column_idx;\n    descending;\n    nulls_first;\n    constructor(args) {\n        if (args != null && args.column_idx != null) {\n            this.column_idx = args.column_idx;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[column_idx] is unset!');\n        }\n        if (args != null && args.descending != null) {\n            this.descending = args.descending;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[descending] is unset!');\n        }\n        if (args != null && args.nulls_first != null) {\n            this.nulls_first = args.nulls_first;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[nulls_first] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('SortingColumn');\n        if (this.column_idx != null) {\n            output.writeFieldBegin('column_idx', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.column_idx);\n            output.writeFieldEnd();\n        }\n        if (this.descending != null) {\n            output.writeFieldBegin('descending', thrift.Thrift.Type.BOOL, 2);\n            output.writeBool(this.descending);\n            output.writeFieldEnd();\n        }\n        if (this.nulls_first != null) {\n            output.writeFieldBegin('nulls_first', thrift.Thrift.Type.BOOL, 3);\n            output.writeBool(this.nulls_first);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.column_idx = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_2 = input.readBool();\n                        _args.descending = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.BOOL) {\n                        const value_3 = input.readBool();\n                        _args.nulls_first = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.column_idx !== undefined &&\n            _args.descending !== undefined &&\n            _args.nulls_first !== undefined) {\n            return new SortingColumn(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read SortingColumn from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class PageEncodingStats {\n    page_type;\n    encoding;\n    count;\n    constructor(args) {\n        if (args != null && args.page_type != null) {\n            this.page_type = args.page_type;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[page_type] is unset!');\n        }\n        if (args != null && args.encoding != null) {\n            this.encoding = args.encoding;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[encoding] is unset!');\n        }\n        if (args != null && args.count != null) {\n            this.count = args.count;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[count] is unset!');\n        }\n    }\n    write(output) {\n        output.writeStructBegin('PageEncodingStats');\n        if (this.page_type != null) {\n            output.writeFieldBegin('page_type', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.page_type);\n            output.writeFieldEnd();\n        }\n        if (this.encoding != null) {\n            output.writeFieldBegin('encoding', thrift.Thrift.Type.I32, 2);\n            output.writeI32(this.encoding);\n            output.writeFieldEnd();\n        }\n        if (this.count != null) {\n            output.writeFieldBegin('count', thrift.Thrift.Type.I32, 3);\n            output.writeI32(this.count);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_1 = input.readI32();\n                        _args.page_type = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_2 = input.readI32();\n                        _args.encoding = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_3 = input.readI32();\n                        _args.count = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.page_type !== undefined &&\n            _args.encoding !== undefined &&\n            _args.count !== undefined) {\n            return new PageEncodingStats(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read PageEncodingStats from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport Int64 from 'node-int64';\nimport * as thrift from 'thrift';\nimport * as KeyValue from \"./KeyValue.js\";\nimport * as PageEncodingStats from \"./PageEncodingStats.js\";\nimport * as Statistics from \"./Statistics.js\";\nexport class ColumnMetaData {\n    type;\n    encodings;\n    path_in_schema;\n    codec;\n    num_values;\n    total_uncompressed_size;\n    total_compressed_size;\n    key_value_metadata;\n    data_page_offset;\n    index_page_offset;\n    dictionary_page_offset;\n    statistics;\n    encoding_stats;\n    constructor(args) {\n        if (args != null && args.type != null) {\n            this.type = args.type;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[type] is unset!');\n        }\n        if (args != null && args.encodings != null) {\n            this.encodings = args.encodings;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[encodings] is unset!');\n        }\n        if (args != null && args.path_in_schema != null) {\n            this.path_in_schema = args.path_in_schema;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[path_in_schema] is unset!');\n        }\n        if (args != null && args.codec != null) {\n            this.codec = args.codec;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[codec] is unset!');\n        }\n        if (args != null && args.num_values != null) {\n            if (typeof args.num_values === 'number') {\n                this.num_values = new Int64(args.num_values);\n            }\n            else {\n                this.num_values = args.num_values;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_values] is unset!');\n        }\n        if (args != null && args.total_uncompressed_size != null) {\n            if (typeof args.total_uncompressed_size === 'number') {\n                this.total_uncompressed_size = new Int64(args.total_uncompressed_size);\n            }\n            else {\n                this.total_uncompressed_size = args.total_uncompressed_size;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[total_uncompressed_size] is unset!');\n        }\n        if (args != null && args.total_compressed_size != null) {\n            if (typeof args.total_compressed_size === 'number') {\n                this.total_compressed_size = new Int64(args.total_compressed_size);\n            }\n            else {\n                this.total_compressed_size = args.total_compressed_size;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[total_compressed_size] is unset!');\n        }\n        if (args != null && args.key_value_metadata != null) {\n            this.key_value_metadata = args.key_value_metadata;\n        }\n        if (args != null && args.data_page_offset != null) {\n            if (typeof args.data_page_offset === 'number') {\n                this.data_page_offset = new Int64(args.data_page_offset);\n            }\n            else {\n                this.data_page_offset = args.data_page_offset;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[data_page_offset] is unset!');\n        }\n        if (args != null && args.index_page_offset != null) {\n            if (typeof args.index_page_offset === 'number') {\n                this.index_page_offset = new Int64(args.index_page_offset);\n            }\n            else {\n                this.index_page_offset = args.index_page_offset;\n            }\n        }\n        if (args != null && args.dictionary_page_offset != null) {\n            if (typeof args.dictionary_page_offset === 'number') {\n                this.dictionary_page_offset = new Int64(args.dictionary_page_offset);\n            }\n            else {\n                this.dictionary_page_offset = args.dictionary_page_offset;\n            }\n        }\n        if (args != null && args.statistics != null) {\n            this.statistics = args.statistics;\n        }\n        if (args != null && args.encoding_stats != null) {\n            this.encoding_stats = args.encoding_stats;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('ColumnMetaData');\n        if (this.type != null) {\n            output.writeFieldBegin('type', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.type);\n            output.writeFieldEnd();\n        }\n        if (this.encodings != null) {\n            output.writeFieldBegin('encodings', thrift.Thrift.Type.LIST, 2);\n            output.writeListBegin(thrift.Thrift.Type.I32, this.encodings.length);\n            this.encodings.forEach((value_1) => {\n                output.writeI32(value_1);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.path_in_schema != null) {\n            output.writeFieldBegin('path_in_schema', thrift.Thrift.Type.LIST, 3);\n            output.writeListBegin(thrift.Thrift.Type.STRING, this.path_in_schema.length);\n            this.path_in_schema.forEach((value_2) => {\n                output.writeString(value_2);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.codec != null) {\n            output.writeFieldBegin('codec', thrift.Thrift.Type.I32, 4);\n            output.writeI32(this.codec);\n            output.writeFieldEnd();\n        }\n        if (this.num_values != null) {\n            output.writeFieldBegin('num_values', thrift.Thrift.Type.I64, 5);\n            output.writeI64(this.num_values);\n            output.writeFieldEnd();\n        }\n        if (this.total_uncompressed_size != null) {\n            output.writeFieldBegin('total_uncompressed_size', thrift.Thrift.Type.I64, 6);\n            output.writeI64(this.total_uncompressed_size);\n            output.writeFieldEnd();\n        }\n        if (this.total_compressed_size != null) {\n            output.writeFieldBegin('total_compressed_size', thrift.Thrift.Type.I64, 7);\n            output.writeI64(this.total_compressed_size);\n            output.writeFieldEnd();\n        }\n        if (this.key_value_metadata != null) {\n            output.writeFieldBegin('key_value_metadata', thrift.Thrift.Type.LIST, 8);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);\n            this.key_value_metadata.forEach((value_3) => {\n                value_3.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.data_page_offset != null) {\n            output.writeFieldBegin('data_page_offset', thrift.Thrift.Type.I64, 9);\n            output.writeI64(this.data_page_offset);\n            output.writeFieldEnd();\n        }\n        if (this.index_page_offset != null) {\n            output.writeFieldBegin('index_page_offset', thrift.Thrift.Type.I64, 10);\n            output.writeI64(this.index_page_offset);\n            output.writeFieldEnd();\n        }\n        if (this.dictionary_page_offset != null) {\n            output.writeFieldBegin('dictionary_page_offset', thrift.Thrift.Type.I64, 11);\n            output.writeI64(this.dictionary_page_offset);\n            output.writeFieldEnd();\n        }\n        if (this.statistics != null) {\n            output.writeFieldBegin('statistics', thrift.Thrift.Type.STRUCT, 12);\n            this.statistics.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.encoding_stats != null) {\n            output.writeFieldBegin('encoding_stats', thrift.Thrift.Type.LIST, 13);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.encoding_stats.length);\n            this.encoding_stats.forEach((value_4) => {\n                value_4.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_5 = input.readI32();\n                        _args.type = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_6 = new Array();\n                        const metadata_1 = input.readListBegin();\n                        const size_1 = metadata_1.size;\n                        for (let i_1 = 0; i_1 < size_1; i_1++) {\n                            const value_7 = input.readI32();\n                            value_6.push(value_7);\n                        }\n                        input.readListEnd();\n                        _args.encodings = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_8 = new Array();\n                        const metadata_2 = input.readListBegin();\n                        const size_2 = metadata_2.size;\n                        for (let i_2 = 0; i_2 < size_2; i_2++) {\n                            const value_9 = input.readString();\n                            value_8.push(value_9);\n                        }\n                        input.readListEnd();\n                        _args.path_in_schema = value_8;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_10 = input.readI32();\n                        _args.codec = value_10;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_11 = input.readI64();\n                        _args.num_values = value_11;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_12 = input.readI64();\n                        _args.total_uncompressed_size = value_12;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_13 = input.readI64();\n                        _args.total_compressed_size = value_13;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 8:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_14 = new Array();\n                        const metadata_3 = input.readListBegin();\n                        const size_3 = metadata_3.size;\n                        for (let i_3 = 0; i_3 < size_3; i_3++) {\n                            const value_15 = KeyValue.KeyValue.read(input);\n                            value_14.push(value_15);\n                        }\n                        input.readListEnd();\n                        _args.key_value_metadata = value_14;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 9:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_16 = input.readI64();\n                        _args.data_page_offset = value_16;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 10:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_17 = input.readI64();\n                        _args.index_page_offset = value_17;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 11:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_18 = input.readI64();\n                        _args.dictionary_page_offset = value_18;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 12:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_19 = Statistics.Statistics.read(input);\n                        _args.statistics = value_19;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 13:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_20 = new Array();\n                        const metadata_4 = input.readListBegin();\n                        const size_4 = metadata_4.size;\n                        for (let i_4 = 0; i_4 < size_4; i_4++) {\n                            const value_21 = PageEncodingStats.PageEncodingStats.read(input);\n                            value_20.push(value_21);\n                        }\n                        input.readListEnd();\n                        _args.encoding_stats = value_20;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.type !== undefined &&\n            _args.encodings !== undefined &&\n            _args.path_in_schema !== undefined &&\n            _args.codec !== undefined &&\n            _args.num_values !== undefined &&\n            _args.total_uncompressed_size !== undefined &&\n            _args.total_compressed_size !== undefined &&\n            _args.data_page_offset !== undefined) {\n            return new ColumnMetaData(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read ColumnMetaData from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport Int64 from 'node-int64';\nimport * as thrift from 'thrift';\nimport * as ColumnMetaData from \"./ColumnMetaData.js\";\nexport class ColumnChunk {\n    file_path;\n    file_offset;\n    meta_data;\n    offset_index_offset;\n    offset_index_length;\n    column_index_offset;\n    column_index_length;\n    constructor(args) {\n        if (args != null && args.file_path != null) {\n            this.file_path = args.file_path;\n        }\n        if (args != null && args.file_offset != null) {\n            if (typeof args.file_offset === 'number') {\n                this.file_offset = new Int64(args.file_offset);\n            }\n            else {\n                this.file_offset = args.file_offset;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[file_offset] is unset!');\n        }\n        if (args != null && args.meta_data != null) {\n            this.meta_data = args.meta_data;\n        }\n        if (args != null && args.offset_index_offset != null) {\n            if (typeof args.offset_index_offset === 'number') {\n                this.offset_index_offset = new Int64(args.offset_index_offset);\n            }\n            else {\n                this.offset_index_offset = args.offset_index_offset;\n            }\n        }\n        if (args != null && args.offset_index_length != null) {\n            this.offset_index_length = args.offset_index_length;\n        }\n        if (args != null && args.column_index_offset != null) {\n            if (typeof args.column_index_offset === 'number') {\n                this.column_index_offset = new Int64(args.column_index_offset);\n            }\n            else {\n                this.column_index_offset = args.column_index_offset;\n            }\n        }\n        if (args != null && args.column_index_length != null) {\n            this.column_index_length = args.column_index_length;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('ColumnChunk');\n        if (this.file_path != null) {\n            output.writeFieldBegin('file_path', thrift.Thrift.Type.STRING, 1);\n            output.writeString(this.file_path);\n            output.writeFieldEnd();\n        }\n        if (this.file_offset != null) {\n            output.writeFieldBegin('file_offset', thrift.Thrift.Type.I64, 2);\n            output.writeI64(this.file_offset);\n            output.writeFieldEnd();\n        }\n        if (this.meta_data != null) {\n            output.writeFieldBegin('meta_data', thrift.Thrift.Type.STRUCT, 3);\n            this.meta_data.write(output);\n            output.writeFieldEnd();\n        }\n        if (this.offset_index_offset != null) {\n            output.writeFieldBegin('offset_index_offset', thrift.Thrift.Type.I64, 4);\n            output.writeI64(this.offset_index_offset);\n            output.writeFieldEnd();\n        }\n        if (this.offset_index_length != null) {\n            output.writeFieldBegin('offset_index_length', thrift.Thrift.Type.I32, 5);\n            output.writeI32(this.offset_index_length);\n            output.writeFieldEnd();\n        }\n        if (this.column_index_offset != null) {\n            output.writeFieldBegin('column_index_offset', thrift.Thrift.Type.I64, 6);\n            output.writeI64(this.column_index_offset);\n            output.writeFieldEnd();\n        }\n        if (this.column_index_length != null) {\n            output.writeFieldBegin('column_index_length', thrift.Thrift.Type.I32, 7);\n            output.writeI32(this.column_index_length);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_1 = input.readString();\n                        _args.file_path = value_1;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_2 = input.readI64();\n                        _args.file_offset = value_2;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        const value_3 = ColumnMetaData.ColumnMetaData.read(input);\n                        _args.meta_data = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_4 = input.readI64();\n                        _args.offset_index_offset = value_4;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_5 = input.readI32();\n                        _args.offset_index_length = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_6 = input.readI64();\n                        _args.column_index_offset = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_7 = input.readI32();\n                        _args.column_index_length = value_7;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.file_offset !== undefined) {\n            return new ColumnChunk(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read ColumnChunk from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport Int64 from 'node-int64';\nimport * as thrift from 'thrift';\nimport * as ColumnChunk from \"./ColumnChunk.js\";\nimport * as SortingColumn from \"./SortingColumn.js\";\nexport class RowGroup {\n    columns;\n    total_byte_size;\n    num_rows;\n    sorting_columns;\n    constructor(args) {\n        if (args != null && args.columns != null) {\n            this.columns = args.columns;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[columns] is unset!');\n        }\n        if (args != null && args.total_byte_size != null) {\n            if (typeof args.total_byte_size === 'number') {\n                this.total_byte_size = new Int64(args.total_byte_size);\n            }\n            else {\n                this.total_byte_size = args.total_byte_size;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[total_byte_size] is unset!');\n        }\n        if (args != null && args.num_rows != null) {\n            if (typeof args.num_rows === 'number') {\n                this.num_rows = new Int64(args.num_rows);\n            }\n            else {\n                this.num_rows = args.num_rows;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_rows] is unset!');\n        }\n        if (args != null && args.sorting_columns != null) {\n            this.sorting_columns = args.sorting_columns;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('RowGroup');\n        if (this.columns != null) {\n            output.writeFieldBegin('columns', thrift.Thrift.Type.LIST, 1);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.columns.length);\n            this.columns.forEach((value_1) => {\n                value_1.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.total_byte_size != null) {\n            output.writeFieldBegin('total_byte_size', thrift.Thrift.Type.I64, 2);\n            output.writeI64(this.total_byte_size);\n            output.writeFieldEnd();\n        }\n        if (this.num_rows != null) {\n            output.writeFieldBegin('num_rows', thrift.Thrift.Type.I64, 3);\n            output.writeI64(this.num_rows);\n            output.writeFieldEnd();\n        }\n        if (this.sorting_columns != null) {\n            output.writeFieldBegin('sorting_columns', thrift.Thrift.Type.LIST, 4);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.sorting_columns.length);\n            this.sorting_columns.forEach((value_2) => {\n                value_2.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_3 = new Array();\n                        const metadata_1 = input.readListBegin();\n                        const size_1 = metadata_1.size;\n                        for (let i_1 = 0; i_1 < size_1; i_1++) {\n                            const value_4 = ColumnChunk.ColumnChunk.read(input);\n                            value_3.push(value_4);\n                        }\n                        input.readListEnd();\n                        _args.columns = value_3;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_5 = input.readI64();\n                        _args.total_byte_size = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_6 = input.readI64();\n                        _args.num_rows = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_7 = new Array();\n                        const metadata_2 = input.readListBegin();\n                        const size_2 = metadata_2.size;\n                        for (let i_2 = 0; i_2 < size_2; i_2++) {\n                            const value_8 = SortingColumn.SortingColumn.read(input);\n                            value_7.push(value_8);\n                        }\n                        input.readListEnd();\n                        _args.sorting_columns = value_7;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.columns !== undefined &&\n            _args.total_byte_size !== undefined &&\n            _args.num_rows !== undefined) {\n            return new RowGroup(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read RowGroup from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nexport class TypeDefinedOrder {\n    constructor() { }\n    write(output) {\n        output.writeStructBegin('TypeDefinedOrder');\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        return new TypeDefinedOrder();\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport Int64 from 'node-int64';\nimport * as thrift from 'thrift';\nimport * as ColumnOrder from \"./ColumnOrder.js\";\nimport * as KeyValue from \"./KeyValue.js\";\nimport * as RowGroup from \"./RowGroup.js\";\nimport * as SchemaElement from \"./SchemaElement.js\";\nexport class FileMetaData {\n    version;\n    schema;\n    num_rows;\n    row_groups;\n    key_value_metadata;\n    created_by;\n    column_orders;\n    constructor(args = null) {\n        if (args != null && args.version != null) {\n            this.version = args.version;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[version] is unset!');\n        }\n        if (args != null && args.schema != null) {\n            this.schema = args.schema;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[schema] is unset!');\n        }\n        if (args != null && args.num_rows != null) {\n            if (typeof args.num_rows === 'number') {\n                this.num_rows = new Int64(args.num_rows);\n            }\n            else {\n                this.num_rows = args.num_rows;\n            }\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[num_rows] is unset!');\n        }\n        if (args != null && args.row_groups != null) {\n            this.row_groups = args.row_groups;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Required field[row_groups] is unset!');\n        }\n        if (args != null && args.key_value_metadata != null) {\n            this.key_value_metadata = args.key_value_metadata;\n        }\n        if (args != null && args.created_by != null) {\n            this.created_by = args.created_by;\n        }\n        if (args != null && args.column_orders != null) {\n            this.column_orders = args.column_orders;\n        }\n    }\n    write(output) {\n        output.writeStructBegin('FileMetaData');\n        if (this.version != null) {\n            output.writeFieldBegin('version', thrift.Thrift.Type.I32, 1);\n            output.writeI32(this.version);\n            output.writeFieldEnd();\n        }\n        if (this.schema != null) {\n            output.writeFieldBegin('schema', thrift.Thrift.Type.LIST, 2);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.schema.length);\n            this.schema.forEach((value_1) => {\n                value_1.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.num_rows != null) {\n            output.writeFieldBegin('num_rows', thrift.Thrift.Type.I64, 3);\n            output.writeI64(this.num_rows);\n            output.writeFieldEnd();\n        }\n        if (this.row_groups != null) {\n            output.writeFieldBegin('row_groups', thrift.Thrift.Type.LIST, 4);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.row_groups.length);\n            this.row_groups.forEach((value_2) => {\n                value_2.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.key_value_metadata != null) {\n            output.writeFieldBegin('key_value_metadata', thrift.Thrift.Type.LIST, 5);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);\n            this.key_value_metadata.forEach((value_3) => {\n                value_3.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        if (this.created_by != null) {\n            output.writeFieldBegin('created_by', thrift.Thrift.Type.STRING, 6);\n            output.writeString(this.created_by);\n            output.writeFieldEnd();\n        }\n        if (this.column_orders != null) {\n            output.writeFieldBegin('column_orders', thrift.Thrift.Type.LIST, 7);\n            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.column_orders.length);\n            this.column_orders.forEach((value_4) => {\n                value_4.write(output);\n            });\n            output.writeListEnd();\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        input.readStructBegin();\n        let _args = {};\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.I32) {\n                        const value_5 = input.readI32();\n                        _args.version = value_5;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 2:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_6 = new Array();\n                        const metadata_1 = input.readListBegin();\n                        const size_1 = metadata_1.size;\n                        for (let i_1 = 0; i_1 < size_1; i_1++) {\n                            const value_7 = SchemaElement.SchemaElement.read(input);\n                            value_6.push(value_7);\n                        }\n                        input.readListEnd();\n                        _args.schema = value_6;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 3:\n                    if (fieldType === thrift.Thrift.Type.I64) {\n                        const value_8 = input.readI64();\n                        _args.num_rows = value_8;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 4:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_9 = new Array();\n                        const metadata_2 = input.readListBegin();\n                        const size_2 = metadata_2.size;\n                        for (let i_2 = 0; i_2 < size_2; i_2++) {\n                            const value_10 = RowGroup.RowGroup.read(input);\n                            value_9.push(value_10);\n                        }\n                        input.readListEnd();\n                        _args.row_groups = value_9;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 5:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_11 = new Array();\n                        const metadata_3 = input.readListBegin();\n                        const size_3 = metadata_3.size;\n                        for (let i_3 = 0; i_3 < size_3; i_3++) {\n                            const value_12 = KeyValue.KeyValue.read(input);\n                            value_11.push(value_12);\n                        }\n                        input.readListEnd();\n                        _args.key_value_metadata = value_11;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 6:\n                    if (fieldType === thrift.Thrift.Type.STRING) {\n                        const value_13 = input.readString();\n                        _args.created_by = value_13;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                case 7:\n                    if (fieldType === thrift.Thrift.Type.LIST) {\n                        const value_14 = new Array();\n                        const metadata_4 = input.readListBegin();\n                        const size_4 = metadata_4.size;\n                        for (let i_4 = 0; i_4 < size_4; i_4++) {\n                            const value_15 = ColumnOrder.ColumnOrder.read(input);\n                            value_14.push(value_15);\n                        }\n                        input.readListEnd();\n                        _args.column_orders = value_14;\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_args.version !== undefined &&\n            _args.schema !== undefined &&\n            _args.num_rows !== undefined &&\n            _args.row_groups !== undefined) {\n            return new FileMetaData(_args);\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read FileMetaData from input');\n        }\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/*\n * Autogenerated by @creditkarma/thrift-typescript v3.7.2\n * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n */\nimport * as thrift from 'thrift';\nimport * as TypeDefinedOrder from \"./TypeDefinedOrder.js\";\nexport class ColumnOrder {\n    TYPE_ORDER;\n    constructor(args) {\n        let _fieldsSet = 0;\n        if (args != null) {\n            if (args.TYPE_ORDER != null) {\n                _fieldsSet++;\n                this.TYPE_ORDER = args.TYPE_ORDER;\n            }\n            if (_fieldsSet > 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n            }\n            else if (_fieldsSet < 1) {\n                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n            }\n        }\n    }\n    static fromTYPE_ORDER(TYPE_ORDER) {\n        return new ColumnOrder({ TYPE_ORDER });\n    }\n    write(output) {\n        output.writeStructBegin('ColumnOrder');\n        if (this.TYPE_ORDER != null) {\n            output.writeFieldBegin('TYPE_ORDER', thrift.Thrift.Type.STRUCT, 1);\n            this.TYPE_ORDER.write(output);\n            output.writeFieldEnd();\n        }\n        output.writeFieldStop();\n        output.writeStructEnd();\n        return;\n    }\n    static read(input) {\n        let _fieldsSet = 0;\n        let _returnValue = null;\n        input.readStructBegin();\n        while (true) {\n            const ret = input.readFieldBegin();\n            const fieldType = ret.ftype;\n            const fieldId = ret.fid;\n            if (fieldType === thrift.Thrift.Type.STOP) {\n                break;\n            }\n            switch (fieldId) {\n                case 1:\n                    if (fieldType === thrift.Thrift.Type.STRUCT) {\n                        _fieldsSet++;\n                        const value_1 = TypeDefinedOrder.TypeDefinedOrder.read(input);\n                        _returnValue = ColumnOrder.fromTYPE_ORDER(value_1);\n                    }\n                    else {\n                        input.skip(fieldType);\n                    }\n                    break;\n                default: {\n                    input.skip(fieldType);\n                }\n            }\n            input.readFieldEnd();\n        }\n        input.readStructEnd();\n        if (_fieldsSet > 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with more than one set value!');\n        }\n        else if (_fieldsSet < 1) {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, 'Cannot read a TUnion with no set value!');\n        }\n        if (_returnValue !== null) {\n            return _returnValue;\n        }\n        else {\n            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, 'Unable to read data for TUnion');\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\nexport const PARQUET_WASM_URL = 'https://unpkg.com/parquet-wasm@0.6.1/esm/parquet_wasm_bg.wasm';\n/**\n * Parquet File Magic String\n */\nexport const PARQUET_MAGIC = 'PAR1';\nexport const PARQUET_MAGIC_ENCRYPTED = 'PARE';\n/**\n * Parquet File Format Version\n */\nexport const PARQUET_VERSION = 1;\n/**\n * Internal type used for repetition/definition levels\n */\nexport const PARQUET_RDLVL_TYPE = 'INT32';\nexport const PARQUET_RDLVL_ENCODING = 'RLE';\n", "import { TBufferedTransport, TCompactProtocol, TFramedTransport, FileMetaData, PageHeader } from \"../parquet-thrift/index.js\";\nclass UFramedTransport extends TFramedTransport {\n    readPos = 0;\n}\n/**\n * Helper function that serializes a thrift object into a buffer\n */\nexport function serializeThrift(obj) {\n    const output = [];\n    const transport = new TBufferedTransport(undefined, (buf) => {\n        output.push(buf);\n    });\n    const protocol = new TCompactProtocol(transport);\n    obj.write(protocol);\n    transport.flush();\n    return Buffer.concat(output);\n}\nexport function decodeThrift(obj, buf, offset) {\n    if (!offset) {\n        // tslint:disable-next-line:no-parameter-reassignment\n        offset = 0;\n    }\n    const transport = new UFramedTransport(buf);\n    transport.readPos = offset;\n    const protocol = new TCompactProtocol(transport);\n    obj.read(protocol);\n    return transport.readPos - offset;\n}\n/**\n * FIXME not ideal that this is linear\n */\nexport function getThriftEnum(klass, value) {\n    for (const k in klass) {\n        if (klass[k] === value) {\n            return k;\n        }\n    }\n    throw new Error('Invalid ENUM value');\n}\nexport function decodeFileMetadata(buf, offset) {\n    if (!offset) {\n        // tslint:disable-next-line:no-parameter-reassignment\n        offset = 0;\n    }\n    const transport = new UFramedTransport(buf);\n    transport.readPos = offset;\n    const protocol = new TCompactProtocol(transport);\n    const metadata = FileMetaData.read(protocol);\n    return { length: transport.readPos - offset, metadata };\n}\nexport function decodePageHeader(buf, offset) {\n    if (!offset) {\n        // tslint:disable-next-line:no-parameter-reassignment\n        offset = 0;\n    }\n    const transport = new UFramedTransport(buf);\n    transport.readPos = offset;\n    const protocol = new TCompactProtocol(transport);\n    const pageHeader = PageHeader.read(protocol);\n    return { length: transport.readPos - offset, pageHeader };\n}\n/**\n * Get the number of bits required to store a given value\n */\nexport function getBitWidth(val) {\n    if (val === 0) {\n        return 0;\n        // tslint:disable-next-line:no-else-after-return\n    }\n    return Math.ceil(Math.log2(val + 1));\n}\n// Supports MQTT path wildcards\n// + all immediate children\n// # all descendents\nexport function fieldIndexOf(arr, elem) {\n    for (let j = 0; j < arr.length; j++) {\n        if (arr[j].length > elem.length) {\n            continue; // eslint-disable-line no-continue\n        }\n        let m = true;\n        for (let i = 0; i < elem.length; i++) {\n            if (arr[j][i] === elem[i] || arr[j][i] === '+' || arr[j][i] === '#') {\n                continue; // eslint-disable-line no-continue\n            }\n            if (i >= arr[j].length && arr[j][arr[j].length - 1] === '#') {\n                continue; // eslint-disable-line no-continue\n            }\n            m = false;\n            break;\n        }\n        if (m)\n            return j;\n    }\n    return -1;\n}\n", "import { PARQUET_CODECS } from \"../codecs/index.js\";\nimport { ConvertedType, Encoding, FieldRepetitionType, PageType, Type } from \"../parquet-thrift/index.js\";\nimport { decompress } from \"../compression.js\";\nimport { PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING } from \"../../lib/constants.js\";\nimport { decodePageHeader, getThriftEnum, getBitWidth } from \"../utils/read-utils.js\";\n/**\n * Decode data pages\n * @param buffer - input data\n * @param column - parquet column\n * @param compression - compression type\n * @returns parquet data page data\n */\nexport async function decodeDataPages(buffer, context) {\n    const cursor = {\n        buffer,\n        offset: 0,\n        size: buffer.length\n    };\n    const data = {\n        rlevels: [],\n        dlevels: [],\n        values: [],\n        pageHeaders: [],\n        count: 0\n    };\n    let dictionary = context.dictionary || [];\n    while (\n    // @ts-ignore size can be undefined\n    cursor.offset < cursor.size &&\n        (!context.numValues || data.dlevels.length < Number(context.numValues))) {\n        // Looks like we have to decode these in sequence due to cursor updates?\n        const page = await decodePage(cursor, context);\n        if (page.dictionary) {\n            dictionary = page.dictionary;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const valueEncoding = getThriftEnum(Encoding, page.pageHeader.data_page_header?.encoding);\n        // Pages might be in different encodings. We don't need to decode in case\n        // of 'PLAIN' encoding because all values are already in place\n        if (dictionary.length && valueEncoding !== 'PLAIN') {\n            // eslint-disable-next-line no-loop-func\n            page.values = page.values.map((value) => dictionary[value]);\n        }\n        for (let index = 0; index < page.rlevels.length; index++) {\n            data.rlevels.push(page.rlevels[index]);\n            data.dlevels.push(page.dlevels[index]);\n            const value = page.values[index];\n            if (value !== undefined) {\n                data.values.push(value);\n            }\n        }\n        data.count += page.count;\n        data.pageHeaders.push(page.pageHeader);\n    }\n    return data;\n}\n/**\n * Decode parquet page based on page type\n * @param cursor\n * @param context\n */\nexport async function decodePage(cursor, context) {\n    let page;\n    const { pageHeader, length } = decodePageHeader(cursor.buffer, cursor.offset);\n    cursor.offset += length;\n    const pageType = getThriftEnum(PageType, pageHeader.type);\n    switch (pageType) {\n        case 'DATA_PAGE':\n            page = await decodeDataPage(cursor, pageHeader, context);\n            break;\n        case 'DATA_PAGE_V2':\n            page = await decodeDataPageV2(cursor, pageHeader, context);\n            break;\n        case 'DICTIONARY_PAGE':\n            page = {\n                dictionary: await decodeDictionaryPage(cursor, pageHeader, context),\n                pageHeader\n            };\n            break;\n        default:\n            throw new Error(`invalid page type: ${pageType}`);\n    }\n    return page;\n}\n/**\n * Decode parquet schema\n * @param schemaElements input schema elements data\n * @param offset offset to read from\n * @param len length of data\n * @returns result.offset\n *   result.next - offset at the end of function\n *   result.schema - schema read from the input data\n * @todo output offset is the same as input - possibly excess output field\n */\nexport function decodeSchema(schemaElements, offset, len) {\n    const schema = {};\n    let next = offset;\n    for (let i = 0; i < len; i++) {\n        const schemaElement = schemaElements[next];\n        const repetitionType = next > 0 ? getThriftEnum(FieldRepetitionType, schemaElement.repetition_type) : 'ROOT';\n        let optional = false;\n        let repeated = false;\n        switch (repetitionType) {\n            case 'REQUIRED':\n                break;\n            case 'OPTIONAL':\n                optional = true;\n                break;\n            case 'REPEATED':\n                repeated = true;\n                break;\n            default:\n                throw new Error('parquet: unknown repetition type');\n        }\n        if (schemaElement.num_children > 0) {\n            const res = decodeSchema(schemaElements, next + 1, schemaElement.num_children);\n            next = res.next;\n            schema[schemaElement.name] = {\n                // type: undefined,\n                optional,\n                repeated,\n                fields: res.schema\n            };\n        }\n        else {\n            const type = getThriftEnum(Type, schemaElement.type);\n            let logicalType = type;\n            if (schemaElement.converted_type) {\n                logicalType = getThriftEnum(ConvertedType, schemaElement.converted_type);\n            }\n            switch (logicalType) {\n                case 'DECIMAL':\n                    logicalType = `${logicalType}_${type}`;\n                    break;\n                default:\n            }\n            schema[schemaElement.name] = {\n                type: logicalType,\n                typeLength: schemaElement.type_length,\n                presision: schemaElement.precision,\n                scale: schemaElement.scale,\n                optional,\n                repeated\n            };\n            next++;\n        }\n    }\n    return { schema, offset, next };\n}\n/**\n * Decode a consecutive array of data using one of the parquet encodings\n */\nfunction decodeValues(type, encoding, cursor, count, opts) {\n    if (!(encoding in PARQUET_CODECS)) {\n        throw new Error(`invalid encoding: ${encoding}`);\n    }\n    return PARQUET_CODECS[encoding].decodeValues(type, cursor, count, opts);\n}\n/**\n * Do decoding of parquet dataPage from column chunk\n * @param cursor\n * @param header\n * @param options\n */\nasync function decodeDataPage(cursor, header, context) {\n    const cursorEnd = cursor.offset + header.compressed_page_size;\n    const valueCount = header.data_page_header?.num_values;\n    /* uncompress page */\n    let dataCursor = cursor;\n    if (context.compression !== 'UNCOMPRESSED') {\n        const valuesBuf = await decompress(context.compression, cursor.buffer.slice(cursor.offset, cursorEnd), header.uncompressed_page_size);\n        dataCursor = {\n            buffer: valuesBuf,\n            offset: 0,\n            size: valuesBuf.length\n        };\n        cursor.offset = cursorEnd;\n    }\n    /* read repetition levels */\n    const rLevelEncoding = getThriftEnum(Encoding, header.data_page_header?.repetition_level_encoding);\n    // tslint:disable-next-line:prefer-array-literal\n    let rLevels = new Array(valueCount);\n    if (context.column.rLevelMax > 0) {\n        rLevels = decodeValues(PARQUET_RDLVL_TYPE, rLevelEncoding, dataCursor, valueCount, {\n            bitWidth: getBitWidth(context.column.rLevelMax),\n            disableEnvelope: false\n            // column: opts.column\n        });\n    }\n    else {\n        rLevels.fill(0);\n    }\n    /* read definition levels */\n    const dLevelEncoding = getThriftEnum(Encoding, header.data_page_header?.definition_level_encoding);\n    // tslint:disable-next-line:prefer-array-literal\n    let dLevels = new Array(valueCount);\n    if (context.column.dLevelMax > 0) {\n        dLevels = decodeValues(PARQUET_RDLVL_TYPE, dLevelEncoding, dataCursor, valueCount, {\n            bitWidth: getBitWidth(context.column.dLevelMax),\n            disableEnvelope: false\n            // column: opts.column\n        });\n    }\n    else {\n        dLevels.fill(0);\n    }\n    let valueCountNonNull = 0;\n    for (const dlvl of dLevels) {\n        if (dlvl === context.column.dLevelMax) {\n            valueCountNonNull++;\n        }\n    }\n    /* read values */\n    const valueEncoding = getThriftEnum(Encoding, header.data_page_header?.encoding);\n    const decodeOptions = {\n        typeLength: context.column.typeLength,\n        bitWidth: context.column.typeLength\n    };\n    const values = decodeValues(context.column.primitiveType, valueEncoding, dataCursor, valueCountNonNull, decodeOptions);\n    return {\n        dlevels: dLevels,\n        rlevels: rLevels,\n        values,\n        count: valueCount,\n        pageHeader: header\n    };\n}\n/**\n * Do decoding of parquet dataPage in version 2 from column chunk\n * @param cursor\n * @param header\n * @param opts\n * @returns\n */\nasync function decodeDataPageV2(cursor, header, context) {\n    const cursorEnd = cursor.offset + header.compressed_page_size;\n    const valueCount = header.data_page_header_v2?.num_values;\n    // @ts-ignore\n    const valueCountNonNull = valueCount - header.data_page_header_v2?.num_nulls;\n    const valueEncoding = getThriftEnum(Encoding, header.data_page_header_v2?.encoding);\n    /* read repetition levels */\n    // tslint:disable-next-line:prefer-array-literal\n    let rLevels = new Array(valueCount);\n    if (context.column.rLevelMax > 0) {\n        rLevels = decodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, cursor, valueCount, {\n            bitWidth: getBitWidth(context.column.rLevelMax),\n            disableEnvelope: true\n        });\n    }\n    else {\n        rLevels.fill(0);\n    }\n    /* read definition levels */\n    // tslint:disable-next-line:prefer-array-literal\n    let dLevels = new Array(valueCount);\n    if (context.column.dLevelMax > 0) {\n        dLevels = decodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, cursor, valueCount, {\n            bitWidth: getBitWidth(context.column.dLevelMax),\n            disableEnvelope: true\n        });\n    }\n    else {\n        dLevels.fill(0);\n    }\n    /* read values */\n    let valuesBufCursor = cursor;\n    if (header.data_page_header_v2?.is_compressed) {\n        const valuesBuf = await decompress(context.compression, cursor.buffer.slice(cursor.offset, cursorEnd), header.uncompressed_page_size);\n        valuesBufCursor = {\n            buffer: valuesBuf,\n            offset: 0,\n            size: valuesBuf.length\n        };\n        cursor.offset = cursorEnd;\n    }\n    const decodeOptions = {\n        typeLength: context.column.typeLength,\n        bitWidth: context.column.typeLength\n    };\n    const values = decodeValues(context.column.primitiveType, valueEncoding, valuesBufCursor, valueCountNonNull, decodeOptions);\n    return {\n        dlevels: dLevels,\n        rlevels: rLevels,\n        values,\n        count: valueCount,\n        pageHeader: header\n    };\n}\n/**\n * Do decoding of dictionary page which helps to iterate over all indexes and get dataPage values.\n * @param cursor\n * @param pageHeader\n * @param context\n */\nasync function decodeDictionaryPage(cursor, pageHeader, context) {\n    const cursorEnd = cursor.offset + pageHeader.compressed_page_size;\n    let dictCursor = {\n        offset: 0,\n        buffer: cursor.buffer.slice(cursor.offset, cursorEnd),\n        size: cursorEnd - cursor.offset\n    };\n    cursor.offset = cursorEnd;\n    if (context.compression !== 'UNCOMPRESSED') {\n        const valuesBuf = await decompress(context.compression, dictCursor.buffer.slice(dictCursor.offset, cursorEnd), pageHeader.uncompressed_page_size);\n        dictCursor = {\n            buffer: valuesBuf,\n            offset: 0,\n            size: valuesBuf.length\n        };\n        cursor.offset = cursorEnd;\n    }\n    const numValues = pageHeader?.dictionary_page_header?.num_values || 0;\n    const decodedDictionaryValues = decodeValues(context.column.primitiveType, context.column.encoding, dictCursor, numValues, \n    // TODO - this looks wrong?\n    context);\n    // Makes it look a little easier\n    let values;\n    if (context?.preserveBinary) {\n        values = decodedDictionaryValues.map((d) => preserveBinary(d));\n    }\n    else {\n        values = decodedDictionaryValues.map((d) => d.toString());\n    }\n    return values;\n}\nfunction preserveBinary(d) {\n    if (ArrayBuffer.isView(d)) {\n        return d;\n    }\n    // Convert to ArrayBuffer\n    if (Buffer.isBuffer(d)) {\n        return d.buffer.slice(d.byteOffset, d.byteLength);\n    }\n    return d.toString();\n}\n", "import { ParquetSchema } from \"../schema/schema.js\";\nimport { decodeSchema, decodeDataPages, decodePage } from \"./decoders.js\";\nimport { materializeRows } from \"../schema/shred.js\";\nimport { PARQUET_MAGIC, PARQUET_MAGIC_ENCRYPTED } from \"../../lib/constants.js\";\nimport { CompressionCodec, Type } from \"../parquet-thrift/index.js\";\nimport { decodeFileMetadata, getThriftEnum, fieldIndexOf } from \"../utils/read-utils.js\";\n/**\n * The parquet envelope reader allows direct, unbuffered access to the individual\n * sections of the parquet file, namely the header, footer and the row groups.\n * This class is intended for advanced/internal users; if you just want to retrieve\n * rows from a parquet file use the ParquetReader instead\n */\nexport class ParquetReader {\n    static defaultProps = {\n        // max ArrayBuffer size in js is 2Gb\n        defaultDictionarySize: 2147483648,\n        preserveBinary: false\n    };\n    props;\n    file;\n    metadata = null;\n    constructor(file, props) {\n        this.file = file;\n        this.props = { ...ParquetReader.defaultProps, ...props };\n    }\n    close() {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.file.close();\n    }\n    // HIGH LEVEL METHODS\n    /** Yield one row at a time */\n    async *rowIterator(props) {\n        for await (const rows of this.rowBatchIterator(props)) {\n            // yield *rows\n            for (const row of rows) {\n                yield row;\n            }\n        }\n    }\n    /** Yield one batch of rows at a time */\n    async *rowBatchIterator(props) {\n        const schema = await this.getSchema();\n        for await (const rowGroup of this.rowGroupIterator(props)) {\n            yield materializeRows(schema, rowGroup);\n        }\n    }\n    /** Iterate over the raw row groups */\n    async *rowGroupIterator(props) {\n        // Ensure strings are nested in arrays\n        const columnList = (props?.columnList || []).map((x) => Array.isArray(x) ? x : [x]);\n        const metadata = await this.getFileMetadata();\n        const schema = await this.getSchema();\n        const rowGroupCount = metadata?.row_groups.length || 0;\n        for (let rowGroupIndex = 0; rowGroupIndex < rowGroupCount; rowGroupIndex++) {\n            const rowGroup = await this.readRowGroup(schema, metadata.row_groups[rowGroupIndex], columnList);\n            yield rowGroup;\n        }\n    }\n    async getRowCount() {\n        const metadata = await this.getFileMetadata();\n        return Number(metadata.num_rows);\n    }\n    async getSchema() {\n        const metadata = await this.getFileMetadata();\n        const root = metadata.schema[0];\n        const { schema: schemaDefinition } = decodeSchema(metadata.schema, 1, root.num_children);\n        const schema = new ParquetSchema(schemaDefinition);\n        return schema;\n    }\n    /**\n     * Returns the user (key/value) metadata for this file\n     * In parquet this is not stored on the schema like it is in arrow\n     */\n    async getSchemaMetadata() {\n        const metadata = await this.getFileMetadata();\n        const md = {};\n        for (const kv of metadata.key_value_metadata) {\n            md[kv.key] = kv.value;\n        }\n        return md;\n    }\n    async getFileMetadata() {\n        if (!this.metadata) {\n            await this.readHeader();\n            this.metadata = this.readFooter();\n        }\n        return this.metadata;\n    }\n    // LOW LEVEL METHODS\n    /** Metadata is stored in the footer */\n    async readHeader() {\n        const arrayBuffer = await this.file.read(0, PARQUET_MAGIC.length);\n        const buffer = Buffer.from(arrayBuffer);\n        const magic = buffer.toString();\n        switch (magic) {\n            case PARQUET_MAGIC:\n                break;\n            case PARQUET_MAGIC_ENCRYPTED:\n                throw new Error('Encrypted parquet file not supported');\n            default:\n                throw new Error(`Invalid parquet file (magic=${magic})`);\n        }\n    }\n    /** Metadata is stored in the footer */\n    async readFooter() {\n        const trailerLen = PARQUET_MAGIC.length + 4;\n        const arrayBuffer = await this.file.read(this.file.size - trailerLen, trailerLen);\n        const trailerBuf = Buffer.from(arrayBuffer);\n        const magic = trailerBuf.slice(4).toString();\n        if (magic !== PARQUET_MAGIC) {\n            throw new Error(`Not a valid parquet file (magic=\"${magic})`);\n        }\n        const metadataSize = trailerBuf.readUInt32LE(0);\n        const metadataOffset = this.file.size - metadataSize - trailerLen;\n        if (metadataOffset < PARQUET_MAGIC.length) {\n            throw new Error(`Invalid metadata size ${metadataOffset}`);\n        }\n        const arrayBuffer2 = await this.file.read(metadataOffset, metadataSize);\n        const metadataBuf = Buffer.from(arrayBuffer2);\n        // let metadata = new parquet_thrift.FileMetaData();\n        // parquet_util.decodeThrift(metadata, metadataBuf);\n        const { metadata } = decodeFileMetadata(metadataBuf);\n        return metadata;\n    }\n    /** Data is stored in row groups (similar to Apache Arrow record batches) */\n    async readRowGroup(schema, rowGroup, columnList) {\n        const buffer = {\n            rowCount: Number(rowGroup.num_rows),\n            columnData: {}\n        };\n        for (const colChunk of rowGroup.columns) {\n            const colMetadata = colChunk.meta_data;\n            const colKey = colMetadata?.path_in_schema;\n            if (columnList.length > 0 && fieldIndexOf(columnList, colKey) < 0) {\n                continue; // eslint-disable-line no-continue\n            }\n            buffer.columnData[colKey.join()] = await this.readColumnChunk(schema, colChunk);\n        }\n        return buffer;\n    }\n    /**\n     * Each row group contains column chunks for all the columns.\n     */\n    async readColumnChunk(schema, colChunk) {\n        if (colChunk.file_path !== undefined && colChunk.file_path !== null) {\n            throw new Error('external references are not supported');\n        }\n        const field = schema.findField(colChunk.meta_data?.path_in_schema);\n        const type = getThriftEnum(Type, colChunk.meta_data?.type);\n        if (type !== field.primitiveType) {\n            throw new Error(`chunk type not matching schema: ${type}`);\n        }\n        const compression = getThriftEnum(CompressionCodec, colChunk.meta_data?.codec);\n        const pagesOffset = Number(colChunk.meta_data?.data_page_offset);\n        let pagesSize = Number(colChunk.meta_data?.total_compressed_size);\n        if (!colChunk.file_path) {\n            pagesSize = Math.min(this.file.size - pagesOffset, Number(colChunk.meta_data?.total_compressed_size));\n        }\n        const context = {\n            type,\n            rLevelMax: field.rLevelMax,\n            dLevelMax: field.dLevelMax,\n            compression,\n            column: field,\n            numValues: colChunk.meta_data?.num_values,\n            dictionary: [],\n            // Options - TBD is this the right place for these?\n            preserveBinary: this.props.preserveBinary\n        };\n        let dictionary;\n        const dictionaryPageOffset = colChunk?.meta_data?.dictionary_page_offset;\n        if (dictionaryPageOffset) {\n            const dictionaryOffset = Number(dictionaryPageOffset);\n            // Getting dictionary from column chunk to iterate all over indexes to get dataPage values.\n            dictionary = await this.getDictionary(dictionaryOffset, context, pagesOffset);\n        }\n        dictionary = context.dictionary?.length ? context.dictionary : dictionary;\n        const arrayBuffer = await this.file.read(pagesOffset, pagesSize);\n        const pagesBuf = Buffer.from(arrayBuffer);\n        return await decodeDataPages(pagesBuf, { ...context, dictionary });\n    }\n    /**\n     * Getting dictionary for allows to flatten values by indices.\n     * @param dictionaryPageOffset\n     * @param context\n     * @param pagesOffset\n     * @returns\n     */\n    async getDictionary(dictionaryPageOffset, context, pagesOffset) {\n        if (dictionaryPageOffset === 0) {\n            // dictionarySize = Math.min(this.fileSize - pagesOffset, this.defaultDictionarySize);\n            // pagesBuf = await this.read(pagesOffset, dictionarySize);\n            // In this case we are working with parquet-mr files format. Problem is described below:\n            // https://stackoverflow.com/questions/55225108/why-is-dictionary-page-offset-0-for-plain-dictionary-encoding\n            // We need to get dictionary page from column chunk if it exists.\n            // Now if we use code commented above we don't get DICTIONARY_PAGE we get DATA_PAGE instead.\n            return [];\n        }\n        const dictionarySize = Math.min(this.file.size - dictionaryPageOffset, this.props.defaultDictionarySize);\n        const arrayBuffer = await this.file.read(dictionaryPageOffset, dictionarySize);\n        const pagesBuf = Buffer.from(arrayBuffer);\n        const cursor = { buffer: pagesBuf, offset: 0, size: pagesBuf.length };\n        const decodedPage = await decodePage(cursor, context);\n        return decodedPage.dictionary;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const PARQUET_TYPE_MAPPING = {\n    BOOLEAN: 'bool',\n    INT32: 'int32',\n    INT64: 'float64',\n    INT96: 'float64',\n    FLOAT: 'float32',\n    DOUBLE: 'float64',\n    BYTE_ARRAY: 'binary',\n    FIXED_LEN_BYTE_ARRAY: 'binary',\n    UTF8: 'utf8',\n    DATE: 'int32',\n    TIME_MILLIS: 'int64',\n    TIME_MICROS: 'int64',\n    TIMESTAMP_MILLIS: 'int64',\n    TIMESTAMP_MICROS: 'int64',\n    UINT_8: 'int32',\n    UINT_16: 'uint16',\n    UINT_32: 'uint32',\n    UINT_64: 'uint64',\n    INT_8: 'int8',\n    INT_16: 'int16',\n    INT_32: 'int32',\n    INT_64: 'int64',\n    JSON: 'binary',\n    BSON: 'binary',\n    // TODO check interal type\n    INTERVAL: 'binary',\n    DECIMAL_INT32: 'float32',\n    DECIMAL_INT64: 'float64',\n    DECIMAL_BYTE_ARRAY: 'float64',\n    DECIMAL_FIXED_LEN_BYTE_ARRAY: 'float64'\n};\nexport function convertParquetSchema(parquetSchema, parquetMetadata) {\n    const fields = getFields(parquetSchema.schema);\n    const metadata = parquetMetadata && getSchemaMetadata(parquetMetadata);\n    const schema = {\n        fields,\n        metadata: metadata || {}\n    };\n    return schema;\n}\nfunction getFields(schema) {\n    const fields = [];\n    for (const name in schema) {\n        const field = schema[name];\n        if (field.fields) {\n            const children = getFields(field.fields);\n            fields.push({ name, type: { type: 'struct', children }, nullable: field.optional });\n        }\n        else {\n            const type = PARQUET_TYPE_MAPPING[field.type];\n            const metadata = getFieldMetadata(field);\n            const arrowField = { name, type, nullable: field.optional, metadata };\n            fields.push(arrowField);\n        }\n    }\n    return fields;\n}\nfunction getFieldMetadata(field) {\n    let metadata;\n    for (const key in field) {\n        if (key !== 'name') {\n            let value = field[key] || '';\n            value = typeof field[key] !== 'string' ? JSON.stringify(field[key]) : field[key];\n            metadata = metadata || {};\n            metadata[key] = value;\n        }\n    }\n    return metadata;\n}\nfunction getSchemaMetadata(parquetMetadata) {\n    let metadata;\n    const keyValueList = parquetMetadata.key_value_metadata || [];\n    for (const { key, value } of keyValueList) {\n        if (typeof value === 'string') {\n            metadata = metadata || {};\n            metadata[key] = value;\n        }\n    }\n    return metadata;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { convertParquetSchema } from \"../arrow/convert-schema-from-parquet.js\";\nimport { unpackGeoMetadata, unpackJSONStringMetadata } from '@loaders.gl/gis';\nexport async function getSchemaFromParquetReader(reader) {\n    const parquetSchema = await reader.getSchema();\n    const parquetMetadata = await reader.getFileMetadata();\n    const schema = convertParquetSchema(parquetSchema, parquetMetadata);\n    unpackGeoMetadata(schema);\n    unpackJSONStringMetadata(schema, 'pandas');\n    return schema;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { convertWKBTableToGeoJSON } from '@loaders.gl/gis';\nimport { WKTLoader, WKBLoader } from '@loaders.gl/wkt';\nimport { parseParquetFile, parseParquetFileInBatches } from \"./parse-parquet.js\";\nexport async function parseGeoParquetFile(file, options) {\n    const table = await parseParquetFile(file, { ...options, shape: 'object-row-table' });\n    const shape = options?.parquet?.shape;\n    return convertTable(table, shape);\n}\nexport async function* parseGeoParquetFileInBatches(file, options) {\n    const tableBatches = parseParquetFileInBatches(file, { ...options, shape: 'object-row-table' });\n    for await (const batch of tableBatches) {\n        const shape = options?.parquet?.shape;\n        yield convertBatch(batch, shape);\n    }\n}\nfunction convertTable(objectRowTable, shape) {\n    switch (shape) {\n        case 'object-row-table':\n            return objectRowTable;\n        case 'geojson-table':\n            try {\n                return convertWKBTableToGeoJSON(objectRowTable, objectRowTable.schema, [\n                    WKTLoader,\n                    WKBLoader\n                ]);\n            }\n            catch (error) {\n                return objectRowTable;\n            }\n        default:\n            throw new Error(shape);\n    }\n}\nfunction convertBatch(objectRowBatch, shape) {\n    switch (shape) {\n        case 'object-row-table':\n            return objectRowBatch;\n        case 'geojson-table':\n            try {\n                const geojsonTable = convertWKBTableToGeoJSON(objectRowBatch, objectRowBatch.schema, [\n                    WKTLoader,\n                    WKBLoader\n                ]);\n                return {\n                    ...objectRowBatch,\n                    ...geojsonTable\n                };\n            }\n            catch (error) {\n                return objectRowBatch;\n            }\n        default:\n            throw new Error(shape);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ParquetReader } from \"../../parquetjs/parser/parquet-reader.js\";\nimport { materializeColumns } from \"../../parquetjs/schema/shred.js\";\nimport { getSchemaFromParquetReader } from \"./get-parquet-schema.js\";\nimport { installBufferPolyfill } from \"../../polyfills/buffer/index.js\";\nimport { preloadCompressions } from \"../../parquetjs/compression.js\";\n/**\n * @deprecated\n */\nexport async function parseParquetFileInColumns(file, options) {\n    installBufferPolyfill();\n    await preloadCompressions(options);\n    for await (const batch of parseParquetFileInColumnarBatches(file, options)) {\n        return {\n            shape: 'columnar-table',\n            schema: batch.schema,\n            data: batch.data\n        };\n    }\n    throw new Error('empty table');\n}\n/**\n * @deprecated\n */\nexport async function* parseParquetFileInColumnarBatches(file, options) {\n    installBufferPolyfill();\n    await preloadCompressions(options);\n    const reader = new ParquetReader(file);\n    // Extract schema and geo metadata\n    const schema = await getSchemaFromParquetReader(reader);\n    const parquetSchema = await reader.getSchema();\n    // Iterate over row batches\n    const rowGroups = reader.rowGroupIterator(options?.parquet);\n    for await (const rowGroup of rowGroups) {\n        yield convertRowGroupToTableBatch(rowGroup, parquetSchema, schema);\n    }\n}\nfunction convertRowGroupToTableBatch(rowGroup, parquetSchema, schema) {\n    // const data = convertParquetRowGroupToColumns(schema, rowGroup);\n    const data = materializeColumns(parquetSchema, rowGroup);\n    return {\n        shape: 'columnar-table',\n        batchType: 'data',\n        schema,\n        data,\n        length: rowGroup.rowCount\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\nexport const ParquetWriter = {\n    name: 'Apache Parquet',\n    id: 'parquet',\n    module: 'parquet',\n    version: VERSION,\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    options: {},\n    encode: async (data, options) => encodeSync(data, options),\n    encodeSync\n};\nfunction encodeSync(data, options) {\n    return new ArrayBuffer(0);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BlobFile } from '@loaders.gl/loader-utils';\nimport { parseParquetFileWasm, parseParquetFileInBatchesWasm } from \"./lib/parsers/parse-parquet-wasm.js\";\nimport { VERSION, PARQUET_WASM_URL } from \"./lib/constants.js\";\n/** Parquet WASM table loader */\nexport const ParquetWasmWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Apache Parquet',\n    id: 'parquet-wasm',\n    module: 'parquet',\n    version: VERSION,\n    worker: false,\n    category: 'table',\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['PAR1', 'PARE'],\n    options: {\n        parquet: {\n            shape: 'arrow-table',\n            limit: undefined, // Provide a limit to the number of rows to be read.\n            offset: 0, // Provide an offset to skip over the given number of rows.\n            batchSize: undefined, // The number of rows in each batch. If not provided, the upstream parquet default is 1024.\n            columns: undefined, // The column names from the file to read.\n            rowGroups: undefined, // Only read data from the provided row group indexes.\n            concurrency: undefined, // The number of concurrent requests to make\n            wasmUrl: PARQUET_WASM_URL\n        }\n    }\n};\n/** Parquet WASM table loader */\nexport const ParquetWasmLoader = {\n    ...ParquetWasmWorkerLoader,\n    parse(arrayBuffer, options) {\n        const wasmOptions = { ...ParquetWasmLoader.options.parquet, ...options?.parquet };\n        return parseParquetFileWasm(new BlobFile(arrayBuffer), wasmOptions);\n    },\n    parseFile(file, options) {\n        const wasmOptions = { ...ParquetWasmLoader.options.parquet, ...options?.parquet };\n        return parseParquetFileWasm(file, wasmOptions);\n    },\n    parseFileInBatches(file, options) {\n        const wasmOptions = { ...ParquetWasmLoader.options.parquet, ...options?.parquet };\n        return parseParquetFileInBatchesWasm(file, wasmOptions);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { serializeArrowSchema } from '@loaders.gl/arrow';\nimport * as arrow from 'apache-arrow';\nimport { loadWasm } from \"../utils/load-wasm.js\";\nimport { makeStreamIterator } from \"../utils/make-stream-iterator.js\";\nexport async function parseParquetFileWasm(file, options) {\n    const wasmUrl = options?.wasmUrl;\n    const wasm = await loadWasm(wasmUrl);\n    let parquetFile;\n    if (file.handle instanceof Blob) {\n        // TODO - let's assume fromFile() works on Blobs and not just on File...\n        parquetFile = await wasm.ParquetFile.fromFile(file.handle);\n    }\n    else {\n        parquetFile = await wasm.ParquetFile.fromUrl(file.url);\n    }\n    const wasmTable = await parquetFile.read(options);\n    const ipcStream = wasmTable.intoIPCStream();\n    const arrowTable = arrow.tableFromIPC(ipcStream);\n    return {\n        shape: 'arrow-table',\n        schema: serializeArrowSchema(arrowTable.schema),\n        data: arrowTable\n    };\n}\nexport async function* parseParquetFileInBatchesWasm(file, options) {\n    const wasmUrl = options?.wasmUrl;\n    const wasm = await loadWasm(wasmUrl);\n    let parquetFile;\n    if (file.handle instanceof Blob) {\n        // Works on Blobs: https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#fromFile\n        parquetFile = await wasm.ParquetFile.fromFile(file.handle);\n    }\n    else {\n        parquetFile = await wasm.ParquetFile.fromUrl(file.url);\n    }\n    const stream = await parquetFile.stream(options);\n    let schema;\n    for await (const table of makeStreamIterator(stream)) {\n        schema ||= serializeArrowSchema(table.schema);\n        yield {\n            batchType: 'data',\n            shape: 'arrow-table',\n            schema,\n            data: table.batches[0],\n            length: table.numRows\n        };\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// eslint-disable-next-line import/default\nimport initWasm from 'parquet-wasm';\nimport * as parquetWasm from 'parquet-wasm';\nimport { PARQUET_WASM_URL } from \"../constants.js\";\nlet initializePromise;\nexport async function loadWasm(wasmUrl = PARQUET_WASM_URL) {\n    if (!initializePromise && typeof initWasm === 'function') {\n        if (!wasmUrl) {\n            throw new Error('ParquetLoader: No wasmUrl provided');\n        }\n        // @ts-ignore\n        initializePromise = initWasm(wasmUrl);\n    }\n    await initializePromise;\n    return parquetWasm;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@loaders.gl/loader-utils';\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(stream, options) {\n    return isBrowser\n        ? makeBrowserStreamIterator(stream, options)\n        : makeNodeStreamIterator(stream, options);\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(stream, options) {\n    // WhatWG: stream is supposed to have a `getIterator` method\n    // if (typeof stream.getIterator === 'function') {\n    //   return stream.getIterator();\n    // }\n    // if (typeof stream[Symbol.asyncIterator] === 'function') {\n    //   return makeToArrayBufferIterator(stream);\n    // }\n    // In the browser, we first need to get a lock on the stream\n    const reader = stream.getReader();\n    let nextBatchPromise;\n    try {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const currentBatchPromise = nextBatchPromise || reader.read();\n            // Issue a read for an additional batch, while we await the next batch\n            // Idea is to make fetching happen in parallel with processing / parsing\n            if (options?._streamReadAhead) {\n                nextBatchPromise = reader.read();\n            }\n            // Read from the stream\n            // value is a Uint8Array\n            const { done, value } = await currentBatchPromise;\n            // Exit if we're done\n            if (done) {\n                return;\n            }\n            // Else yield the chunk\n            if (value) {\n                yield value;\n            }\n        }\n    }\n    catch (error) {\n        // TODO - examples makes it look like this should always be called,\n        // but that generates exceptions so only call it if we do not reach the end\n        reader.releaseLock();\n    }\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(stream, options) {\n    // Hacky test for node version to ensure we don't call bad polyfills\n    // NODE 10+: stream is an asyncIterator\n    yield* stream;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as arrow from 'apache-arrow';\nimport { loadWasm } from \"../utils/load-wasm.js\";\n/**\n * Encode Arrow arrow.Table to Parquet buffer\n */\nexport async function encode(table, options) {\n    const wasmUrl = options.parquet?.wasmUrl;\n    const wasm = await loadWasm(wasmUrl);\n    // Serialize the table to the IPC format.\n    const arrowTable = table.data;\n    const ipcStream = arrow.tableToIPC(arrowTable);\n    // Pass the IPC stream to the Parquet writer.\n    const wasmTable = wasm.Table.fromIPCStream(ipcStream);\n    const wasmProperties = new wasm.WriterPropertiesBuilder().build();\n    try {\n        const parquetBytes = wasm.writeParquet(wasmTable, wasmProperties);\n        // const parquetBytes = wasm.writeParquet(wasmTable, wasmProperties);\n        return parquetBytes.buffer.slice(parquetBytes.byteOffset, parquetBytes.byteLength + parquetBytes.byteOffset);\n    }\n    finally {\n        // wasmTable.free();\n        // wasmProperties.free();\n    }\n}\n// type WriteOptions = {\n//   compression?: number;\n//   dictionaryEnabled?: boolean;\n//   encoding?: number;\n//   maxRowGroupSize?: number;\n//   maxStatisticsSize?: number;\n//   statisticsEnabled?: boolean;\n//   writeBatchSize?: number;\n//   dataPageSizeLimit?: number;\n//   dictionaryPageSizeLimit?: number;\n// };\n// columnCompression: Record<string, number>;\n// columnDictionaryEnabled: Record<string, boolean>;\n// columnEncoding: Record<string, number>;\n// columnMaxStatisticsSize\n// compression:Record<string, number>;\n// setCreatedBy\n// setDataPageSizeLimit\n// setDictionaryEnabled\n// setDictionaryPageSizeLimit\n// setEncoding\n// setMaxRowGroupSize\n// setMaxStatisticsSize\n// setStatisticsEnabled\n// setWriteBatchSize\n// setWriterVersion\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { encode } from \"./lib/encoders/encode-parquet-wasm.js\";\nimport { VERSION, PARQUET_WASM_URL } from \"./lib/constants.js\";\n/** Parquet WASM writer */\nexport const ParquetWasmWriter = {\n    name: 'Apache Parquet',\n    id: 'parquet-wasm',\n    module: 'parquet',\n    version: VERSION,\n    extensions: ['parquet'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    options: {\n        parquet: {\n            wasmUrl: PARQUET_WASM_URL\n        }\n    },\n    encode(arrowTable, options) {\n        options = { parquet: { ...ParquetWasmWriter.options.parquet, ...options?.parquet }, ...options };\n        return encode(arrowTable, options);\n    }\n};\n", "import * as fs from 'fs';\nexport function load(name) {\n    return (module || global).require(name);\n}\nexport function oswrite(os, buf) {\n    return new Promise((resolve, reject) => {\n        os.write(buf, (err) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\nexport function osclose(os) {\n    return new Promise((resolve, reject) => {\n        os.close((err) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\nexport function osopen(path, opts) {\n    return new Promise((resolve, reject) => {\n        const outputStream = fs.createWriteStream(path, opts);\n        outputStream.once('open', (fd) => resolve(outputStream));\n        outputStream.once('error', (err) => reject(err));\n    });\n}\n", "import { PARQUET_CODECS } from \"../codecs/index.js\";\nimport * as Compression from \"../compression.js\";\nimport * as Shred from \"../schema/shred.js\";\nimport { ColumnChunk, ColumnMetaData, CompressionCodec, ConvertedType, DataPageHeader, DataPageHeaderV2, Encoding, FieldRepetitionType, FileMetaData, KeyValue, PageHeader, PageType, RowGroup, SchemaElement, Type } from \"../parquet-thrift/index.js\";\nimport { osopen, oswrite, osclose } from \"../utils/file-utils.js\";\nimport { getBitWidth, serializeThrift } from \"../utils/read-utils.js\";\nimport Int64 from 'node-int64';\n/**\n * Parquet File Magic String\n */\nconst PARQUET_MAGIC = 'PAR1';\n/**\n * Parquet File Format Version\n */\nconst PARQUET_VERSION = 1;\n/**\n * Default Page and Row Group sizes\n */\nconst PARQUET_DEFAULT_PAGE_SIZE = 8192;\nconst PARQUET_DEFAULT_ROW_GROUP_SIZE = 4096;\n/**\n * Repetition and Definition Level Encoding\n */\nconst PARQUET_RDLVL_TYPE = 'INT32';\nconst PARQUET_RDLVL_ENCODING = 'RLE';\n/**\n * Write a parquet file to an output stream. The ParquetEncoder will perform\n * buffering/batching for performance, so close() must be called after all rows\n * are written.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class ParquetEncoder {\n    /**\n     * Convenience method to create a new buffered parquet writer that writes to\n     * the specified file\n     */\n    static async openFile(schema, path, opts) {\n        const outputStream = await osopen(path, opts);\n        return ParquetEncoder.openStream(schema, outputStream, opts);\n    }\n    /**\n     * Convenience method to create a new buffered parquet writer that writes to\n     * the specified stream\n     */\n    static async openStream(schema, outputStream, opts = {}) {\n        const envelopeWriter = await ParquetEnvelopeWriter.openStream(schema, outputStream, opts);\n        return new ParquetEncoder(schema, envelopeWriter, opts);\n    }\n    schema;\n    envelopeWriter;\n    rowBuffer;\n    rowGroupSize;\n    closed;\n    userMetadata;\n    /**\n     * Create a new buffered parquet writer for a given envelope writer\n     */\n    constructor(schema, envelopeWriter, opts) {\n        this.schema = schema;\n        this.envelopeWriter = envelopeWriter;\n        // @ts-ignore Row buffer typings...\n        this.rowBuffer = {};\n        this.rowGroupSize = opts.rowGroupSize || PARQUET_DEFAULT_ROW_GROUP_SIZE;\n        this.closed = false;\n        this.userMetadata = {};\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.writeHeader();\n    }\n    async writeHeader() {\n        // TODO - better not mess with promises in the constructor\n        try {\n            await this.envelopeWriter.writeHeader();\n        }\n        catch (err) {\n            await this.envelopeWriter.close();\n            throw err;\n        }\n    }\n    /**\n     * Append a single row to the parquet file. Rows are buffered in memory until\n     * rowGroupSize rows are in the buffer or close() is called\n     */\n    async appendRow(row) {\n        if (this.closed) {\n            throw new Error('writer was closed');\n        }\n        Shred.shredRecord(this.schema, row, this.rowBuffer);\n        if (this.rowBuffer.rowCount >= this.rowGroupSize) {\n            // @ts-ignore\n            this.rowBuffer = {};\n        }\n    }\n    /**\n     * Finish writing the parquet file and commit the footer to disk. This method\n     * MUST be called after you are finished adding rows. You must not call this\n     * method twice on the same object or add any rows after the close() method has\n     * been called\n     */\n    async close(callback) {\n        if (this.closed) {\n            throw new Error('writer was closed');\n        }\n        this.closed = true;\n        if (this.rowBuffer.rowCount > 0 || this.rowBuffer.rowCount >= this.rowGroupSize) {\n            // @ts-ignore\n            this.rowBuffer = {};\n        }\n        await this.envelopeWriter.writeFooter(this.userMetadata);\n        await this.envelopeWriter.close();\n        // this.envelopeWriter = null;\n        if (callback) {\n            callback();\n        }\n    }\n    /**\n     * Add key<>value metadata to the file\n     */\n    setMetadata(key, value) {\n        // TODO: value to be any, obj -> JSON\n        this.userMetadata[String(key)] = String(value);\n    }\n    /**\n     * Set the parquet row group size. This values controls the maximum number\n     * of rows that are buffered in memory at any given time as well as the number\n     * of rows that are co-located on disk. A higher value is generally better for\n     * read-time I/O performance at the tradeoff of write-time memory usage.\n     */\n    setRowGroupSize(cnt) {\n        this.rowGroupSize = cnt;\n    }\n    /**\n     * Set the parquet data page size. The data page size controls the maximum\n     * number of column values that are written to disk as a consecutive array\n     */\n    setPageSize(cnt) {\n        this.envelopeWriter.setPageSize(cnt);\n    }\n}\n/**\n * Create a parquet file from a schema and a number of row groups. This class\n * performs direct, unbuffered writes to the underlying output stream and is\n * intendend for advanced and internal users; the writeXXX methods must be\n * called in the correct order to produce a valid file.\n */\nexport class ParquetEnvelopeWriter {\n    /**\n     * Create a new parquet envelope writer that writes to the specified stream\n     */\n    static async openStream(schema, outputStream, opts) {\n        const writeFn = oswrite.bind(undefined, outputStream);\n        const closeFn = osclose.bind(undefined, outputStream);\n        return new ParquetEnvelopeWriter(schema, writeFn, closeFn, 0, opts);\n    }\n    schema;\n    write;\n    close;\n    offset;\n    rowCount;\n    rowGroups;\n    pageSize;\n    useDataPageV2;\n    constructor(schema, writeFn, closeFn, fileOffset, opts) {\n        this.schema = schema;\n        this.write = writeFn;\n        this.close = closeFn;\n        this.offset = fileOffset;\n        this.rowCount = 0;\n        this.rowGroups = [];\n        this.pageSize = opts.pageSize || PARQUET_DEFAULT_PAGE_SIZE;\n        this.useDataPageV2 = 'useDataPageV2' in opts ? Boolean(opts.useDataPageV2) : false;\n    }\n    writeSection(buf) {\n        this.offset += buf.length;\n        return this.write(buf);\n    }\n    /**\n     * Encode the parquet file header\n     */\n    writeHeader() {\n        return this.writeSection(Buffer.from(PARQUET_MAGIC));\n    }\n    /**\n     * Encode a parquet row group. The records object should be created using the\n     * shredRecord method\n     */\n    async writeRowGroup(records) {\n        const rgroup = await encodeRowGroup(this.schema, records, {\n            baseOffset: this.offset,\n            pageSize: this.pageSize,\n            useDataPageV2: this.useDataPageV2\n        });\n        this.rowCount += records.rowCount;\n        this.rowGroups.push(rgroup.metadata);\n        return await this.writeSection(rgroup.body);\n    }\n    /**\n     * Write the parquet file footer\n     */\n    writeFooter(userMetadata) {\n        if (!userMetadata) {\n            // tslint:disable-next-line:no-parameter-reassignment\n            userMetadata = {};\n        }\n        return this.writeSection(encodeFooter(this.schema, this.rowCount, this.rowGroups, userMetadata));\n    }\n    /**\n     * Set the parquet data page size. The data page size controls the maximum\n     * number of column values that are written to disk as a consecutive array\n     */\n    setPageSize(cnt) {\n        this.pageSize = cnt;\n    }\n}\n/**\n * Create a parquet transform stream\nexport class ParquetTransformer<T> extends stream.Transform {\n  public writer: ParquetEncoder<T>;\n\n  constructor(schema: ParquetSchema, opts: ParquetEncoderOptions = {}) {\n    super({objectMode: true});\n\n    const writeProxy = (function (t: ParquetTransformer<any>) {\n      return async function (b: any): Promise<void> {\n        t.push(b);\n      };\n    })(this);\n\n    this.writer = new ParquetEncoder(\n      schema,\n      new ParquetEnvelopeWriter(schema, writeProxy, async () => {}, 0, opts),\n      opts\n    );\n  }\n\n  // tslint:disable-next-line:function-name\n  _transform(row: any, encoding: string, callback: (val?: any) => void): Promise<void> {\n    if (row) {\n      return this.writer.appendRow(row).then(callback);\n    }\n    callback();\n    return Promise.resolve();\n  }\n\n  // tslint:disable-next-line:function-name\n  async _flush(callback: (val?: any) => void) {\n    await this.writer.close(callback);\n  }\n}\n */\n/**\n * Encode a consecutive array of data using one of the parquet encodings\n */\nfunction encodeValues(type, encoding, values, opts) {\n    if (!(encoding in PARQUET_CODECS)) {\n        throw new Error(`invalid encoding: ${encoding}`);\n    }\n    return PARQUET_CODECS[encoding].encodeValues(type, values, opts);\n}\n/**\n * Encode a parquet data page\n */\nasync function encodeDataPage(column, data) {\n    /* encode repetition and definition levels */\n    let rLevelsBuf = Buffer.alloc(0);\n    if (column.rLevelMax > 0) {\n        rLevelsBuf = encodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, data.rlevels, {\n            bitWidth: getBitWidth(column.rLevelMax)\n            // disableEnvelope: false\n        });\n    }\n    let dLevelsBuf = Buffer.alloc(0);\n    if (column.dLevelMax > 0) {\n        dLevelsBuf = encodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, data.dlevels, {\n            bitWidth: getBitWidth(column.dLevelMax)\n            // disableEnvelope: false\n        });\n    }\n    /* encode values */\n    const valuesBuf = encodeValues(column.primitiveType, column.encoding, data.values, {\n        typeLength: column.typeLength,\n        bitWidth: column.typeLength\n    });\n    const dataBuf = Buffer.concat([rLevelsBuf, dLevelsBuf, valuesBuf]);\n    // compression = column.compression === 'UNCOMPRESSED' ? (compression || 'UNCOMPRESSED') : column.compression;\n    const compressedBuf = await Compression.deflate(column.compression, dataBuf);\n    /* build page header */\n    const header = new PageHeader({\n        type: PageType.DATA_PAGE,\n        data_page_header: new DataPageHeader({\n            num_values: data.count,\n            encoding: Encoding[column.encoding],\n            definition_level_encoding: Encoding[PARQUET_RDLVL_ENCODING], // [PARQUET_RDLVL_ENCODING],\n            repetition_level_encoding: Encoding[PARQUET_RDLVL_ENCODING] // [PARQUET_RDLVL_ENCODING]\n        }),\n        uncompressed_page_size: dataBuf.length,\n        compressed_page_size: compressedBuf.length\n    });\n    /* concat page header, repetition and definition levels and values */\n    const headerBuf = serializeThrift(header);\n    const page = Buffer.concat([headerBuf, compressedBuf]);\n    return { header, headerSize: headerBuf.length, page };\n}\n/**\n * Encode a parquet data page (v2)\n */\nasync function encodeDataPageV2(column, data, rowCount) {\n    /* encode values */\n    const valuesBuf = encodeValues(column.primitiveType, column.encoding, data.values, {\n        typeLength: column.typeLength,\n        bitWidth: column.typeLength\n    });\n    // compression = column.compression === 'UNCOMPRESSED' ? (compression || 'UNCOMPRESSED') : column.compression;\n    const compressedBuf = await Compression.deflate(column.compression, valuesBuf);\n    /* encode repetition and definition levels */\n    let rLevelsBuf = Buffer.alloc(0);\n    if (column.rLevelMax > 0) {\n        rLevelsBuf = encodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, data.rlevels, {\n            bitWidth: getBitWidth(column.rLevelMax),\n            disableEnvelope: true\n        });\n    }\n    let dLevelsBuf = Buffer.alloc(0);\n    if (column.dLevelMax > 0) {\n        dLevelsBuf = encodeValues(PARQUET_RDLVL_TYPE, PARQUET_RDLVL_ENCODING, data.dlevels, {\n            bitWidth: getBitWidth(column.dLevelMax),\n            disableEnvelope: true\n        });\n    }\n    /* build page header */\n    const header = new PageHeader({\n        type: PageType.DATA_PAGE_V2,\n        data_page_header_v2: new DataPageHeaderV2({\n            num_values: data.count,\n            num_nulls: data.count - data.values.length,\n            num_rows: rowCount,\n            encoding: Encoding[column.encoding],\n            definition_levels_byte_length: dLevelsBuf.length,\n            repetition_levels_byte_length: rLevelsBuf.length,\n            is_compressed: column.compression !== 'UNCOMPRESSED'\n        }),\n        uncompressed_page_size: rLevelsBuf.length + dLevelsBuf.length + valuesBuf.length,\n        compressed_page_size: rLevelsBuf.length + dLevelsBuf.length + compressedBuf.length\n    });\n    /* concat page header, repetition and definition levels and values */\n    const headerBuf = serializeThrift(header);\n    const page = Buffer.concat([headerBuf, rLevelsBuf, dLevelsBuf, compressedBuf]);\n    return { header, headerSize: headerBuf.length, page };\n}\n/**\n * Encode an array of values into a parquet column chunk\n */\nasync function encodeColumnChunk(column, buffer, offset, opts) {\n    const data = buffer.columnData[column.path.join()];\n    const baseOffset = (opts.baseOffset || 0) + offset;\n    /* encode data page(s) */\n    // const pages: Buffer[] = [];\n    let pageBuf;\n    // tslint:disable-next-line:variable-name\n    let total_uncompressed_size = 0;\n    // tslint:disable-next-line:variable-name\n    let total_compressed_size = 0;\n    {\n        const result = opts.useDataPageV2\n            ? await encodeDataPageV2(column, data, buffer.rowCount)\n            : await encodeDataPage(column, data);\n        // pages.push(result.page);\n        pageBuf = result.page;\n        total_uncompressed_size += result.header.uncompressed_page_size + result.headerSize;\n        total_compressed_size += result.header.compressed_page_size + result.headerSize;\n    }\n    // const pagesBuf = Buffer.concat(pages);\n    // const compression = column.compression === 'UNCOMPRESSED' ? (opts.compression || 'UNCOMPRESSED') : column.compression;\n    /* prepare metadata header */\n    const metadata = new ColumnMetaData({\n        path_in_schema: column.path,\n        num_values: data.count,\n        data_page_offset: baseOffset,\n        encodings: [],\n        total_uncompressed_size, //  : pagesBuf.length,\n        total_compressed_size,\n        type: Type[column.primitiveType],\n        codec: CompressionCodec[column.compression]\n    });\n    /* list encodings */\n    metadata.encodings.push(Encoding[PARQUET_RDLVL_ENCODING]);\n    metadata.encodings.push(Encoding[column.encoding]);\n    /* concat metadata header and data pages */\n    const metadataOffset = baseOffset + pageBuf.length;\n    const body = Buffer.concat([pageBuf, serializeThrift(metadata)]);\n    return { body, metadata, metadataOffset };\n}\n/**\n * Encode a list of column values into a parquet row group\n */\nasync function encodeRowGroup(schema, data, opts) {\n    const metadata = new RowGroup({\n        num_rows: data.rowCount,\n        columns: [],\n        total_byte_size: 0\n    });\n    let body = Buffer.alloc(0);\n    for (const field of schema.fieldList) {\n        if (field.isNested) {\n            continue; // eslint-disable-line no-continue\n        }\n        const cchunkData = await encodeColumnChunk(field, data, body.length, opts);\n        const cchunk = new ColumnChunk({\n            file_offset: cchunkData.metadataOffset,\n            meta_data: cchunkData.metadata\n        });\n        metadata.columns.push(cchunk);\n        metadata.total_byte_size = new Int64(Number(metadata.total_byte_size) + cchunkData.body.length);\n        body = Buffer.concat([body, cchunkData.body]);\n    }\n    return { body, metadata };\n}\n/**\n * Encode a parquet file metadata footer\n */\nfunction encodeFooter(schema, rowCount, rowGroups, userMetadata) {\n    const metadata = new FileMetaData({\n        version: PARQUET_VERSION,\n        created_by: 'parquets',\n        num_rows: rowCount,\n        row_groups: rowGroups,\n        schema: [],\n        key_value_metadata: []\n    });\n    for (const key in userMetadata) {\n        const kv = new KeyValue({\n            key,\n            value: userMetadata[key]\n        });\n        metadata.key_value_metadata?.push?.(kv);\n    }\n    {\n        const schemaRoot = new SchemaElement({\n            name: 'root',\n            num_children: Object.keys(schema.fields).length\n        });\n        metadata.schema.push(schemaRoot);\n    }\n    for (const field of schema.fieldList) {\n        const relt = FieldRepetitionType[field.repetitionType];\n        const schemaElem = new SchemaElement({\n            name: field.name,\n            repetition_type: relt\n        });\n        if (field.isNested) {\n            schemaElem.num_children = field.fieldCount;\n        }\n        else {\n            schemaElem.type = Type[field.primitiveType];\n        }\n        if (field.originalType) {\n            schemaElem.converted_type = ConvertedType[field.originalType];\n        }\n        schemaElem.type_length = field.typeLength;\n        metadata.schema.push(schemaElem);\n    }\n    const metadataEncoded = serializeThrift(metadata);\n    const footerEncoded = Buffer.alloc(metadataEncoded.length + 8);\n    metadataEncoded.copy(footerEncoded);\n    footerEncoded.writeUInt32LE(metadataEncoded.length, metadataEncoded.length);\n    footerEncoded.write(PARQUET_MAGIC, metadataEncoded.length + 4);\n    return footerEncoded;\n}\n"],
  "mappings": "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",
  "names": ["Buffer", "byteLength", "ieee754", "Buffer", "i", "base64", "Buffer", "Buffer", "import_loader_utils", "INT53", "encodeValues", "decodeValues", "varint", "count", "decodeValues", "encodeValues", "encodeValues", "decodeValues", "lz4js", "cpath", "Type", "ConvertedType", "FieldRepetitionType", "Encoding", "CompressionCodec", "PageType", "Int64", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "JSON", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "thrift", "import_node_int64", "thrift", "Int64", "import_node_int64", "thrift", "Int64", "import_node_int64", "thrift", "Int64", "thrift", "import_node_int64", "thrift", "thrift", "Int64", "decodeValues", "log", "import_gis", "convertTable", "VERSION", "Buffer", "VERSION", "import_loader_utils", "initWasm", "import_loader_utils", "arrow", "import_node_int64", "PARQUET_MAGIC", "PARQUET_RDLVL_TYPE", "PARQUET_RDLVL_ENCODING", "encodeValues", "Int64"]
}
