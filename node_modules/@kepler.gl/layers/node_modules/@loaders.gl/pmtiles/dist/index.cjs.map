{
  "version": 3,
  "sources": ["index.js", "pmtiles-source.js", "lib/parse-pmtiles.js", "lib/blob-source.js", "pmtiles-loader.js", "lib/version.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { PMTilesSource } from \"./pmtiles-source.js\";\nexport { PMTilesTileSource } from \"./pmtiles-source.js\";\nexport { PMTilesLoader as _PMTilesLoader } from \"./pmtiles-loader.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { MVTLoader } from '@loaders.gl/mvt';\nimport * as pmtiles from 'pmtiles';\nconst { PMTiles } = pmtiles;\nimport { parsePMTilesHeader } from \"./lib/parse-pmtiles.js\";\nimport { BlobSource } from \"./lib/blob-source.js\";\nconst VERSION = '1.0.0';\n/**\n * Creates vector tile data sources for PMTiles urls or blobs\n */\nexport const PMTilesSource = {\n    name: 'PMTiles',\n    id: 'pmtiles',\n    module: 'pmtiles',\n    version: VERSION,\n    extensions: ['pmtiles'],\n    mimeTypes: ['application/octet-stream'],\n    options: { url: undefined, pmtiles: {} },\n    type: 'pmtiles',\n    fromUrl: true,\n    fromBlob: true,\n    testURL: (url) => url.endsWith('.pmtiles'),\n    createDataSource: (url, props) => new PMTilesTileSource(url, props)\n};\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class PMTilesTileSource extends DataSource {\n    data;\n    props;\n    mimeType = null;\n    pmtiles;\n    metadata;\n    constructor(data, props) {\n        super(props);\n        this.props = props;\n        const url = typeof data === 'string' ? resolvePath(data) : new BlobSource(data, 'pmtiles');\n        this.data = data;\n        this.pmtiles = new PMTiles(url);\n        this.getTileData = this.getTileData.bind(this);\n        this.metadata = this.getMetadata();\n    }\n    async getSchema() {\n        return { fields: [], metadata: {} };\n    }\n    async getMetadata() {\n        const pmtilesHeader = await this.pmtiles.getHeader();\n        const pmtilesMetadata = (await this.pmtiles.getMetadata()) || {};\n        const metadata = parsePMTilesHeader(pmtilesHeader, pmtilesMetadata, { includeFormatHeader: false }, this.loadOptions);\n        // Add additional attribution if necessary\n        if (this.props.attributions) {\n            metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n        }\n        if (metadata?.tileMIMEType) {\n            this.mimeType = metadata?.tileMIMEType;\n        }\n        // TODO - do we need to allow tileSize to be overridden? Some PMTiles examples seem to suggest it.\n        return metadata;\n    }\n    async getTile(tileParams) {\n        const { x, y, z } = tileParams;\n        const rangeResponse = await this.pmtiles.getZxy(z, x, y);\n        const arrayBuffer = rangeResponse?.data;\n        if (!arrayBuffer) {\n            // console.error('No arrayBuffer', tileParams);\n            return null;\n        }\n        return arrayBuffer;\n    }\n    // Tile Source interface implementation: deck.gl compatible API\n    // TODO - currently only handles image tiles, not vector tiles\n    async getTileData(tileParams) {\n        const { x, y, z } = tileParams.index;\n        const metadata = await this.metadata;\n        switch (metadata.tileMIMEType) {\n            case 'application/vnd.mapbox-vector-tile':\n                return await this.getVectorTile({ x, y, z, layers: [] });\n            default:\n                return await this.getImageTile({ x, y, z, layers: [] });\n        }\n    }\n    // ImageTileSource interface implementation\n    async getImageTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? await ImageLoader.parse(arrayBuffer, this.loadOptions) : null;\n    }\n    // VectorTileSource interface implementation\n    async getVectorTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        const loadOptions = {\n            shape: 'geojson-table',\n            mvt: {\n                coordinates: 'wgs84',\n                tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.z },\n                ...this.loadOptions?.mvt\n            },\n            ...this.loadOptions\n        };\n        return arrayBuffer ? await MVTLoader.parse(arrayBuffer, loadOptions) : null;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { TileJSONLoader } from '@loaders.gl/mvt';\n// import {Source, PMTiles, Header, TileType} from 'pmtiles';\nimport * as pmtiles from 'pmtiles';\nconst { TileType } = pmtiles;\n/**\n * Parse PMTiles metdata from a PMTiles file\n * @param header\n * @param tilejsonMetadata\n * @param options\n * @param loadOptions\n * @returns\n */\nexport function parsePMTilesHeader(header, pmtilesMetadata, options, loadOptions) {\n    // Ironically, to use the TileJSON loader we need to stringify the metadata again.\n    // This is the price of integrating with the existing pmtiles library.\n    // TODO - provide a non-standard TileJSONLoader parsers that accepts a JSON object?\n    let tilejson = null;\n    if (pmtilesMetadata) {\n        try {\n            const string = JSON.stringify(pmtilesMetadata);\n            tilejson = TileJSONLoader.parseTextSync?.(string, loadOptions) || null;\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('PMTiles metadata could not be interpreted as TileJSON', error);\n        }\n    }\n    const partialMetadata = {};\n    if (typeof tilejson?.name === 'string') {\n        partialMetadata.name = tilejson.name;\n    }\n    if (typeof tilejson?.htmlAttribution === 'string') {\n        partialMetadata.attributions = [tilejson.htmlAttribution];\n    }\n    const metadata = {\n        ...partialMetadata,\n        format: 'pmtiles',\n        formatVersion: header.specVersion,\n        attributions: [],\n        tileMIMEType: decodeTileType(header.tileType),\n        minZoom: header.minZoom,\n        maxZoom: header.maxZoom,\n        boundingBox: [\n            [header.minLon, header.minLat],\n            [header.maxLon, header.maxLat]\n        ],\n        center: [header.centerLon, header.centerLat],\n        centerZoom: header.centerZoom,\n        etag: header.etag\n    };\n    if (tilejson) {\n        metadata.tilejson = tilejson;\n    }\n    // Application can optionally include the raw header and metadata.\n    if (options?.includeFormatHeader) {\n        metadata.formatHeader = header;\n        metadata.formatMetadata = metadata;\n    }\n    return metadata;\n}\n/** Extract a MIME type for tiles from vector tile header  */\nfunction decodeTileType(tileType) {\n    switch (tileType) {\n        case TileType.Mvt:\n            return 'application/vnd.mapbox-vector-tile';\n        case TileType.Png:\n            return 'image/png';\n        case TileType.Jpeg:\n            return 'image/jpeg';\n        case TileType.Webp:\n            return 'image/webp';\n        case TileType.Avif:\n            return 'image/avif';\n        default:\n            return 'application/octet-stream';\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * A PMTiles library compatible source that reads from blobs\n * @deprecated TODO - reimplement as ReadableFileSource\n * Use loaders.gl HTTP range requests instead\n */\nexport class BlobSource {\n    blob;\n    key;\n    constructor(blob, key) {\n        this.blob = blob;\n        this.key = key;\n    }\n    // TODO - how is this used?\n    getKey() {\n        // @ts-expect-error url is only defined on File subclass\n        return this.blob.url || '';\n    }\n    async getBytes(offset, length, signal) {\n        const slice = this.blob.slice(offset, offset + length);\n        const data = await slice.arrayBuffer();\n        return {\n            data\n            // etag: response.headers.get('ETag') || undefined,\n            // cacheControl: response.headers.get('Cache-Control') || undefined,\n            // expires: response.headers.get('Expires') || undefined\n        };\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BlobFile } from '@loaders.gl/loader-utils';\nimport { VERSION } from \"./lib/version.js\";\nimport { PMTilesTileSource } from \"./pmtiles-source.js\";\n/**\n * Loader for PMTiles metadata\n * @note This loader is intended to allow PMTiles to be treated like other file types in top-level loading logic.\n * @note For actual access to the tile data, use the PMTilesSource class.\n */\nexport const PMTilesLoader = {\n    name: 'PMTiles',\n    id: 'pmtiles',\n    module: 'pmtiles',\n    version: VERSION,\n    extensions: ['pmtiles'],\n    mimeTypes: ['application/octet-stream'],\n    tests: ['PMTiles'],\n    options: {\n        pmtiles: {}\n    },\n    parse: async (arrayBuffer, options) => parseFileAsPMTiles(new BlobFile(new Blob([arrayBuffer])), options),\n    parseFile: parseFileAsPMTiles\n};\nasync function parseFileAsPMTiles(file, options) {\n    const source = new PMTilesTileSource(file.handle, {\n        pmtiles: options?.pmtiles || {}\n    });\n    const formatSpecificMetadata = await source.getMetadata();\n    const { tileMIMEType, tilejson = {} } = formatSpecificMetadata;\n    const { layers = [] } = tilejson;\n    switch (tileMIMEType) {\n        case 'application/vnd.mapbox-vector-tile':\n            return {\n                shape: 'vector-source',\n                layers: layers.map((layer) => ({ name: layer.name, schema: layer.schema })),\n                tables: [],\n                formatSpecificMetadata\n            };\n        case 'image/png':\n        case 'image/jpeg':\n            return { shape: 'image-source', formatSpecificMetadata };\n        default:\n            throw new Error(`PMTilesLoader: Unsupported tile MIME type ${tileMIMEType}`);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n"],
  "mappings": "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",
  "names": ["import_mvt", "pmtiles", "pmtiles", "import_loader_utils", "VERSION", "VERSION"]
}
