"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrowTextVector = exports.formatTextLabelData = exports.defaultPadding = void 0;
exports.getTextOffsetByRadius = getTextOffsetByRadius;
exports.textLabelAccessor = void 0;
var arrow = _interopRequireWildcard(require("apache-arrow"));
var _viewportMercatorProject = require("viewport-mercator-project");
var _utils = require("@kepler.gl/utils");
var _commonUtils = require("@kepler.gl/common-utils");
var _uniq = _interopRequireDefault(require("lodash/uniq"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

var defaultPadding = exports.defaultPadding = 20;
function getTextOffsetByRadius(radiusScale, getRadius, mapState) {
  return function (textLabel) {
    var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(mapState);
    var xMult = textLabel.anchor === 'middle' ? 0 : textLabel.anchor === 'start' ? 1 : -1;
    var yMult = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? 1 : -1;
    var sizeOffset = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? textLabel.size : textLabel.size;
    var pixelRadius = radiusScale * distanceScale.pixelsPerMeter[0];
    var padding = defaultPadding;
    return typeof getRadius === 'function' ? function (d) {
      return [xMult * (getRadius(d) * pixelRadius + padding), yMult * (getRadius(d) * pixelRadius + padding + sizeOffset)];
    } : [xMult * (getRadius * pixelRadius + padding), yMult * (getRadius * pixelRadius + padding + sizeOffset)];
  };
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
var textLabelAccessor = exports.textLabelAccessor = function textLabelAccessor(textLabel) {
  return function (dc) {
    return function (d) {
      var val = textLabel.field.valueAccessor(d);
      return (0, _commonUtils.notNullorUndefined)(val) ? String(val) : '';
    };
  };
};
var formatTextLabelData = exports.formatTextLabelData = function formatTextLabelData(_ref) {
  var textLabel = _ref.textLabel,
    triggerChanged = _ref.triggerChanged,
    oldLayerData = _ref.oldLayerData,
    data = _ref.data,
    dataContainer = _ref.dataContainer,
    filteredIndex = _ref.filteredIndex;
  return textLabel.map(function (tl, i) {
    if (!tl.field) {
      // if no field selected,
      return {
        getText: null,
        characterSet: []
      };
    }
    var getTextAccessor = textLabelAccessor(tl)(dataContainer);
    var characterSet;
    var getText = getTextAccessor;
    var rebuildArrowTextVector = true;
    if (!(triggerChanged !== null && triggerChanged !== void 0 && triggerChanged["getLabelCharacterSet-".concat(i)]) && oldLayerData && oldLayerData.textLabels && oldLayerData.textLabels[i]) {
      characterSet = oldLayerData.textLabels[i].characterSet;
      getText = oldLayerData.textLabels[i].getText;
      rebuildArrowTextVector = false;
    } else {
      if (data instanceof arrow.Table) {
        // we don't filter out arrow tables,
        // so we use filteredIndex array instead
        var allLabels = [];
        if (tl.field) {
          if (filteredIndex) {
            filteredIndex.forEach(function (value, index) {
              if (value > 0) allLabels.push(getTextAccessor({
                index: index
              }));
            });
          } else {
            for (var index = 0; index < dataContainer.numRows(); ++index) {
              allLabels.push(getTextAccessor({
                index: index
              }));
            }
          }
        }
        characterSet = (0, _uniq["default"])(allLabels.join(''));
      } else {
        var _allLabels = tl.field ? data.map(getTextAccessor) : [];
        characterSet = (0, _uniq["default"])(_allLabels.join(''));
      }
    }

    // For Arrow Layers getText has to be an arrow vector.
    // For now check here for ArrowTable, not ArrowDataContainer.
    if (rebuildArrowTextVector && data instanceof arrow.Table && dataContainer instanceof _utils.ArrowDataContainer) {
      getText = dataContainer.getColumn(tl.field.fieldIdx);
      try {
        getText = getArrowTextVector(getText, getTextAccessor);
      } catch (error) {
        // empty text labels
        getText = getArrowTextVector(getText, function () {
          return ' ';
        });
      }
    }
    return {
      characterSet: characterSet,
      getText: getText
    };
  });
};

/**
 * Get an arrow vector suitable to render text labels with arrow layers.
 * @param getText A candidate arrow vector to use for text labels.
 * @param getTextAccessor Text label accessor.
 */
var getArrowTextVector = exports.getArrowTextVector = function getArrowTextVector(candidateTextVector, getTextAccessor) {
  // if the passed vector is suitable for text labels
  if (arrow.DataType.isUtf8(candidateTextVector === null || candidateTextVector === void 0 ? void 0 : candidateTextVector.type)) {
    return candidateTextVector;
  }

  // create utf8 vector from source vector with the same number of batches.
  // @ts-expect-error
  var offsets = candidateTextVector._offsets;
  var numOffsets = offsets.length;
  var batchVectors = [];
  var datum = {
    index: 0
  };
  for (var batchIndex = 0; batchIndex < numOffsets - 1; batchIndex++) {
    var batchStart = offsets[batchIndex];
    var batchEnd = offsets[batchIndex + 1];
    var batchLabels = [];
    for (var rowIndex = batchStart; rowIndex < batchEnd; ++rowIndex) {
      datum.index = rowIndex;
      batchLabels.push(getTextAccessor(datum));
    }
    batchVectors.push(arrow.vectorFromArray(batchLabels, new arrow.Utf8()));
  }
  var input = batchVectors.flatMap(function (x) {
    return x.data;
  }).flat(Number.POSITIVE_INFINITY);
  return new arrow.Vector(input);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhcnJvdyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl92aWV3cG9ydE1lcmNhdG9yUHJvamVjdCIsIl91dGlscyIsIl9jb21tb25VdGlscyIsIl91bmlxIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsImhhcyIsImdldCIsIm4iLCJfX3Byb3RvX18iLCJhIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ1IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaSIsInNldCIsImRlZmF1bHRQYWRkaW5nIiwiZXhwb3J0cyIsImdldFRleHRPZmZzZXRCeVJhZGl1cyIsInJhZGl1c1NjYWxlIiwiZ2V0UmFkaXVzIiwibWFwU3RhdGUiLCJ0ZXh0TGFiZWwiLCJkaXN0YW5jZVNjYWxlIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJ4TXVsdCIsImFuY2hvciIsInlNdWx0IiwiYWxpZ25tZW50Iiwic2l6ZU9mZnNldCIsInNpemUiLCJwaXhlbFJhZGl1cyIsInBpeGVsc1Blck1ldGVyIiwicGFkZGluZyIsImQiLCJ0ZXh0TGFiZWxBY2Nlc3NvciIsImRjIiwidmFsIiwiZmllbGQiLCJ2YWx1ZUFjY2Vzc29yIiwibm90TnVsbG9yVW5kZWZpbmVkIiwiU3RyaW5nIiwiZm9ybWF0VGV4dExhYmVsRGF0YSIsIl9yZWYiLCJ0cmlnZ2VyQ2hhbmdlZCIsIm9sZExheWVyRGF0YSIsImRhdGEiLCJkYXRhQ29udGFpbmVyIiwiZmlsdGVyZWRJbmRleCIsIm1hcCIsInRsIiwiZ2V0VGV4dCIsImNoYXJhY3RlclNldCIsImdldFRleHRBY2Nlc3NvciIsInJlYnVpbGRBcnJvd1RleHRWZWN0b3IiLCJjb25jYXQiLCJ0ZXh0TGFiZWxzIiwiVGFibGUiLCJhbGxMYWJlbHMiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsInB1c2giLCJudW1Sb3dzIiwidW5pcSIsImpvaW4iLCJBcnJvd0RhdGFDb250YWluZXIiLCJnZXRDb2x1bW4iLCJmaWVsZElkeCIsImdldEFycm93VGV4dFZlY3RvciIsImVycm9yIiwiY2FuZGlkYXRlVGV4dFZlY3RvciIsIkRhdGFUeXBlIiwiaXNVdGY4IiwidHlwZSIsIm9mZnNldHMiLCJfb2Zmc2V0cyIsIm51bU9mZnNldHMiLCJsZW5ndGgiLCJiYXRjaFZlY3RvcnMiLCJkYXR1bSIsImJhdGNoSW5kZXgiLCJiYXRjaFN0YXJ0IiwiYmF0Y2hFbmQiLCJiYXRjaExhYmVscyIsInJvd0luZGV4IiwidmVjdG9yRnJvbUFycmF5IiwiVXRmOCIsImlucHV0IiwiZmxhdE1hcCIsIngiLCJmbGF0IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJWZWN0b3IiXSwic291cmNlcyI6WyIuLi9zcmMvbGF5ZXItdGV4dC1sYWJlbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHtnZXREaXN0YW5jZVNjYWxlc30gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQge0RhdGFDb250YWluZXJJbnRlcmZhY2UsIEFycm93RGF0YUNvbnRhaW5lcn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZH0gZnJvbSAnQGtlcGxlci5nbC9jb21tb24tdXRpbHMnO1xuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoL3VuaXEnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZGRpbmcgPSAyMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRPZmZzZXRCeVJhZGl1cyhyYWRpdXNTY2FsZSwgZ2V0UmFkaXVzLCBtYXBTdGF0ZSkge1xuICByZXR1cm4gdGV4dExhYmVsID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlID0gZ2V0RGlzdGFuY2VTY2FsZXMobWFwU3RhdGUpO1xuICAgIGNvbnN0IHhNdWx0ID0gdGV4dExhYmVsLmFuY2hvciA9PT0gJ21pZGRsZScgPyAwIDogdGV4dExhYmVsLmFuY2hvciA9PT0gJ3N0YXJ0JyA/IDEgOiAtMTtcbiAgICBjb25zdCB5TXVsdCA9IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdjZW50ZXInID8gMCA6IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdib3R0b20nID8gMSA6IC0xO1xuXG4gICAgY29uc3Qgc2l6ZU9mZnNldCA9XG4gICAgICB0ZXh0TGFiZWwuYWxpZ25tZW50ID09PSAnY2VudGVyJ1xuICAgICAgICA/IDBcbiAgICAgICAgOiB0ZXh0TGFiZWwuYWxpZ25tZW50ID09PSAnYm90dG9tJ1xuICAgICAgICA/IHRleHRMYWJlbC5zaXplXG4gICAgICAgIDogdGV4dExhYmVsLnNpemU7XG5cbiAgICBjb25zdCBwaXhlbFJhZGl1cyA9IHJhZGl1c1NjYWxlICogZGlzdGFuY2VTY2FsZS5waXhlbHNQZXJNZXRlclswXTtcbiAgICBjb25zdCBwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmc7XG5cbiAgICByZXR1cm4gdHlwZW9mIGdldFJhZGl1cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBkID0+IFtcbiAgICAgICAgICB4TXVsdCAqIChnZXRSYWRpdXMoZCkgKiBwaXhlbFJhZGl1cyArIHBhZGRpbmcpLFxuICAgICAgICAgIHlNdWx0ICogKGdldFJhZGl1cyhkKSAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyArIHNpemVPZmZzZXQpXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIHhNdWx0ICogKGdldFJhZGl1cyAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyksXG4gICAgICAgICAgeU11bHQgKiAoZ2V0UmFkaXVzICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nICsgc2l6ZU9mZnNldClcbiAgICAgICAgXTtcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IGNvbnN0IHRleHRMYWJlbEFjY2Vzc29yID0gdGV4dExhYmVsID0+IGRjID0+IGQgPT4ge1xuICBjb25zdCB2YWwgPSB0ZXh0TGFiZWwuZmllbGQudmFsdWVBY2Nlc3NvcihkKTtcbiAgcmV0dXJuIG5vdE51bGxvclVuZGVmaW5lZCh2YWwpID8gU3RyaW5nKHZhbCkgOiAnJztcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRUZXh0TGFiZWxEYXRhID0gKHtcbiAgdGV4dExhYmVsLFxuICB0cmlnZ2VyQ2hhbmdlZCxcbiAgb2xkTGF5ZXJEYXRhLFxuICBkYXRhLFxuICBkYXRhQ29udGFpbmVyLFxuICBmaWx0ZXJlZEluZGV4XG59OiB7XG4gIHRleHRMYWJlbDogYW55O1xuICB0cmlnZ2VyQ2hhbmdlZD86IGJvb2xlYW4gfCB7W2tleTogc3RyaW5nXTogYm9vbGVhbn07XG4gIG9sZExheWVyRGF0YTogYW55O1xuICBkYXRhOiBhbnk7XG4gIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2U7XG4gIGZpbHRlcmVkSW5kZXg/OiBVaW50OENsYW1wZWRBcnJheSB8IG51bGw7XG59KSA9PiB7XG4gIHJldHVybiB0ZXh0TGFiZWwubWFwKCh0bCwgaSkgPT4ge1xuICAgIGlmICghdGwuZmllbGQpIHtcbiAgICAgIC8vIGlmIG5vIGZpZWxkIHNlbGVjdGVkLFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0VGV4dDogbnVsbCxcbiAgICAgICAgY2hhcmFjdGVyU2V0OiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRUZXh0QWNjZXNzb3I6IChkOiB7aW5kZXg6IG51bWJlcn0pID0+IHN0cmluZyA9IHRleHRMYWJlbEFjY2Vzc29yKHRsKShkYXRhQ29udGFpbmVyKTtcbiAgICBsZXQgY2hhcmFjdGVyU2V0O1xuICAgIGxldCBnZXRUZXh0OiB0eXBlb2YgZ2V0VGV4dEFjY2Vzc29yIHwgYXJyb3cuVmVjdG9yID0gZ2V0VGV4dEFjY2Vzc29yO1xuXG4gICAgbGV0IHJlYnVpbGRBcnJvd1RleHRWZWN0b3IgPSB0cnVlO1xuICAgIGlmIChcbiAgICAgICF0cmlnZ2VyQ2hhbmdlZD8uW2BnZXRMYWJlbENoYXJhY3RlclNldC0ke2l9YF0gJiZcbiAgICAgIG9sZExheWVyRGF0YSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHMgJiZcbiAgICAgIG9sZExheWVyRGF0YS50ZXh0TGFiZWxzW2ldXG4gICAgKSB7XG4gICAgICBjaGFyYWN0ZXJTZXQgPSBvbGRMYXllckRhdGEudGV4dExhYmVsc1tpXS5jaGFyYWN0ZXJTZXQ7XG4gICAgICBnZXRUZXh0ID0gb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHNbaV0uZ2V0VGV4dDtcbiAgICAgIHJlYnVpbGRBcnJvd1RleHRWZWN0b3IgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBhcnJvdy5UYWJsZSkge1xuICAgICAgICAvLyB3ZSBkb24ndCBmaWx0ZXIgb3V0IGFycm93IHRhYmxlcyxcbiAgICAgICAgLy8gc28gd2UgdXNlIGZpbHRlcmVkSW5kZXggYXJyYXkgaW5zdGVhZFxuICAgICAgICBjb25zdCBhbGxMYWJlbHM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh0bC5maWVsZCkge1xuICAgICAgICAgIGlmIChmaWx0ZXJlZEluZGV4KSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEluZGV4LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSBhbGxMYWJlbHMucHVzaChnZXRUZXh0QWNjZXNzb3Ioe2luZGV4fSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhQ29udGFpbmVyLm51bVJvd3MoKTsgKytpbmRleCkge1xuICAgICAgICAgICAgICBhbGxMYWJlbHMucHVzaChnZXRUZXh0QWNjZXNzb3Ioe2luZGV4fSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFyYWN0ZXJTZXQgPSB1bmlxKGFsbExhYmVscy5qb2luKCcnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhbGxMYWJlbHMgPSB0bC5maWVsZCA/IGRhdGEubWFwKGdldFRleHRBY2Nlc3NvcikgOiBbXTtcbiAgICAgICAgY2hhcmFjdGVyU2V0ID0gdW5pcShhbGxMYWJlbHMuam9pbignJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBBcnJvdyBMYXllcnMgZ2V0VGV4dCBoYXMgdG8gYmUgYW4gYXJyb3cgdmVjdG9yLlxuICAgIC8vIEZvciBub3cgY2hlY2sgaGVyZSBmb3IgQXJyb3dUYWJsZSwgbm90IEFycm93RGF0YUNvbnRhaW5lci5cbiAgICBpZiAoXG4gICAgICByZWJ1aWxkQXJyb3dUZXh0VmVjdG9yICYmXG4gICAgICBkYXRhIGluc3RhbmNlb2YgYXJyb3cuVGFibGUgJiZcbiAgICAgIGRhdGFDb250YWluZXIgaW5zdGFuY2VvZiBBcnJvd0RhdGFDb250YWluZXJcbiAgICApIHtcbiAgICAgIGdldFRleHQgPSBkYXRhQ29udGFpbmVyLmdldENvbHVtbih0bC5maWVsZC5maWVsZElkeCk7XG4gICAgICB0cnkge1xuICAgICAgICBnZXRUZXh0ID0gZ2V0QXJyb3dUZXh0VmVjdG9yKGdldFRleHQgYXMgYXJyb3cuVmVjdG9yLCBnZXRUZXh0QWNjZXNzb3IpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gZW1wdHkgdGV4dCBsYWJlbHNcbiAgICAgICAgZ2V0VGV4dCA9IGdldEFycm93VGV4dFZlY3RvcihnZXRUZXh0LCAoKSA9PiAnICcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGFyYWN0ZXJTZXQsXG4gICAgICBnZXRUZXh0XG4gICAgfTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBhbiBhcnJvdyB2ZWN0b3Igc3VpdGFibGUgdG8gcmVuZGVyIHRleHQgbGFiZWxzIHdpdGggYXJyb3cgbGF5ZXJzLlxuICogQHBhcmFtIGdldFRleHQgQSBjYW5kaWRhdGUgYXJyb3cgdmVjdG9yIHRvIHVzZSBmb3IgdGV4dCBsYWJlbHMuXG4gKiBAcGFyYW0gZ2V0VGV4dEFjY2Vzc29yIFRleHQgbGFiZWwgYWNjZXNzb3IuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBcnJvd1RleHRWZWN0b3IgPSAoXG4gIGNhbmRpZGF0ZVRleHRWZWN0b3I6IGFycm93LlZlY3RvcixcbiAgZ2V0VGV4dEFjY2Vzc29yOiAoe2luZGV4fToge2luZGV4OiBudW1iZXJ9KSA9PiBzdHJpbmdcbik6IGFycm93LlZlY3RvciA9PiB7XG4gIC8vIGlmIHRoZSBwYXNzZWQgdmVjdG9yIGlzIHN1aXRhYmxlIGZvciB0ZXh0IGxhYmVsc1xuICBpZiAoYXJyb3cuRGF0YVR5cGUuaXNVdGY4KGNhbmRpZGF0ZVRleHRWZWN0b3I/LnR5cGUpKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZVRleHRWZWN0b3I7XG4gIH1cblxuICAvLyBjcmVhdGUgdXRmOCB2ZWN0b3IgZnJvbSBzb3VyY2UgdmVjdG9yIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJhdGNoZXMuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgY29uc3Qgb2Zmc2V0cyA9IGNhbmRpZGF0ZVRleHRWZWN0b3IuX29mZnNldHM7XG4gIGNvbnN0IG51bU9mZnNldHMgPSBvZmZzZXRzLmxlbmd0aDtcbiAgY29uc3QgYmF0Y2hWZWN0b3JzOiBhcnJvdy5WZWN0b3JbXSA9IFtdO1xuICBjb25zdCBkYXR1bSA9IHtpbmRleDogMH07XG4gIGZvciAobGV0IGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgbnVtT2Zmc2V0cyAtIDE7IGJhdGNoSW5kZXgrKykge1xuICAgIGNvbnN0IGJhdGNoU3RhcnQgPSBvZmZzZXRzW2JhdGNoSW5kZXhdO1xuICAgIGNvbnN0IGJhdGNoRW5kID0gb2Zmc2V0c1tiYXRjaEluZGV4ICsgMV07XG5cbiAgICBjb25zdCBiYXRjaExhYmVsczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCByb3dJbmRleCA9IGJhdGNoU3RhcnQ7IHJvd0luZGV4IDwgYmF0Y2hFbmQ7ICsrcm93SW5kZXgpIHtcbiAgICAgIGRhdHVtLmluZGV4ID0gcm93SW5kZXg7XG4gICAgICBiYXRjaExhYmVscy5wdXNoKGdldFRleHRBY2Nlc3NvcihkYXR1bSkpO1xuICAgIH1cblxuICAgIGJhdGNoVmVjdG9ycy5wdXNoKGFycm93LnZlY3RvckZyb21BcnJheShiYXRjaExhYmVscywgbmV3IGFycm93LlV0ZjgoKSkpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQgPSBiYXRjaFZlY3RvcnMuZmxhdE1hcCh4ID0+IHguZGF0YSkuZmxhdChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gIHJldHVybiBuZXcgYXJyb3cuVmVjdG9yKGlucHV0KTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxLQUFBLEdBQUFDLHVCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyx3QkFBQSxHQUFBRCxPQUFBO0FBQ0EsSUFBQUUsTUFBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsWUFBQSxHQUFBSCxPQUFBO0FBQ0EsSUFBQUksS0FBQSxHQUFBQyxzQkFBQSxDQUFBTCxPQUFBO0FBQStCLFNBQUFNLHlCQUFBQyxDQUFBLDZCQUFBQyxPQUFBLG1CQUFBQyxDQUFBLE9BQUFELE9BQUEsSUFBQUUsQ0FBQSxPQUFBRixPQUFBLFlBQUFGLHdCQUFBLFlBQUFBLHlCQUFBQyxDQUFBLFdBQUFBLENBQUEsR0FBQUcsQ0FBQSxHQUFBRCxDQUFBLEtBQUFGLENBQUE7QUFBQSxTQUFBUix3QkFBQVEsQ0FBQSxFQUFBRSxDQUFBLFNBQUFBLENBQUEsSUFBQUYsQ0FBQSxJQUFBQSxDQUFBLENBQUFJLFVBQUEsU0FBQUosQ0FBQSxlQUFBQSxDQUFBLGdCQUFBSyxPQUFBLENBQUFMLENBQUEsMEJBQUFBLENBQUEsc0JBQUFBLENBQUEsUUFBQUcsQ0FBQSxHQUFBSix3QkFBQSxDQUFBRyxDQUFBLE9BQUFDLENBQUEsSUFBQUEsQ0FBQSxDQUFBRyxHQUFBLENBQUFOLENBQUEsVUFBQUcsQ0FBQSxDQUFBSSxHQUFBLENBQUFQLENBQUEsT0FBQVEsQ0FBQSxLQUFBQyxTQUFBLFVBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxjQUFBLElBQUFELE1BQUEsQ0FBQUUsd0JBQUEsV0FBQUMsQ0FBQSxJQUFBZCxDQUFBLG9CQUFBYyxDQUFBLE9BQUFDLGNBQUEsQ0FBQUMsSUFBQSxDQUFBaEIsQ0FBQSxFQUFBYyxDQUFBLFNBQUFHLENBQUEsR0FBQVAsQ0FBQSxHQUFBQyxNQUFBLENBQUFFLHdCQUFBLENBQUFiLENBQUEsRUFBQWMsQ0FBQSxVQUFBRyxDQUFBLEtBQUFBLENBQUEsQ0FBQVYsR0FBQSxJQUFBVSxDQUFBLENBQUFDLEdBQUEsSUFBQVAsTUFBQSxDQUFBQyxjQUFBLENBQUFKLENBQUEsRUFBQU0sQ0FBQSxFQUFBRyxDQUFBLElBQUFULENBQUEsQ0FBQU0sQ0FBQSxJQUFBZCxDQUFBLENBQUFjLENBQUEsWUFBQU4sQ0FBQSxjQUFBUixDQUFBLEVBQUFHLENBQUEsSUFBQUEsQ0FBQSxDQUFBZSxHQUFBLENBQUFsQixDQUFBLEVBQUFRLENBQUEsR0FBQUEsQ0FBQTtBQVAvQjtBQUNBOztBQVFPLElBQU1XLGNBQWMsR0FBQUMsT0FBQSxDQUFBRCxjQUFBLEdBQUcsRUFBRTtBQUV6QixTQUFTRSxxQkFBcUJBLENBQUNDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUU7RUFDdEUsT0FBTyxVQUFBQyxTQUFTLEVBQUk7SUFDbEIsSUFBTUMsYUFBYSxHQUFHLElBQUFDLDBDQUFpQixFQUFDSCxRQUFRLENBQUM7SUFDakQsSUFBTUksS0FBSyxHQUFHSCxTQUFTLENBQUNJLE1BQU0sS0FBSyxRQUFRLEdBQUcsQ0FBQyxHQUFHSixTQUFTLENBQUNJLE1BQU0sS0FBSyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2RixJQUFNQyxLQUFLLEdBQUdMLFNBQVMsQ0FBQ00sU0FBUyxLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUdOLFNBQVMsQ0FBQ00sU0FBUyxLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTlGLElBQU1DLFVBQVUsR0FDZFAsU0FBUyxDQUFDTSxTQUFTLEtBQUssUUFBUSxHQUM1QixDQUFDLEdBQ0ROLFNBQVMsQ0FBQ00sU0FBUyxLQUFLLFFBQVEsR0FDaENOLFNBQVMsQ0FBQ1EsSUFBSSxHQUNkUixTQUFTLENBQUNRLElBQUk7SUFFcEIsSUFBTUMsV0FBVyxHQUFHWixXQUFXLEdBQUdJLGFBQWEsQ0FBQ1MsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNqRSxJQUFNQyxPQUFPLEdBQUdqQixjQUFjO0lBRTlCLE9BQU8sT0FBT0ksU0FBUyxLQUFLLFVBQVUsR0FDbEMsVUFBQWMsQ0FBQztNQUFBLE9BQUksQ0FDSFQsS0FBSyxJQUFJTCxTQUFTLENBQUNjLENBQUMsQ0FBQyxHQUFHSCxXQUFXLEdBQUdFLE9BQU8sQ0FBQyxFQUM5Q04sS0FBSyxJQUFJUCxTQUFTLENBQUNjLENBQUMsQ0FBQyxHQUFHSCxXQUFXLEdBQUdFLE9BQU8sR0FBR0osVUFBVSxDQUFDLENBQzVEO0lBQUEsSUFDRCxDQUNFSixLQUFLLElBQUlMLFNBQVMsR0FBR1csV0FBVyxHQUFHRSxPQUFPLENBQUMsRUFDM0NOLEtBQUssSUFBSVAsU0FBUyxHQUFHVyxXQUFXLEdBQUdFLE9BQU8sR0FBR0osVUFBVSxDQUFDLENBQ3pEO0VBQ1AsQ0FBQztBQUNIOztBQUVBO0FBQ08sSUFBTU0saUJBQWlCLEdBQUFsQixPQUFBLENBQUFrQixpQkFBQSxHQUFHLFNBQXBCQSxpQkFBaUJBLENBQUdiLFNBQVM7RUFBQSxPQUFJLFVBQUFjLEVBQUU7SUFBQSxPQUFJLFVBQUFGLENBQUMsRUFBSTtNQUN2RCxJQUFNRyxHQUFHLEdBQUdmLFNBQVMsQ0FBQ2dCLEtBQUssQ0FBQ0MsYUFBYSxDQUFDTCxDQUFDLENBQUM7TUFDNUMsT0FBTyxJQUFBTSwrQkFBa0IsRUFBQ0gsR0FBRyxDQUFDLEdBQUdJLE1BQU0sQ0FBQ0osR0FBRyxDQUFDLEdBQUcsRUFBRTtJQUNuRCxDQUFDO0VBQUE7QUFBQTtBQUVNLElBQU1LLG1CQUFtQixHQUFBekIsT0FBQSxDQUFBeUIsbUJBQUEsR0FBRyxTQUF0QkEsbUJBQW1CQSxDQUFBQyxJQUFBLEVBYzFCO0VBQUEsSUFiSnJCLFNBQVMsR0FBQXFCLElBQUEsQ0FBVHJCLFNBQVM7SUFDVHNCLGNBQWMsR0FBQUQsSUFBQSxDQUFkQyxjQUFjO0lBQ2RDLFlBQVksR0FBQUYsSUFBQSxDQUFaRSxZQUFZO0lBQ1pDLElBQUksR0FBQUgsSUFBQSxDQUFKRyxJQUFJO0lBQ0pDLGFBQWEsR0FBQUosSUFBQSxDQUFiSSxhQUFhO0lBQ2JDLGFBQWEsR0FBQUwsSUFBQSxDQUFiSyxhQUFhO0VBU2IsT0FBTzFCLFNBQVMsQ0FBQzJCLEdBQUcsQ0FBQyxVQUFDQyxFQUFFLEVBQUVwQyxDQUFDLEVBQUs7SUFDOUIsSUFBSSxDQUFDb0MsRUFBRSxDQUFDWixLQUFLLEVBQUU7TUFDYjtNQUNBLE9BQU87UUFDTGEsT0FBTyxFQUFFLElBQUk7UUFDYkMsWUFBWSxFQUFFO01BQ2hCLENBQUM7SUFDSDtJQUVBLElBQU1DLGVBQStDLEdBQUdsQixpQkFBaUIsQ0FBQ2UsRUFBRSxDQUFDLENBQUNILGFBQWEsQ0FBQztJQUM1RixJQUFJSyxZQUFZO0lBQ2hCLElBQUlELE9BQThDLEdBQUdFLGVBQWU7SUFFcEUsSUFBSUMsc0JBQXNCLEdBQUcsSUFBSTtJQUNqQyxJQUNFLEVBQUNWLGNBQWMsYUFBZEEsY0FBYyxlQUFkQSxjQUFjLHlCQUFBVyxNQUFBLENBQTJCekMsQ0FBQyxFQUFHLEtBQzlDK0IsWUFBWSxJQUNaQSxZQUFZLENBQUNXLFVBQVUsSUFDdkJYLFlBQVksQ0FBQ1csVUFBVSxDQUFDMUMsQ0FBQyxDQUFDLEVBQzFCO01BQ0FzQyxZQUFZLEdBQUdQLFlBQVksQ0FBQ1csVUFBVSxDQUFDMUMsQ0FBQyxDQUFDLENBQUNzQyxZQUFZO01BQ3RERCxPQUFPLEdBQUdOLFlBQVksQ0FBQ1csVUFBVSxDQUFDMUMsQ0FBQyxDQUFDLENBQUNxQyxPQUFPO01BQzVDRyxzQkFBc0IsR0FBRyxLQUFLO0lBQ2hDLENBQUMsTUFBTTtNQUNMLElBQUlSLElBQUksWUFBWTFELEtBQUssQ0FBQ3FFLEtBQUssRUFBRTtRQUMvQjtRQUNBO1FBQ0EsSUFBTUMsU0FBbUIsR0FBRyxFQUFFO1FBQzlCLElBQUlSLEVBQUUsQ0FBQ1osS0FBSyxFQUFFO1VBQ1osSUFBSVUsYUFBYSxFQUFFO1lBQ2pCQSxhQUFhLENBQUNXLE9BQU8sQ0FBQyxVQUFDQyxLQUFLLEVBQUVDLEtBQUssRUFBSztjQUN0QyxJQUFJRCxLQUFLLEdBQUcsQ0FBQyxFQUFFRixTQUFTLENBQUNJLElBQUksQ0FBQ1QsZUFBZSxDQUFDO2dCQUFDUSxLQUFLLEVBQUxBO2NBQUssQ0FBQyxDQUFDLENBQUM7WUFDekQsQ0FBQyxDQUFDO1VBQ0osQ0FBQyxNQUFNO1lBQ0wsS0FBSyxJQUFJQSxLQUFLLEdBQUcsQ0FBQyxFQUFFQSxLQUFLLEdBQUdkLGFBQWEsQ0FBQ2dCLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRUYsS0FBSyxFQUFFO2NBQzVESCxTQUFTLENBQUNJLElBQUksQ0FBQ1QsZUFBZSxDQUFDO2dCQUFDUSxLQUFLLEVBQUxBO2NBQUssQ0FBQyxDQUFDLENBQUM7WUFDMUM7VUFDRjtRQUNGO1FBQ0FULFlBQVksR0FBRyxJQUFBWSxnQkFBSSxFQUFDTixTQUFTLENBQUNPLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUN6QyxDQUFDLE1BQU07UUFDTCxJQUFNUCxVQUFTLEdBQUdSLEVBQUUsQ0FBQ1osS0FBSyxHQUFHUSxJQUFJLENBQUNHLEdBQUcsQ0FBQ0ksZUFBZSxDQUFDLEdBQUcsRUFBRTtRQUMzREQsWUFBWSxHQUFHLElBQUFZLGdCQUFJLEVBQUNOLFVBQVMsQ0FBQ08sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO01BQ3pDO0lBQ0Y7O0lBRUE7SUFDQTtJQUNBLElBQ0VYLHNCQUFzQixJQUN0QlIsSUFBSSxZQUFZMUQsS0FBSyxDQUFDcUUsS0FBSyxJQUMzQlYsYUFBYSxZQUFZbUIseUJBQWtCLEVBQzNDO01BQ0FmLE9BQU8sR0FBR0osYUFBYSxDQUFDb0IsU0FBUyxDQUFDakIsRUFBRSxDQUFDWixLQUFLLENBQUM4QixRQUFRLENBQUM7TUFDcEQsSUFBSTtRQUNGakIsT0FBTyxHQUFHa0Isa0JBQWtCLENBQUNsQixPQUFPLEVBQWtCRSxlQUFlLENBQUM7TUFDeEUsQ0FBQyxDQUFDLE9BQU9pQixLQUFLLEVBQUU7UUFDZDtRQUNBbkIsT0FBTyxHQUFHa0Isa0JBQWtCLENBQUNsQixPQUFPLEVBQUU7VUFBQSxPQUFNLEdBQUc7UUFBQSxFQUFDO01BQ2xEO0lBQ0Y7SUFFQSxPQUFPO01BQ0xDLFlBQVksRUFBWkEsWUFBWTtNQUNaRCxPQUFPLEVBQVBBO0lBQ0YsQ0FBQztFQUNILENBQUMsQ0FBQztBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQU1rQixrQkFBa0IsR0FBQXBELE9BQUEsQ0FBQW9ELGtCQUFBLEdBQUcsU0FBckJBLGtCQUFrQkEsQ0FDN0JFLG1CQUFpQyxFQUNqQ2xCLGVBQXFELEVBQ3BDO0VBQ2pCO0VBQ0EsSUFBSWpFLEtBQUssQ0FBQ29GLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDRixtQkFBbUIsYUFBbkJBLG1CQUFtQix1QkFBbkJBLG1CQUFtQixDQUFFRyxJQUFJLENBQUMsRUFBRTtJQUNwRCxPQUFPSCxtQkFBbUI7RUFDNUI7O0VBRUE7RUFDQTtFQUNBLElBQU1JLE9BQU8sR0FBR0osbUJBQW1CLENBQUNLLFFBQVE7RUFDNUMsSUFBTUMsVUFBVSxHQUFHRixPQUFPLENBQUNHLE1BQU07RUFDakMsSUFBTUMsWUFBNEIsR0FBRyxFQUFFO0VBQ3ZDLElBQU1DLEtBQUssR0FBRztJQUFDbkIsS0FBSyxFQUFFO0VBQUMsQ0FBQztFQUN4QixLQUFLLElBQUlvQixVQUFVLEdBQUcsQ0FBQyxFQUFFQSxVQUFVLEdBQUdKLFVBQVUsR0FBRyxDQUFDLEVBQUVJLFVBQVUsRUFBRSxFQUFFO0lBQ2xFLElBQU1DLFVBQVUsR0FBR1AsT0FBTyxDQUFDTSxVQUFVLENBQUM7SUFDdEMsSUFBTUUsUUFBUSxHQUFHUixPQUFPLENBQUNNLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFFeEMsSUFBTUcsV0FBcUIsR0FBRyxFQUFFO0lBQ2hDLEtBQUssSUFBSUMsUUFBUSxHQUFHSCxVQUFVLEVBQUVHLFFBQVEsR0FBR0YsUUFBUSxFQUFFLEVBQUVFLFFBQVEsRUFBRTtNQUMvREwsS0FBSyxDQUFDbkIsS0FBSyxHQUFHd0IsUUFBUTtNQUN0QkQsV0FBVyxDQUFDdEIsSUFBSSxDQUFDVCxlQUFlLENBQUMyQixLQUFLLENBQUMsQ0FBQztJQUMxQztJQUVBRCxZQUFZLENBQUNqQixJQUFJLENBQUMxRSxLQUFLLENBQUNrRyxlQUFlLENBQUNGLFdBQVcsRUFBRSxJQUFJaEcsS0FBSyxDQUFDbUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ3pFO0VBRUEsSUFBTUMsS0FBSyxHQUFHVCxZQUFZLENBQUNVLE9BQU8sQ0FBQyxVQUFBQyxDQUFDO0lBQUEsT0FBSUEsQ0FBQyxDQUFDNUMsSUFBSTtFQUFBLEVBQUMsQ0FBQzZDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxpQkFBaUIsQ0FBQztFQUU5RSxPQUFPLElBQUl6RyxLQUFLLENBQUMwRyxNQUFNLENBQUNOLEtBQUssQ0FBQztBQUNoQyxDQUFDIiwiaWdub3JlTGlzdCI6W119