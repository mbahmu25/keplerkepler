import Layer, { LayerBaseConfig, VisualChannels } from './base-layer';
import { default as KeplerTable } from '@kepler.gl/table';
import { Merge, LayerColumn } from '@kepler.gl/types';
declare type MapboxLayerGLColumns = {
    lat: LayerColumn;
    lng: LayerColumn;
    geoarrow?: LayerColumn;
};
export declare type MapboxLayerGLConfig = Merge<LayerBaseConfig, {
    columns: MapboxLayerGLColumns;
}>;
export declare const COLUMN_MODE_POINTS = "points";
export declare const mapboxRequiredColumns: string[];
export declare const pointColResolver: ({ lat, lng, geoarrow }: MapboxLayerGLColumns, columnMode?: string) => string;
declare class MapboxLayerGL extends Layer {
    config: MapboxLayerGLConfig;
    get overlayType(): "mapboxgl";
    get type(): string | null;
    get isAggregated(): true;
    get supportedColumnModes(): {
        key: string;
        label: string;
        requiredColumns: string[];
    }[];
    get columnPairs(): import("@kepler.gl/types").ColumnPairs;
    get noneLayerDataAffectingProps(): never[];
    get visualChannels(): VisualChannels;
    datasetSelector: (config: MapboxLayerGLConfig) => string;
    gpuFilterSelector: (config: MapboxLayerGLConfig, datasets: any) => any;
    columnsSelector: (config: MapboxLayerGLConfig) => string;
    sourceSelector: ((state: {
        dataId: string;
        label: string;
        color: import("@kepler.gl/types").RGBColor;
        columns: MapboxLayerGLColumns;
        isVisible: boolean;
        isConfigActive: boolean;
        highlightColor: import("@kepler.gl/types").RGBColor | import("@kepler.gl/types").RGBAColor;
        hidden: boolean;
        visConfig: import("@kepler.gl/types").LayerVisConfig;
        textLabel: import("@kepler.gl/types").LayerTextLabel[];
        colorUI: {
            color: import("@kepler.gl/types").ColorUI;
            colorRange: import("@kepler.gl/types").ColorUI;
        };
        animation: {
            enabled: boolean;
            domain?: [number, number] | null | undefined;
        };
        aggregatedBins?: import("@kepler.gl/types").AggregatedBin[] | undefined;
        columnMode?: string | undefined;
        heightField?: import("@kepler.gl/types").VisualChannelField | undefined;
        heightDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        heightScale?: string | undefined;
    }) => string) & import("reselect").OutputSelectorFields<(args_0: string, args_1: string) => string, {
        clearCache: () => void;
    }> & {
        clearCache: () => void;
    };
    filterSelector: ((state: {
        dataId: string;
        label: string;
        color: import("@kepler.gl/types").RGBColor;
        columns: MapboxLayerGLColumns;
        isVisible: boolean;
        isConfigActive: boolean;
        highlightColor: import("@kepler.gl/types").RGBColor | import("@kepler.gl/types").RGBAColor;
        hidden: boolean;
        visConfig: import("@kepler.gl/types").LayerVisConfig;
        textLabel: import("@kepler.gl/types").LayerTextLabel[];
        colorUI: {
            color: import("@kepler.gl/types").ColorUI;
            colorRange: import("@kepler.gl/types").ColorUI;
        };
        animation: {
            enabled: boolean;
            domain?: [number, number] | null | undefined;
        };
        aggregatedBins?: import("@kepler.gl/types").AggregatedBin[] | undefined;
        columnMode?: string | undefined;
        heightField?: import("@kepler.gl/types").VisualChannelField | undefined;
        heightDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        heightScale?: string | undefined;
    }, datasets: any) => any[] | null) & import("reselect").OutputSelectorFields<(args_0: any) => any[] | null, {
        clearCache: () => void;
    }> & {
        clearCache: () => void;
    };
    isValidFilter(filter: any): number | false;
    getDataUpdateTriggers({ filteredIndex, gpuFilter, id }: KeplerTable): any;
    getGeometry(position: any): {
        type: string;
        coordinates: any;
    } | null;
    calculateDataAttribute({ dataContainer, filteredIndex, gpuFilter }: KeplerTable, getPosition: any): {
        type: string;
        features: import("geojson").Feature<import("geojson").Geometry, import("geojson").GeoJsonProperties>[];
    };
    shouldRenderLayer(): boolean;
}
export default MapboxLayerGL;
