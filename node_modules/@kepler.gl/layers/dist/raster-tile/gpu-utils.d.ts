/// <reference types="luma.gl__webgl" />
import { Texture2DProps } from '@luma.gl/webgl';
import { RasterWebGL } from '@kepler.gl/deckgl-layers';
declare type ShaderModule = RasterWebGL.ShaderModule;
import { CategoricalColormapOptions, ImageData, RenderSubLayersProps } from './types';
/**
 * Discrete-valued colormaps (e.g. from the output of
 * classification algorithms) in the raster layer. Previously, the values passed to
 * `TEXTURE_MIN_FILTER` and `TEXTURE_MAG_FILTER` were `GL.LINEAR`, which meant that the GPU would
 * linearly interpolate values between two neighboring colormap pixel values. Setting these values
 * to NEAREST means that the GPU will choose the nearest value on the texture2D lookup operation,
 * which fixes precision issues for discrete-valued colormaps. This should be ok for continuous
 * colormaps as long as the color difference between each pixel on the colormap is small.
 */
export declare const COLORMAP_TEXTURE_PARAMETERS: {
    [x: number]: number;
};
/**
 * Select correct module type for "combineBands"
 *
 * combineBands joins up to four 2D arrays (contained in imageBands) into a single "rgba" image
 * texture on the GPU. That shader code needs to have the same data type as the actual image data.
 * E.g. for float data the texture needs to be `sampler2D`, for uint data the texture needs to be
 * `usampler2D` and for int data the texture needs to be `isampler2D`.
 */
export declare function getCombineBandsModule(imageBands: Texture2DProps[]): ShaderModule;
/** Select correct image masking shader module for mask data type
 * The imageMask could (at least in the future, theoretically) be of a different data format than
 * the imageBands data itself.
 */
export declare function getImageMaskModule(imageMask: Texture2DProps): ShaderModule;
/**
 * Load image and wrap with default WebGL texture parameters
 *
 * @param url URL to load image
 * @param textureParams parameters to pass to Texture2D
 *
 * @return image object to pass to Texture2D constructor
 */
export declare function loadImage(url: string, textureParams?: Texture2DProps, requestOptions?: RequestInit): Promise<Texture2DProps>;
declare type FetchLike = (url: string, options?: RequestInit) => Promise<Response>;
declare type LoadingOptions = {
    fetch?: typeof fetch | FetchLike;
};
/**
 * Load NPY Array
 *
 * The NPY format is described here: https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html.
 * It's designed to be a very simple file format to hold an N-dimensional block of data. The header describes the data type, shape, and order (either C or Fortran) of the array.
 *
 * @param url URL to load NPY Array
 * @param split Whether to split single typed array representing an N-dimensional array into an Array with each dimension as its own typed array
 *
 * @return image object to pass to Texture2D constructor
 */
export declare function loadNpyArray(request: {
    url: string;
    rasterServerUrl: string;
    options: RequestInit;
}, split: true, options?: LoadingOptions): Promise<Texture2DProps[] | null>;
export declare function loadNpyArray(request: {
    url: string;
    rasterServerUrl: string;
    options: RequestInit;
}, split: false, options?: LoadingOptions): Promise<Texture2DProps | null>;
/**
 * Create texture data for categorical colormap scale
 * @param categoricalOptions - color map configuration and min-max values of categorical band
 * @returns texture data
 */
export declare function generateCategoricalColormapTexture(categoricalOptions: CategoricalColormapOptions): Texture2DProps;
export declare function getModules({ images, props }: {
    images: Partial<ImageData>;
    props?: RenderSubLayersProps;
}): {
    modules: ShaderModule[];
    moduleProps: Record<string, any>;
};
export {};
