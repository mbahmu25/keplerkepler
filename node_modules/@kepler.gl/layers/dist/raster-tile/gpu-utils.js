"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLORMAP_TEXTURE_PARAMETERS = void 0;
exports.generateCategoricalColormapTexture = generateCategoricalColormapTexture;
exports.getCombineBandsModule = getCombineBandsModule;
exports.getImageMaskModule = getImageMaskModule;
exports.getModules = getModules;
exports.loadImage = loadImage;
exports.loadNpyArray = loadNpyArray;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _core = require("@loaders.gl/core");
var _images = require("@loaders.gl/images");
var _textures = require("@loaders.gl/textures");
var _constants = _interopRequireDefault(require("@luma.gl/constants"));
var _commonUtils = require("@kepler.gl/common-utils");
var _constants2 = require("@kepler.gl/constants");
var _deckglLayers = require("@kepler.gl/deckgl-layers");
var _utils = require("@kepler.gl/utils");
var _rasterTileUtils = require("./raster-tile-utils");
var _requestThrottle = require("./request-throttle");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
/**
 * Functions and constants for handling webgl/luma.gl/deck.gl entities
 */
var combineBandsFloat = _deckglLayers.RasterWebGL.combineBandsFloat,
  combineBandsInt = _deckglLayers.RasterWebGL.combineBandsInt,
  combineBandsUint = _deckglLayers.RasterWebGL.combineBandsUint,
  maskFloat = _deckglLayers.RasterWebGL.maskFloat,
  maskInt = _deckglLayers.RasterWebGL.maskInt,
  maskUint = _deckglLayers.RasterWebGL.maskUint,
  linearRescale = _deckglLayers.RasterWebGL.linearRescale,
  gammaContrast = _deckglLayers.RasterWebGL.gammaContrast,
  sigmoidalContrast = _deckglLayers.RasterWebGL.sigmoidalContrast,
  normalizedDifference = _deckglLayers.RasterWebGL.normalizedDifference,
  enhancedVegetationIndex = _deckglLayers.RasterWebGL.enhancedVegetationIndex,
  soilAdjustedVegetationIndex = _deckglLayers.RasterWebGL.soilAdjustedVegetationIndex,
  modifiedSoilAdjustedVegetationIndex = _deckglLayers.RasterWebGL.modifiedSoilAdjustedVegetationIndex,
  colormapModule = _deckglLayers.RasterWebGL.colormap,
  filter = _deckglLayers.RasterWebGL.filter,
  saturation = _deckglLayers.RasterWebGL.saturation,
  reorderBands = _deckglLayers.RasterWebGL.reorderBands,
  rgbaImage = _deckglLayers.RasterWebGL.rgbaImage;
/**
 * Describe WebGL2 Texture parameters to use for given input data type
 */

/**
 * Convert TypedArray to WebGL2 Texture Parameters
 */
function getWebGL2TextureParameters(data) {
  if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return {
      // Note: texture data has no auto-rescaling; pixel values stay as 0-255
      format: _constants["default"].R8UI,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].UNSIGNED_BYTE
    };
  }
  if (data instanceof Uint16Array) {
    return {
      format: _constants["default"].R16UI,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].UNSIGNED_SHORT
    };
  }
  if (data instanceof Uint32Array) {
    return {
      format: _constants["default"].R32UI,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].UNSIGNED_INT
    };
  }
  if (data instanceof Int8Array) {
    return {
      format: _constants["default"].R8I,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].BYTE
    };
  }
  if (data instanceof Int16Array) {
    return {
      format: _constants["default"].R16I,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].SHORT
    };
  }
  if (data instanceof Int32Array) {
    return {
      format: _constants["default"].R32I,
      dataFormat: _constants["default"].RED_INTEGER,
      type: _constants["default"].INT
    };
  }
  if (data instanceof Float32Array) {
    return {
      format: _constants["default"].R32F,
      dataFormat: _constants["default"].RED,
      type: _constants["default"].FLOAT
    };
  }
  if (data instanceof Float64Array) {
    return {
      format: _constants["default"].R32F,
      dataFormat: _constants["default"].RED,
      type: _constants["default"].FLOAT
    };
  }

  // For exhaustive check above; following should never occur
  // https://stackoverflow.com/a/58009992
  var unexpectedInput = data;
  throw new Error(unexpectedInput);
}

/**
 * Discrete-valued colormaps (e.g. from the output of
 * classification algorithms) in the raster layer. Previously, the values passed to
 * `TEXTURE_MIN_FILTER` and `TEXTURE_MAG_FILTER` were `GL.LINEAR`, which meant that the GPU would
 * linearly interpolate values between two neighboring colormap pixel values. Setting these values
 * to NEAREST means that the GPU will choose the nearest value on the texture2D lookup operation,
 * which fixes precision issues for discrete-valued colormaps. This should be ok for continuous
 * colormaps as long as the color difference between each pixel on the colormap is small.
 */
var COLORMAP_TEXTURE_PARAMETERS = exports.COLORMAP_TEXTURE_PARAMETERS = (0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])({}, _constants["default"].TEXTURE_MIN_FILTER, _constants["default"].NEAREST), _constants["default"].TEXTURE_MAG_FILTER, _constants["default"].NEAREST), _constants["default"].TEXTURE_WRAP_S, _constants["default"].CLAMP_TO_EDGE), _constants["default"].TEXTURE_WRAP_T, _constants["default"].CLAMP_TO_EDGE);
var DEFAULT_8BIT_TEXTURE_PARAMETERS = (0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])({}, _constants["default"].TEXTURE_MIN_FILTER, _constants["default"].LINEAR_MIPMAP_LINEAR), _constants["default"].TEXTURE_MAG_FILTER, _constants["default"].LINEAR), _constants["default"].TEXTURE_WRAP_S, _constants["default"].CLAMP_TO_EDGE), _constants["default"].TEXTURE_WRAP_T, _constants["default"].CLAMP_TO_EDGE);
var DEFAULT_HIGH_BIT_TEXTURE_PARAMETERS = (0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])({}, _constants["default"].TEXTURE_MIN_FILTER, _constants["default"].NEAREST), _constants["default"].TEXTURE_MAG_FILTER, _constants["default"].NEAREST), _constants["default"].TEXTURE_WRAP_S, _constants["default"].CLAMP_TO_EDGE), _constants["default"].TEXTURE_WRAP_T, _constants["default"].CLAMP_TO_EDGE);

/**
 * Select correct module type for "combineBands"
 *
 * combineBands joins up to four 2D arrays (contained in imageBands) into a single "rgba" image
 * texture on the GPU. That shader code needs to have the same data type as the actual image data.
 * E.g. for float data the texture needs to be `sampler2D`, for uint data the texture needs to be
 * `usampler2D` and for int data the texture needs to be `isampler2D`.
 */
function getCombineBandsModule(imageBands) {
  // Each image array is expected/required to be of the same data type
  switch (imageBands[0].format) {
    case _constants["default"].R8UI:
      return combineBandsUint;
    case _constants["default"].R16UI:
      return combineBandsUint;
    case _constants["default"].R32UI:
      return combineBandsUint;
    case _constants["default"].R8I:
      return combineBandsInt;
    case _constants["default"].R16I:
      return combineBandsInt;
    case _constants["default"].R32I:
      return combineBandsInt;
    case _constants["default"].R32F:
      return combineBandsFloat;
    default:
      throw new Error('bad format');
  }
}

/** Select correct image masking shader module for mask data type
 * The imageMask could (at least in the future, theoretically) be of a different data format than
 * the imageBands data itself.
 */
function getImageMaskModule(imageMask) {
  switch (imageMask.format) {
    case _constants["default"].R8UI:
      return maskUint;
    case _constants["default"].R16UI:
      return maskUint;
    case _constants["default"].R32UI:
      return maskUint;
    case _constants["default"].R8I:
      return maskInt;
    case _constants["default"].R16I:
      return maskInt;
    case _constants["default"].R32I:
      return maskInt;
    case _constants["default"].R32F:
      return maskFloat;
    default:
      throw new Error('bad format');
  }
}

/**
 * Load image and wrap with default WebGL texture parameters
 *
 * @param url URL to load image
 * @param textureParams parameters to pass to Texture2D
 *
 * @return image object to pass to Texture2D constructor
 */
function loadImage(_x) {
  return _loadImage.apply(this, arguments);
}
function _loadImage() {
  _loadImage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
    var textureParams,
      requestOptions,
      response,
      image,
      _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          textureParams = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          requestOptions = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
          _context.next = 4;
          return (0, _core.fetchFile)(url, requestOptions);
        case 4:
          response = _context.sent;
          _context.next = 7;
          return (0, _core.parse)(response, _images.ImageLoader);
        case 7:
          image = _context.sent;
          return _context.abrupt("return", _objectSpread({
            data: image,
            parameters: DEFAULT_8BIT_TEXTURE_PARAMETERS,
            format: _constants["default"].RGB
          }, textureParams));
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _loadImage.apply(this, arguments);
}
/**
 * Load NPY Array
 *
 * The NPY format is described here: https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html.
 * It's designed to be a very simple file format to hold an N-dimensional block of data. The header describes the data type, shape, and order (either C or Fortran) of the array.
 *
 * @param url URL to load NPY Array
 * @param split Whether to split single typed array representing an N-dimensional array into an Array with each dimension as its own typed array
 *
 * @return image object to pass to Texture2D constructor
 */
function loadNpyArray(_x2, _x3, _x4) {
  return _loadNpyArray.apply(this, arguments);
}
/**
 * Create texture data for categorical colormap scale
 * @param categoricalOptions - color map configuration and min-max values of categorical band
 * @returns texture data
 */
function _loadNpyArray() {
  _loadNpyArray = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(request, split, options) {
    var numAttempts, asset;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          numAttempts = 1 + (0, _utils.getApplicationConfig)().rasterServerMaxRetries;
          _context3.next = 3;
          return (0, _requestThrottle.getRequestThrottle)().throttleRequest(request.rasterServerUrl, /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
            var attempt, _request$options$sign, _getLoaderOptions, npyOptions, response, data, header, shape, _getWebGL2TexturePara, format, dataFormat, type, _shape, z, height, width, mipmaps, parameters, channels, channelSize, i, _getApplicationConfig, _error$response;
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  attempt = 0;
                case 1:
                  if (!(attempt < numAttempts)) {
                    _context2.next = 33;
                    break;
                  }
                  _context2.prev = 2;
                  _getLoaderOptions = (0, _constants2.getLoaderOptions)(), npyOptions = _getLoaderOptions.npy;
                  _context2.next = 6;
                  return (0, _core.load)(request.url, _textures.NPYLoader, {
                    npy: npyOptions,
                    fetch: options === null || options === void 0 ? void 0 : options.fetch
                  });
                case 6:
                  response = _context2.sent;
                  if (!(!response || !response.data || (_request$options$sign = request.options.signal) !== null && _request$options$sign !== void 0 && _request$options$sign.aborted)) {
                    _context2.next = 9;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 9:
                  // Float64 data needs to be coerced to Float32 for the GPU
                  if (response.data instanceof Float64Array) {
                    response.data = Float32Array.from(response.data);
                  }
                  data = response.data, header = response.header;
                  shape = header.shape;
                  _getWebGL2TexturePara = getWebGL2TextureParameters(data), format = _getWebGL2TexturePara.format, dataFormat = _getWebGL2TexturePara.dataFormat, type = _getWebGL2TexturePara.type; // TODO: check height-width or width-height
                  // Regardless, images usually square
                  // TODO: handle cases of 256x256x1 instead of 1x256x256
                  _shape = (0, _slicedToArray2["default"])(shape, 3), z = _shape[0], height = _shape[1], width = _shape[2]; // Since we now use WebGL2 data types for 8-bit textures, we set the following for all textures
                  mipmaps = false;
                  parameters = DEFAULT_HIGH_BIT_TEXTURE_PARAMETERS;
                  if (split) {
                    _context2.next = 18;
                    break;
                  }
                  return _context2.abrupt("return", {
                    data: data,
                    width: width,
                    height: height,
                    format: format,
                    dataFormat: dataFormat,
                    type: type,
                    parameters: parameters,
                    mipmaps: mipmaps
                  });
                case 18:
                  // Split into individual arrays
                  channels = [];
                  channelSize = height * width;
                  for (i = 0; i < z; i++) {
                    channels.push({
                      data: data.subarray(i * channelSize, (i + 1) * channelSize),
                      width: width,
                      height: height,
                      format: format,
                      dataFormat: dataFormat,
                      type: type,
                      parameters: parameters,
                      mipmaps: mipmaps
                    });
                  }
                  return _context2.abrupt("return", channels);
                case 24:
                  _context2.prev = 24;
                  _context2.t0 = _context2["catch"](2);
                  if (!(attempt < numAttempts && _context2.t0 instanceof _core.FetchError && (_getApplicationConfig = (0, _utils.getApplicationConfig)().rasterServerServerErrorsToRetry) !== null && _getApplicationConfig !== void 0 && _getApplicationConfig.includes((_error$response = _context2.t0.response) === null || _error$response === void 0 ? void 0 : _error$response.status))) {
                    _context2.next = 30;
                    break;
                  }
                  _context2.next = 29;
                  return (0, _commonUtils.sleep)((0, _utils.getApplicationConfig)().rasterServerRetryDelay);
                case 29:
                  return _context2.abrupt("continue", 30);
                case 30:
                  attempt++;
                  _context2.next = 1;
                  break;
                case 33:
                  return _context2.abrupt("return", null);
                case 34:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, null, [[2, 24]]);
          })));
        case 3:
          asset = _context3.sent;
          return _context3.abrupt("return", asset);
        case 5:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _loadNpyArray.apply(this, arguments);
}
function generateCategoricalColormapTexture(categoricalOptions) {
  var data = (0, _rasterTileUtils.generateCategoricalBitmapArray)(categoricalOptions);
  return {
    data: data,
    width: _rasterTileUtils.CATEGORICAL_TEXTURE_WIDTH,
    height: 1,
    format: _constants["default"].RGBA,
    dataFormat: _constants["default"].RGBA,
    type: _constants["default"].UNSIGNED_BYTE,
    parameters: COLORMAP_TEXTURE_PARAMETERS,
    mipmaps: false
  };
}

// TODO: would probably be simpler to only pass in the props actually used by this function. That
// would mean a smaller object than RenderSubLayersProps
// eslint-disable-next-line max-statements, complexity
function getModules(_ref) {
  var images = _ref.images,
    props = _ref.props;
  var moduleProps = {};
  // Array of luma.gl WebGL modules to pass to the RasterLayer
  var modules = [];

  // use rgba image directly. Used for raster .pmtiles rendering
  if (images.imageRgba) {
    modules.push(rgbaImage);

    // no support for other modules atm for direct rgba mode
    return {
      modules: modules,
      moduleProps: moduleProps
    };
  }
  if (!props) {
    return {
      modules: modules,
      moduleProps: moduleProps
    };
  }
  var renderBandIndexes = props.renderBandIndexes,
    nonLinearRescaling = props.nonLinearRescaling,
    linearRescalingFactor = props.linearRescalingFactor,
    minPixelValue = props.minPixelValue,
    maxPixelValue = props.maxPixelValue,
    gammaContrastFactor = props.gammaContrastFactor,
    sigmoidalContrastFactor = props.sigmoidalContrastFactor,
    sigmoidalBiasFactor = props.sigmoidalBiasFactor,
    saturationValue = props.saturationValue,
    bandCombination = props.bandCombination,
    filterEnabled = props.filterEnabled,
    filterRange = props.filterRange,
    dataType = props.dataType,
    minCategoricalBandValue = props.minCategoricalBandValue,
    maxCategoricalBandValue = props.maxCategoricalBandValue,
    hasCategoricalColorMap = props.hasCategoricalColorMap;
  if (Array.isArray(images.imageBands) && images.imageBands.length > 0) {
    modules.push(getCombineBandsModule(images.imageBands));
  }
  if (images.imageMask) {
    modules.push(getImageMaskModule(images.imageMask));
    // In general, data masks are 0 for nodata and the maximum value for valid data, e.g. 255 or
    // 65535 for uint8 or uint16 data, respectively
    moduleProps.maskKeepMin = 1;
  }
  if (Array.isArray(renderBandIndexes)) {
    modules.push(reorderBands);
    moduleProps.ordering = renderBandIndexes;
  }
  var globalRange = maxPixelValue - minPixelValue;
  // Fix rescaling if we are sure that dataset is categorical
  if (hasCategoricalColorMap) {
    modules.push(linearRescale);
    moduleProps.linearRescaleScaler = 1 / maxPixelValue;
    moduleProps.linearRescaleOffset = 0;
  } else if ((0, _rasterTileUtils.isRescalingAllowed)(bandCombination)) {
    if (!nonLinearRescaling) {
      var _linearRescalingFacto = (0, _slicedToArray2["default"])(linearRescalingFactor, 2),
        min = _linearRescalingFacto[0],
        max = _linearRescalingFacto[1];
      var localRange = max - min;

      // Add linear rescaling module
      modules.push(linearRescale);

      // Divide by local range * global range
      moduleProps.linearRescaleScaler = 1 / (localRange * globalRange);

      // Subtract off the local min
      moduleProps.linearRescaleOffset = -min;

      // Clamp to [0, 1] done automatically?
    } else {
      modules.push(linearRescale);
      moduleProps.linearRescaleScaler = 1 / maxPixelValue;
      moduleProps.linearRescaleOffset = 0;
      modules.push(gammaContrast);
      moduleProps.gammaContrastValue = gammaContrastFactor;
      modules.push(sigmoidalContrast);
      moduleProps.sigmoidalContrast = sigmoidalContrastFactor;
      moduleProps.sigmoidalBias = sigmoidalBiasFactor;
    }
    if (Number.isFinite(saturationValue) && saturationValue !== 1) {
      modules.push(saturation);
      moduleProps.saturationValue = saturationValue;
    }
  }
  switch (bandCombination) {
    case 'normalizedDifference':
      modules.push(normalizedDifference);
      break;
    case 'enhancedVegetationIndex':
      modules.push(enhancedVegetationIndex);
      break;
    case 'soilAdjustedVegetationIndex':
      modules.push(soilAdjustedVegetationIndex);
      break;
    case 'modifiedSoilAdjustedVegetationIndex':
      modules.push(modifiedSoilAdjustedVegetationIndex);
      break;
    default:
      break;
  }
  if ((0, _rasterTileUtils.isFilterAllowed)(bandCombination) && filterEnabled) {
    modules.push(filter);
    moduleProps.filterMin1 = filterRange[0];
    moduleProps.filterMax1 = filterRange[1];
  }

  // Apply colormap
  if ((0, _rasterTileUtils.isColormapAllowed)(bandCombination) && images.imageColormap) {
    modules.push(colormapModule);
    moduleProps.minCategoricalBandValue = minCategoricalBandValue;
    moduleProps.maxCategoricalBandValue = maxCategoricalBandValue;
    moduleProps.dataTypeMaxValue = _rasterTileUtils.dtypeMaxValue[dataType];
    moduleProps.maxPixelValue = maxPixelValue;
  }
  return {
    modules: modules,
    moduleProps: moduleProps
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY29yZSIsInJlcXVpcmUiLCJfaW1hZ2VzIiwiX3RleHR1cmVzIiwiX2NvbnN0YW50cyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfY29tbW9uVXRpbHMiLCJfY29uc3RhbnRzMiIsIl9kZWNrZ2xMYXllcnMiLCJfdXRpbHMiLCJfcmFzdGVyVGlsZVV0aWxzIiwiX3JlcXVlc3RUaHJvdHRsZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiY29tYmluZUJhbmRzRmxvYXQiLCJSYXN0ZXJXZWJHTCIsImNvbWJpbmVCYW5kc0ludCIsImNvbWJpbmVCYW5kc1VpbnQiLCJtYXNrRmxvYXQiLCJtYXNrSW50IiwibWFza1VpbnQiLCJsaW5lYXJSZXNjYWxlIiwiZ2FtbWFDb250cmFzdCIsInNpZ21vaWRhbENvbnRyYXN0Iiwibm9ybWFsaXplZERpZmZlcmVuY2UiLCJlbmhhbmNlZFZlZ2V0YXRpb25JbmRleCIsInNvaWxBZGp1c3RlZFZlZ2V0YXRpb25JbmRleCIsIm1vZGlmaWVkU29pbEFkanVzdGVkVmVnZXRhdGlvbkluZGV4IiwiY29sb3JtYXBNb2R1bGUiLCJjb2xvcm1hcCIsInNhdHVyYXRpb24iLCJyZW9yZGVyQmFuZHMiLCJyZ2JhSW1hZ2UiLCJnZXRXZWJHTDJUZXh0dXJlUGFyYW1ldGVycyIsImRhdGEiLCJVaW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJmb3JtYXQiLCJHTCIsIlI4VUkiLCJkYXRhRm9ybWF0IiwiUkVEX0lOVEVHRVIiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsIlVpbnQxNkFycmF5IiwiUjE2VUkiLCJVTlNJR05FRF9TSE9SVCIsIlVpbnQzMkFycmF5IiwiUjMyVUkiLCJVTlNJR05FRF9JTlQiLCJJbnQ4QXJyYXkiLCJSOEkiLCJCWVRFIiwiSW50MTZBcnJheSIsIlIxNkkiLCJTSE9SVCIsIkludDMyQXJyYXkiLCJSMzJJIiwiSU5UIiwiRmxvYXQzMkFycmF5IiwiUjMyRiIsIlJFRCIsIkZMT0FUIiwiRmxvYXQ2NEFycmF5IiwidW5leHBlY3RlZElucHV0IiwiRXJyb3IiLCJDT0xPUk1BUF9URVhUVVJFX1BBUkFNRVRFUlMiLCJleHBvcnRzIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwiREVGQVVMVF84QklUX1RFWFRVUkVfUEFSQU1FVEVSUyIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiTElORUFSIiwiREVGQVVMVF9ISUdIX0JJVF9URVhUVVJFX1BBUkFNRVRFUlMiLCJnZXRDb21iaW5lQmFuZHNNb2R1bGUiLCJpbWFnZUJhbmRzIiwiZ2V0SW1hZ2VNYXNrTW9kdWxlIiwiaW1hZ2VNYXNrIiwibG9hZEltYWdlIiwiX3giLCJfbG9hZEltYWdlIiwiX2FzeW5jVG9HZW5lcmF0b3IyIiwiX3JlZ2VuZXJhdG9yIiwibWFyayIsIl9jYWxsZWUiLCJ1cmwiLCJ0ZXh0dXJlUGFyYW1zIiwicmVxdWVzdE9wdGlvbnMiLCJyZXNwb25zZSIsImltYWdlIiwiX2FyZ3MiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwidW5kZWZpbmVkIiwiZmV0Y2hGaWxlIiwic2VudCIsInBhcnNlIiwiSW1hZ2VMb2FkZXIiLCJhYnJ1cHQiLCJwYXJhbWV0ZXJzIiwiUkdCIiwic3RvcCIsImxvYWROcHlBcnJheSIsIl94MiIsIl94MyIsIl94NCIsIl9sb2FkTnB5QXJyYXkiLCJfY2FsbGVlMyIsInJlcXVlc3QiLCJzcGxpdCIsIm9wdGlvbnMiLCJudW1BdHRlbXB0cyIsImFzc2V0IiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiZ2V0QXBwbGljYXRpb25Db25maWciLCJyYXN0ZXJTZXJ2ZXJNYXhSZXRyaWVzIiwiZ2V0UmVxdWVzdFRocm90dGxlIiwidGhyb3R0bGVSZXF1ZXN0IiwicmFzdGVyU2VydmVyVXJsIiwiX2NhbGxlZTIiLCJhdHRlbXB0IiwiX3JlcXVlc3Qkb3B0aW9ucyRzaWduIiwiX2dldExvYWRlck9wdGlvbnMiLCJucHlPcHRpb25zIiwiaGVhZGVyIiwic2hhcGUiLCJfZ2V0V2ViR0wyVGV4dHVyZVBhcmEiLCJfc2hhcGUiLCJ6IiwiaGVpZ2h0Iiwid2lkdGgiLCJtaXBtYXBzIiwiY2hhbm5lbHMiLCJjaGFubmVsU2l6ZSIsImkiLCJfZ2V0QXBwbGljYXRpb25Db25maWciLCJfZXJyb3IkcmVzcG9uc2UiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJnZXRMb2FkZXJPcHRpb25zIiwibnB5IiwibG9hZCIsIk5QWUxvYWRlciIsImZldGNoIiwic2lnbmFsIiwiYWJvcnRlZCIsImZyb20iLCJfc2xpY2VkVG9BcnJheTIiLCJzdWJhcnJheSIsInQwIiwiRmV0Y2hFcnJvciIsInJhc3RlclNlcnZlclNlcnZlckVycm9yc1RvUmV0cnkiLCJpbmNsdWRlcyIsInN0YXR1cyIsInNsZWVwIiwicmFzdGVyU2VydmVyUmV0cnlEZWxheSIsImdlbmVyYXRlQ2F0ZWdvcmljYWxDb2xvcm1hcFRleHR1cmUiLCJjYXRlZ29yaWNhbE9wdGlvbnMiLCJnZW5lcmF0ZUNhdGVnb3JpY2FsQml0bWFwQXJyYXkiLCJDQVRFR09SSUNBTF9URVhUVVJFX1dJRFRIIiwiUkdCQSIsImdldE1vZHVsZXMiLCJfcmVmIiwiaW1hZ2VzIiwicHJvcHMiLCJtb2R1bGVQcm9wcyIsIm1vZHVsZXMiLCJpbWFnZVJnYmEiLCJyZW5kZXJCYW5kSW5kZXhlcyIsIm5vbkxpbmVhclJlc2NhbGluZyIsImxpbmVhclJlc2NhbGluZ0ZhY3RvciIsIm1pblBpeGVsVmFsdWUiLCJtYXhQaXhlbFZhbHVlIiwiZ2FtbWFDb250cmFzdEZhY3RvciIsInNpZ21vaWRhbENvbnRyYXN0RmFjdG9yIiwic2lnbW9pZGFsQmlhc0ZhY3RvciIsInNhdHVyYXRpb25WYWx1ZSIsImJhbmRDb21iaW5hdGlvbiIsImZpbHRlckVuYWJsZWQiLCJmaWx0ZXJSYW5nZSIsImRhdGFUeXBlIiwibWluQ2F0ZWdvcmljYWxCYW5kVmFsdWUiLCJtYXhDYXRlZ29yaWNhbEJhbmRWYWx1ZSIsImhhc0NhdGVnb3JpY2FsQ29sb3JNYXAiLCJBcnJheSIsImlzQXJyYXkiLCJtYXNrS2VlcE1pbiIsIm9yZGVyaW5nIiwiZ2xvYmFsUmFuZ2UiLCJsaW5lYXJSZXNjYWxlU2NhbGVyIiwibGluZWFyUmVzY2FsZU9mZnNldCIsImlzUmVzY2FsaW5nQWxsb3dlZCIsIl9saW5lYXJSZXNjYWxpbmdGYWN0byIsIm1pbiIsIm1heCIsImxvY2FsUmFuZ2UiLCJnYW1tYUNvbnRyYXN0VmFsdWUiLCJzaWdtb2lkYWxCaWFzIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ZpbHRlckFsbG93ZWQiLCJmaWx0ZXJNaW4xIiwiZmlsdGVyTWF4MSIsImlzQ29sb3JtYXBBbGxvd2VkIiwiaW1hZ2VDb2xvcm1hcCIsImRhdGFUeXBlTWF4VmFsdWUiLCJkdHlwZU1heFZhbHVlIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Jhc3Rlci10aWxlL2dwdS11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG4vKipcbiAqIEZ1bmN0aW9ucyBhbmQgY29uc3RhbnRzIGZvciBoYW5kbGluZyB3ZWJnbC9sdW1hLmdsL2RlY2suZ2wgZW50aXRpZXNcbiAqL1xuXG5pbXBvcnQge3BhcnNlLCBmZXRjaEZpbGUsIGxvYWQsIEZldGNoRXJyb3J9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnO1xuaW1wb3J0IHtJbWFnZUxvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvaW1hZ2VzJztcbmltcG9ydCB7TlBZTG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC90ZXh0dXJlcyc7XG5pbXBvcnQgR0wgZnJvbSAnQGx1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7VGV4dHVyZTJEUHJvcHN9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcblxuaW1wb3J0IHtzbGVlcH0gZnJvbSAnQGtlcGxlci5nbC9jb21tb24tdXRpbHMnO1xuaW1wb3J0IHtnZXRMb2FkZXJPcHRpb25zfSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1Jhc3RlcldlYkdMfSBmcm9tICdAa2VwbGVyLmdsL2RlY2tnbC1sYXllcnMnO1xuaW1wb3J0IHtnZXRBcHBsaWNhdGlvbkNvbmZpZ30gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5cbnR5cGUgU2hhZGVyTW9kdWxlID0gUmFzdGVyV2ViR0wuU2hhZGVyTW9kdWxlO1xuY29uc3Qge1xuICBjb21iaW5lQmFuZHNGbG9hdCxcbiAgY29tYmluZUJhbmRzSW50LFxuICBjb21iaW5lQmFuZHNVaW50LFxuICBtYXNrRmxvYXQsXG4gIG1hc2tJbnQsXG4gIG1hc2tVaW50LFxuICBsaW5lYXJSZXNjYWxlLFxuICBnYW1tYUNvbnRyYXN0LFxuICBzaWdtb2lkYWxDb250cmFzdCxcbiAgbm9ybWFsaXplZERpZmZlcmVuY2UsXG4gIGVuaGFuY2VkVmVnZXRhdGlvbkluZGV4LFxuICBzb2lsQWRqdXN0ZWRWZWdldGF0aW9uSW5kZXgsXG4gIG1vZGlmaWVkU29pbEFkanVzdGVkVmVnZXRhdGlvbkluZGV4LFxuICBjb2xvcm1hcDogY29sb3JtYXBNb2R1bGUsXG4gIGZpbHRlcixcbiAgc2F0dXJhdGlvbixcbiAgcmVvcmRlckJhbmRzLFxuICByZ2JhSW1hZ2Vcbn0gPSBSYXN0ZXJXZWJHTDtcblxuaW1wb3J0IHtcbiAgQ0FURUdPUklDQUxfVEVYVFVSRV9XSURUSCxcbiAgZHR5cGVNYXhWYWx1ZSxcbiAgZ2VuZXJhdGVDYXRlZ29yaWNhbEJpdG1hcEFycmF5LFxuICBpc0NvbG9ybWFwQWxsb3dlZCxcbiAgaXNGaWx0ZXJBbGxvd2VkLFxuICBpc1Jlc2NhbGluZ0FsbG93ZWRcbn0gZnJvbSAnLi9yYXN0ZXItdGlsZS11dGlscyc7XG5pbXBvcnQge1xuICBDYXRlZ29yaWNhbENvbG9ybWFwT3B0aW9ucyxcbiAgSW1hZ2VEYXRhLFxuICBOUFlMb2FkZXJEYXRhVHlwZXMsXG4gIE5QWUxvYWRlclJlc3BvbnNlLFxuICBSZW5kZXJTdWJMYXllcnNQcm9wc1xufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7Z2V0UmVxdWVzdFRocm90dGxlfSBmcm9tICcuL3JlcXVlc3QtdGhyb3R0bGUnO1xuXG4vKipcbiAqIERlc2NyaWJlIFdlYkdMMiBUZXh0dXJlIHBhcmFtZXRlcnMgdG8gdXNlIGZvciBnaXZlbiBpbnB1dCBkYXRhIHR5cGVcbiAqL1xuaW50ZXJmYWNlIFdlYkdMVGV4dHVyZUZvcm1hdCB7XG4gIGZvcm1hdDogbnVtYmVyO1xuICBkYXRhRm9ybWF0OiBudW1iZXI7XG4gIHR5cGU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IFR5cGVkQXJyYXkgdG8gV2ViR0wyIFRleHR1cmUgUGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBnZXRXZWJHTDJUZXh0dXJlUGFyYW1ldGVycyhkYXRhOiBOUFlMb2FkZXJEYXRhVHlwZXMpOiBXZWJHTFRleHR1cmVGb3JtYXQgfCBuZXZlciB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gTm90ZTogdGV4dHVyZSBkYXRhIGhhcyBubyBhdXRvLXJlc2NhbGluZzsgcGl4ZWwgdmFsdWVzIHN0YXkgYXMgMC0yNTVcbiAgICAgIGZvcm1hdDogR0wuUjhVSSxcbiAgICAgIGRhdGFGb3JtYXQ6IEdMLlJFRF9JTlRFR0VSLFxuICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogR0wuUjE2VUksXG4gICAgICBkYXRhRm9ybWF0OiBHTC5SRURfSU5URUdFUixcbiAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX1NIT1JUXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBHTC5SMzJVSSxcbiAgICAgIGRhdGFGb3JtYXQ6IEdMLlJFRF9JTlRFR0VSLFxuICAgICAgdHlwZTogR0wuVU5TSUdORURfSU5UXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogR0wuUjhJLFxuICAgICAgZGF0YUZvcm1hdDogR0wuUkVEX0lOVEVHRVIsXG4gICAgICB0eXBlOiBHTC5CWVRFXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IEdMLlIxNkksXG4gICAgICBkYXRhRm9ybWF0OiBHTC5SRURfSU5URUdFUixcbiAgICAgIHR5cGU6IEdMLlNIT1JUXG4gICAgfTtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBHTC5SMzJJLFxuICAgICAgZGF0YUZvcm1hdDogR0wuUkVEX0lOVEVHRVIsXG4gICAgICB0eXBlOiBHTC5JTlRcbiAgICB9O1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogR0wuUjMyRixcbiAgICAgIGRhdGFGb3JtYXQ6IEdMLlJFRCxcbiAgICAgIHR5cGU6IEdMLkZMT0FUXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogR0wuUjMyRixcbiAgICAgIGRhdGFGb3JtYXQ6IEdMLlJFRCxcbiAgICAgIHR5cGU6IEdMLkZMT0FUXG4gICAgfTtcbiAgfVxuXG4gIC8vIEZvciBleGhhdXN0aXZlIGNoZWNrIGFib3ZlOyBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIG9jY3VyXG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81ODAwOTk5MlxuICBjb25zdCB1bmV4cGVjdGVkSW5wdXQ6IG5ldmVyID0gZGF0YTtcbiAgdGhyb3cgbmV3IEVycm9yKHVuZXhwZWN0ZWRJbnB1dCk7XG59XG5cbi8qKlxuICogRGlzY3JldGUtdmFsdWVkIGNvbG9ybWFwcyAoZS5nLiBmcm9tIHRoZSBvdXRwdXQgb2ZcbiAqIGNsYXNzaWZpY2F0aW9uIGFsZ29yaXRobXMpIGluIHRoZSByYXN0ZXIgbGF5ZXIuIFByZXZpb3VzbHksIHRoZSB2YWx1ZXMgcGFzc2VkIHRvXG4gKiBgVEVYVFVSRV9NSU5fRklMVEVSYCBhbmQgYFRFWFRVUkVfTUFHX0ZJTFRFUmAgd2VyZSBgR0wuTElORUFSYCwgd2hpY2ggbWVhbnQgdGhhdCB0aGUgR1BVIHdvdWxkXG4gKiBsaW5lYXJseSBpbnRlcnBvbGF0ZSB2YWx1ZXMgYmV0d2VlbiB0d28gbmVpZ2hib3JpbmcgY29sb3JtYXAgcGl4ZWwgdmFsdWVzLiBTZXR0aW5nIHRoZXNlIHZhbHVlc1xuICogdG8gTkVBUkVTVCBtZWFucyB0aGF0IHRoZSBHUFUgd2lsbCBjaG9vc2UgdGhlIG5lYXJlc3QgdmFsdWUgb24gdGhlIHRleHR1cmUyRCBsb29rdXAgb3BlcmF0aW9uLFxuICogd2hpY2ggZml4ZXMgcHJlY2lzaW9uIGlzc3VlcyBmb3IgZGlzY3JldGUtdmFsdWVkIGNvbG9ybWFwcy4gVGhpcyBzaG91bGQgYmUgb2sgZm9yIGNvbnRpbnVvdXNcbiAqIGNvbG9ybWFwcyBhcyBsb25nIGFzIHRoZSBjb2xvciBkaWZmZXJlbmNlIGJldHdlZW4gZWFjaCBwaXhlbCBvbiB0aGUgY29sb3JtYXAgaXMgc21hbGwuXG4gKi9cbmV4cG9ydCBjb25zdCBDT0xPUk1BUF9URVhUVVJFX1BBUkFNRVRFUlMgPSB7XG4gIFtHTC5URVhUVVJFX01JTl9GSUxURVJdOiBHTC5ORUFSRVNULFxuICBbR0wuVEVYVFVSRV9NQUdfRklMVEVSXTogR0wuTkVBUkVTVCxcbiAgW0dMLlRFWFRVUkVfV1JBUF9TXTogR0wuQ0xBTVBfVE9fRURHRSxcbiAgW0dMLlRFWFRVUkVfV1JBUF9UXTogR0wuQ0xBTVBfVE9fRURHRVxufTtcblxuY29uc3QgREVGQVVMVF84QklUX1RFWFRVUkVfUEFSQU1FVEVSUyA9IHtcbiAgW0dMLlRFWFRVUkVfTUlOX0ZJTFRFUl06IEdMLkxJTkVBUl9NSVBNQVBfTElORUFSLFxuICBbR0wuVEVYVFVSRV9NQUdfRklMVEVSXTogR0wuTElORUFSLFxuICBbR0wuVEVYVFVSRV9XUkFQX1NdOiBHTC5DTEFNUF9UT19FREdFLFxuICBbR0wuVEVYVFVSRV9XUkFQX1RdOiBHTC5DTEFNUF9UT19FREdFXG59O1xuXG5jb25zdCBERUZBVUxUX0hJR0hfQklUX1RFWFRVUkVfUEFSQU1FVEVSUyA9IHtcbiAgW0dMLlRFWFRVUkVfTUlOX0ZJTFRFUl06IEdMLk5FQVJFU1QsXG4gIFtHTC5URVhUVVJFX01BR19GSUxURVJdOiBHTC5ORUFSRVNULFxuICBbR0wuVEVYVFVSRV9XUkFQX1NdOiBHTC5DTEFNUF9UT19FREdFLFxuICBbR0wuVEVYVFVSRV9XUkFQX1RdOiBHTC5DTEFNUF9UT19FREdFXG59O1xuXG4vKipcbiAqIFNlbGVjdCBjb3JyZWN0IG1vZHVsZSB0eXBlIGZvciBcImNvbWJpbmVCYW5kc1wiXG4gKlxuICogY29tYmluZUJhbmRzIGpvaW5zIHVwIHRvIGZvdXIgMkQgYXJyYXlzIChjb250YWluZWQgaW4gaW1hZ2VCYW5kcykgaW50byBhIHNpbmdsZSBcInJnYmFcIiBpbWFnZVxuICogdGV4dHVyZSBvbiB0aGUgR1BVLiBUaGF0IHNoYWRlciBjb2RlIG5lZWRzIHRvIGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBhY3R1YWwgaW1hZ2UgZGF0YS5cbiAqIEUuZy4gZm9yIGZsb2F0IGRhdGEgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgYHNhbXBsZXIyRGAsIGZvciB1aW50IGRhdGEgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmVcbiAqIGB1c2FtcGxlcjJEYCBhbmQgZm9yIGludCBkYXRhIHRoZSB0ZXh0dXJlIG5lZWRzIHRvIGJlIGBpc2FtcGxlcjJEYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbWJpbmVCYW5kc01vZHVsZShpbWFnZUJhbmRzOiBUZXh0dXJlMkRQcm9wc1tdKTogU2hhZGVyTW9kdWxlIHtcbiAgLy8gRWFjaCBpbWFnZSBhcnJheSBpcyBleHBlY3RlZC9yZXF1aXJlZCB0byBiZSBvZiB0aGUgc2FtZSBkYXRhIHR5cGVcbiAgc3dpdGNoIChpbWFnZUJhbmRzWzBdLmZvcm1hdCkge1xuICAgIGNhc2UgR0wuUjhVSTpcbiAgICAgIHJldHVybiBjb21iaW5lQmFuZHNVaW50O1xuICAgIGNhc2UgR0wuUjE2VUk6XG4gICAgICByZXR1cm4gY29tYmluZUJhbmRzVWludDtcbiAgICBjYXNlIEdMLlIzMlVJOlxuICAgICAgcmV0dXJuIGNvbWJpbmVCYW5kc1VpbnQ7XG4gICAgY2FzZSBHTC5SOEk6XG4gICAgICByZXR1cm4gY29tYmluZUJhbmRzSW50O1xuICAgIGNhc2UgR0wuUjE2STpcbiAgICAgIHJldHVybiBjb21iaW5lQmFuZHNJbnQ7XG4gICAgY2FzZSBHTC5SMzJJOlxuICAgICAgcmV0dXJuIGNvbWJpbmVCYW5kc0ludDtcbiAgICBjYXNlIEdMLlIzMkY6XG4gICAgICByZXR1cm4gY29tYmluZUJhbmRzRmxvYXQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGZvcm1hdCcpO1xuICB9XG59XG5cbi8qKiBTZWxlY3QgY29ycmVjdCBpbWFnZSBtYXNraW5nIHNoYWRlciBtb2R1bGUgZm9yIG1hc2sgZGF0YSB0eXBlXG4gKiBUaGUgaW1hZ2VNYXNrIGNvdWxkIChhdCBsZWFzdCBpbiB0aGUgZnV0dXJlLCB0aGVvcmV0aWNhbGx5KSBiZSBvZiBhIGRpZmZlcmVudCBkYXRhIGZvcm1hdCB0aGFuXG4gKiB0aGUgaW1hZ2VCYW5kcyBkYXRhIGl0c2VsZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltYWdlTWFza01vZHVsZShpbWFnZU1hc2s6IFRleHR1cmUyRFByb3BzKTogU2hhZGVyTW9kdWxlIHtcbiAgc3dpdGNoIChpbWFnZU1hc2suZm9ybWF0KSB7XG4gICAgY2FzZSBHTC5SOFVJOlxuICAgICAgcmV0dXJuIG1hc2tVaW50O1xuICAgIGNhc2UgR0wuUjE2VUk6XG4gICAgICByZXR1cm4gbWFza1VpbnQ7XG4gICAgY2FzZSBHTC5SMzJVSTpcbiAgICAgIHJldHVybiBtYXNrVWludDtcbiAgICBjYXNlIEdMLlI4STpcbiAgICAgIHJldHVybiBtYXNrSW50O1xuICAgIGNhc2UgR0wuUjE2STpcbiAgICAgIHJldHVybiBtYXNrSW50O1xuICAgIGNhc2UgR0wuUjMySTpcbiAgICAgIHJldHVybiBtYXNrSW50O1xuICAgIGNhc2UgR0wuUjMyRjpcbiAgICAgIHJldHVybiBtYXNrRmxvYXQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGZvcm1hdCcpO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBpbWFnZSBhbmQgd3JhcCB3aXRoIGRlZmF1bHQgV2ViR0wgdGV4dHVyZSBwYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHVybCBVUkwgdG8gbG9hZCBpbWFnZVxuICogQHBhcmFtIHRleHR1cmVQYXJhbXMgcGFyYW1ldGVycyB0byBwYXNzIHRvIFRleHR1cmUyRFxuICpcbiAqIEByZXR1cm4gaW1hZ2Ugb2JqZWN0IHRvIHBhc3MgdG8gVGV4dHVyZTJEIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2UoXG4gIHVybDogc3RyaW5nLFxuICB0ZXh0dXJlUGFyYW1zOiBUZXh0dXJlMkRQcm9wcyA9IHt9LFxuICByZXF1ZXN0T3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxuKTogUHJvbWlzZTxUZXh0dXJlMkRQcm9wcz4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoRmlsZSh1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBwYXJzZShyZXNwb25zZSwgSW1hZ2VMb2FkZXIpO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YTogaW1hZ2UsXG4gICAgcGFyYW1ldGVyczogREVGQVVMVF84QklUX1RFWFRVUkVfUEFSQU1FVEVSUyxcbiAgICBmb3JtYXQ6IEdMLlJHQixcbiAgICAuLi50ZXh0dXJlUGFyYW1zXG4gIH07XG59XG5cbnR5cGUgRmV0Y2hMaWtlID0gKHVybDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdEluaXQpID0+IFByb21pc2U8UmVzcG9uc2U+O1xudHlwZSBMb2FkaW5nT3B0aW9ucyA9IHtcbiAgZmV0Y2g/OiB0eXBlb2YgZmV0Y2ggfCBGZXRjaExpa2U7XG59O1xuXG4vKipcbiAqIExvYWQgTlBZIEFycmF5XG4gKlxuICogVGhlIE5QWSBmb3JtYXQgaXMgZGVzY3JpYmVkIGhlcmU6IGh0dHBzOi8vbnVtcHkub3JnL2RvYy9zdGFibGUvcmVmZXJlbmNlL2dlbmVyYXRlZC9udW1weS5saWIuZm9ybWF0Lmh0bWwuXG4gKiBJdCdzIGRlc2lnbmVkIHRvIGJlIGEgdmVyeSBzaW1wbGUgZmlsZSBmb3JtYXQgdG8gaG9sZCBhbiBOLWRpbWVuc2lvbmFsIGJsb2NrIG9mIGRhdGEuIFRoZSBoZWFkZXIgZGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUsIHNoYXBlLCBhbmQgb3JkZXIgKGVpdGhlciBDIG9yIEZvcnRyYW4pIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gdXJsIFVSTCB0byBsb2FkIE5QWSBBcnJheVxuICogQHBhcmFtIHNwbGl0IFdoZXRoZXIgdG8gc3BsaXQgc2luZ2xlIHR5cGVkIGFycmF5IHJlcHJlc2VudGluZyBhbiBOLWRpbWVuc2lvbmFsIGFycmF5IGludG8gYW4gQXJyYXkgd2l0aCBlYWNoIGRpbWVuc2lvbiBhcyBpdHMgb3duIHR5cGVkIGFycmF5XG4gKlxuICogQHJldHVybiBpbWFnZSBvYmplY3QgdG8gcGFzcyB0byBUZXh0dXJlMkQgY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWROcHlBcnJheShcbiAgcmVxdWVzdDoge3VybDogc3RyaW5nOyByYXN0ZXJTZXJ2ZXJVcmw6IHN0cmluZzsgb3B0aW9uczogUmVxdWVzdEluaXR9LFxuICBzcGxpdDogdHJ1ZSxcbiAgb3B0aW9ucz86IExvYWRpbmdPcHRpb25zXG4pOiBQcm9taXNlPFRleHR1cmUyRFByb3BzW10gfCBudWxsPjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkTnB5QXJyYXkoXG4gIHJlcXVlc3Q6IHt1cmw6IHN0cmluZzsgcmFzdGVyU2VydmVyVXJsOiBzdHJpbmc7IG9wdGlvbnM6IFJlcXVlc3RJbml0fSxcbiAgc3BsaXQ6IGZhbHNlLFxuICBvcHRpb25zPzogTG9hZGluZ09wdGlvbnNcbik6IFByb21pc2U8VGV4dHVyZTJEUHJvcHMgfCBudWxsPjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkTnB5QXJyYXkoXG4gIHJlcXVlc3Q6IHt1cmw6IHN0cmluZzsgcmFzdGVyU2VydmVyVXJsOiBzdHJpbmc7IG9wdGlvbnM6IFJlcXVlc3RJbml0fSxcbiAgc3BsaXQ6IGJvb2xlYW4sXG4gIG9wdGlvbnM/OiBMb2FkaW5nT3B0aW9uc1xuKTogUHJvbWlzZTxUZXh0dXJlMkRQcm9wcyB8IFRleHR1cmUyRFByb3BzW10gfCBudWxsPiB7XG4gIGNvbnN0IG51bUF0dGVtcHRzID0gMSArIGdldEFwcGxpY2F0aW9uQ29uZmlnKCkucmFzdGVyU2VydmVyTWF4UmV0cmllcztcblxuICBjb25zdCBhc3NldCA9IGF3YWl0IGdldFJlcXVlc3RUaHJvdHRsZSgpLnRocm90dGxlUmVxdWVzdChyZXF1ZXN0LnJhc3RlclNlcnZlclVybCwgYXN5bmMgKCkgPT4ge1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbnVtQXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge25weTogbnB5T3B0aW9uc30gPSBnZXRMb2FkZXJPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlOiBOUFlMb2FkZXJSZXNwb25zZSA9IGF3YWl0IGxvYWQocmVxdWVzdC51cmwsIE5QWUxvYWRlciwge1xuICAgICAgICAgIG5weTogbnB5T3B0aW9ucyxcbiAgICAgICAgICBmZXRjaDogb3B0aW9ucz8uZmV0Y2hcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuZGF0YSB8fCByZXF1ZXN0Lm9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbG9hdDY0IGRhdGEgbmVlZHMgdG8gYmUgY29lcmNlZCB0byBGbG9hdDMyIGZvciB0aGUgR1BVXG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IEZsb2F0MzJBcnJheS5mcm9tKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge2RhdGEsIGhlYWRlcn0gPSByZXNwb25zZTtcbiAgICAgICAgY29uc3Qge3NoYXBlfSA9IGhlYWRlcjtcbiAgICAgICAgY29uc3Qge2Zvcm1hdCwgZGF0YUZvcm1hdCwgdHlwZX0gPSBnZXRXZWJHTDJUZXh0dXJlUGFyYW1ldGVycyhkYXRhKTtcblxuICAgICAgICAvLyBUT0RPOiBjaGVjayBoZWlnaHQtd2lkdGggb3Igd2lkdGgtaGVpZ2h0XG4gICAgICAgIC8vIFJlZ2FyZGxlc3MsIGltYWdlcyB1c3VhbGx5IHNxdWFyZVxuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgY2FzZXMgb2YgMjU2eDI1NngxIGluc3RlYWQgb2YgMXgyNTZ4MjU2XG4gICAgICAgIGNvbnN0IFt6LCBoZWlnaHQsIHdpZHRoXSA9IHNoYXBlO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIG5vdyB1c2UgV2ViR0wyIGRhdGEgdHlwZXMgZm9yIDgtYml0IHRleHR1cmVzLCB3ZSBzZXQgdGhlIGZvbGxvd2luZyBmb3IgYWxsIHRleHR1cmVzXG4gICAgICAgIGNvbnN0IG1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IERFRkFVTFRfSElHSF9CSVRfVEVYVFVSRV9QQVJBTUVURVJTO1xuXG4gICAgICAgIGlmICghc3BsaXQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZGF0YUZvcm1hdCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgbWlwbWFwc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdCBpbnRvIGluZGl2aWR1YWwgYXJyYXlzXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzOiBUZXh0dXJlMkRQcm9wc1tdID0gW107XG4gICAgICAgIGNvbnN0IGNoYW5uZWxTaXplID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgejsgaSsrKSB7XG4gICAgICAgICAgY2hhbm5lbHMucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLnN1YmFycmF5KGkgKiBjaGFubmVsU2l6ZSwgKGkgKyAxKSAqIGNoYW5uZWxTaXplKSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZGF0YUZvcm1hdCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgbWlwbWFwc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFubmVscztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFJldHJ5IGlmIFNlcnZpY2UgVGVtcG9yYXJpbHkgVW5hdmFpbGFibGUgNTAzIGVycm9yIGV0Yy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGF0dGVtcHQgPCBudW1BdHRlbXB0cyAmJlxuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRmV0Y2hFcnJvciAmJlxuICAgICAgICAgIGdldEFwcGxpY2F0aW9uQ29uZmlnKCkucmFzdGVyU2VydmVyU2VydmVyRXJyb3JzVG9SZXRyeT8uaW5jbHVkZXMoXG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZT8uc3RhdHVzIGFzIG51bWJlclxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXdhaXQgc2xlZXAoZ2V0QXBwbGljYXRpb25Db25maWcoKS5yYXN0ZXJTZXJ2ZXJSZXRyeURlbGF5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG5cbiAgcmV0dXJuIGFzc2V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0ZXh0dXJlIGRhdGEgZm9yIGNhdGVnb3JpY2FsIGNvbG9ybWFwIHNjYWxlXG4gKiBAcGFyYW0gY2F0ZWdvcmljYWxPcHRpb25zIC0gY29sb3IgbWFwIGNvbmZpZ3VyYXRpb24gYW5kIG1pbi1tYXggdmFsdWVzIG9mIGNhdGVnb3JpY2FsIGJhbmRcbiAqIEByZXR1cm5zIHRleHR1cmUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDYXRlZ29yaWNhbENvbG9ybWFwVGV4dHVyZShcbiAgY2F0ZWdvcmljYWxPcHRpb25zOiBDYXRlZ29yaWNhbENvbG9ybWFwT3B0aW9uc1xuKTogVGV4dHVyZTJEUHJvcHMge1xuICBjb25zdCBkYXRhID0gZ2VuZXJhdGVDYXRlZ29yaWNhbEJpdG1hcEFycmF5KGNhdGVnb3JpY2FsT3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICB3aWR0aDogQ0FURUdPUklDQUxfVEVYVFVSRV9XSURUSCxcbiAgICBoZWlnaHQ6IDEsXG4gICAgZm9ybWF0OiBHTC5SR0JBLFxuICAgIGRhdGFGb3JtYXQ6IEdMLlJHQkEsXG4gICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICBwYXJhbWV0ZXJzOiBDT0xPUk1BUF9URVhUVVJFX1BBUkFNRVRFUlMsXG4gICAgbWlwbWFwczogZmFsc2VcbiAgfTtcbn1cblxuLy8gVE9ETzogd291bGQgcHJvYmFibHkgYmUgc2ltcGxlciB0byBvbmx5IHBhc3MgaW4gdGhlIHByb3BzIGFjdHVhbGx5IHVzZWQgYnkgdGhpcyBmdW5jdGlvbi4gVGhhdFxuLy8gd291bGQgbWVhbiBhIHNtYWxsZXIgb2JqZWN0IHRoYW4gUmVuZGVyU3ViTGF5ZXJzUHJvcHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZHVsZXMoe1xuICBpbWFnZXMsXG4gIHByb3BzXG59OiB7XG4gIGltYWdlczogUGFydGlhbDxJbWFnZURhdGE+O1xuICBwcm9wcz86IFJlbmRlclN1YkxheWVyc1Byb3BzO1xufSk6IHtcbiAgbW9kdWxlczogU2hhZGVyTW9kdWxlW107XG4gIG1vZHVsZVByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufSB7XG4gIGNvbnN0IG1vZHVsZVByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIC8vIEFycmF5IG9mIGx1bWEuZ2wgV2ViR0wgbW9kdWxlcyB0byBwYXNzIHRvIHRoZSBSYXN0ZXJMYXllclxuICBjb25zdCBtb2R1bGVzOiBTaGFkZXJNb2R1bGVbXSA9IFtdO1xuXG4gIC8vIHVzZSByZ2JhIGltYWdlIGRpcmVjdGx5LiBVc2VkIGZvciByYXN0ZXIgLnBtdGlsZXMgcmVuZGVyaW5nXG4gIGlmIChpbWFnZXMuaW1hZ2VSZ2JhKSB7XG4gICAgbW9kdWxlcy5wdXNoKHJnYmFJbWFnZSk7XG5cbiAgICAvLyBubyBzdXBwb3J0IGZvciBvdGhlciBtb2R1bGVzIGF0bSBmb3IgZGlyZWN0IHJnYmEgbW9kZVxuICAgIHJldHVybiB7bW9kdWxlcywgbW9kdWxlUHJvcHN9O1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybiB7bW9kdWxlcywgbW9kdWxlUHJvcHN9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHJlbmRlckJhbmRJbmRleGVzLFxuICAgIG5vbkxpbmVhclJlc2NhbGluZyxcbiAgICBsaW5lYXJSZXNjYWxpbmdGYWN0b3IsXG4gICAgbWluUGl4ZWxWYWx1ZSxcbiAgICBtYXhQaXhlbFZhbHVlLFxuICAgIGdhbW1hQ29udHJhc3RGYWN0b3IsXG4gICAgc2lnbW9pZGFsQ29udHJhc3RGYWN0b3IsXG4gICAgc2lnbW9pZGFsQmlhc0ZhY3RvcixcbiAgICBzYXR1cmF0aW9uVmFsdWUsXG4gICAgYmFuZENvbWJpbmF0aW9uLFxuICAgIGZpbHRlckVuYWJsZWQsXG4gICAgZmlsdGVyUmFuZ2UsXG4gICAgZGF0YVR5cGUsXG4gICAgbWluQ2F0ZWdvcmljYWxCYW5kVmFsdWUsXG4gICAgbWF4Q2F0ZWdvcmljYWxCYW5kVmFsdWUsXG4gICAgaGFzQ2F0ZWdvcmljYWxDb2xvck1hcFxuICB9ID0gcHJvcHM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaW1hZ2VzLmltYWdlQmFuZHMpICYmIGltYWdlcy5pbWFnZUJhbmRzLmxlbmd0aCA+IDApIHtcbiAgICBtb2R1bGVzLnB1c2goZ2V0Q29tYmluZUJhbmRzTW9kdWxlKGltYWdlcy5pbWFnZUJhbmRzKSk7XG4gIH1cblxuICBpZiAoaW1hZ2VzLmltYWdlTWFzaykge1xuICAgIG1vZHVsZXMucHVzaChnZXRJbWFnZU1hc2tNb2R1bGUoaW1hZ2VzLmltYWdlTWFzaykpO1xuICAgIC8vIEluIGdlbmVyYWwsIGRhdGEgbWFza3MgYXJlIDAgZm9yIG5vZGF0YSBhbmQgdGhlIG1heGltdW0gdmFsdWUgZm9yIHZhbGlkIGRhdGEsIGUuZy4gMjU1IG9yXG4gICAgLy8gNjU1MzUgZm9yIHVpbnQ4IG9yIHVpbnQxNiBkYXRhLCByZXNwZWN0aXZlbHlcbiAgICBtb2R1bGVQcm9wcy5tYXNrS2VlcE1pbiA9IDE7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShyZW5kZXJCYW5kSW5kZXhlcykpIHtcbiAgICBtb2R1bGVzLnB1c2gocmVvcmRlckJhbmRzKTtcbiAgICBtb2R1bGVQcm9wcy5vcmRlcmluZyA9IHJlbmRlckJhbmRJbmRleGVzO1xuICB9XG5cbiAgY29uc3QgZ2xvYmFsUmFuZ2UgPSBtYXhQaXhlbFZhbHVlIC0gbWluUGl4ZWxWYWx1ZTtcbiAgLy8gRml4IHJlc2NhbGluZyBpZiB3ZSBhcmUgc3VyZSB0aGF0IGRhdGFzZXQgaXMgY2F0ZWdvcmljYWxcbiAgaWYgKGhhc0NhdGVnb3JpY2FsQ29sb3JNYXApIHtcbiAgICBtb2R1bGVzLnB1c2gobGluZWFyUmVzY2FsZSk7XG4gICAgbW9kdWxlUHJvcHMubGluZWFyUmVzY2FsZVNjYWxlciA9IDEgLyBtYXhQaXhlbFZhbHVlO1xuICAgIG1vZHVsZVByb3BzLmxpbmVhclJlc2NhbGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGlzUmVzY2FsaW5nQWxsb3dlZChiYW5kQ29tYmluYXRpb24pKSB7XG4gICAgaWYgKCFub25MaW5lYXJSZXNjYWxpbmcpIHtcbiAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBsaW5lYXJSZXNjYWxpbmdGYWN0b3I7XG4gICAgICBjb25zdCBsb2NhbFJhbmdlID0gbWF4IC0gbWluO1xuXG4gICAgICAvLyBBZGQgbGluZWFyIHJlc2NhbGluZyBtb2R1bGVcbiAgICAgIG1vZHVsZXMucHVzaChsaW5lYXJSZXNjYWxlKTtcblxuICAgICAgLy8gRGl2aWRlIGJ5IGxvY2FsIHJhbmdlICogZ2xvYmFsIHJhbmdlXG4gICAgICBtb2R1bGVQcm9wcy5saW5lYXJSZXNjYWxlU2NhbGVyID0gMSAvIChsb2NhbFJhbmdlICogZ2xvYmFsUmFuZ2UpO1xuXG4gICAgICAvLyBTdWJ0cmFjdCBvZmYgdGhlIGxvY2FsIG1pblxuICAgICAgbW9kdWxlUHJvcHMubGluZWFyUmVzY2FsZU9mZnNldCA9IC1taW47XG5cbiAgICAgIC8vIENsYW1wIHRvIFswLCAxXSBkb25lIGF1dG9tYXRpY2FsbHk/XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZHVsZXMucHVzaChsaW5lYXJSZXNjYWxlKTtcbiAgICAgIG1vZHVsZVByb3BzLmxpbmVhclJlc2NhbGVTY2FsZXIgPSAxIC8gbWF4UGl4ZWxWYWx1ZTtcbiAgICAgIG1vZHVsZVByb3BzLmxpbmVhclJlc2NhbGVPZmZzZXQgPSAwO1xuXG4gICAgICBtb2R1bGVzLnB1c2goZ2FtbWFDb250cmFzdCk7XG4gICAgICBtb2R1bGVQcm9wcy5nYW1tYUNvbnRyYXN0VmFsdWUgPSBnYW1tYUNvbnRyYXN0RmFjdG9yO1xuXG4gICAgICBtb2R1bGVzLnB1c2goc2lnbW9pZGFsQ29udHJhc3QpO1xuICAgICAgbW9kdWxlUHJvcHMuc2lnbW9pZGFsQ29udHJhc3QgPSBzaWdtb2lkYWxDb250cmFzdEZhY3RvcjtcbiAgICAgIG1vZHVsZVByb3BzLnNpZ21vaWRhbEJpYXMgPSBzaWdtb2lkYWxCaWFzRmFjdG9yO1xuICAgIH1cblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2F0dXJhdGlvblZhbHVlKSAmJiBzYXR1cmF0aW9uVmFsdWUgIT09IDEpIHtcbiAgICAgIG1vZHVsZXMucHVzaChzYXR1cmF0aW9uKTtcbiAgICAgIG1vZHVsZVByb3BzLnNhdHVyYXRpb25WYWx1ZSA9IHNhdHVyYXRpb25WYWx1ZTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKGJhbmRDb21iaW5hdGlvbikge1xuICAgIGNhc2UgJ25vcm1hbGl6ZWREaWZmZXJlbmNlJzpcbiAgICAgIG1vZHVsZXMucHVzaChub3JtYWxpemVkRGlmZmVyZW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmhhbmNlZFZlZ2V0YXRpb25JbmRleCc6XG4gICAgICBtb2R1bGVzLnB1c2goZW5oYW5jZWRWZWdldGF0aW9uSW5kZXgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc29pbEFkanVzdGVkVmVnZXRhdGlvbkluZGV4JzpcbiAgICAgIG1vZHVsZXMucHVzaChzb2lsQWRqdXN0ZWRWZWdldGF0aW9uSW5kZXgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW9kaWZpZWRTb2lsQWRqdXN0ZWRWZWdldGF0aW9uSW5kZXgnOlxuICAgICAgbW9kdWxlcy5wdXNoKG1vZGlmaWVkU29pbEFkanVzdGVkVmVnZXRhdGlvbkluZGV4KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpc0ZpbHRlckFsbG93ZWQoYmFuZENvbWJpbmF0aW9uKSAmJiBmaWx0ZXJFbmFibGVkKSB7XG4gICAgbW9kdWxlcy5wdXNoKGZpbHRlcik7XG4gICAgbW9kdWxlUHJvcHMuZmlsdGVyTWluMSA9IGZpbHRlclJhbmdlWzBdO1xuICAgIG1vZHVsZVByb3BzLmZpbHRlck1heDEgPSBmaWx0ZXJSYW5nZVsxXTtcbiAgfVxuXG4gIC8vIEFwcGx5IGNvbG9ybWFwXG4gIGlmIChpc0NvbG9ybWFwQWxsb3dlZChiYW5kQ29tYmluYXRpb24pICYmIGltYWdlcy5pbWFnZUNvbG9ybWFwKSB7XG4gICAgbW9kdWxlcy5wdXNoKGNvbG9ybWFwTW9kdWxlKTtcbiAgICBtb2R1bGVQcm9wcy5taW5DYXRlZ29yaWNhbEJhbmRWYWx1ZSA9IG1pbkNhdGVnb3JpY2FsQmFuZFZhbHVlO1xuICAgIG1vZHVsZVByb3BzLm1heENhdGVnb3JpY2FsQmFuZFZhbHVlID0gbWF4Q2F0ZWdvcmljYWxCYW5kVmFsdWU7XG4gICAgbW9kdWxlUHJvcHMuZGF0YVR5cGVNYXhWYWx1ZSA9IGR0eXBlTWF4VmFsdWVbZGF0YVR5cGVdO1xuICAgIG1vZHVsZVByb3BzLm1heFBpeGVsVmFsdWUgPSBtYXhQaXhlbFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHttb2R1bGVzLCBtb2R1bGVQcm9wc307XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT0EsSUFBQUEsS0FBQSxHQUFBQyxPQUFBO0FBQ0EsSUFBQUMsT0FBQSxHQUFBRCxPQUFBO0FBQ0EsSUFBQUUsU0FBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsVUFBQSxHQUFBQyxzQkFBQSxDQUFBSixPQUFBO0FBR0EsSUFBQUssWUFBQSxHQUFBTCxPQUFBO0FBQ0EsSUFBQU0sV0FBQSxHQUFBTixPQUFBO0FBQ0EsSUFBQU8sYUFBQSxHQUFBUCxPQUFBO0FBQ0EsSUFBQVEsTUFBQSxHQUFBUixPQUFBO0FBd0JBLElBQUFTLGdCQUFBLEdBQUFULE9BQUE7QUFlQSxJQUFBVSxnQkFBQSxHQUFBVixPQUFBO0FBQXNELFNBQUFXLFFBQUFDLENBQUEsRUFBQUMsQ0FBQSxRQUFBQyxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsSUFBQSxDQUFBSixDQUFBLE9BQUFHLE1BQUEsQ0FBQUUscUJBQUEsUUFBQUMsQ0FBQSxHQUFBSCxNQUFBLENBQUFFLHFCQUFBLENBQUFMLENBQUEsR0FBQUMsQ0FBQSxLQUFBSyxDQUFBLEdBQUFBLENBQUEsQ0FBQUMsTUFBQSxXQUFBTixDQUFBLFdBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQVIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFRLFVBQUEsT0FBQVAsQ0FBQSxDQUFBUSxJQUFBLENBQUFDLEtBQUEsQ0FBQVQsQ0FBQSxFQUFBSSxDQUFBLFlBQUFKLENBQUE7QUFBQSxTQUFBVSxjQUFBWixDQUFBLGFBQUFDLENBQUEsTUFBQUEsQ0FBQSxHQUFBWSxTQUFBLENB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