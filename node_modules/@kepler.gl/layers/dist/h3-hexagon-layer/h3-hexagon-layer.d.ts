import Layer, { LayerBaseConfig, LayerBaseConfigPartial, LayerColorConfig, LayerCoverageConfig, LayerSizeConfig } from '../base-layer';
import { Centroid } from '@kepler.gl/common-utils';
import { DataContainerInterface } from '@kepler.gl/utils';
import H3HexagonLayerIcon from './h3-hexagon-layer-icon';
import { ColorRange, VisConfigBoolean, VisConfigColorRange, VisConfigNumber, VisConfigRange, Merge, LayerColumn } from '@kepler.gl/types';
import { Datasets, KeplerTable } from '@kepler.gl/table';
export declare type HexagonIdLayerColumnsConfig = {
    hex_id: LayerColumn;
};
export declare type HexagonIdLayerVisConfigSettings = {
    opacity: VisConfigNumber;
    strokeOpacity: VisConfigNumber;
    colorRange: VisConfigColorRange;
    coverage: VisConfigNumber;
    enable3d: VisConfigBoolean;
    sizeRange: VisConfigRange;
    coverageRange: VisConfigRange;
    elevationScale: VisConfigNumber;
    enableElevationZoomFactor: VisConfigBoolean;
    filled: VisConfigBoolean;
    outline: VisConfigBoolean;
    thickness: VisConfigNumber;
};
export declare type HexagonIdLayerVisConfig = {
    opacity: number;
    strokeOpacity: number;
    colorRange: ColorRange;
    coverage: number;
    enable3d: boolean;
    sizeRange: [number, number];
    coverageRange: [number, number];
    elevationScale: number;
    enableElevationZoomFactor: boolean;
    filled: boolean;
    outline: boolean;
    thickness: number;
};
export declare type HexagonIdLayerVisualChannelConfig = LayerColorConfig & LayerSizeConfig & LayerCoverageConfig;
export declare type HexagonIdLayerConfig = Merge<LayerBaseConfig, {
    columns: HexagonIdLayerColumnsConfig;
    visConfig: HexagonIdLayerVisConfig;
}> & HexagonIdLayerVisualChannelConfig;
export declare type HexagonIdLayerData = {
    index: number;
    id: any;
    centroid: Centroid;
};
export declare const hexIdRequiredColumns: ['hex_id'];
export declare const hexIdAccessor: ({ hex_id }: HexagonIdLayerColumnsConfig) => (dc: DataContainerInterface) => (d: any) => any;
/** Accessor that tries to convert h3 indicies in decimal form to hex form */
export declare const hexIdExAccessor: ({ hex_id }: HexagonIdLayerColumnsConfig) => (dc: DataContainerInterface) => (d: any) => any;
export declare const defaultElevation = 500;
export declare const defaultCoverage = 1;
export declare const HexagonIdVisConfigs: {
    opacity: VisConfigNumber;
    strokeOpacity: VisConfigNumber;
    colorRange: 'colorRange';
    filled: VisConfigBoolean;
    outline: 'outline';
    strokeColor: 'strokeColor';
    strokeColorRange: 'strokeColorRange';
    thickness: 'thickness';
    coverage: 'coverage';
    enable3d: 'enable3d';
    sizeRange: 'elevationRange';
    coverageRange: 'coverageRange';
    elevationScale: 'elevationScale';
    enableElevationZoomFactor: 'enableElevationZoomFactor';
    fixedHeight: 'fixedHeight';
};
export default class HexagonIdLayer extends Layer {
    dataToFeature: {
        centroids: Centroid[];
    };
    config: HexagonIdLayerConfig;
    visConfigSettings: HexagonIdLayerVisConfigSettings;
    constructor(props: any);
    get type(): 'hexagonId';
    get name(): 'H3';
    get requiredLayerColumns(): ["hex_id"];
    get layerIcon(): typeof H3HexagonLayerIcon;
    get visualChannels(): {
        color: {
            accessor: string;
            condition: (config: any) => any;
            property: string;
            field: string;
            scale: string;
            domain: string;
            range: string;
            key: string;
            channelScaleType: string;
            nullValue?: any;
            defaultMeasure?: any;
            defaultValue?: any;
            getAttributeValue?: ((config: any) => (d: any) => any) | undefined;
            fixed?: any;
            supportedFieldTypes?: import("@kepler.gl/types").SupportedFieldTypes[] | undefined;
            aggregation?: import("@kepler.gl/types").VisualChannelAggregation | undefined;
        };
        strokeColor: {
            property: string;
            key: string;
            field: string;
            scale: string;
            domain: string;
            range: string;
            channelScaleType: "color";
            accessor: string;
            condition: (config: any) => any;
            defaultValue: (config: any) => any;
        };
        size: {
            property: string;
            accessor: string;
            nullValue: number;
            condition: (config: any) => any;
            defaultValue: number;
            field: string;
            scale: string;
            domain: string;
            range: string;
            key: string;
            channelScaleType: string;
            defaultMeasure?: any;
            getAttributeValue?: ((config: any) => (d: any) => any) | undefined;
            fixed?: any;
            supportedFieldTypes?: import("@kepler.gl/types").SupportedFieldTypes[] | undefined;
            aggregation?: import("@kepler.gl/types").VisualChannelAggregation | undefined;
        };
        coverage: {
            property: string;
            field: string;
            scale: string;
            domain: string;
            range: string;
            key: string;
            channelScaleType: "radius";
            accessor: string;
            nullValue: number;
            defaultValue: number;
        };
    };
    setInitialLayerConfig(dataset: any): this;
    static findDefaultLayerProps({ fields, dataContainer, label }: KeplerTable): {
        props: any;
    };
    getDefaultLayerConfig(props: LayerBaseConfigPartial): {
        strokeColorField: null;
        strokeColorDomain: number[];
        strokeColorScale: string;
        colorUI: {
            strokeColorRange: import("@kepler.gl/types").ColorUI;
            color: import("@kepler.gl/types").ColorUI;
            colorRange: import("@kepler.gl/types").ColorUI;
        };
        coverageField: null;
        coverageDomain: number[];
        coverageScale: string;
        textLabel: {
            anchor: string;
            field: import("@kepler.gl/types").Field | null;
            color: import("@kepler.gl/types").RGBColor;
            background: boolean;
            size: number;
            offset: [number, number];
            alignment: string;
            outlineWidth: number;
            outlineColor: import("@kepler.gl/types").RGBAColor;
            backgroundColor: import("@kepler.gl/types").RGBAColor;
        }[];
        dataId: string;
        label: string;
        color: import("@kepler.gl/types").RGBColor;
        columns: import("@kepler.gl/types").LayerColumns;
        isVisible: boolean;
        isConfigActive: boolean;
        highlightColor: import("@kepler.gl/types").RGBColor | import("@kepler.gl/types").RGBAColor;
        hidden: boolean;
        visConfig: import("@kepler.gl/types").LayerVisConfig;
        animation: {
            enabled: boolean;
            domain?: [number, number] | null | undefined;
        };
        aggregatedBins?: import("@kepler.gl/types").AggregatedBin[] | undefined;
        columnMode?: string | undefined;
        heightField?: import("@kepler.gl/types").VisualChannelField | undefined;
        heightDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        heightScale?: string | undefined;
        colorField?: import("@kepler.gl/types").VisualChannelField | undefined;
        colorDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        colorScale?: string | number | symbol | undefined;
        sizeDomain?: import("@kepler.gl/types").VisualChannelDomain | undefined;
        sizeScale?: string | number | symbol | undefined;
        sizeField?: import("@kepler.gl/types").VisualChannelField | undefined;
    };
    calculateDataAttribute({ filteredIndex }: KeplerTable, getHexId: any): HexagonIdLayerData[];
    formatLayerData(datasets: Datasets, oldLayerData: any): {};
    updateLayerMeta(dataset: KeplerTable, getHexId: any): void;
    renderLayer(opts: any): any[];
}
