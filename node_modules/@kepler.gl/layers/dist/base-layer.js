"use strict";

var _typeof3 = require("@babel/runtime/helpers/typeof");
var _regeneratorRuntime2 = require("@babel/runtime/regenerator");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layerColors = exports.defaultGetFieldValue = exports["default"] = exports.colorMaker = exports.OVERLAY_TYPE_CONST = exports.LAYER_ID_LENGTH = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _core = require("@deck.gl/core");
var _deckglArrowLayers = require("@kepler.gl/deckgl-arrow-layers");
var _extensions = require("@deck.gl/extensions");
var _layers = require("@deck.gl/layers");
var _window = require("global/window");
var _keymirror = _interopRequireDefault(require("keymirror"));
var arrow = _interopRequireWildcard(require("apache-arrow"));
var _defaultLayerIcon = _interopRequireDefault(require("./default-layer-icon"));
var _layerUpdate = require("./layer-update");
var _layerUtils = require("./layer-utils");
var _constants = require("@kepler.gl/constants");
var _utils = require("@kepler.gl/utils");
var _commonUtils = require("@kepler.gl/common-utils");
var _memoize = _interopRequireDefault(require("lodash/memoize"));
var _getApplicationConfig; // SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof3(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(generateColor);
/**
 * Approx. number of points to sample in a large data set
 */
var LAYER_ID_LENGTH = exports.LAYER_ID_LENGTH = 6;
var MAX_SAMPLE_SIZE = 5000;
var defaultDomain = [0, 1];
var dataFilterExtension = new _extensions.DataFilterExtension({
  filterSize: _constants.MAX_GPU_FILTERS,
  // `countItems` option. It enables the GPU to report the number of objects that pass the filter criteria via the `onFilteredItemsChange` callback.
  // @ts-expect-error not typed
  countItems: (_getApplicationConfig = (0, _utils.getApplicationConfig)().useOnFilteredItemsChange) !== null && _getApplicationConfig !== void 0 ? _getApplicationConfig : false
});

// eslint-disable-next-line @typescript-eslint/no-unused-vars
var defaultDataAccessor = function defaultDataAccessor(dc) {
  return function (d) {
    return d;
  };
};
var identity = function identity(d) {
  return d;
};
// Can't use fiedValueAccesor because need the raw data to render tooltip
// SHAN: Revisit here
var defaultGetFieldValue = exports.defaultGetFieldValue = function defaultGetFieldValue(field, d) {
  return field.valueAccessor(d);
};
var OVERLAY_TYPE_CONST = exports.OVERLAY_TYPE_CONST = (0, _keymirror["default"])({
  deckgl: null,
  mapboxgl: null
});
var layerColors = exports.layerColors = Object.values(_constants.DataVizColors).map(_utils.hexToRgb);
function generateColor() {
  var index;
  return _regenerator["default"].wrap(function generateColor$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        index = 0;
      case 1:
        if (!(index < layerColors.length + 1)) {
          _context.next = 7;
          break;
        }
        if (index === layerColors.length) {
          index = 0;
        }
        _context.next = 5;
        return layerColors[index++];
      case 5:
        _context.next = 1;
        break;
      case 7:
      case "end":
        return _context.stop();
    }
  }, _marked);
}
var colorMaker = exports.colorMaker = generateColor();
var Layer = /*#__PURE__*/function () {
  function Layer(props) {
    (0, _classCallCheck2["default"])(this, Layer);
    (0, _defineProperty2["default"])(this, "id", void 0);
    (0, _defineProperty2["default"])(this, "meta", void 0);
    (0, _defineProperty2["default"])(this, "visConfigSettings", void 0);
    (0, _defineProperty2["default"])(this, "config", void 0);
    // TODO: define _oldDataUpdateTriggers
    (0, _defineProperty2["default"])(this, "_oldDataUpdateTriggers", void 0);
    (0, _defineProperty2["default"])(this, "isValid", void 0);
    (0, _defineProperty2["default"])(this, "errorMessage", void 0);
    (0, _defineProperty2["default"])(this, "filteredItemCount", void 0);
    this.id = props.id || (0, _commonUtils.generateHashId)(LAYER_ID_LENGTH);
    // meta
    this.meta = {};

    // visConfigSettings
    this.visConfigSettings = {};
    this.config = this.getDefaultLayerConfig(props);

    // set columnMode from supported columns
    if (!this.config.columnMode) {
      var supportedColumnModes = this.supportedColumnModes;
      if (supportedColumnModes !== null && supportedColumnModes !== void 0 && supportedColumnModes.length) {
        var _supportedColumnModes;
        this.config.columnMode = (_supportedColumnModes = supportedColumnModes[0]) === null || _supportedColumnModes === void 0 ? void 0 : _supportedColumnModes.key;
      }
    }
    // then set column, columnMode should already been set
    this.config.columns = this.getLayerColumns(props.columns);

    // false indicates that the layer caused an error, and was disabled
    this.isValid = true;
    this.errorMessage = null;
    // item count
    this.filteredItemCount = {};
  }
  return (0, _createClass2["default"])(Layer, [{
    key: "layerIcon",
    get: function get() {
      return _defaultLayerIcon["default"];
    }
  }, {
    key: "overlayType",
    get: function get() {
      return OVERLAY_TYPE_CONST.deckgl;
    }
  }, {
    key: "type",
    get: function get() {
      return null;
    }
  }, {
    key: "name",
    get: function get() {
      return this.type;
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      var supportedColumnModes = this.supportedColumnModes;
      if (supportedColumnModes) {
        return supportedColumnModes.reduce(function (acc, obj) {
          return obj.requiredColumns ? acc.concat(obj.requiredColumns) : acc;
        }, []);
      }
      return [];
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      var supportedColumnModes = this.supportedColumnModes;
      if (supportedColumnModes) {
        return supportedColumnModes.reduce(function (acc, obj) {
          return obj.optionalColumns ? acc.concat(obj.optionalColumns) : acc;
        }, []);
      }
      return [];
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: {
          property: 'color',
          field: 'colorField',
          scale: 'colorScale',
          domain: 'colorDomain',
          range: 'colorRange',
          key: 'color',
          channelScaleType: _constants.CHANNEL_SCALES.color,
          nullValue: _constants.NO_VALUE_COLOR,
          defaultValue: function defaultValue(config) {
            return config.color;
          }
        },
        size: {
          property: 'size',
          field: 'sizeField',
          scale: 'sizeScale',
          domain: 'sizeDomain',
          range: 'sizeRange',
          key: 'size',
          channelScaleType: _constants.CHANNEL_SCALES.size,
          nullValue: 0,
          defaultValue: 1
        }
      };
    }
  }, {
    key: "columnValidators",
    get: function get() {
      return {};
    }
    /*
     * Column pairs maps layer column to a specific field pairs,
     * By default, it is set to null
     */
  }, {
    key: "columnPairs",
    get: function get() {
      return null;
    }

    /**
     * Column labels if its different than column key
     */
  }, {
    key: "columnLabels",
    get: function get() {
      return null;
    }

    /*
     * Default point column pairs, can be used for point based layers: point, icon etc.
     */
  }, {
    key: "defaultPointColumnPairs",
    get: function get() {
      return {
        lat: {
          pair: ['lng', 'altitude'],
          fieldPairKey: 'lat'
        },
        lng: {
          pair: ['lat', 'altitude'],
          fieldPairKey: 'lng'
        },
        altitude: {
          pair: ['lng', 'lat'],
          fieldPairKey: 'altitude'
        }
      };
    }

    /*
     * Default link column pairs, can be used for link based layers: arc, line etc
     */
  }, {
    key: "defaultLinkColumnPairs",
    get: function get() {
      return {
        lat: {
          pair: ['lng', 'alt'],
          fieldPairKey: 'lat'
        },
        lng: {
          pair: ['lat', 'alt'],
          fieldPairKey: 'lng'
        },
        alt: {
          pair: ['lng', 'lat'],
          fieldPairKey: 'altitude'
        },
        lat0: {
          pair: 'lng0',
          fieldPairKey: 'lat'
        },
        lng0: {
          pair: 'lat0',
          fieldPairKey: 'lng'
        },
        alt0: {
          pair: ['lng0', 'lat0'],
          fieldPairKey: 'altitude'
        },
        lat1: {
          pair: 'lng1',
          fieldPairKey: 'lat'
        },
        lng1: {
          pair: 'lat1',
          fieldPairKey: 'lng'
        },
        alt1: {
          pair: ['lng1', 'lat1'],
          fieldPairKey: 'altitude'
        }
      };
    }

    /**
     * Return a React component for to render layer instructions in a modal
     * @returns {object} - an object
     * @example
     *  return {
     *    id: 'iconInfo',
     *    template: IconInfoModal,
     *    modalProps: {
     *      title: 'How to draw icons'
     *   };
     * }
     */
  }, {
    key: "layerInfoModal",
    get: function get() {
      return null;
    }

    /**
     * Returns which column modes this layer supports
     */
  }, {
    key: "supportedColumnModes",
    get: function get() {
      return null;
    }
  }, {
    key: "supportedDatasetTypes",
    get: function get() {
      return null;
    }

    /*
     * Given a dataset, automatically find props to create layer based on it
     * and return the props and previous found layers.
     * By default, no layers will be found
     */
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig(props) {
      var _props$isVisible, _props$isConfigActive, _props$hidden;
      return _objectSpread({
        dataId: props.dataId,
        label: props.label || _constants.DEFAULT_LAYER_LABEL,
        color: props.color || colorMaker.next().value,
        // set columns later
        columns: {},
        isVisible: (_props$isVisible = props.isVisible) !== null && _props$isVisible !== void 0 ? _props$isVisible : true,
        isConfigActive: (_props$isConfigActive = props.isConfigActive) !== null && _props$isConfigActive !== void 0 ? _props$isConfigActive : false,
        highlightColor: props.highlightColor || _constants.DEFAULT_HIGHLIGHT_COLOR,
        hidden: (_props$hidden = props.hidden) !== null && _props$hidden !== void 0 ? _props$hidden : false,
        // TODO: refactor this into separate visual Channel config
        // color by field, domain is set by filters, field, scale type
        colorField: null,
        colorDomain: [0, 1],
        colorScale: _constants.SCALE_TYPES.quantile,
        // color by size, domain is set by filters, field, scale type
        sizeDomain: [0, 1],
        sizeScale: _constants.SCALE_TYPES.linear,
        sizeField: null,
        visConfig: {},
        textLabel: [_constants.DEFAULT_TEXT_LABEL],
        colorUI: {
          color: _constants.DEFAULT_COLOR_UI,
          colorRange: _constants.DEFAULT_COLOR_UI
        },
        animation: {
          enabled: false
        }
      }, props.columnMode ? {
        columnMode: props.columnMode
      } : {});
    }

    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */
  }, {
    key: "getVisualChannelDescription",
    value: function getVisualChannelDescription(key) {
      // e.g. label: Color, measure: Vehicle Type
      var channel = this.visualChannels[key];
      if (!channel) return {
        label: '',
        measure: undefined
      };
      var rangeSettings = this.visConfigSettings[channel.range];
      var fieldSettings = this.config[channel.field];
      var label = rangeSettings === null || rangeSettings === void 0 ? void 0 : rangeSettings.label;
      return {
        label: typeof label === 'function' ? label(this.config) : label || '',
        measure: fieldSettings ? fieldSettings.displayName || fieldSettings.name : channel.defaultMeasure
      };
    }

    /**
     * Assign a field to layer column, return column config
     */
  }, {
    key: "assignColumn",
    value: function assignColumn(key, field) {
      var _this$config$columns;
      // field value could be null for optional columns
      var update = field ? {
        value: field.name,
        fieldIdx: field.fieldIdx
      } : {
        value: null,
        fieldIdx: -1
      };
      return _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2["default"])({}, key, _objectSpread(_objectSpread({}, (_this$config$columns = this.config.columns) === null || _this$config$columns === void 0 ? void 0 : _this$config$columns[key]), update)));
    }

    /**
     * Assign a field pair to column config, return column config
     */
  }, {
    key: "assignColumnPairs",
    value: function assignColumnPairs(key, fieldPairs) {
      var _this$columnPairs, _this$columnPairs2;
      if (!this.columnPairs || !((_this$columnPairs = this.columnPairs) !== null && _this$columnPairs !== void 0 && _this$columnPairs[key])) {
        // should not end in this state
        return this.config.columns;
      }
      // key = 'lat'
      var _ref = ((_this$columnPairs2 = this.columnPairs) === null || _this$columnPairs2 === void 0 ? void 0 : _this$columnPairs2[key]) || {},
        pair = _ref.pair,
        fieldPairKey = _ref.fieldPairKey;
      if (typeof fieldPairKey === 'string' && !fieldPairs[fieldPairKey]) {
        // do not allow `key: undefined` to creep into the `updatedColumn` object
        return this.config.columns;
      }

      // pair = ['lng', 'alt] | 'lng'
      var updatedColumn = _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2["default"])({}, key, fieldPairs[fieldPairKey]));
      var partnerKeys = (0, _commonUtils.toArray)(pair);
      var _iterator = _createForOfIteratorHelper(partnerKeys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _this$columnPairs3, _this$columnPairs4;
          var partnerKey = _step.value;
          if (this.config.columns[partnerKey] && (_this$columnPairs3 = this.columnPairs) !== null && _this$columnPairs3 !== void 0 && _this$columnPairs3[partnerKey] &&
          // @ts-ignore
          fieldPairs[(_this$columnPairs4 = this.columnPairs) === null || _this$columnPairs4 === void 0 ? void 0 : _this$columnPairs4[partnerKey].fieldPairKey]) {
            var _this$columnPairs5;
            // @ts-ignore
            updatedColumn[partnerKey] = fieldPairs[(_this$columnPairs5 = this.columnPairs) === null || _this$columnPairs5 === void 0 ? void 0 : _this$columnPairs5[partnerKey].fieldPairKey];
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return updatedColumn;
    }

    /**
     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
  }, {
    key: "getZoomFactor",
    value: function getZoomFactor(_ref2) {
      var zoom = _ref2.zoom,
        _ref2$zoomOffset = _ref2.zoomOffset,
        zoomOffset = _ref2$zoomOffset === void 0 ? 0 : _ref2$zoomOffset;
      return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));
    }

    /**
     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number=} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
  }, {
    key: "getElevationZoomFactor",
    value: function getElevationZoomFactor(_ref3) {
      var zoom = _ref3.zoom,
        _ref3$zoomOffset = _ref3.zoomOffset,
        zoomOffset = _ref3$zoomOffset === void 0 ? 0 : _ref3$zoomOffset;
      // enableElevationZoomFactor is used to support existing maps
      var _this$config$visConfi = this.config.visConfig,
        fixedHeight = _this$config$visConfi.fixedHeight,
        enableElevationZoomFactor = _this$config$visConfi.enableElevationZoomFactor;
      return fixedHeight || enableElevationZoomFactor === false ? 1 : Math.pow(2, Math.max(8 - zoom + zoomOffset, 0));
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "formatLayerData",
    value: function formatLayerData(datasets, oldLayerData, animationConfig) {
      return {};
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "renderLayer",
    value: function renderLayer() {
      return [];
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getHoverData",
    value: function getHoverData(object, dataContainer,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fields,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    animationConfig,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hoverInfo) {
      if (!object) {
        return null;
      }

      // By default, each entry of layerData should have an index of a row in the original data container.
      // Each layer can implement its own getHoverData method
      return dataContainer.row(object.index);
    }
  }, {
    key: "getFilteredItemCount",
    value: function getFilteredItemCount() {
      // use first layer
      if (Object.keys(this.filteredItemCount).length) {
        var firstLayer = Object.keys(this.filteredItemCount)[0];
        return this.filteredItemCount[firstLayer];
      }
      return null;
    }
    /**
     * When change layer type, try to copy over layer configs as much as possible
     * @param configToCopy - config to copy over
     * @param visConfigSettings - visConfig settings of config to copy
     * @param datasets - current datasets.
     * @param defaultLayerProps - default layer creation configurations for current layer and datasets.
     */
  }, {
    key: "assignConfigToLayer",
    value: function assignConfigToLayer(configToCopy, visConfigSettings, datasets, defaultLayerProps) {
      var _this = this;
      // don't deep merge visualChannel field
      // don't deep merge color range, reversed: is not a key by default
      var shallowCopy = ['colorRange', 'strokeColorRange'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.field;
      }));

      // don't copy over domain and animation
      var notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(function (v) {
        return v.domain;
      }));
      // if range is for the same property group copy it, otherwise, not to copy
      Object.values(this.visualChannels).forEach(function (v) {
        if (configToCopy.visConfig[v.range] && _this.visConfigSettings[v.range] && visConfigSettings[v.range].group !== _this.visConfigSettings[v.range].group) {
          notToCopy.push(v.range);
        }
      });

      // don't copy over visualChannel range
      var currentConfig = this.config;
      var copied = this.copyLayerConfig(currentConfig, configToCopy, {
        shallowCopy: shallowCopy,
        notToCopy: notToCopy
      });

      // update columNode based on new columns
      if (this.config.columnMode && this.supportedColumnModes) {
        var _satisfiedColumnMode;
        var dataset = datasets === null || datasets === void 0 ? void 0 : datasets[this.config.dataId];
        // try to find a mode with all requied columns from the source config
        var satisfiedColumnMode = (0, _layerUtils.getSatisfiedColumnMode)(this.supportedColumnModes, copied.columns, dataset === null || dataset === void 0 ? void 0 : dataset.fields);

        // if no suitable column mode found or no such columMode exists for the layer
        // then try use one of the automatically detected layer configs
        if (!satisfiedColumnMode) {
          var options = [].concat((0, _toConsumableArray2["default"])((defaultLayerProps === null || defaultLayerProps === void 0 ? void 0 : defaultLayerProps.props) || []), (0, _toConsumableArray2["default"])((defaultLayerProps === null || defaultLayerProps === void 0 ? void 0 : defaultLayerProps.altProps) || []));
          if (options.length) {
            // Use the first of the default configurations
            var defaultColumnConfig = options[0].columns;
            satisfiedColumnMode = (0, _layerUtils.getSatisfiedColumnMode)(this.supportedColumnModes, defaultColumnConfig, dataset === null || dataset === void 0 ? void 0 : dataset.fields);
            if (satisfiedColumnMode) {
              copied.columns = _objectSpread(_objectSpread({}, copied.columns), defaultColumnConfig);
            }
          }
        }
        copied.columnMode = ((_satisfiedColumnMode = satisfiedColumnMode) === null || _satisfiedColumnMode === void 0 ? void 0 : _satisfiedColumnMode.key) || copied.columnMode;
      }
      this.updateLayerConfig(copied);
      // validate visualChannel field type and scale types
      Object.keys(this.visualChannels).forEach(function (channel) {
        _this.validateVisualChannel(channel);
      });
    }

    /*
     * Recursively copy config over to an empty layer
     * when received saved config, or copy config over from a different layer type
     * make sure to only copy over value to existing keys
     * @param {object} currentConfig - existing config to be override
     * @param {object} configToCopy - new Config to copy over
     * @param {string[]} shallowCopy - array of properties to not to be deep copied
     * @param {string[]} notToCopy - array of properties not to copy
     * @returns {object} - copied config
     */
  }, {
    key: "copyLayerConfig",
    value: function copyLayerConfig(currentConfig, configToCopy) {
      var _this2 = this;
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref4$shallowCopy = _ref4.shallowCopy,
        shallowCopy = _ref4$shallowCopy === void 0 ? [] : _ref4$shallowCopy,
        _ref4$notToCopy = _ref4.notToCopy,
        notToCopy = _ref4$notToCopy === void 0 ? [] : _ref4$notToCopy;
      var copied = {};
      Object.keys(currentConfig).forEach(function (key) {
        if ((0, _utils.isPlainObject)(currentConfig[key]) && (0, _utils.isPlainObject)(configToCopy[key]) && !shallowCopy.includes(key) && !notToCopy.includes(key)) {
          // recursively assign object value
          copied[key] = _this2.copyLayerConfig(currentConfig[key], configToCopy[key], {
            shallowCopy: shallowCopy,
            notToCopy: notToCopy
          });
        } else if ((0, _commonUtils.notNullorUndefined)(configToCopy[key]) && !notToCopy.includes(key)) {
          // copy
          copied[key] = configToCopy[key];
        } else {
          // keep existing
          copied[key] = currentConfig[key];
        }
      });
      return copied;
    }
  }, {
    key: "registerVisConfig",
    value: function registerVisConfig(layerVisConfigs) {
      var _this3 = this;
      Object.keys(layerVisConfigs).forEach(function (item) {
        var configItem = layerVisConfigs[item];
        if (typeof configItem === 'string' && _constants.LAYER_VIS_CONFIGS[configItem]) {
          // if assigned one of default LAYER_CONFIGS
          _this3.config.visConfig[item] = _constants.LAYER_VIS_CONFIGS[configItem].defaultValue;
          _this3.visConfigSettings[item] = _constants.LAYER_VIS_CONFIGS[configItem];
        } else if ((0, _typeof2["default"])(configItem) === 'object' && ['type', 'defaultValue'].every(function (p) {
          return Object.prototype.hasOwnProperty.call(configItem, p);
        })) {
          // if provided customized visConfig, and has type && defaultValue
          // TODO: further check if customized visConfig is valid
          _this3.config.visConfig[item] = configItem.defaultValue;
          _this3.visConfigSettings[item] = configItem;
        }
      });
    }
  }, {
    key: "getLayerColumns",
    value: function getLayerColumns() {
      var propsColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var columnValidators = this.columnValidators || {};
      var required = this.requiredLayerColumns.reduce(function (accu, key) {
        var _propsColumns$key$val, _propsColumns$key, _propsColumns$key$fie, _propsColumns$key2, _propsColumns$key$val2, _propsColumns$key3, _propsColumns$key$fie2, _propsColumns$key4;
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, columnValidators[key] ? {
          value: (_propsColumns$key$val = (_propsColumns$key = propsColumns[key]) === null || _propsColumns$key === void 0 ? void 0 : _propsColumns$key.value) !== null && _propsColumns$key$val !== void 0 ? _propsColumns$key$val : null,
          fieldIdx: (_propsColumns$key$fie = (_propsColumns$key2 = propsColumns[key]) === null || _propsColumns$key2 === void 0 ? void 0 : _propsColumns$key2.fieldIdx) !== null && _propsColumns$key$fie !== void 0 ? _propsColumns$key$fie : -1,
          validator: columnValidators[key]
        } : {
          value: (_propsColumns$key$val2 = (_propsColumns$key3 = propsColumns[key]) === null || _propsColumns$key3 === void 0 ? void 0 : _propsColumns$key3.value) !== null && _propsColumns$key$val2 !== void 0 ? _propsColumns$key$val2 : null,
          fieldIdx: (_propsColumns$key$fie2 = (_propsColumns$key4 = propsColumns[key]) === null || _propsColumns$key4 === void 0 ? void 0 : _propsColumns$key4.fieldIdx) !== null && _propsColumns$key$fie2 !== void 0 ? _propsColumns$key$fie2 : -1
        }));
      }, {});
      var optional = this.optionalColumns.reduce(function (accu, key) {
        var _propsColumns$key$val3, _propsColumns$key5, _propsColumns$key$fie3, _propsColumns$key6;
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, {
          value: (_propsColumns$key$val3 = (_propsColumns$key5 = propsColumns[key]) === null || _propsColumns$key5 === void 0 ? void 0 : _propsColumns$key5.value) !== null && _propsColumns$key$val3 !== void 0 ? _propsColumns$key$val3 : null,
          fieldIdx: (_propsColumns$key$fie3 = (_propsColumns$key6 = propsColumns[key]) === null || _propsColumns$key6 === void 0 ? void 0 : _propsColumns$key6.fieldIdx) !== null && _propsColumns$key$fie3 !== void 0 ? _propsColumns$key$fie3 : -1,
          optional: true
        }));
      }, {});
      var columns = _objectSpread(_objectSpread({}, required), optional);
      return columns;
    }
  }, {
    key: "updateLayerConfig",
    value: function updateLayerConfig(newConfig) {
      this.config = _objectSpread(_objectSpread({}, this.config), newConfig);
      return this;
    }
  }, {
    key: "updateLayerVisConfig",
    value: function updateLayerVisConfig(newVisConfig) {
      this.config.visConfig = _objectSpread(_objectSpread({}, this.config.visConfig), newVisConfig);
      return this;
    }
  }, {
    key: "updateLayerColorUI",
    value: function updateLayerColorUI(prop, newConfig) {
      var _this$config = this.config,
        previous = _this$config.colorUI,
        visConfig = _this$config.visConfig;
      if (!(0, _utils.isPlainObject)(newConfig) || typeof prop !== 'string') {
        return this;
      }
      var colorUIProp = Object.entries(newConfig).reduce(function (accu, _ref5) {
        var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
          key = _ref6[0],
          value = _ref6[1];
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, key, (0, _utils.isPlainObject)(accu[key]) && (0, _utils.isPlainObject)(value) ? _objectSpread(_objectSpread({}, accu[key]), value) : value));
      }, previous[prop] || _constants.DEFAULT_COLOR_UI);
      var colorUI = _objectSpread(_objectSpread({}, previous), {}, (0, _defineProperty2["default"])({}, prop, colorUIProp));
      this.updateLayerConfig({
        colorUI: colorUI
      });
      // if colorUI[prop] is colorRange
      var isColorRange = visConfig[prop] && visConfig[prop].colors;
      if (isColorRange) {
        // if open dropdown and prop is color range
        // Automatically set colorRangeConfig's step and reversed
        this.updateColorUIByColorRange(newConfig, prop);

        // if changes in UI is made to 'reversed', 'steps' or steps
        // update current layer colorRange
        this.updateColorRangeByColorUI(newConfig, previous, prop);

        // if set colorRangeConfig to custom
        // initiate customPalette to be edited in the ui
        this.updateCustomPalette(newConfig, previous, prop);
      }
      return this;
    }

    // if set colorRangeConfig to custom palette or custom breaks
    // initiate customPalette to be edited in the ui
  }, {
    key: "updateCustomPalette",
    value: function updateCustomPalette(newConfig, previous, prop) {
      var _newConfig$colorRange, _newConfig$colorRange2;
      if (!((_newConfig$colorRange = newConfig.colorRangeConfig) !== null && _newConfig$colorRange !== void 0 && _newConfig$colorRange.custom) && !((_newConfig$colorRange2 = newConfig.colorRangeConfig) !== null && _newConfig$colorRange2 !== void 0 && _newConfig$colorRange2.customBreaks)) {
        return;
      }
      if (newConfig.customPalette) {
        // if new config also set customPalette, no need to initiate new
        return;
      }
      var _this$config2 = this.config,
        colorUI = _this$config2.colorUI,
        visConfig = _this$config2.visConfig;
      if (!visConfig[prop]) return;
      // make copy of current color range to customPalette
      var customPalette = _objectSpread({}, visConfig[prop]);
      if (newConfig.colorRangeConfig.customBreaks && !customPalette.colorMap) {
        // find visualChanel
        var visualChannels = this.visualChannels;
        var channelKey = Object.keys(visualChannels).find(function (key) {
          return visualChannels[key].range === prop;
        });
        if (!channelKey) {
          // should never happn
          _window.console.warn("updateColorUI: Can't find visual channel which range is ".concat(prop));
          return;
        }
        // add name|type|category to updateCustomPalette if customBreaks, so that
        // colors will not be override as well when inverse palette with custom break
        // initiate colorMap from current scale

        var colorMap = (0, _utils.initializeLayerColorMap)(this, visualChannels[channelKey]);
        customPalette = (0, _utils.initializeCustomPalette)(visConfig[prop], colorMap);
      } else if (newConfig.colorRangeConfig.custom) {
        customPalette = (0, _utils.initializeCustomPalette)(visConfig[prop]);
      }
      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          customPalette: customPalette
        })))
      });
    }

    /**
     * if open dropdown and prop is color range
     * Automatically set colorRangeConfig's step and reversed
     * @param {*} newConfig
     * @param {*} prop
     */
  }, {
    key: "updateColorUIByColorRange",
    value: function updateColorUIByColorRange(newConfig, prop) {
      var _newConfig$customPale;
      var _this$config3 = this.config,
        colorUI = _this$config3.colorUI,
        visConfig = _this$config3.visConfig;

      // when custom palette adds/removes step, the number in "Steps" input control
      // should be updated as well
      var isCustom = ((_newConfig$customPale = newConfig.customPalette) === null || _newConfig$customPale === void 0 ? void 0 : _newConfig$customPale.category) === 'Custom';
      var customStepsChanged = isCustom ? newConfig.customPalette.colors.length !== visConfig[prop].colors.length : false;
      if (typeof newConfig.showDropdown !== 'number' && !customStepsChanged) return;
      this.updateLayerConfig({
        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2["default"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {
          colorRangeConfig: _objectSpread(_objectSpread({}, colorUI[prop].colorRangeConfig), {}, {
            steps: customStepsChanged ? colorUI[prop].customPalette.colors.length : visConfig[prop].colors.length,
            reversed: Boolean(visConfig[prop].reversed)
          })
        })))
      });
    }
  }, {
    key: "updateColorRangeByColorUI",
    value: function updateColorRangeByColorUI(newConfig, previous, prop) {
      // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps
      var shouldUpdate = newConfig.colorRangeConfig && ['reversed', 'steps', 'colorBlindSafe', 'type'].some(function (key) {
        return Object.prototype.hasOwnProperty.call(newConfig.colorRangeConfig, key) && newConfig.colorRangeConfig[key] !== (previous[prop] || _constants.DEFAULT_COLOR_UI).colorRangeConfig[key];
      });
      if (!shouldUpdate) return;
      var _this$config4 = this.config,
        colorUI = _this$config4.colorUI,
        visConfig = _this$config4.visConfig;

      // for custom palette, one can only 'reverse' the colors in custom palette.
      // changing 'steps', 'colorBindSafe', 'type' should fall back to predefined palette.
      var isCustomColorReversed = visConfig.colorRange.category === 'Custom' && newConfig.colorRangeConfig && Object.prototype.hasOwnProperty.call(newConfig.colorRangeConfig, 'reversed');
      var update = isCustomColorReversed ? (0, _utils.updateCustomColorRangeByColorUI)(visConfig[prop], colorUI[prop].colorRangeConfig) : (0, _utils.updateColorRangeByMatchingPalette)(visConfig[prop], colorUI[prop].colorRangeConfig);
      if (update) {
        this.updateLayerVisConfig((0, _defineProperty2["default"])({}, prop, update));
      }
    }
  }, {
    key: "hasColumnValue",
    value: function hasColumnValue(column) {
      return Boolean(column && column.value && column.fieldIdx > -1);
    }
  }, {
    key: "hasRequiredColumn",
    value: function hasRequiredColumn(column) {
      return Boolean(column && (column.optional || this.hasColumnValue(column)));
    }
    /**
     * Check whether layer has all columns
     * @returns yes or no
     */
  }, {
    key: "hasAllColumns",
    value: function hasAllColumns() {
      var _this4 = this;
      var _this$config5 = this.config,
        columns = _this$config5.columns,
        columnMode = _this$config5.columnMode;
      // if layer has different column mode, check if have all required columns of current column Mode
      if (columnMode) {
        var _currentColumnModes$r;
        var currentColumnModes = (this.supportedColumnModes || []).find(function (colMode) {
          return colMode.key === columnMode;
        });
        return Boolean(currentColumnModes !== undefined && ((_currentColumnModes$r = currentColumnModes.requiredColumns) === null || _currentColumnModes$r === void 0 ? void 0 : _currentColumnModes$r.every(function (colKey) {
          return _this4.hasColumnValue(columns[colKey]);
        })));
      }
      return Boolean(columns && Object.values(columns).every(function (column) {
        return _this4.hasRequiredColumn(column);
      }));
    }

    /**
     * Check whether layer has data
     *
     * @param {Array | Object} layerData
     * @returns {boolean} yes or no
     */
  }, {
    key: "hasLayerData",
    value: function hasLayerData(layerData) {
      if (!layerData) {
        return false;
      }
      return Boolean(layerData.data && (layerData.data.length || layerData.data.numRows));
    }
  }, {
    key: "isValidToSave",
    value: function isValidToSave() {
      return Boolean(this.type && this.hasAllColumns());
    }
  }, {
    key: "shouldRenderLayer",
    value: function shouldRenderLayer(data) {
      return Boolean(this.type) && this.hasAllColumns() && this.hasLayerData(data) && typeof this.renderLayer === 'function';
    }
  }, {
    key: "getColorScale",
    value: function getColorScale(colorScale, colorDomain, colorRange) {
      if (colorScale === _constants.SCALE_TYPES.customOrdinal) {
        return (0, _utils.getCategoricalColorScale)(colorDomain, colorRange);
      }
      if ((0, _utils.hasColorMap)(colorRange) && colorScale === _constants.SCALE_TYPES.custom) {
        var _colorRange$colorMap;
        var cMap = new Map();
        (_colorRange$colorMap = colorRange.colorMap) === null || _colorRange$colorMap === void 0 || _colorRange$colorMap.forEach(function (_ref7) {
          var _ref8 = (0, _slicedToArray2["default"])(_ref7, 2),
            k = _ref8[0],
            v = _ref8[1];
          cMap.set(k, typeof v === 'string' ? (0, _utils.hexToRgb)(v) : v);
        });
        var scaleType = colorScale === _constants.SCALE_TYPES.custom ? colorScale : _constants.SCALE_TYPES.ordinal;
        var scale = (0, _utils.getScaleFunction)(scaleType, cMap.values(), cMap.keys(), false);
        scale.unknown(cMap.get(_constants.UNKNOWN_COLOR_KEY) || _constants.NO_VALUE_COLOR);
        return scale;
      }
      return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_utils.hexToRgb));
    }
  }, {
    key: "accessVSFieldValue",
    value: function accessVSFieldValue(_field, _indexKey) {
      return defaultGetFieldValue;
    }
    /**
     * Mapping from visual channels to deck.gl accesors
     * @param param Parameters
     * @param param.dataAccessor Access kepler.gl layer data from deck.gl layer
     * @param param.dataContainer DataContainer to use use with dataAccessor
     * @return {Object} attributeAccessors - deck.gl layer attribute accessors
     */
  }, {
    key: "getAttributeAccessors",
    value: function getAttributeAccessors(_ref9) {
      var _this5 = this;
      var _ref9$dataAccessor = _ref9.dataAccessor,
        dataAccessor = _ref9$dataAccessor === void 0 ? defaultDataAccessor : _ref9$dataAccessor,
        dataContainer = _ref9.dataContainer,
        indexKey = _ref9.indexKey;
      var attributeAccessors = {};
      Object.keys(this.visualChannels).forEach(function (channel) {
        var _this5$visualChannels = _this5.visualChannels[channel],
          field = _this5$visualChannels.field,
          fixed = _this5$visualChannels.fixed,
          scale = _this5$visualChannels.scale,
          domain = _this5$visualChannels.domain,
          range = _this5$visualChannels.range,
          accessor = _this5$visualChannels.accessor,
          defaultValue = _this5$visualChannels.defaultValue,
          getAttributeValue = _this5$visualChannels.getAttributeValue,
          nullValue = _this5$visualChannels.nullValue,
          channelScaleType = _this5$visualChannels.channelScaleType;
        if (accessor) {
          var shouldGetScale = _this5.config[field];
          if (shouldGetScale) {
            var isFixed = fixed && _this5.config.visConfig[fixed];
            var scaleFunction = channelScaleType === _constants.CHANNEL_SCALES.color ? _this5.getColorScale(_this5.config[scale], _this5.config[domain], _this5.config.visConfig[range]) : _this5.getVisChannelScale(_this5.config[scale], _this5.config[domain], _this5.config.visConfig[range], isFixed);
            var getFieldValue = _this5.accessVSFieldValue(_this5.config[field], indexKey);
            if (scaleFunction) {
              attributeAccessors[accessor] = scaleFunction.byZoom ? (0, _memoize["default"])(function (z) {
                var scaleFunc = scaleFunction(z);
                return function (d) {
                  return _this5.getEncodedChannelValue(scaleFunc, dataAccessor(dataContainer)(d), _this5.config[field], nullValue, getFieldValue);
                };
              }) : function (d) {
                return _this5.getEncodedChannelValue(scaleFunction, dataAccessor(dataContainer)(d), _this5.config[field], nullValue, getFieldValue);
              };

              // set getFillColorByZoom to true
              if (scaleFunction.byZoom) {
                attributeAccessors["".concat(accessor, "ByZoom")] = true;
              }
            }
          } else if (typeof getAttributeValue === 'function') {
            attributeAccessors[accessor] = getAttributeValue(_this5.config);
          } else {
            attributeAccessors[accessor] = typeof defaultValue === 'function' ? defaultValue(_this5.config) : defaultValue;
          }
          if (!attributeAccessors[accessor]) {
            _window.console.warn("Failed to provide accessor function for ".concat(accessor || channel));
          }
        }
      });
      return attributeAccessors;
    }
  }, {
    key: "getVisChannelScale",
    value: function getVisChannelScale(scale, domain, range, fixed) {
      // if quantile is provided per zoom
      if ((0, _utils.isDomainQuantile)(domain) && scale === _constants.SCALE_TYPES.quantile) {
        var zSteps = domain.z;
        var getScale = function getScaleByZoom(z) {
          var scaleDomain = (0, _utils.getDomainStepsbyZoom)(domain.quantiles, zSteps, z);
          var thresholds = (0, _utils.getThresholdsFromQuantiles)(scaleDomain, range.length);
          return (0, _utils.getScaleFunction)('threshold', range, thresholds, false);
        };
        getScale.byZoom = true;
        return getScale;
      } else if ((0, _utils.isDomainStops)(domain)) {
        // color is based on zoom
        var _zSteps = domain.z;
        // get scale function by z
        // {
        //  z: [z, z, z],
        //  stops: [[min, max], [min, max]],
        //  interpolation: 'interpolate'
        // }

        var _getScale = function getScaleByZoom(z) {
          var scaleDomain = (0, _utils.getDomainStepsbyZoom)(domain.stops, _zSteps, z);
          return (0, _utils.getScaleFunction)(scale, range, scaleDomain, fixed);
        };
        _getScale.byZoom = true;
        return _getScale;
      }
      return _constants.SCALE_FUNC[fixed ? 'linear' : scale]().domain(domain).range(fixed ? domain : range);
    }

    /**
     * Get longitude and latitude bounds of the data.
     */
  }, {
    key: "getPointsBounds",
    value: function getPointsBounds(dataContainer) {
      var getPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
      // no need to loop through the entire dataset
      // get a sample of data to calculate bounds
      var sampleData = dataContainer.numRows() > MAX_SAMPLE_SIZE ? (0, _utils.getSampleContainerData)(dataContainer, MAX_SAMPLE_SIZE) : dataContainer;
      var points = getPosition ? sampleData.mapIndex(getPosition) : [];
      var latBounds = (0, _utils.getLatLngBounds)(points, 1, [-90, 90]);
      var lngBounds = (0, _utils.getLatLngBounds)(points, 0, [-180, 180]);
      if (!latBounds || !lngBounds) {
        return null;
      }
      return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];
    }
  }, {
    key: "getChangedTriggers",
    value: function getChangedTriggers(dataUpdateTriggers) {
      var triggerChanged = (0, _layerUpdate.diffUpdateTriggers)(dataUpdateTriggers, this._oldDataUpdateTriggers);
      this._oldDataUpdateTriggers = dataUpdateTriggers;
      return triggerChanged;
    }
  }, {
    key: "getEncodedChannelValue",
    value: function getEncodedChannelValue(scale, data, field) {
      var nullValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.NO_VALUE_COLOR;
      var getValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultGetFieldValue;
      var value = getValue(field, data);
      if (!(0, _commonUtils.notNullorUndefined)(value)) {
        return nullValue;
      }
      var attributeValue;
      if (Array.isArray(value)) {
        attributeValue = value.map(scale);
      } else {
        attributeValue = scale(value);
      }
      if (!(0, _commonUtils.notNullorUndefined)(attributeValue)) {
        attributeValue = nullValue;
      }
      return attributeValue;
    }
  }, {
    key: "updateMeta",
    value: function updateMeta(meta) {
      this.meta = _objectSpread(_objectSpread({}, this.meta), meta);
    }
  }, {
    key: "getDataUpdateTriggers",
    value: function getDataUpdateTriggers(_ref10) {
      var filteredIndex = _ref10.filteredIndex,
        id = _ref10.id,
        dataContainer = _ref10.dataContainer;
      var columns = this.config.columns;
      return _objectSpread({
        getData: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns,
          filteredIndex: filteredIndex
        },
        getMeta: {
          datasetId: id,
          dataContainer: dataContainer,
          columns: columns
        }
      }, (this.config.textLabel || []).reduce(function (accu, tl, i) {
        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, "getLabelCharacterSet-".concat(i), tl.field ? tl.field.name : null));
      }, {}));
    }
  }, {
    key: "updateData",
    value: function updateData(datasets, oldLayerData) {
      if (!this.config.dataId) {
        return {};
      }
      var layerDataset = datasets[this.config.dataId];
      var dataContainer = layerDataset.dataContainer;
      var getPosition = this.getPositionAccessor(dataContainer, layerDataset);
      var dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);
      var triggerChanged = this.getChangedTriggers(dataUpdateTriggers);
      if (triggerChanged && (triggerChanged.getMeta || triggerChanged.getData)) {
        this.updateLayerMeta(layerDataset, getPosition);

        // reset filteredItemCount
        this.filteredItemCount = {};
      }
      var data = [];
      if (!(triggerChanged && triggerChanged.getData) && oldLayerData && oldLayerData.data) {
        // same data
        data = oldLayerData.data;
      } else {
        data = this.calculateDataAttribute(layerDataset, getPosition);
      }
      return {
        data: data,
        triggerChanged: triggerChanged
      };
    }

    /**
     * helper function to update one layer domain when state.data changed
     * if state.data change is due ot update filter, newFiler will be passed
     * called by updateAllLayerDomainData
     * @param datasets
     * @param newFilter
     * @returns layer
     */
  }, {
    key: "updateLayerDomain",
    value: function updateLayerDomain(datasets, newFilter) {
      var _this6 = this;
      var table = this.getDataset(datasets);
      if (!table) {
        return this;
      }
      Object.values(this.visualChannels).forEach(function (channel) {
        var scale = channel.scale;
        var scaleType = _this6.config[scale];
        // ordinal domain is based on dataContainer, if only filter changed
        // no need to update ordinal domain
        if (!newFilter || scaleType !== _constants.SCALE_TYPES.ordinal) {
          var domain = channel.domain;
          var updatedDomain = _this6.calculateLayerDomain(table, channel);
          _this6.updateLayerConfig((0, _defineProperty2["default"])({}, domain, updatedDomain));
        }
      });
      return this;
    }
  }, {
    key: "getDataset",
    value: function getDataset(datasets) {
      return this.config.dataId ? datasets[this.config.dataId] : null;
    }

    /**
     * Validate visual channel field and scales based on supported field & scale type
     * @param channel
     */
  }, {
    key: "validateVisualChannel",
    value: function validateVisualChannel(channel) {
      this.validateFieldType(channel);
      this.validateScale(channel);
    }

    /**
     * Validate field type based on channelScaleType
     */
  }, {
    key: "validateFieldType",
    value: function validateFieldType(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
        channelScaleType = visualChannel.channelScaleType,
        supportedFieldTypes = visualChannel.supportedFieldTypes;
      if (this.config[field]) {
        // if field is selected, check if field type is supported
        var channelSupportedFieldTypes = supportedFieldTypes || _constants.CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];
        if (!channelSupportedFieldTypes.includes(this.config[field].type)) {
          // field type is not supported, set it back to null
          // set scale back to default
          this.updateLayerConfig((0, _defineProperty2["default"])({}, field, null));
        }
      }
    }

    /**
     * Validate scale type based on aggregation
     */
  }, {
    key: "validateScale",
    value: function validateScale(channel) {
      var visualChannel = this.visualChannels[channel];
      var scale = visualChannel.scale;
      if (!scale) {
        // visualChannel doesn't have scale
        return;
      }
      var scaleOptions = this.getScaleOptions(channel);
      // check if current selected scale is
      // supported, if not, change to default
      if (!scaleOptions.includes(this.config[scale])) {
        this.updateLayerConfig((0, _defineProperty2["default"])({}, scale, scaleOptions[0]));
      }
    }

    /**
     * Get scale options based on current field
     * @param {string} channel
     * @returns {string[]}
     */
  }, {
    key: "getScaleOptions",
    value: function getScaleOptions(channel) {
      var visualChannel = this.visualChannels[channel];
      var field = visualChannel.field,
        scale = visualChannel.scale,
        channelScaleType = visualChannel.channelScaleType;
      return this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : [this.getDefaultLayerConfig({
        dataId: ''
      })[scale]];
    }
  }, {
    key: "updateLayerVisualChannel",
    value: function updateLayerVisualChannel(dataset, channel) {
      var visualChannel = this.visualChannels[channel];
      this.validateVisualChannel(channel);
      // calculate layer channel domain
      var updatedDomain = this.calculateLayerDomain(dataset, visualChannel);
      this.updateLayerConfig((0, _defineProperty2["default"])({}, visualChannel.domain, updatedDomain));
    }
  }, {
    key: "getVisualChannelUpdateTriggers",
    value: function getVisualChannelUpdateTriggers() {
      var _this7 = this;
      var updateTriggers = {};
      Object.values(this.visualChannels).forEach(function (visualChannel) {
        // field range scale domain
        var accessor = visualChannel.accessor,
          field = visualChannel.field,
          scale = visualChannel.scale,
          domain = visualChannel.domain,
          range = visualChannel.range,
          defaultValue = visualChannel.defaultValue,
          fixed = visualChannel.fixed;
        if (accessor) {
          updateTriggers[accessor] = _objectSpread((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])({}, field, _this7.config[field]), scale, _this7.config[scale]), domain, _this7.config[domain]), range, _this7.config.visConfig[range]), "defaultValue", typeof defaultValue === 'function' ? defaultValue(_this7.config) : defaultValue), fixed ? (0, _defineProperty2["default"])({}, fixed, _this7.config.visConfig[fixed]) : {});
        }
      });
      return updateTriggers;
    }
  }, {
    key: "calculateLayerDomain",
    value: function calculateLayerDomain(dataset, visualChannel) {
      var scale = visualChannel.scale;
      var scaleType = this.config[scale];
      var field = this.config[visualChannel.field];
      if (!field) {
        // if colorField or sizeField were set back to null
        return defaultDomain;
      }
      return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;
    }
  }, {
    key: "hasHoveredObject",
    value: function hasHoveredObject(objectInfo) {
      return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;
    }
  }, {
    key: "isLayerHovered",
    value: function isLayerHovered(objectInfo) {
      var _objectInfo$layer;
      return (objectInfo === null || objectInfo === void 0 ? void 0 : objectInfo.picked) && (objectInfo === null || objectInfo === void 0 || (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 || (_objectInfo$layer = _objectInfo$layer.props) === null || _objectInfo$layer === void 0 ? void 0 : _objectInfo$layer.id) === this.id;
    }
  }, {
    key: "getRadiusScaleByZoom",
    value: function getRadiusScaleByZoom(mapState, fixedRadius) {
      var radiusChannel = Object.values(this.visualChannels).find(function (vc) {
        return vc.property === 'radius';
      });
      if (!radiusChannel) {
        return 1;
      }
      var field = radiusChannel.field;
      var fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;
      var radius = this.config.visConfig.radius;
      return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);
    }
  }, {
    key: "shouldCalculateLayerData",
    value: function shouldCalculateLayerData(props) {
      var _this8 = this;
      return props.some(function (p) {
        return !_this8.noneLayerDataAffectingProps.includes(p);
      });
    }
  }, {
    key: "getBrushingExtensionProps",
    value: function getBrushingExtensionProps(interactionConfig, brushingTarget) {
      var brush = interactionConfig.brush;
      return {
        // brushing
        autoHighlight: !brush.enabled,
        brushingRadius: brush.config.size * 1000,
        brushingTarget: brushingTarget || 'source',
        brushingEnabled: brush.enabled
      };
    }
  }, {
    key: "getDefaultDeckLayerProps",
    value: function getDefaultDeckLayerProps(_ref12) {
      var idx = _ref12.idx,
        gpuFilter = _ref12.gpuFilter,
        mapState = _ref12.mapState,
        layerCallbacks = _ref12.layerCallbacks,
        visible = _ref12.visible;
      return {
        id: this.id,
        idx: idx,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT,
        pickable: true,
        wrapLongitude: true,
        parameters: {
          depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)
        },
        hidden: this.config.hidden,
        // visconfig
        opacity: this.config.visConfig.opacity,
        highlightColor: this.config.highlightColor,
        // data filtering
        extensions: [dataFilterExtension],
        filterRange: gpuFilter ? gpuFilter.filterRange : undefined,
        onFilteredItemsChange: gpuFilter ? layerCallbacks === null || layerCallbacks === void 0 ? void 0 : layerCallbacks.onFilteredItemsChange : undefined,
        // layer should be visible and if splitMap, shown in to one of panel
        visible: this.config.isVisible && visible
      };
    }
  }, {
    key: "getDefaultHoverLayerProps",
    value: function getDefaultHoverLayerProps() {
      return {
        id: "".concat(this.id, "-hovered"),
        pickable: false,
        wrapLongitude: true,
        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT
      };
    }
  }, {
    key: "renderTextLabelLayer",
    value: function renderTextLabelLayer(_ref13, renderOpts) {
      var _this9 = this;
      var getPosition = _ref13.getPosition,
        getFiltered = _ref13.getFiltered,
        getPixelOffset = _ref13.getPixelOffset,
        backgroundProps = _ref13.backgroundProps,
        updateTriggers = _ref13.updateTriggers,
        sharedProps = _ref13.sharedProps;
      var data = renderOpts.data,
        mapState = renderOpts.mapState;
      var textLabel = this.config.textLabel;
      var TextLayerClass = data.data instanceof arrow.Table ? _deckglArrowLayers.GeoArrowTextLayer : _layers.TextLayer;
      return data.textLabels.reduce(function (accu, d, i) {
        if (d.getText) {
          var _textLabel$i$field, _textLabel$i$field2;
          var background = textLabel[i].background || (backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.background);
          accu.push(
          // @ts-expect-error
          new TextLayerClass(_objectSpread(_objectSpread({}, sharedProps), {}, {
            id: "".concat(_this9.id, "-label-").concat((_textLabel$i$field = textLabel[i].field) === null || _textLabel$i$field === void 0 ? void 0 : _textLabel$i$field.name),
            data: data.data,
            visible: _this9.config.isVisible,
            getText: d.getText,
            getPosition: getPosition,
            getFiltered: getFiltered,
            characterSet: d.characterSet,
            getPixelOffset: getPixelOffset(textLabel[i]),
            getSize: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,
            sizeScale: textLabel[i].size,
            getTextAnchor: textLabel[i].anchor,
            getAlignmentBaseline: textLabel[i].alignment,
            getColor: textLabel[i].color,
            outlineWidth: textLabel[i].outlineWidth * _constants.TEXT_OUTLINE_MULTIPLIER,
            outlineColor: textLabel[i].outlineColor,
            background: background,
            getBackgroundColor: textLabel[i].backgroundColor,
            fontSettings: {
              sdf: textLabel[i].outlineWidth > 0
            },
            parameters: {
              // text will always show on top of all layers
              depthTest: false
            },
            getFilterValue: data.getFilterValue,
            updateTriggers: _objectSpread(_objectSpread({}, updateTriggers), {}, {
              getText: (_textLabel$i$field2 = textLabel[i].field) === null || _textLabel$i$field2 === void 0 ? void 0 : _textLabel$i$field2.name,
              getPixelOffset: _objectSpread(_objectSpread({}, updateTriggers.getRadius), {}, {
                mapState: mapState,
                anchor: textLabel[i].anchor,
                alignment: textLabel[i].alignment
              }),
              getTextAnchor: textLabel[i].anchor,
              getAlignmentBaseline: textLabel[i].alignment,
              getColor: textLabel[i].color
            }),
            _subLayerProps: _objectSpread({}, background ? {
              background: {
                parameters: {
                  cull: false
                }
              }
            } : null)
          })));
        }
        return accu;
      }, []);
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "calculateDataAttribute",
    value: function calculateDataAttribute(keplerTable, getPosition) {
      // implemented in subclasses
      return [];
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(dataset, getPosition) {
      // implemented in subclasses
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getPositionAccessor",
    value: function getPositionAccessor(_dataContainer,
    // TODO refactor for the next major version to pass only dataset
    _dataset) {
      // implemented in subclasses
      return function () {
        return null;
      };
    }
  }, {
    key: "getLegendVisualChannels",
    value: function getLegendVisualChannels() {
      return this.visualChannels;
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(dataset, foundLayers) {
      return {
        props: [],
        foundLayers: foundLayers
      };
    }

    /**
     * Given a array of preset required column names
     * found field that has the same name to set as layer column
     *
     * @param {object} defaultFields
     * @param {object[]} allFields
     * @returns {object[] | null} all possible required layer column pairs
     */
  }, {
    key: "findDefaultColumnField",
    value: function findDefaultColumnField(defaultFields, allFields) {
      // find all matched fields for each required col
      var requiredColumns = Object.keys(defaultFields).reduce(function (prev, key) {
        var requiredFields = allFields.filter(function (f) {
          return f.name === defaultFields[key] || defaultFields[key].includes(f.name);
        });
        prev[key] = requiredFields.length ? requiredFields.map(function (f) {
          return {
            value: f.name,
            fieldIdx: f.fieldIdx
          };
        }) : null;
        return prev;
      }, {});
      if (!Object.values(requiredColumns).every(Boolean)) {
        // if any field missing, return null
        return null;
      }
      return this.getAllPossibleColumnPairs(requiredColumns);
    }
  }, {
    key: "getAllPossibleColumnPairs",
    value: function getAllPossibleColumnPairs(requiredColumns) {
      // for multiple matched field for one required column, return multiple
      // combinations, e. g. if column a has 2 matched, column b has 3 matched
      // 6 possible column pairs will be returned
      var allKeys = Object.keys(requiredColumns);
      var pointers = allKeys.map(function (k, i) {
        return i === allKeys.length - 1 ? -1 : 0;
      });
      var countPerKey = allKeys.map(function (k) {
        return requiredColumns[k].length;
      });
      // TODO: Better typings
      var pairs = [];

      /* eslint-disable no-loop-func */
      while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {
        var newPair = pointers.reduce(function (prev, cuur, i) {
          prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];
          return prev;
        }, {});
        pairs.push(newPair);
      }
      /* eslint-enable no-loop-func */

      // recursively increment pointers
      function incrementPointers(pts, counts, index) {
        if (index === 0 && pts[0] === counts[0] - 1) {
          // nothing to increment
          return false;
        }
        if (pts[index] + 1 < counts[index]) {
          pts[index] = pts[index] + 1;
          return true;
        }
        pts[index] = 0;
        return incrementPointers(pts, counts, index - 1);
      }
      return pairs;
    }
  }, {
    key: "hexToRgb",
    value: function hexToRgb(c) {
      return (0, _utils.hexToRgb)(c);
    }
  }]);
}();
var _default = exports["default"] = Layer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY29yZSIsInJlcXVpcmUiLCJfZGVja2dsQXJyb3dMYXllcnMiLCJfZXh0ZW5zaW9ucyIsIl9sYXllcnMiLCJfd2luZG93IiwiX2tleW1pcnJvciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJhcnJvdyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2RlZmF1bHRMYXllckljb24iLCJfbGF5ZXJVcGRhdGUiLCJfbGF5ZXJVdGlscyIsIl9jb25zdGFudHMiLCJfdXRpbHMiLCJfY29tbW9uVXRpbHMiLCJfbWVtb2l6ZSIsIl9nZXRBcHBsaWNhdGlvbkNvbmZpZyIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsImUiLCJXZWFrTWFwIiwiciIsInQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZjMiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImkiLCJzZXQiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiQXJyYXkiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibGVuZ3RoIiwiX24iLCJGIiwicyIsImRvbmUiLCJ2YWx1ZSIsImYiLCJUeXBlRXJyb3IiLCJvIiwibmV4dCIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0Iiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfbWFya2VkIiwiX3JlZ2VuZXJhdG9yUnVudGltZTIiLCJtYXJrIiwiZ2VuZXJhdGVDb2xvciIsIkxBWUVSX0lEX0xFTkdUSCIsImV4cG9ydHMiLCJNQVhfU0FNUExFX1NJWkUiLCJkZWZhdWx0RG9tYWluIiwiZGF0YUZpbHRlckV4dGVuc2lvbiIsIkRhdGFGaWx0ZXJFeHRlbnNpb24iLCJmaWx0ZXJTaXplIiwiTUFYX0dQVV9GSUxURVJTIiwiY291bnRJdGVtcyIsImdldEFwcGxpY2F0aW9uQ29uZmlnIiwidXNlT25GaWx0ZXJlZEl0ZW1zQ2hhbmdlIiwiZGVmYXVsdERhdGFBY2Nlc3NvciIsImRjIiwiZCIsImlkZW50aXR5IiwiZGVmYXVsdEdldEZpZWxkVmFsdWUiLCJmaWVsZCIsInZhbHVlQWNjZXNzb3IiLCJPVkVSTEFZX1RZUEVfQ09OU1QiLCJrZXltaXJyb3IiLCJkZWNrZ2wiLCJtYXBib3hnbCIsImxheWVyQ29sb3JzIiwidmFsdWVzIiwiRGF0YVZpekNvbG9ycyIsIm1hcCIsImhleFRvUmdiIiwiaW5kZXgiLCJfcmVnZW5lcmF0b3IiLCJ3cmFwIiwiZ2VuZXJhdGVDb2xvciQiLCJfY29udGV4dCIsInByZXYiLCJzdG9wIiwiY29sb3JNYWtlciIsIkxheWVyIiwicHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2syIiwiaWQiLCJnZW5lcmF0ZUhhc2hJZCIsIm1ldGEiLCJ2aXNDb25maWdTZXR0aW5ncyIsImNvbmZpZyIsImdldERlZmF1bHRMYXllckNvbmZpZyIsImNvbHVtbk1vZGUiLCJzdXBwb3J0ZWRDb2x1bW5Nb2RlcyIsIl9zdXBwb3J0ZWRDb2x1bW5Nb2RlcyIsImtleSIsImNvbHVtbnMiLCJnZXRMYXllckNvbHVtbnMiLCJpc1ZhbGlkIiwiZXJyb3JNZXNzYWdlIiwiZmlsdGVyZWRJdGVtQ291bnQiLCJfY3JlYXRlQ2xhc3MyIiwiRGVmYXVsdExheWVySWNvbiIsInR5cGUiLCJyZWR1Y2UiLCJhY2MiLCJvYmoiLCJyZXF1aXJlZENvbHVtbnMiLCJjb25jYXQiLCJvcHRpb25hbENvbHVtbnMiLCJjb2xvciIsInByb3BlcnR5Iiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsIm51bGxWYWx1ZSIsIk5PX1ZBTFVFX0NPTE9SIiwiZGVmYXVsdFZhbHVlIiwic2l6ZSIsImxhdCIsInBhaXIiLCJmaWVsZFBhaXJLZXkiLCJsbmciLCJhbHRpdHVkZSIsImFsdCIsImxhdDAiLCJsbmcwIiwiYWx0MCIsImxhdDEiLCJsbmcxIiwiYWx0MSIsIl9wcm9wcyRpc1Zpc2libGUiLCJfcHJvcHMkaXNDb25maWdBY3RpdmUiLCJfcHJvcHMkaGlkZGVuIiwiZGF0YUlkIiwibGFiZWwiLCJERUZBVUxUX0xBWUVSX0xBQkVMIiwiaXNWaXNpYmxlIiwiaXNDb25maWdBY3RpdmUiLCJoaWdobGlnaHRDb2xvciIsIkRFRkFVTFRfSElHSExJR0hUX0NPTE9SIiwiaGlkZGVuIiwiY29sb3JGaWVsZCIsImNvbG9yRG9tYWluIiwiY29sb3JTY2FsZSIsIlNDQUxFX1RZUEVTIiwicXVhbnRpbGUiLCJzaXplRG9tYWluIiwic2l6ZVNjYWxlIiwibGluZWFyIiwic2l6ZUZpZWxkIiwidmlzQ29uZmlnIiwidGV4dExhYmVsIiwiREVGQVVMVF9URVhUX0xBQkVMIiwiY29sb3JVSSIsIkRFRkFVTFRfQ09MT1JfVUkiLCJjb2xvclJhbmdlIiwiYW5pbWF0aW9uIiwiZW5hYmxlZCIsImdldFZpc3VhbENoYW5uZWxEZXNjcmlwdGlvbiIsImNoYW5uZWwiLCJ2aXN1YWxDaGFubmVscyIsIm1lYXN1cmUiLCJ1bmRlZmluZWQiLCJyYW5nZVNldHRpbmdzIiwiZmllbGRTZXR0aW5ncyIsImRpc3BsYXlOYW1lIiwiZGVmYXVsdE1lYXN1cmUiLCJhc3NpZ25Db2x1bW4iLCJfdGhpcyRjb25maWckY29sdW1ucyIsInVwZGF0ZSIsImZpZWxkSWR4IiwiYXNzaWduQ29sdW1uUGFpcnMiLCJmaWVsZFBhaXJzIiwiX3RoaXMkY29sdW1uUGFpcnMiLCJfdGhpcyRjb2x1bW5QYWlyczIiLCJjb2x1bW5QYWlycyIsIl9yZWYiLCJ1cGRhdGVkQ29sdW1uIiwicGFydG5lcktleXMiLCJ0b0FycmF5IiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfdGhpcyRjb2x1bW5QYWlyczMiLCJfdGhpcyRjb2x1bW5QYWlyczQiLCJwYXJ0bmVyS2V5IiwiX3RoaXMkY29sdW1uUGFpcnM1IiwiZXJyIiwiZ2V0Wm9vbUZhY3RvciIsIl9yZWYyIiwiem9vbSIsIl9yZWYyJHpvb21PZmZzZXQiLCJ6b29tT2Zmc2V0IiwiTWF0aCIsInBvdyIsIm1heCIsImdldEVsZXZhdGlvblpvb21GYWN0b3IiLCJfcmVmMyIsIl9yZWYzJHpvb21PZmZzZXQiLCJfdGhpcyRjb25maWckdmlzQ29uZmkiLCJmaXhlZEhlaWdodCIsImVuYWJsZUVsZXZhdGlvblpvb21GYWN0b3IiLCJmb3JtYXRMYXllckRhdGEiLCJkYXRhc2V0cyIsIm9sZExheWVyRGF0YSIsImFuaW1hdGlvbkNvbmZpZyIsInJlbmRlckxheWVyIiwiZ2V0SG92ZXJEYXRhIiwib2JqZWN0IiwiZGF0YUNvbnRhaW5lciIsImZpZWxkcyIsImhvdmVySW5mbyIsInJvdyIsImdldEZpbHRlcmVkSXRlbUNvdW50IiwiZmlyc3RMYXllciIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJjb25maWdUb0NvcHkiLCJkZWZhdWx0TGF5ZXJQcm9wcyIsIl90aGlzIiwic2hhbGxvd0NvcHkiLCJ2Iiwibm90VG9Db3B5IiwiZ3JvdXAiLCJjdXJyZW50Q29uZmlnIiwiY29waWVkIiwiY29weUxheWVyQ29uZmlnIiwiX3NhdGlzZmllZENvbHVtbk1vZGUiLCJkYXRhc2V0Iiwic2F0aXNmaWVkQ29sdW1uTW9kZSIsImdldFNhdGlzZmllZENvbHVtbk1vZGUiLCJvcHRpb25zIiwiX3RvQ29uc3VtYWJsZUFycmF5MiIsImFsdFByb3BzIiwiZGVmYXVsdENvbHVtbkNvbmZpZyIsInVwZGF0ZUxheWVyQ29uZmlnIiwidmFsaWRhdGVWaXN1YWxDaGFubmVsIiwiX3RoaXMyIiwiX3JlZjQiLCJfcmVmNCRzaGFsbG93Q29weSIsIl9yZWY0JG5vdFRvQ29weSIsImlzUGxhaW5PYmplY3QiLCJpbmNsdWRlcyIsIm5vdE51bGxvclVuZGVmaW5lZCIsInJlZ2lzdGVyVmlzQ29uZmlnIiwibGF5ZXJWaXNDb25maWdzIiwiX3RoaXMzIiwiaXRlbSIsImNvbmZpZ0l0ZW0iLCJMQVlFUl9WSVNfQ09ORklHUyIsIl90eXBlb2YyIiwiZXZlcnkiLCJwIiwicHJvdG90eXBlIiwicHJvcHNDb2x1bW5zIiwiY29sdW1uVmFsaWRhdG9ycyIsInJlcXVpcmVkIiwicmVxdWlyZWRMYXllckNvbHVtbnMiLCJhY2N1IiwiX3Byb3BzQ29sdW1ucyRrZXkkdmFsIiwiX3Byb3BzQ29sdW1ucyRrZXkiLCJfcHJvcHNDb2x1bW5zJGtleSRmaWUiLCJfcHJvcHNDb2x1bW5zJGtleTIiLCJfcHJvcHNDb2x1bW5zJGtleSR2YWwyIiwiX3Byb3BzQ29sdW1ucyRrZXkzIiwiX3Byb3BzQ29sdW1ucyRrZXkkZmllMiIsIl9wcm9wc0NvbHVtbnMka2V5NCIsInZhbGlkYXRvciIsIm9wdGlvbmFsIiwiX3Byb3BzQ29sdW1ucyRrZXkkdmFsMyIsIl9wcm9wc0NvbHVtbnMka2V5NSIsIl9wcm9wc0NvbHVtbnMka2V5JGZpZTMiLCJfcHJvcHNDb2x1bW5zJGtleTYiLCJuZXdDb25maWciLCJ1cGRhdGVMYXllclZpc0NvbmZpZyIsIm5ld1Zpc0NvbmZpZyIsInVwZGF0ZUxheWVyQ29sb3JVSSIsInByb3AiLCJfdGhpcyRjb25maWciLCJwcmV2aW91cyIsImNvbG9yVUlQcm9wIiwiZW50cmllcyIsIl9yZWY1IiwiX3JlZjYiLCJfc2xpY2VkVG9BcnJheTIiLCJpc0NvbG9yUmFuZ2UiLCJjb2xvcnMiLCJ1cGRhdGVDb2xvclVJQnlDb2xvclJhbmdlIiwidXBkYXRlQ29sb3JSYW5nZUJ5Q29sb3JVSSIsInVwZGF0ZUN1c3RvbVBhbGV0dGUiLCJfbmV3Q29uZmlnJGNvbG9yUmFuZ2UiLCJfbmV3Q29uZmlnJGNvbG9yUmFuZ2UyIiwiY29sb3JSYW5nZUNvbmZpZyIsImN1c3RvbSIsImN1c3RvbUJyZWFrcyIsImN1c3RvbVBhbGV0dGUiLCJfdGhpcyRjb25maWcyIiwiY29sb3JNYXAiLCJjaGFubmVsS2V5IiwiZmluZCIsIkNvbnNvbGUiLCJ3YXJuIiwiaW5pdGlhbGl6ZUxheWVyQ29sb3JNYXAiLCJpbml0aWFsaXplQ3VzdG9tUGFsZXR0ZSIsIl9uZXdDb25maWckY3VzdG9tUGFsZSIsIl90aGlzJGNvbmZpZzMiLCJpc0N1c3RvbSIsImNhdGVnb3J5IiwiY3VzdG9tU3RlcHNDaGFuZ2VkIiwic2hvd0Ryb3Bkb3duIiwic3RlcHMiLCJyZXZlcnNlZCIsIkJvb2xlYW4iLCJzaG91bGRVcGRhdGUiLCJzb21lIiwiX3RoaXMkY29uZmlnNCIsImlzQ3VzdG9tQ29sb3JSZXZlcnNlZCIsInVwZGF0ZUN1c3RvbUNvbG9yUmFuZ2VCeUNvbG9yVUkiLCJ1cGRhdGVDb2xvclJhbmdlQnlNYXRjaGluZ1BhbGV0dGUiLCJoYXNDb2x1bW5WYWx1ZSIsImNvbHVtbiIsImhhc1JlcXVpcmVkQ29sdW1uIiwiaGFzQWxsQ29sdW1ucyIsIl90aGlzNCIsIl90aGlzJGNvbmZpZzUiLCJfY3VycmVudENvbHVtbk1vZGVzJHIiLCJjdXJyZW50Q29sdW1uTW9kZXMiLCJjb2xNb2RlIiwiY29sS2V5IiwiaGFzTGF5ZXJEYXRhIiwibGF5ZXJEYXRhIiwiZGF0YSIsIm51bVJvd3MiLCJpc1ZhbGlkVG9TYXZlIiwic2hvdWxkUmVuZGVyTGF5ZXIiLCJnZXRDb2xvclNjYWxlIiwiY3VzdG9tT3JkaW5hbCIsImdldENhdGVnb3JpY2FsQ29sb3JTY2FsZSIsImhhc0NvbG9yTWFwIiwiX2NvbG9yUmFuZ2UkY29sb3JNYXAiLCJjTWFwIiwiTWFwIiwiX3JlZjciLCJfcmVmOCIsImsiLCJzY2FsZVR5cGUiLCJvcmRpbmFsIiwiZ2V0U2NhbGVGdW5jdGlvbiIsInVua25vd24iLCJVTktOT1dOX0NPTE9SX0tFWSIsImdldFZpc0NoYW5uZWxTY2FsZSIsImFjY2Vzc1ZTRmllbGRWYWx1ZSIsIl9maWVsZCIsIl9pbmRleEtleSIsImdldEF0dHJpYnV0ZUFjY2Vzc29ycyIsIl9yZWY5IiwiX3RoaXM1IiwiX3JlZjkkZGF0YUFjY2Vzc29yIiwiZGF0YUFjY2Vzc29yIiwiaW5kZXhLZXkiLCJhdHRyaWJ1dGVBY2Nlc3NvcnMiLCJfdGhpczUkdmlzdWFsQ2hhbm5lbHMiLCJmaXhlZCIsImFjY2Vzc29yIiwiZ2V0QXR0cmlidXRlVmFsdWUiLCJzaG91bGRHZXRTY2FsZSIsImlzRml4ZWQiLCJzY2FsZUZ1bmN0aW9uIiwiZ2V0RmllbGRWYWx1ZSIsImJ5Wm9vbSIsIm1lbW9pemUiLCJ6Iiwic2NhbGVGdW5jIiwiZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZSIsImlzRG9tYWluUXVhbnRpbGUiLCJ6U3RlcHMiLCJnZXRTY2FsZSIsImdldFNjYWxlQnlab29tIiwic2NhbGVEb21haW4iLCJnZXREb21haW5TdGVwc2J5Wm9vbSIsInF1YW50aWxlcyIsInRocmVzaG9sZHMiLCJnZXRUaHJlc2hvbGRzRnJvbVF1YW50aWxlcyIsImlzRG9tYWluU3RvcHMiLCJzdG9wcyIsIlNDQUxFX0ZVTkMiLCJnZXRQb2ludHNCb3VuZHMiLCJnZXRQb3NpdGlvbiIsInNhbXBsZURhdGEiLCJnZXRTYW1wbGVDb250YWluZXJEYXRhIiwicG9pbnRzIiwibWFwSW5kZXgiLCJsYXRCb3VuZHMiLCJnZXRMYXRMbmdCb3VuZHMiLCJsbmdCb3VuZHMiLCJnZXRDaGFuZ2VkVHJpZ2dlcnMiLCJkYXRhVXBkYXRlVHJpZ2dlcnMiLCJ0cmlnZ2VyQ2hhbmdlZCIsImRpZmZVcGRhdGVUcmlnZ2VycyIsIl9vbGREYXRhVXBkYXRlVHJpZ2dlcnMiLCJnZXRWYWx1ZSIsImF0dHJpYnV0ZVZhbHVlIiwidXBkYXRlTWV0YSIsImdldERhdGFVcGRhdGVUcmlnZ2VycyIsIl9yZWYxMCIsImZpbHRlcmVkSW5kZXgiLCJnZXREYXRhIiwiZGF0YXNldElkIiwiZ2V0TWV0YSIsInRsIiwidXBkYXRlRGF0YSIsImxheWVyRGF0YXNldCIsImdldFBvc2l0aW9uQWNjZXNzb3IiLCJ1cGRhdGVMYXllck1ldGEiLCJjYWxjdWxhdGVEYXRhQXR0cmlidXRlIiwidXBkYXRlTGF5ZXJEb21haW4iLCJuZXdGaWx0ZXIiLCJfdGhpczYiLCJ0YWJsZSIsImdldERhdGFzZXQiLCJ1cGRhdGVkRG9tYWluIiwiY2FsY3VsYXRlTGF5ZXJEb21haW4iLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsInZhbGlkYXRlU2NhbGUiLCJ2aXN1YWxDaGFubmVsIiwic3VwcG9ydGVkRmllbGRUeXBlcyIsImNoYW5uZWxTdXBwb3J0ZWRGaWVsZFR5cGVzIiwiQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTIiwic2NhbGVPcHRpb25zIiwiZ2V0U2NhbGVPcHRpb25zIiwiRklFTERfT1BUUyIsInVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbCIsImdldFZpc3VhbENoYW5uZWxVcGRhdGVUcmlnZ2VycyIsIl90aGlzNyIsInVwZGF0ZVRyaWdnZXJzIiwiZ2V0Q29sdW1uTGF5ZXJEb21haW4iLCJoYXNIb3ZlcmVkT2JqZWN0Iiwib2JqZWN0SW5mbyIsImlzTGF5ZXJIb3ZlcmVkIiwiX29iamVjdEluZm8kbGF5ZXIiLCJwaWNrZWQiLCJsYXllciIsImdldFJhZGl1c1NjYWxlQnlab29tIiwibWFwU3RhdGUiLCJmaXhlZFJhZGl1cyIsInJhZGl1c0NoYW5uZWwiLCJ2YyIsInJhZGl1cyIsInNob3VsZENhbGN1bGF0ZUxheWVyRGF0YSIsIl90aGlzOCIsIm5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcyIsImdldEJydXNoaW5nRXh0ZW5zaW9uUHJvcHMiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImJydXNoaW5nVGFyZ2V0IiwiYnJ1c2giLCJhdXRvSGlnaGxpZ2h0IiwiYnJ1c2hpbmdSYWRpdXMiLCJicnVzaGluZ0VuYWJsZWQiLCJnZXREZWZhdWx0RGVja0xheWVyUHJvcHMiLCJfcmVmMTIiLCJpZHgiLCJncHVGaWx0ZXIiLCJsYXllckNhbGxiYWNrcyIsInZpc2libGUiLCJjb29yZGluYXRlU3lzdGVtIiwiQ09PUkRJTkFURV9TWVNURU0iLCJMTkdMQVQiLCJwaWNrYWJsZSIsIndyYXBMb25naXR1ZGUiLCJwYXJhbWV0ZXJzIiwiZGVwdGhUZXN0IiwiZHJhZ1JvdGF0ZSIsImVuYWJsZTNkIiwib3BhY2l0eSIsImV4dGVuc2lvbnMiLCJmaWx0ZXJSYW5nZSIsIm9uRmlsdGVyZWRJdGVtc0NoYW5nZSIsImdldERlZmF1bHRIb3ZlckxheWVyUHJvcHMiLCJyZW5kZXJUZXh0TGFiZWxMYXllciIsIl9yZWYxMyIsInJlbmRlck9wdHMiLCJfdGhpczkiLCJnZXRGaWx0ZXJlZCIsImdldFBpeGVsT2Zmc2V0IiwiYmFja2dyb3VuZFByb3BzIiwic2hhcmVkUHJvcHMiLCJUZXh0TGF5ZXJDbGFzcyIsIlRhYmxlIiwiR2VvQXJyb3dUZXh0TGF5ZXIiLCJUZXh0TGF5ZXIiLCJ0ZXh0TGFiZWxzIiwiZ2V0VGV4dCIsIl90ZXh0TGFiZWwkaSRmaWVsZCIsIl90ZXh0TGFiZWwkaSRmaWVsZDIiLCJiYWNrZ3JvdW5kIiwiY2hhcmFjdGVyU2V0IiwiZ2V0U2l6ZSIsIlBST0pFQ1RFRF9QSVhFTF9TSVpFX01VTFRJUExJRVIiLCJnZXRUZXh0QW5jaG9yIiwiYW5jaG9yIiwiZ2V0QWxpZ25tZW50QmFzZWxpbmUiLCJhbGlnbm1lbnQiLCJnZXRDb2xvciIsIm91dGxpbmVXaWR0aCIsIlRFWFRfT1VUTElORV9NVUxUSVBMSUVSIiwib3V0bGluZUNvbG9yIiwiZ2V0QmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZm9udFNldHRpbmdzIiwic2RmIiwiZ2V0RmlsdGVyVmFsdWUiLCJnZXRSYWRpdXMiLCJfc3ViTGF5ZXJQcm9wcyIsImN1bGwiLCJrZXBsZXJUYWJsZSIsIl9kYXRhQ29udGFpbmVyIiwiX2RhdGFzZXQiLCJnZXRMZWdlbmRWaXN1YWxDaGFubmVscyIsImZpbmREZWZhdWx0TGF5ZXJQcm9wcyIsImZvdW5kTGF5ZXJzIiwiZmluZERlZmF1bHRDb2x1bW5GaWVsZCIsImRlZmF1bHRGaWVsZHMiLCJhbGxGaWVsZHMiLCJyZXF1aXJlZEZpZWxkcyIsImdldEFsbFBvc3NpYmxlQ29sdW1uUGFpcnMiLCJhbGxLZXlzIiwicG9pbnRlcnMiLCJjb3VudFBlcktleSIsInBhaXJzIiwiaW5jcmVtZW50UG9pbnRlcnMiLCJuZXdQYWlyIiwiY3V1ciIsInB0cyIsImNvdW50cyIsImMiLCJfZGVmYXVsdCJdLCJzb3VyY2VzIjpbIi4uL3NyYy9iYXNlLWxheWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHtHZW9BcnJvd1RleHRMYXllcn0gZnJvbSAnQGtlcGxlci5nbC9kZWNrZ2wtYXJyb3ctbGF5ZXJzJztcbmltcG9ydCB7RGF0YUZpbHRlckV4dGVuc2lvbn0gZnJvbSAnQGRlY2suZ2wvZXh0ZW5zaW9ucyc7XG5pbXBvcnQge1RleHRMYXllcn0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzJztcbmltcG9ydCB7Y29uc29sZSBhcyBDb25zb2xlfSBmcm9tICdnbG9iYWwvd2luZG93JztcbmltcG9ydCBrZXltaXJyb3IgZnJvbSAna2V5bWlycm9yJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IERlZmF1bHRMYXllckljb24gZnJvbSAnLi9kZWZhdWx0LWxheWVyLWljb24nO1xuaW1wb3J0IHtkaWZmVXBkYXRlVHJpZ2dlcnN9IGZyb20gJy4vbGF5ZXItdXBkYXRlJztcbmltcG9ydCB7Z2V0U2F0aXNmaWVkQ29sdW1uTW9kZSwgRmluZERlZmF1bHRMYXllclByb3BzUmV0dXJuVmFsdWV9IGZyb20gJy4vbGF5ZXItdXRpbHMnO1xuXG5pbXBvcnQge1xuICBDSEFOTkVMX1NDQUxFUyxcbiAgQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTLFxuICBERUZBVUxUX0NPTE9SX1VJLFxuICBERUZBVUxUX0hJR0hMSUdIVF9DT0xPUixcbiAgREVGQVVMVF9MQVlFUl9MQUJFTCxcbiAgREVGQVVMVF9URVhUX0xBQkVMLFxuICBEYXRhVml6Q29sb3JzLFxuICBGSUVMRF9PUFRTLFxuICBMQVlFUl9WSVNfQ09ORklHUyxcbiAgTUFYX0dQVV9GSUxURVJTLFxuICBOT19WQUxVRV9DT0xPUixcbiAgUFJPSkVDVEVEX1BJWEVMX1NJWkVfTVVMVElQTElFUixcbiAgU0NBTEVfRlVOQyxcbiAgU0NBTEVfVFlQRVMsXG4gIFRFWFRfT1VUTElORV9NVUxUSVBMSUVSLFxuICBVTktOT1dOX0NPTE9SX0tFWVxufSBmcm9tICdAa2VwbGVyLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBEYXRhQ29udGFpbmVySW50ZXJmYWNlLFxuICBEb21haW5RdWFudGlsZXMsXG4gIGdldEFwcGxpY2F0aW9uQ29uZmlnLFxuICBnZXRMYXRMbmdCb3VuZHMsXG4gIGdldFNhbXBsZUNvbnRhaW5lckRhdGEsXG4gIGhhc0NvbG9yTWFwLFxuICBoZXhUb1JnYixcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNEb21haW5TdG9wcyxcbiAgdXBkYXRlQ29sb3JSYW5nZUJ5TWF0Y2hpbmdQYWxldHRlXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuaW1wb3J0IHtnZW5lcmF0ZUhhc2hJZCwgdG9BcnJheSwgbm90TnVsbG9yVW5kZWZpbmVkfSBmcm9tICdAa2VwbGVyLmdsL2NvbW1vbi11dGlscyc7XG5pbXBvcnQge0RhdGFzZXRzLCBHcHVGaWx0ZXIsIEtlcGxlclRhYmxlfSBmcm9tICdAa2VwbGVyLmdsL3RhYmxlJztcbmltcG9ydCB7XG4gIEFnZ3JlZ2F0ZWRCaW4sXG4gIENvbG9yUmFuZ2UsXG4gIENvbG9yVUksXG4gIEZpZWxkLFxuICBGaWx0ZXIsXG4gIEdldFZpc0NoYW5uZWxTY2FsZVJldHVyblR5cGUsXG4gIExheWVyVmlzQ29uZmlnU2V0dGluZ3MsXG4gIE1hcFN0YXRlLFxuICBBbmltYXRpb25Db25maWcsXG4gIEtlcGxlckxheWVyLFxuICBMYXllckJhc2VDb25maWcsXG4gIExheWVyQ29sdW1ucyxcbiAgTGF5ZXJDb2x1bW4sXG4gIENvbHVtblBhaXJzLFxuICBDb2x1bW5MYWJlbHMsXG4gIFN1cHBvcnRlZENvbHVtbk1vZGUsXG4gIEZpZWxkUGFpcixcbiAgTmVzdGVkUGFydGlhbCxcbiAgUkdCQ29sb3IsXG4gIFZhbHVlT2YsXG4gIFZpc3VhbENoYW5uZWwsXG4gIFZpc3VhbENoYW5uZWxzLFxuICBWaXN1YWxDaGFubmVsRG9tYWluLFxuICBWaXN1YWxDaGFubmVsRmllbGQsXG4gIFZpc3VhbENoYW5uZWxTY2FsZVxufSBmcm9tICdAa2VwbGVyLmdsL3R5cGVzJztcbmltcG9ydCB7XG4gIGdldFNjYWxlRnVuY3Rpb24sXG4gIGluaXRpYWxpemVMYXllckNvbG9yTWFwLFxuICBnZXRDYXRlZ29yaWNhbENvbG9yU2NhbGUsXG4gIHVwZGF0ZUN1c3RvbUNvbG9yUmFuZ2VCeUNvbG9yVUlcbn0gZnJvbSAnQGtlcGxlci5nbC91dGlscyc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gvbWVtb2l6ZSc7XG5pbXBvcnQge1xuICBpbml0aWFsaXplQ3VzdG9tUGFsZXR0ZSxcbiAgaXNEb21haW5RdWFudGlsZSxcbiAgZ2V0RG9tYWluU3RlcHNieVpvb20sXG4gIGdldFRocmVzaG9sZHNGcm9tUXVhbnRpbGVzXG59IGZyb20gJ0BrZXBsZXIuZ2wvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSB7XG4gIEFnZ3JlZ2F0ZWRCaW4sXG4gIExheWVyQmFzZUNvbmZpZyxcbiAgVmlzdWFsQ2hhbm5lbCxcbiAgVmlzdWFsQ2hhbm5lbHMsXG4gIFZpc3VhbENoYW5uZWxEb21haW4sXG4gIFZpc3VhbENoYW5uZWxGaWVsZCxcbiAgVmlzdWFsQ2hhbm5lbFNjYWxlXG59O1xuXG5leHBvcnQgdHlwZSBMYXllckJhc2VDb25maWdQYXJ0aWFsID0ge2RhdGFJZDogTGF5ZXJCYXNlQ29uZmlnWydkYXRhSWQnXX0gJiBQYXJ0aWFsPExheWVyQmFzZUNvbmZpZz47XG5cbmV4cG9ydCB0eXBlIExheWVyQ29sb3JDb25maWcgPSB7XG4gIGNvbG9yRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgY29sb3JEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGNvbG9yU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllclNpemVDb25maWcgPSB7XG4gIC8vIGNvbG9yIGJ5IHNpemUsIGRvbWFpbiBpcyBzZXQgYnkgZmlsdGVycywgZmllbGQsIHNjYWxlIHR5cGVcbiAgc2l6ZURvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgc2l6ZVNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG4gIHNpemVGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xufTtcbmV4cG9ydCB0eXBlIExheWVySGVpZ2h0Q29uZmlnID0ge1xuICBoZWlnaHRGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xuICBoZWlnaHREb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGhlaWdodFNjYWxlOiBWaXN1YWxDaGFubmVsU2NhbGU7XG59O1xuZXhwb3J0IHR5cGUgTGF5ZXJTdHJva2VDb2xvckNvbmZpZyA9IHtcbiAgc3Ryb2tlQ29sb3JGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xuICBzdHJva2VDb2xvckRvbWFpbjogVmlzdWFsQ2hhbm5lbERvbWFpbjtcbiAgc3Ryb2tlQ29sb3JTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xufTtcbmV4cG9ydCB0eXBlIExheWVyQ292ZXJhZ2VDb25maWcgPSB7XG4gIGNvdmVyYWdlRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgY292ZXJhZ2VEb21haW46IFZpc3VhbENoYW5uZWxEb21haW47XG4gIGNvdmVyYWdlU2NhbGU6IFZpc3VhbENoYW5uZWxTY2FsZTtcbn07XG5leHBvcnQgdHlwZSBMYXllclJhZGl1c0NvbmZpZyA9IHtcbiAgcmFkaXVzRmllbGQ6IFZpc3VhbENoYW5uZWxGaWVsZDtcbiAgcmFkaXVzRG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluO1xuICByYWRpdXNTY2FsZTogVmlzdWFsQ2hhbm5lbFNjYWxlO1xufTtcbmV4cG9ydCB0eXBlIExheWVyV2VpZ2h0Q29uZmlnID0ge1xuICB3ZWlnaHRGaWVsZDogVmlzdWFsQ2hhbm5lbEZpZWxkO1xufTtcblxuZXhwb3J0IHR5cGUgVmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uID0ge1xuICBsYWJlbDogc3RyaW5nO1xuICBtZWFzdXJlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG50eXBlIENvbHVtblZhbGlkYXRvciA9IChjb2x1bW46IExheWVyQ29sdW1uLCBjb2x1bW5zOiBMYXllckNvbHVtbnMsIGFsbEZpZWxkczogRmllbGRbXSkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IHR5cGUgVXBkYXRlVHJpZ2dlcnMgPSB7XG4gIFtrZXk6IHN0cmluZ106IFVwZGF0ZVRyaWdnZXI7XG59O1xuZXhwb3J0IHR5cGUgVXBkYXRlVHJpZ2dlciA9IHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcbmV4cG9ydCB0eXBlIExheWVyQm91bmRzID0gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbi8qKlxuICogQXBwcm94LiBudW1iZXIgb2YgcG9pbnRzIHRvIHNhbXBsZSBpbiBhIGxhcmdlIGRhdGEgc2V0XG4gKi9cbmV4cG9ydCBjb25zdCBMQVlFUl9JRF9MRU5HVEggPSA2O1xuXG5jb25zdCBNQVhfU0FNUExFX1NJWkUgPSA1MDAwO1xuY29uc3QgZGVmYXVsdERvbWFpbjogW251bWJlciwgbnVtYmVyXSA9IFswLCAxXTtcbmNvbnN0IGRhdGFGaWx0ZXJFeHRlbnNpb24gPSBuZXcgRGF0YUZpbHRlckV4dGVuc2lvbih7XG4gIGZpbHRlclNpemU6IE1BWF9HUFVfRklMVEVSUyxcbiAgLy8gYGNvdW50SXRlbXNgIG9wdGlvbi4gSXQgZW5hYmxlcyB0aGUgR1BVIHRvIHJlcG9ydCB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdGhhdCBwYXNzIHRoZSBmaWx0ZXIgY3JpdGVyaWEgdmlhIHRoZSBgb25GaWx0ZXJlZEl0ZW1zQ2hhbmdlYCBjYWxsYmFjay5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgdHlwZWRcbiAgY291bnRJdGVtczogZ2V0QXBwbGljYXRpb25Db25maWcoKS51c2VPbkZpbHRlcmVkSXRlbXNDaGFuZ2UgPz8gZmFsc2Vcbn0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jb25zdCBkZWZhdWx0RGF0YUFjY2Vzc29yID0gZGMgPT4gZCA9PiBkO1xuY29uc3QgaWRlbnRpdHkgPSBkID0+IGQ7XG4vLyBDYW4ndCB1c2UgZmllZFZhbHVlQWNjZXNvciBiZWNhdXNlIG5lZWQgdGhlIHJhdyBkYXRhIHRvIHJlbmRlciB0b29sdGlwXG4vLyBTSEFOOiBSZXZpc2l0IGhlcmVcbmV4cG9ydCBjb25zdCBkZWZhdWx0R2V0RmllbGRWYWx1ZSA9IChmaWVsZCwgZCkgPT4gZmllbGQudmFsdWVBY2Nlc3NvcihkKTtcblxuZXhwb3J0IGNvbnN0IE9WRVJMQVlfVFlQRV9DT05TVCA9IGtleW1pcnJvcih7XG4gIGRlY2tnbDogbnVsbCxcbiAgbWFwYm94Z2w6IG51bGxcbn0pO1xuXG5leHBvcnQgY29uc3QgbGF5ZXJDb2xvcnMgPSBPYmplY3QudmFsdWVzKERhdGFWaXpDb2xvcnMpLm1hcChoZXhUb1JnYik7XG5mdW5jdGlvbiogZ2VuZXJhdGVDb2xvcigpOiBHZW5lcmF0b3I8UkdCQ29sb3I+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgbGF5ZXJDb2xvcnMubGVuZ3RoICsgMSkge1xuICAgIGlmIChpbmRleCA9PT0gbGF5ZXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICAgIHlpZWxkIGxheWVyQ29sb3JzW2luZGV4KytdO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIExheWVySW5mb01vZGFsID0ge1xuICBpZDogc3RyaW5nO1xuICB0ZW1wbGF0ZTogUmVhY3QuRkM8dm9pZD47XG4gIG1vZGFsUHJvcHM6IHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbG9yTWFrZXIgPSBnZW5lcmF0ZUNvbG9yKCk7XG5cbmV4cG9ydCB0eXBlIEJhc2VMYXllckNvbnN0cnVjdG9yUHJvcHMgPSB7XG4gIGlkPzogc3RyaW5nO1xufSAmIExheWVyQmFzZUNvbmZpZ1BhcnRpYWw7XG5cbmNsYXNzIExheWVyIGltcGxlbWVudHMgS2VwbGVyTGF5ZXIge1xuICBpZDogc3RyaW5nO1xuICBtZXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB2aXNDb25maWdTZXR0aW5nczoge1xuICAgIFtrZXk6IHN0cmluZ106IFZhbHVlT2Y8TGF5ZXJWaXNDb25maWdTZXR0aW5ncz47XG4gIH07XG4gIGNvbmZpZzogTGF5ZXJCYXNlQ29uZmlnICYgUGFydGlhbDxMYXllckNvbG9yQ29uZmlnICYgTGF5ZXJTaXplQ29uZmlnPjtcbiAgLy8gVE9ETzogZGVmaW5lIF9vbGREYXRhVXBkYXRlVHJpZ2dlcnNcbiAgX29sZERhdGFVcGRhdGVUcmlnZ2VyczogYW55O1xuXG4gIGlzVmFsaWQ6IGJvb2xlYW47XG4gIGVycm9yTWVzc2FnZTogc3RyaW5nIHwgbnVsbDtcbiAgZmlsdGVyZWRJdGVtQ291bnQ6IHtcbiAgICBbZGVja0xheWVySWQ6IHN0cmluZ106IG51bWJlcjtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQmFzZUxheWVyQ29uc3RydWN0b3JQcm9wcykge1xuICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBnZW5lcmF0ZUhhc2hJZChMQVlFUl9JRF9MRU5HVEgpO1xuICAgIC8vIG1ldGFcbiAgICB0aGlzLm1ldGEgPSB7fTtcblxuICAgIC8vIHZpc0NvbmZpZ1NldHRpbmdzXG4gICAgdGhpcy52aXNDb25maWdTZXR0aW5ncyA9IHt9O1xuXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmdldERlZmF1bHRMYXllckNvbmZpZyhwcm9wcyk7XG5cbiAgICAvLyBzZXQgY29sdW1uTW9kZSBmcm9tIHN1cHBvcnRlZCBjb2x1bW5zXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5jb2x1bW5Nb2RlKSB7XG4gICAgICBjb25zdCB7c3VwcG9ydGVkQ29sdW1uTW9kZXN9ID0gdGhpcztcbiAgICAgIGlmIChzdXBwb3J0ZWRDb2x1bW5Nb2Rlcz8ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmNvbHVtbk1vZGUgPSBzdXBwb3J0ZWRDb2x1bW5Nb2Rlc1swXT8ua2V5O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGVuIHNldCBjb2x1bW4sIGNvbHVtbk1vZGUgc2hvdWxkIGFscmVhZHkgYmVlbiBzZXRcbiAgICB0aGlzLmNvbmZpZy5jb2x1bW5zID0gdGhpcy5nZXRMYXllckNvbHVtbnMocHJvcHMuY29sdW1ucyk7XG5cbiAgICAvLyBmYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbGF5ZXIgY2F1c2VkIGFuIGVycm9yLCBhbmQgd2FzIGRpc2FibGVkXG4gICAgdGhpcy5pc1ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG51bGw7XG4gICAgLy8gaXRlbSBjb3VudFxuICAgIHRoaXMuZmlsdGVyZWRJdGVtQ291bnQgPSB7fTtcbiAgfVxuXG4gIGdldCBsYXllckljb24oKTogUmVhY3QuRWxlbWVudFR5cGUge1xuICAgIHJldHVybiBEZWZhdWx0TGF5ZXJJY29uO1xuICB9XG5cbiAgZ2V0IG92ZXJsYXlUeXBlKCk6IGtleW9mIHR5cGVvZiBPVkVSTEFZX1RZUEVfQ09OU1Qge1xuICAgIHJldHVybiBPVkVSTEFZX1RZUEVfQ09OU1QuZGVja2dsO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0IGlzQWdncmVnYXRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgcmVxdWlyZWRMYXllckNvbHVtbnMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHtzdXBwb3J0ZWRDb2x1bW5Nb2Rlc30gPSB0aGlzO1xuICAgIGlmIChzdXBwb3J0ZWRDb2x1bW5Nb2Rlcykge1xuICAgICAgcmV0dXJuIHN1cHBvcnRlZENvbHVtbk1vZGVzLnJlZHVjZTxzdHJpbmdbXT4oXG4gICAgICAgIChhY2MsIG9iaikgPT4gKG9iai5yZXF1aXJlZENvbHVtbnMgPyBhY2MuY29uY2F0KG9iai5yZXF1aXJlZENvbHVtbnMpIDogYWNjKSxcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldCBvcHRpb25hbENvbHVtbnMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHtzdXBwb3J0ZWRDb2x1bW5Nb2Rlc30gPSB0aGlzO1xuICAgIGlmIChzdXBwb3J0ZWRDb2x1bW5Nb2Rlcykge1xuICAgICAgcmV0dXJuIHN1cHBvcnRlZENvbHVtbk1vZGVzLnJlZHVjZTxzdHJpbmdbXT4oXG4gICAgICAgIChhY2MsIG9iaikgPT4gKG9iai5vcHRpb25hbENvbHVtbnMgPyBhY2MuY29uY2F0KG9iai5vcHRpb25hbENvbHVtbnMpIDogYWNjKSxcbiAgICAgICAgW11cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldCBub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMoKSB7XG4gICAgcmV0dXJuIFsnbGFiZWwnLCAnb3BhY2l0eScsICd0aGlja25lc3MnLCAnaXNWaXNpYmxlJywgJ2hpZGRlbiddO1xuICB9XG5cbiAgZ2V0IHZpc3VhbENoYW5uZWxzKCk6IFZpc3VhbENoYW5uZWxzIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgcHJvcGVydHk6ICdjb2xvcicsXG4gICAgICAgIGZpZWxkOiAnY29sb3JGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAnY29sb3JTY2FsZScsXG4gICAgICAgIGRvbWFpbjogJ2NvbG9yRG9tYWluJyxcbiAgICAgICAgcmFuZ2U6ICdjb2xvclJhbmdlJyxcbiAgICAgICAga2V5OiAnY29sb3InLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5jb2xvcixcbiAgICAgICAgbnVsbFZhbHVlOiBOT19WQUxVRV9DT0xPUixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb25maWcgPT4gY29uZmlnLmNvbG9yXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBwcm9wZXJ0eTogJ3NpemUnLFxuICAgICAgICBmaWVsZDogJ3NpemVGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAnc2l6ZVNjYWxlJyxcbiAgICAgICAgZG9tYWluOiAnc2l6ZURvbWFpbicsXG4gICAgICAgIHJhbmdlOiAnc2l6ZVJhbmdlJyxcbiAgICAgICAga2V5OiAnc2l6ZScsXG4gICAgICAgIGNoYW5uZWxTY2FsZVR5cGU6IENIQU5ORUxfU0NBTEVTLnNpemUsXG4gICAgICAgIG51bGxWYWx1ZTogMCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldCBjb2x1bW5WYWxpZGF0b3JzKCk6IHtba2V5OiBzdHJpbmddOiBDb2x1bW5WYWxpZGF0b3J9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLypcbiAgICogQ29sdW1uIHBhaXJzIG1hcHMgbGF5ZXIgY29sdW1uIHRvIGEgc3BlY2lmaWMgZmllbGQgcGFpcnMsXG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBudWxsXG4gICAqL1xuICBnZXQgY29sdW1uUGFpcnMoKTogQ29sdW1uUGFpcnMgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2x1bW4gbGFiZWxzIGlmIGl0cyBkaWZmZXJlbnQgdGhhbiBjb2x1bW4ga2V5XG4gICAqL1xuICBnZXQgY29sdW1uTGFiZWxzKCk6IENvbHVtbkxhYmVscyB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgICogRGVmYXVsdCBwb2ludCBjb2x1bW4gcGFpcnMsIGNhbiBiZSB1c2VkIGZvciBwb2ludCBiYXNlZCBsYXllcnM6IHBvaW50LCBpY29uIGV0Yy5cbiAgICovXG4gIGdldCBkZWZhdWx0UG9pbnRDb2x1bW5QYWlycygpOiBDb2x1bW5QYWlycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdDoge3BhaXI6IFsnbG5nJywgJ2FsdGl0dWRlJ10sIGZpZWxkUGFpcktleTogJ2xhdCd9LFxuICAgICAgbG5nOiB7cGFpcjogWydsYXQnLCAnYWx0aXR1ZGUnXSwgZmllbGRQYWlyS2V5OiAnbG5nJ30sXG4gICAgICBhbHRpdHVkZToge3BhaXI6IFsnbG5nJywgJ2xhdCddLCBmaWVsZFBhaXJLZXk6ICdhbHRpdHVkZSd9XG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAqIERlZmF1bHQgbGluayBjb2x1bW4gcGFpcnMsIGNhbiBiZSB1c2VkIGZvciBsaW5rIGJhc2VkIGxheWVyczogYXJjLCBsaW5lIGV0Y1xuICAgKi9cbiAgZ2V0IGRlZmF1bHRMaW5rQ29sdW1uUGFpcnMoKTogQ29sdW1uUGFpcnMge1xuICAgIHJldHVybiB7XG4gICAgICBsYXQ6IHtwYWlyOiBbJ2xuZycsICdhbHQnXSwgZmllbGRQYWlyS2V5OiAnbGF0J30sXG4gICAgICBsbmc6IHtwYWlyOiBbJ2xhdCcsICdhbHQnXSwgZmllbGRQYWlyS2V5OiAnbG5nJ30sXG4gICAgICBhbHQ6IHtwYWlyOiBbJ2xuZycsICdsYXQnXSwgZmllbGRQYWlyS2V5OiAnYWx0aXR1ZGUnfSxcblxuICAgICAgbGF0MDoge3BhaXI6ICdsbmcwJywgZmllbGRQYWlyS2V5OiAnbGF0J30sXG4gICAgICBsbmcwOiB7cGFpcjogJ2xhdDAnLCBmaWVsZFBhaXJLZXk6ICdsbmcnfSxcbiAgICAgIGFsdDA6IHtwYWlyOiBbJ2xuZzAnLCAnbGF0MCddLCBmaWVsZFBhaXJLZXk6ICdhbHRpdHVkZSd9LFxuXG4gICAgICBsYXQxOiB7cGFpcjogJ2xuZzEnLCBmaWVsZFBhaXJLZXk6ICdsYXQnfSxcbiAgICAgIGxuZzE6IHtwYWlyOiAnbGF0MScsIGZpZWxkUGFpcktleTogJ2xuZyd9LFxuICAgICAgYWx0MToge3BhaXI6IFsnbG5nMScsICdsYXQxJ10sIGZpZWxkUGFpcktleTogJ2FsdGl0dWRlJ31cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFJlYWN0IGNvbXBvbmVudCBmb3IgdG8gcmVuZGVyIGxheWVyIGluc3RydWN0aW9ucyBpbiBhIG1vZGFsXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gYW4gb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqICByZXR1cm4ge1xuICAgKiAgICBpZDogJ2ljb25JbmZvJyxcbiAgICogICAgdGVtcGxhdGU6IEljb25JbmZvTW9kYWwsXG4gICAqICAgIG1vZGFsUHJvcHM6IHtcbiAgICogICAgICB0aXRsZTogJ0hvdyB0byBkcmF3IGljb25zJ1xuICAgKiAgIH07XG4gICAqIH1cbiAgICovXG4gIGdldCBsYXllckluZm9Nb2RhbCgpOiBMYXllckluZm9Nb2RhbCB8IFJlY29yZDxzdHJpbmcsIExheWVySW5mb01vZGFsPiB8IG51bGwge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hpY2ggY29sdW1uIG1vZGVzIHRoaXMgbGF5ZXIgc3VwcG9ydHNcbiAgICovXG4gIGdldCBzdXBwb3J0ZWRDb2x1bW5Nb2RlcygpOiBTdXBwb3J0ZWRDb2x1bW5Nb2RlW10gfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBzdXBwb3J0ZWREYXRhc2V0VHlwZXMoKTogc3RyaW5nW10gfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAqIEdpdmVuIGEgZGF0YXNldCwgYXV0b21hdGljYWxseSBmaW5kIHByb3BzIHRvIGNyZWF0ZSBsYXllciBiYXNlZCBvbiBpdFxuICAgKiBhbmQgcmV0dXJuIHRoZSBwcm9wcyBhbmQgcHJldmlvdXMgZm91bmQgbGF5ZXJzLlxuICAgKiBCeSBkZWZhdWx0LCBubyBsYXllcnMgd2lsbCBiZSBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyhcbiAgICBkYXRhc2V0OiBLZXBsZXJUYWJsZSxcbiAgICBmb3VuZExheWVycz86IGFueVtdXG4gICk6IEZpbmREZWZhdWx0TGF5ZXJQcm9wc1JldHVyblZhbHVlIHtcbiAgICByZXR1cm4ge3Byb3BzOiBbXSwgZm91bmRMYXllcnN9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgYXJyYXkgb2YgcHJlc2V0IHJlcXVpcmVkIGNvbHVtbiBuYW1lc1xuICAgKiBmb3VuZCBmaWVsZCB0aGF0IGhhcyB0aGUgc2FtZSBuYW1lIHRvIHNldCBhcyBsYXllciBjb2x1bW5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRGaWVsZHNcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gYWxsRmllbGRzXG4gICAqIEByZXR1cm5zIHtvYmplY3RbXSB8IG51bGx9IGFsbCBwb3NzaWJsZSByZXF1aXJlZCBsYXllciBjb2x1bW4gcGFpcnNcbiAgICovXG4gIHN0YXRpYyBmaW5kRGVmYXVsdENvbHVtbkZpZWxkKGRlZmF1bHRGaWVsZHMsIGFsbEZpZWxkcykge1xuICAgIC8vIGZpbmQgYWxsIG1hdGNoZWQgZmllbGRzIGZvciBlYWNoIHJlcXVpcmVkIGNvbFxuICAgIGNvbnN0IHJlcXVpcmVkQ29sdW1ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRGaWVsZHMpLnJlZHVjZSgocHJldiwga2V5KSA9PiB7XG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IGFsbEZpZWxkcy5maWx0ZXIoXG4gICAgICAgIGYgPT4gZi5uYW1lID09PSBkZWZhdWx0RmllbGRzW2tleV0gfHwgZGVmYXVsdEZpZWxkc1trZXldLmluY2x1ZGVzKGYubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIHByZXZba2V5XSA9IHJlcXVpcmVkRmllbGRzLmxlbmd0aFxuICAgICAgICA/IHJlcXVpcmVkRmllbGRzLm1hcChmID0+ICh7XG4gICAgICAgICAgICB2YWx1ZTogZi5uYW1lLFxuICAgICAgICAgICAgZmllbGRJZHg6IGYuZmllbGRJZHhcbiAgICAgICAgICB9KSlcbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKHJlcXVpcmVkQ29sdW1ucykuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgIC8vIGlmIGFueSBmaWVsZCBtaXNzaW5nLCByZXR1cm4gbnVsbFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsUG9zc2libGVDb2x1bW5QYWlycyhyZXF1aXJlZENvbHVtbnMpO1xuICB9XG5cbiAgc3RhdGljIGdldEFsbFBvc3NpYmxlQ29sdW1uUGFpcnMocmVxdWlyZWRDb2x1bW5zKSB7XG4gICAgLy8gZm9yIG11bHRpcGxlIG1hdGNoZWQgZmllbGQgZm9yIG9uZSByZXF1aXJlZCBjb2x1bW4sIHJldHVybiBtdWx0aXBsZVxuICAgIC8vIGNvbWJpbmF0aW9ucywgZS4gZy4gaWYgY29sdW1uIGEgaGFzIDIgbWF0Y2hlZCwgY29sdW1uIGIgaGFzIDMgbWF0Y2hlZFxuICAgIC8vIDYgcG9zc2libGUgY29sdW1uIHBhaXJzIHdpbGwgYmUgcmV0dXJuZWRcbiAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXMocmVxdWlyZWRDb2x1bW5zKTtcbiAgICBjb25zdCBwb2ludGVycyA9IGFsbEtleXMubWFwKChrLCBpKSA9PiAoaSA9PT0gYWxsS2V5cy5sZW5ndGggLSAxID8gLTEgOiAwKSk7XG4gICAgY29uc3QgY291bnRQZXJLZXkgPSBhbGxLZXlzLm1hcChrID0+IHJlcXVpcmVkQ29sdW1uc1trXS5sZW5ndGgpO1xuICAgIC8vIFRPRE86IEJldHRlciB0eXBpbmdzXG4gICAgY29uc3QgcGFpcnM6IGFueVtdID0gW107XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICB3aGlsZSAoaW5jcmVtZW50UG9pbnRlcnMocG9pbnRlcnMsIGNvdW50UGVyS2V5LCBwb2ludGVycy5sZW5ndGggLSAxKSkge1xuICAgICAgY29uc3QgbmV3UGFpciA9IHBvaW50ZXJzLnJlZHVjZSgocHJldiwgY3V1ciwgaSkgPT4ge1xuICAgICAgICBwcmV2W2FsbEtleXNbaV1dID0gcmVxdWlyZWRDb2x1bW5zW2FsbEtleXNbaV1dW2N1dXJdO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcGFpcnMucHVzaChuZXdQYWlyKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGluY3JlbWVudCBwb2ludGVyc1xuICAgIGZ1bmN0aW9uIGluY3JlbWVudFBvaW50ZXJzKHB0cywgY291bnRzLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmIHB0c1swXSA9PT0gY291bnRzWzBdIC0gMSkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGluY3JlbWVudFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwdHNbaW5kZXhdICsgMSA8IGNvdW50c1tpbmRleF0pIHtcbiAgICAgICAgcHRzW2luZGV4XSA9IHB0c1tpbmRleF0gKyAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHRzW2luZGV4XSA9IDA7XG4gICAgICByZXR1cm4gaW5jcmVtZW50UG9pbnRlcnMocHRzLCBjb3VudHMsIGluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgc3RhdGljIGhleFRvUmdiKGMpIHtcbiAgICByZXR1cm4gaGV4VG9SZ2IoYyk7XG4gIH1cblxuICBnZXREZWZhdWx0TGF5ZXJDb25maWcoXG4gICAgcHJvcHM6IExheWVyQmFzZUNvbmZpZ1BhcnRpYWxcbiAgKTogTGF5ZXJCYXNlQ29uZmlnICYgUGFydGlhbDxMYXllckNvbG9yQ29uZmlnICYgTGF5ZXJTaXplQ29uZmlnPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFJZDogcHJvcHMuZGF0YUlkLFxuICAgICAgbGFiZWw6IHByb3BzLmxhYmVsIHx8IERFRkFVTFRfTEFZRVJfTEFCRUwsXG4gICAgICBjb2xvcjogcHJvcHMuY29sb3IgfHwgY29sb3JNYWtlci5uZXh0KCkudmFsdWUsXG4gICAgICAvLyBzZXQgY29sdW1ucyBsYXRlclxuICAgICAgY29sdW1uczoge30sXG4gICAgICBpc1Zpc2libGU6IHByb3BzLmlzVmlzaWJsZSA/PyB0cnVlLFxuICAgICAgaXNDb25maWdBY3RpdmU6IHByb3BzLmlzQ29uZmlnQWN0aXZlID8/IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0Q29sb3I6IHByb3BzLmhpZ2hsaWdodENvbG9yIHx8IERFRkFVTFRfSElHSExJR0hUX0NPTE9SLFxuICAgICAgaGlkZGVuOiBwcm9wcy5oaWRkZW4gPz8gZmFsc2UsXG5cbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgaW50byBzZXBhcmF0ZSB2aXN1YWwgQ2hhbm5lbCBjb25maWdcbiAgICAgIC8vIGNvbG9yIGJ5IGZpZWxkLCBkb21haW4gaXMgc2V0IGJ5IGZpbHRlcnMsIGZpZWxkLCBzY2FsZSB0eXBlXG4gICAgICBjb2xvckZpZWxkOiBudWxsLFxuICAgICAgY29sb3JEb21haW46IFswLCAxXSxcbiAgICAgIGNvbG9yU2NhbGU6IFNDQUxFX1RZUEVTLnF1YW50aWxlLFxuXG4gICAgICAvLyBjb2xvciBieSBzaXplLCBkb21haW4gaXMgc2V0IGJ5IGZpbHRlcnMsIGZpZWxkLCBzY2FsZSB0eXBlXG4gICAgICBzaXplRG9tYWluOiBbMCwgMV0sXG4gICAgICBzaXplU2NhbGU6IFNDQUxFX1RZUEVTLmxpbmVhcixcbiAgICAgIHNpemVGaWVsZDogbnVsbCxcblxuICAgICAgdmlzQ29uZmlnOiB7fSxcblxuICAgICAgdGV4dExhYmVsOiBbREVGQVVMVF9URVhUX0xBQkVMXSxcblxuICAgICAgY29sb3JVSToge1xuICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUl9VSSxcbiAgICAgICAgY29sb3JSYW5nZTogREVGQVVMVF9DT0xPUl9VSVxuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjoge2VuYWJsZWQ6IGZhbHNlfSxcbiAgICAgIC4uLihwcm9wcy5jb2x1bW5Nb2RlID8ge2NvbHVtbk1vZGU6IHByb3BzLmNvbHVtbk1vZGV9IDoge30pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc2NyaXB0aW9uIG9mIGEgdmlzdWFsQ2hhbm5lbCBjb25maWdcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uKGtleTogc3RyaW5nKTogVmlzdWFsQ2hhbm5lbERlc2NyaXB0aW9uIHtcbiAgICAvLyBlLmcuIGxhYmVsOiBDb2xvciwgbWVhc3VyZTogVmVoaWNsZSBUeXBlXG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMudmlzdWFsQ2hhbm5lbHNba2V5XTtcbiAgICBpZiAoIWNoYW5uZWwpIHJldHVybiB7bGFiZWw6ICcnLCBtZWFzdXJlOiB1bmRlZmluZWR9O1xuICAgIGNvbnN0IHJhbmdlU2V0dGluZ3MgPSB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW2NoYW5uZWwucmFuZ2VdO1xuICAgIGNvbnN0IGZpZWxkU2V0dGluZ3MgPSB0aGlzLmNvbmZpZ1tjaGFubmVsLmZpZWxkXTtcbiAgICBjb25zdCBsYWJlbCA9IHJhbmdlU2V0dGluZ3M/LmxhYmVsO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nID8gbGFiZWwodGhpcy5jb25maWcpIDogbGFiZWwgfHwgJycsXG4gICAgICBtZWFzdXJlOiBmaWVsZFNldHRpbmdzXG4gICAgICAgID8gZmllbGRTZXR0aW5ncy5kaXNwbGF5TmFtZSB8fCBmaWVsZFNldHRpbmdzLm5hbWVcbiAgICAgICAgOiBjaGFubmVsLmRlZmF1bHRNZWFzdXJlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBmaWVsZCB0byBsYXllciBjb2x1bW4sIHJldHVybiBjb2x1bW4gY29uZmlnXG4gICAqL1xuICBhc3NpZ25Db2x1bW4oa2V5OiBzdHJpbmcsIGZpZWxkOiB7bmFtZTogc3RyaW5nOyBmaWVsZElkeDogbnVtYmVyfSk6IExheWVyQ29sdW1ucyB7XG4gICAgLy8gZmllbGQgdmFsdWUgY291bGQgYmUgbnVsbCBmb3Igb3B0aW9uYWwgY29sdW1uc1xuICAgIGNvbnN0IHVwZGF0ZSA9IGZpZWxkXG4gICAgICA/IHtcbiAgICAgICAgICB2YWx1ZTogZmllbGQubmFtZSxcbiAgICAgICAgICBmaWVsZElkeDogZmllbGQuZmllbGRJZHhcbiAgICAgICAgfVxuICAgICAgOiB7dmFsdWU6IG51bGwsIGZpZWxkSWR4OiAtMX07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25maWcuY29sdW1ucyxcbiAgICAgIFtrZXldOiB7XG4gICAgICAgIC4uLnRoaXMuY29uZmlnLmNvbHVtbnM/LltrZXldLFxuICAgICAgICAuLi51cGRhdGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBhIGZpZWxkIHBhaXIgdG8gY29sdW1uIGNvbmZpZywgcmV0dXJuIGNvbHVtbiBjb25maWdcbiAgICovXG4gIGFzc2lnbkNvbHVtblBhaXJzKGtleTogc3RyaW5nLCBmaWVsZFBhaXJzOiBGaWVsZFBhaXIpOiBMYXllckNvbHVtbnMge1xuICAgIGlmICghdGhpcy5jb2x1bW5QYWlycyB8fCAhdGhpcy5jb2x1bW5QYWlycz8uW2tleV0pIHtcbiAgICAgIC8vIHNob3VsZCBub3QgZW5kIGluIHRoaXMgc3RhdGVcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5jb2x1bW5zO1xuICAgIH1cbiAgICAvLyBrZXkgPSAnbGF0J1xuICAgIGNvbnN0IHtwYWlyLCBmaWVsZFBhaXJLZXl9ID0gdGhpcy5jb2x1bW5QYWlycz8uW2tleV0gfHwge307XG5cbiAgICBpZiAodHlwZW9mIGZpZWxkUGFpcktleSA9PT0gJ3N0cmluZycgJiYgIWZpZWxkUGFpcnNbZmllbGRQYWlyS2V5XSkge1xuICAgICAgLy8gZG8gbm90IGFsbG93IGBrZXk6IHVuZGVmaW5lZGAgdG8gY3JlZXAgaW50byB0aGUgYHVwZGF0ZWRDb2x1bW5gIG9iamVjdFxuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgLy8gcGFpciA9IFsnbG5nJywgJ2FsdF0gfCAnbG5nJ1xuICAgIGNvbnN0IHVwZGF0ZWRDb2x1bW4gPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZy5jb2x1bW5zLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmaWVsZFBhaXJLZXkgY2FuIGJlIHN0cmluZ1tdIGhlcmU/XG4gICAgICBba2V5XTogZmllbGRQYWlyc1tmaWVsZFBhaXJLZXldXG4gICAgfTtcblxuICAgIGNvbnN0IHBhcnRuZXJLZXlzID0gdG9BcnJheShwYWlyKTtcbiAgICBmb3IgKGNvbnN0IHBhcnRuZXJLZXkgb2YgcGFydG5lcktleXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5jb25maWcuY29sdW1uc1twYXJ0bmVyS2V5XSAmJlxuICAgICAgICB0aGlzLmNvbHVtblBhaXJzPy5bcGFydG5lcktleV0gJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmaWVsZFBhaXJzW3RoaXMuY29sdW1uUGFpcnM/LltwYXJ0bmVyS2V5XS5maWVsZFBhaXJLZXldXG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB1cGRhdGVkQ29sdW1uW3BhcnRuZXJLZXldID0gZmllbGRQYWlyc1t0aGlzLmNvbHVtblBhaXJzPy5bcGFydG5lcktleV0uZmllbGRQYWlyS2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZENvbHVtbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYSByYWRpdXMgem9vbSBtdWx0aXBsaWVyIHRvIHJlbmRlciBwb2ludHMsIHNvIHRoZXkgYXJlIHZpc2libGUgaW4gYWxsIHpvb20gbGV2ZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IG1hcFN0YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXBTdGF0ZS56b29tIC0gYWN0dWFsIHpvb21cbiAgICogQHBhcmFtIHtudW1iZXIgfCB2b2lkfSBtYXBTdGF0ZS56b29tT2Zmc2V0IC0gem9vbU9mZnNldCB3aGVuIHJlbmRlciBpbiB0aGUgcGxvdCBjb250YWluZXIgZm9yIGV4cG9ydCBpbWFnZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Wm9vbUZhY3Rvcih7em9vbSwgem9vbU9mZnNldCA9IDB9KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGgubWF4KDE0IC0gem9vbSArIHpvb21PZmZzZXQsIDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYSBlbGV2YXRpb24gem9vbSBtdWx0aXBsaWVyIHRvIHJlbmRlciBwb2ludHMsIHNvIHRoZXkgYXJlIHZpc2libGUgaW4gYWxsIHpvb20gbGV2ZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IG1hcFN0YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXBTdGF0ZS56b29tIC0gYWN0dWFsIHpvb21cbiAgICogQHBhcmFtIHtudW1iZXI9fSBtYXBTdGF0ZS56b29tT2Zmc2V0IC0gem9vbU9mZnNldCB3aGVuIHJlbmRlciBpbiB0aGUgcGxvdCBjb250YWluZXIgZm9yIGV4cG9ydCBpbWFnZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0RWxldmF0aW9uWm9vbUZhY3Rvcih7em9vbSwgem9vbU9mZnNldCA9IDB9OiB7em9vbTogbnVtYmVyOyB6b29tT2Zmc2V0PzogbnVtYmVyfSk6IG51bWJlciB7XG4gICAgLy8gZW5hYmxlRWxldmF0aW9uWm9vbUZhY3RvciBpcyB1c2VkIHRvIHN1cHBvcnQgZXhpc3RpbmcgbWFwc1xuICAgIGNvbnN0IHtmaXhlZEhlaWdodCwgZW5hYmxlRWxldmF0aW9uWm9vbUZhY3Rvcn0gPSB0aGlzLmNvbmZpZy52aXNDb25maWc7XG4gICAgcmV0dXJuIGZpeGVkSGVpZ2h0IHx8IGVuYWJsZUVsZXZhdGlvblpvb21GYWN0b3IgPT09IGZhbHNlXG4gICAgICA/IDFcbiAgICAgIDogTWF0aC5wb3coMiwgTWF0aC5tYXgoOCAtIHpvb20gKyB6b29tT2Zmc2V0LCAwKSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGZvcm1hdExheWVyRGF0YShkYXRhc2V0czogRGF0YXNldHMsIG9sZExheWVyRGF0YT86IHVua25vd24sIGFuaW1hdGlvbkNvbmZpZz86IEFuaW1hdGlvbkNvbmZpZykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmVuZGVyTGF5ZXIoLi4uYXJnczogYW55W10pOiBhbnlbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBnZXRIb3ZlckRhdGEoXG4gICAgb2JqZWN0OiBhbnksXG4gICAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZmllbGRzPzogRmllbGRbXSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYW5pbWF0aW9uQ29uZmlnPzogQW5pbWF0aW9uQ29uZmlnLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBob3ZlckluZm8/OiB7aW5kZXg6IG51bWJlcn1cbiAgKTogYW55IHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgZWFjaCBlbnRyeSBvZiBsYXllckRhdGEgc2hvdWxkIGhhdmUgYW4gaW5kZXggb2YgYSByb3cgaW4gdGhlIG9yaWdpbmFsIGRhdGEgY29udGFpbmVyLlxuICAgIC8vIEVhY2ggbGF5ZXIgY2FuIGltcGxlbWVudCBpdHMgb3duIGdldEhvdmVyRGF0YSBtZXRob2RcbiAgICByZXR1cm4gZGF0YUNvbnRhaW5lci5yb3cob2JqZWN0LmluZGV4KTtcbiAgfVxuXG4gIGdldEZpbHRlcmVkSXRlbUNvdW50KCk6IG51bWJlciB8IG51bGwge1xuICAgIC8vIHVzZSBmaXJzdCBsYXllclxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmZpbHRlcmVkSXRlbUNvdW50KS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0TGF5ZXIgPSBPYmplY3Qua2V5cyh0aGlzLmZpbHRlcmVkSXRlbUNvdW50KVswXTtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkSXRlbUNvdW50W2ZpcnN0TGF5ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2hlbiBjaGFuZ2UgbGF5ZXIgdHlwZSwgdHJ5IHRvIGNvcHkgb3ZlciBsYXllciBjb25maWdzIGFzIG11Y2ggYXMgcG9zc2libGVcbiAgICogQHBhcmFtIGNvbmZpZ1RvQ29weSAtIGNvbmZpZyB0byBjb3B5IG92ZXJcbiAgICogQHBhcmFtIHZpc0NvbmZpZ1NldHRpbmdzIC0gdmlzQ29uZmlnIHNldHRpbmdzIG9mIGNvbmZpZyB0byBjb3B5XG4gICAqIEBwYXJhbSBkYXRhc2V0cyAtIGN1cnJlbnQgZGF0YXNldHMuXG4gICAqIEBwYXJhbSBkZWZhdWx0TGF5ZXJQcm9wcyAtIGRlZmF1bHQgbGF5ZXIgY3JlYXRpb24gY29uZmlndXJhdGlvbnMgZm9yIGN1cnJlbnQgbGF5ZXIgYW5kIGRhdGFzZXRzLlxuICAgKi9cbiAgYXNzaWduQ29uZmlnVG9MYXllcihcbiAgICBjb25maWdUb0NvcHk6IExheWVyQmFzZUNvbmZpZyAmIFBhcnRpYWw8TGF5ZXJDb2xvckNvbmZpZyAmIExheWVyU2l6ZUNvbmZpZz4sXG4gICAgdmlzQ29uZmlnU2V0dGluZ3M6IHtba2V5OiBzdHJpbmddOiBWYWx1ZU9mPExheWVyVmlzQ29uZmlnU2V0dGluZ3M+fSxcbiAgICBkYXRhc2V0cz86IERhdGFzZXRzLFxuICAgIGRlZmF1bHRMYXllclByb3BzPzogRmluZERlZmF1bHRMYXllclByb3BzUmV0dXJuVmFsdWUgfCBudWxsXG4gICkge1xuICAgIC8vIGRvbid0IGRlZXAgbWVyZ2UgdmlzdWFsQ2hhbm5lbCBmaWVsZFxuICAgIC8vIGRvbid0IGRlZXAgbWVyZ2UgY29sb3IgcmFuZ2UsIHJldmVyc2VkOiBpcyBub3QgYSBrZXkgYnkgZGVmYXVsdFxuICAgIGNvbnN0IHNoYWxsb3dDb3B5ID0gWydjb2xvclJhbmdlJywgJ3N0cm9rZUNvbG9yUmFuZ2UnXS5jb25jYXQoXG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLm1hcCh2ID0+IHYuZmllbGQpXG4gICAgKTtcblxuICAgIC8vIGRvbid0IGNvcHkgb3ZlciBkb21haW4gYW5kIGFuaW1hdGlvblxuICAgIGNvbnN0IG5vdFRvQ29weSA9IFsnYW5pbWF0aW9uJ10uY29uY2F0KE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykubWFwKHYgPT4gdi5kb21haW4pKTtcbiAgICAvLyBpZiByYW5nZSBpcyBmb3IgdGhlIHNhbWUgcHJvcGVydHkgZ3JvdXAgY29weSBpdCwgb3RoZXJ3aXNlLCBub3QgdG8gY29weVxuICAgIE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZm9yRWFjaCh2ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgY29uZmlnVG9Db3B5LnZpc0NvbmZpZ1t2LnJhbmdlXSAmJlxuICAgICAgICB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdICYmXG4gICAgICAgIHZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdLmdyb3VwICE9PSB0aGlzLnZpc0NvbmZpZ1NldHRpbmdzW3YucmFuZ2VdLmdyb3VwXG4gICAgICApIHtcbiAgICAgICAgbm90VG9Db3B5LnB1c2godi5yYW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBkb24ndCBjb3B5IG92ZXIgdmlzdWFsQ2hhbm5lbCByYW5nZVxuICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBjb3BpZWQgPSB0aGlzLmNvcHlMYXllckNvbmZpZyhjdXJyZW50Q29uZmlnLCBjb25maWdUb0NvcHksIHtcbiAgICAgIHNoYWxsb3dDb3B5LFxuICAgICAgbm90VG9Db3B5XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgY29sdW1Ob2RlIGJhc2VkIG9uIG5ldyBjb2x1bW5zXG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbHVtbk1vZGUgJiYgdGhpcy5zdXBwb3J0ZWRDb2x1bW5Nb2Rlcykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzPy5bdGhpcy5jb25maWcuZGF0YUlkXTtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGEgbW9kZSB3aXRoIGFsbCByZXF1aWVkIGNvbHVtbnMgZnJvbSB0aGUgc291cmNlIGNvbmZpZ1xuICAgICAgbGV0IHNhdGlzZmllZENvbHVtbk1vZGUgPSBnZXRTYXRpc2ZpZWRDb2x1bW5Nb2RlKFxuICAgICAgICB0aGlzLnN1cHBvcnRlZENvbHVtbk1vZGVzLFxuICAgICAgICBjb3BpZWQuY29sdW1ucyxcbiAgICAgICAgZGF0YXNldD8uZmllbGRzXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBubyBzdWl0YWJsZSBjb2x1bW4gbW9kZSBmb3VuZCBvciBubyBzdWNoIGNvbHVtTW9kZSBleGlzdHMgZm9yIHRoZSBsYXllclxuICAgICAgLy8gdGhlbiB0cnkgdXNlIG9uZSBvZiB0aGUgYXV0b21hdGljYWxseSBkZXRlY3RlZCBsYXllciBjb25maWdzXG4gICAgICBpZiAoIXNhdGlzZmllZENvbHVtbk1vZGUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICAgICAgICAuLi4oZGVmYXVsdExheWVyUHJvcHM/LnByb3BzIHx8IFtdKSxcbiAgICAgICAgICAuLi4oZGVmYXVsdExheWVyUHJvcHM/LmFsdFByb3BzIHx8IFtdKVxuICAgICAgICBdO1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG9mIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25zXG4gICAgICAgICAgY29uc3QgZGVmYXVsdENvbHVtbkNvbmZpZyA9IG9wdGlvbnNbMF0uY29sdW1ucztcblxuICAgICAgICAgIHNhdGlzZmllZENvbHVtbk1vZGUgPSBnZXRTYXRpc2ZpZWRDb2x1bW5Nb2RlKFxuICAgICAgICAgICAgdGhpcy5zdXBwb3J0ZWRDb2x1bW5Nb2RlcyxcbiAgICAgICAgICAgIGRlZmF1bHRDb2x1bW5Db25maWcsXG4gICAgICAgICAgICBkYXRhc2V0Py5maWVsZHNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHNhdGlzZmllZENvbHVtbk1vZGUpIHtcbiAgICAgICAgICAgIGNvcGllZC5jb2x1bW5zID0ge1xuICAgICAgICAgICAgICAuLi5jb3BpZWQuY29sdW1ucyxcbiAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbHVtbkNvbmZpZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29waWVkLmNvbHVtbk1vZGUgPSBzYXRpc2ZpZWRDb2x1bW5Nb2RlPy5rZXkgfHwgY29waWVkLmNvbHVtbk1vZGU7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyhjb3BpZWQpO1xuICAgIC8vIHZhbGlkYXRlIHZpc3VhbENoYW5uZWwgZmllbGQgdHlwZSBhbmQgc2NhbGUgdHlwZXNcbiAgICBPYmplY3Qua2V5cyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gICAgfSk7XG4gIH1cblxuICAvKlxuICAgKiBSZWN1cnNpdmVseSBjb3B5IGNvbmZpZyBvdmVyIHRvIGFuIGVtcHR5IGxheWVyXG4gICAqIHdoZW4gcmVjZWl2ZWQgc2F2ZWQgY29uZmlnLCBvciBjb3B5IGNvbmZpZyBvdmVyIGZyb20gYSBkaWZmZXJlbnQgbGF5ZXIgdHlwZVxuICAgKiBtYWtlIHN1cmUgdG8gb25seSBjb3B5IG92ZXIgdmFsdWUgdG8gZXhpc3Rpbmcga2V5c1xuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbmZpZyAtIGV4aXN0aW5nIGNvbmZpZyB0byBiZSBvdmVycmlkZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnVG9Db3B5IC0gbmV3IENvbmZpZyB0byBjb3B5IG92ZXJcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhbGxvd0NvcHkgLSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIG5vdCB0byBiZSBkZWVwIGNvcGllZFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBub3RUb0NvcHkgLSBhcnJheSBvZiBwcm9wZXJ0aWVzIG5vdCB0byBjb3B5XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gY29waWVkIGNvbmZpZ1xuICAgKi9cbiAgY29weUxheWVyQ29uZmlnKFxuICAgIGN1cnJlbnRDb25maWcsXG4gICAgY29uZmlnVG9Db3B5LFxuICAgIHtzaGFsbG93Q29weSA9IFtdLCBub3RUb0NvcHkgPSBbXX06IHtzaGFsbG93Q29weT86IHN0cmluZ1tdOyBub3RUb0NvcHk/OiBzdHJpbmdbXX0gPSB7fVxuICApIHtcbiAgICBjb25zdCBjb3BpZWQ6IHtjb2x1bW5Nb2RlPzogc3RyaW5nOyBjb2x1bW5zPzogTGF5ZXJDb2x1bW5zfSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGN1cnJlbnRDb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgaXNQbGFpbk9iamVjdChjdXJyZW50Q29uZmlnW2tleV0pICYmXG4gICAgICAgIGlzUGxhaW5PYmplY3QoY29uZmlnVG9Db3B5W2tleV0pICYmXG4gICAgICAgICFzaGFsbG93Q29weS5pbmNsdWRlcyhrZXkpICYmXG4gICAgICAgICFub3RUb0NvcHkuaW5jbHVkZXMoa2V5KVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGFzc2lnbiBvYmplY3QgdmFsdWVcbiAgICAgICAgY29waWVkW2tleV0gPSB0aGlzLmNvcHlMYXllckNvbmZpZyhjdXJyZW50Q29uZmlnW2tleV0sIGNvbmZpZ1RvQ29weVtrZXldLCB7XG4gICAgICAgICAgc2hhbGxvd0NvcHksXG4gICAgICAgICAgbm90VG9Db3B5XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChub3ROdWxsb3JVbmRlZmluZWQoY29uZmlnVG9Db3B5W2tleV0pICYmICFub3RUb0NvcHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAvLyBjb3B5XG4gICAgICAgIGNvcGllZFtrZXldID0gY29uZmlnVG9Db3B5W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBrZWVwIGV4aXN0aW5nXG4gICAgICAgIGNvcGllZFtrZXldID0gY3VycmVudENvbmZpZ1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvcGllZDtcbiAgfVxuXG4gIHJlZ2lzdGVyVmlzQ29uZmlnKGxheWVyVmlzQ29uZmlnczoge1xuICAgIFtrZXk6IHN0cmluZ106IGtleW9mIExheWVyVmlzQ29uZmlnU2V0dGluZ3MgfCBWYWx1ZU9mPExheWVyVmlzQ29uZmlnU2V0dGluZ3M+O1xuICB9KSB7XG4gICAgT2JqZWN0LmtleXMobGF5ZXJWaXNDb25maWdzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgY29uZmlnSXRlbSA9IGxheWVyVmlzQ29uZmlnc1tpdGVtXTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnSXRlbSA9PT0gJ3N0cmluZycgJiYgTEFZRVJfVklTX0NPTkZJR1NbY29uZmlnSXRlbV0pIHtcbiAgICAgICAgLy8gaWYgYXNzaWduZWQgb25lIG9mIGRlZmF1bHQgTEFZRVJfQ09ORklHU1xuICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbaXRlbV0gPSBMQVlFUl9WSVNfQ09ORklHU1tjb25maWdJdGVtXS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMudmlzQ29uZmlnU2V0dGluZ3NbaXRlbV0gPSBMQVlFUl9WSVNfQ09ORklHU1tjb25maWdJdGVtXTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBjb25maWdJdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBbJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJ10uZXZlcnkocCA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnSXRlbSwgcCkpXG4gICAgICApIHtcbiAgICAgICAgLy8gaWYgcHJvdmlkZWQgY3VzdG9taXplZCB2aXNDb25maWcsIGFuZCBoYXMgdHlwZSAmJiBkZWZhdWx0VmFsdWVcbiAgICAgICAgLy8gVE9ETzogZnVydGhlciBjaGVjayBpZiBjdXN0b21pemVkIHZpc0NvbmZpZyBpcyB2YWxpZFxuICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbaXRlbV0gPSBjb25maWdJdGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy52aXNDb25maWdTZXR0aW5nc1tpdGVtXSA9IGNvbmZpZ0l0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRMYXllckNvbHVtbnMocHJvcHNDb2x1bW5zID0ge30pIHtcbiAgICBjb25zdCBjb2x1bW5WYWxpZGF0b3JzID0gdGhpcy5jb2x1bW5WYWxpZGF0b3JzIHx8IHt9O1xuICAgIGNvbnN0IHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZExheWVyQ29sdW1ucy5yZWR1Y2UoXG4gICAgICAoYWNjdSwga2V5KSA9PiAoe1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XTogY29sdW1uVmFsaWRhdG9yc1trZXldXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwcm9wc0NvbHVtbnNba2V5XT8udmFsdWUgPz8gbnVsbCxcbiAgICAgICAgICAgICAgZmllbGRJZHg6IHByb3BzQ29sdW1uc1trZXldPy5maWVsZElkeCA/PyAtMSxcbiAgICAgICAgICAgICAgdmFsaWRhdG9yOiBjb2x1bW5WYWxpZGF0b3JzW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHt2YWx1ZTogcHJvcHNDb2x1bW5zW2tleV0/LnZhbHVlID8/IG51bGwsIGZpZWxkSWR4OiBwcm9wc0NvbHVtbnNba2V5XT8uZmllbGRJZHggPz8gLTF9XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMub3B0aW9uYWxDb2x1bW5zLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB7XG4gICAgICAgICAgdmFsdWU6IHByb3BzQ29sdW1uc1trZXldPy52YWx1ZSA/PyBudWxsLFxuICAgICAgICAgIGZpZWxkSWR4OiBwcm9wc0NvbHVtbnNba2V5XT8uZmllbGRJZHggPz8gLTEsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gey4uLnJlcXVpcmVkLCAuLi5vcHRpb25hbH07XG5cbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHVwZGF0ZUxheWVyQ29uZmlnPFxuICAgIExheWVyQ29uZmlnIGV4dGVuZHMgTGF5ZXJCYXNlQ29uZmlnICZcbiAgICAgIFBhcnRpYWw8TGF5ZXJDb2xvckNvbmZpZyAmIExheWVyU2l6ZUNvbmZpZz4gPSBMYXllckJhc2VDb25maWdcbiAgPihuZXdDb25maWc6IFBhcnRpYWw8TGF5ZXJDb25maWc+KTogTGF5ZXIge1xuICAgIHRoaXMuY29uZmlnID0gey4uLnRoaXMuY29uZmlnLCAuLi5uZXdDb25maWd9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJWaXNDb25maWcobmV3VmlzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcudmlzQ29uZmlnID0gey4uLnRoaXMuY29uZmlnLnZpc0NvbmZpZywgLi4ubmV3VmlzQ29uZmlnfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZUxheWVyQ29sb3JVSShwcm9wOiBzdHJpbmcsIG5ld0NvbmZpZzogTmVzdGVkUGFydGlhbDxDb2xvclVJPik6IExheWVyIHtcbiAgICBjb25zdCB7Y29sb3JVSTogcHJldmlvdXMsIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChuZXdDb25maWcpIHx8IHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JVSVByb3AgPSBPYmplY3QuZW50cmllcyhuZXdDb25maWcpLnJlZHVjZSgoYWNjdSwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2N1LFxuICAgICAgICBba2V5XTpcbiAgICAgICAgICBpc1BsYWluT2JqZWN0KGFjY3Vba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgID8gey4uLmFjY3Vba2V5XSwgLi4uKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KX1cbiAgICAgICAgICAgIDogdmFsdWVcbiAgICAgIH07XG4gICAgfSwgcHJldmlvdXNbcHJvcF0gfHwgREVGQVVMVF9DT0xPUl9VSSk7XG5cbiAgICBjb25zdCBjb2xvclVJID0ge1xuICAgICAgLi4ucHJldmlvdXMsXG4gICAgICBbcHJvcF06IGNvbG9yVUlQcm9wXG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlTGF5ZXJDb25maWcoe2NvbG9yVUl9KTtcbiAgICAvLyBpZiBjb2xvclVJW3Byb3BdIGlzIGNvbG9yUmFuZ2VcbiAgICBjb25zdCBpc0NvbG9yUmFuZ2UgPSB2aXNDb25maWdbcHJvcF0gJiYgdmlzQ29uZmlnW3Byb3BdLmNvbG9ycztcblxuICAgIGlmIChpc0NvbG9yUmFuZ2UpIHtcbiAgICAgIC8vIGlmIG9wZW4gZHJvcGRvd24gYW5kIHByb3AgaXMgY29sb3IgcmFuZ2VcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgc2V0IGNvbG9yUmFuZ2VDb25maWcncyBzdGVwIGFuZCByZXZlcnNlZFxuICAgICAgdGhpcy51cGRhdGVDb2xvclVJQnlDb2xvclJhbmdlKG5ld0NvbmZpZywgcHJvcCk7XG5cbiAgICAgIC8vIGlmIGNoYW5nZXMgaW4gVUkgaXMgbWFkZSB0byAncmV2ZXJzZWQnLCAnc3RlcHMnIG9yIHN0ZXBzXG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBsYXllciBjb2xvclJhbmdlXG4gICAgICB0aGlzLnVwZGF0ZUNvbG9yUmFuZ2VCeUNvbG9yVUkobmV3Q29uZmlnLCBwcmV2aW91cywgcHJvcCk7XG5cbiAgICAgIC8vIGlmIHNldCBjb2xvclJhbmdlQ29uZmlnIHRvIGN1c3RvbVxuICAgICAgLy8gaW5pdGlhdGUgY3VzdG9tUGFsZXR0ZSB0byBiZSBlZGl0ZWQgaW4gdGhlIHVpXG4gICAgICB0aGlzLnVwZGF0ZUN1c3RvbVBhbGV0dGUobmV3Q29uZmlnLCBwcmV2aW91cywgcHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBpZiBzZXQgY29sb3JSYW5nZUNvbmZpZyB0byBjdXN0b20gcGFsZXR0ZSBvciBjdXN0b20gYnJlYWtzXG4gIC8vIGluaXRpYXRlIGN1c3RvbVBhbGV0dGUgdG8gYmUgZWRpdGVkIGluIHRoZSB1aVxuICB1cGRhdGVDdXN0b21QYWxldHRlKG5ld0NvbmZpZywgcHJldmlvdXMsIHByb3ApIHtcbiAgICBpZiAoIW5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnPy5jdXN0b20gJiYgIW5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnPy5jdXN0b21CcmVha3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV3Q29uZmlnLmN1c3RvbVBhbGV0dGUpIHtcbiAgICAgIC8vIGlmIG5ldyBjb25maWcgYWxzbyBzZXQgY3VzdG9tUGFsZXR0ZSwgbm8gbmVlZCB0byBpbml0aWF0ZSBuZXdcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge2NvbG9yVUksIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmICghdmlzQ29uZmlnW3Byb3BdKSByZXR1cm47XG4gICAgLy8gbWFrZSBjb3B5IG9mIGN1cnJlbnQgY29sb3IgcmFuZ2UgdG8gY3VzdG9tUGFsZXR0ZVxuICAgIGxldCBjdXN0b21QYWxldHRlID0ge1xuICAgICAgLi4udmlzQ29uZmlnW3Byb3BdXG4gICAgfTtcblxuICAgIGlmIChuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZy5jdXN0b21CcmVha3MgJiYgIWN1c3RvbVBhbGV0dGUuY29sb3JNYXApIHtcbiAgICAgIC8vIGZpbmQgdmlzdWFsQ2hhbmVsXG4gICAgICBjb25zdCB2aXN1YWxDaGFubmVscyA9IHRoaXMudmlzdWFsQ2hhbm5lbHM7XG4gICAgICBjb25zdCBjaGFubmVsS2V5ID0gT2JqZWN0LmtleXModmlzdWFsQ2hhbm5lbHMpLmZpbmQoXG4gICAgICAgIGtleSA9PiB2aXN1YWxDaGFubmVsc1trZXldLnJhbmdlID09PSBwcm9wXG4gICAgICApO1xuICAgICAgaWYgKCFjaGFubmVsS2V5KSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwblxuICAgICAgICBDb25zb2xlLndhcm4oYHVwZGF0ZUNvbG9yVUk6IENhbid0IGZpbmQgdmlzdWFsIGNoYW5uZWwgd2hpY2ggcmFuZ2UgaXMgJHtwcm9wfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhZGQgbmFtZXx0eXBlfGNhdGVnb3J5IHRvIHVwZGF0ZUN1c3RvbVBhbGV0dGUgaWYgY3VzdG9tQnJlYWtzLCBzbyB0aGF0XG4gICAgICAvLyBjb2xvcnMgd2lsbCBub3QgYmUgb3ZlcnJpZGUgYXMgd2VsbCB3aGVuIGludmVyc2UgcGFsZXR0ZSB3aXRoIGN1c3RvbSBicmVha1xuICAgICAgLy8gaW5pdGlhdGUgY29sb3JNYXAgZnJvbSBjdXJyZW50IHNjYWxlXG5cbiAgICAgIGNvbnN0IGNvbG9yTWFwID0gaW5pdGlhbGl6ZUxheWVyQ29sb3JNYXAodGhpcywgdmlzdWFsQ2hhbm5lbHNbY2hhbm5lbEtleV0pO1xuICAgICAgY3VzdG9tUGFsZXR0ZSA9IGluaXRpYWxpemVDdXN0b21QYWxldHRlKHZpc0NvbmZpZ1twcm9wXSwgY29sb3JNYXApO1xuICAgIH0gZWxzZSBpZiAobmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcuY3VzdG9tKSB7XG4gICAgICBjdXN0b21QYWxldHRlID0gaW5pdGlhbGl6ZUN1c3RvbVBhbGV0dGUodmlzQ29uZmlnW3Byb3BdKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgIGNvbG9yVUk6IHtcbiAgICAgICAgLi4uY29sb3JVSSxcbiAgICAgICAgW3Byb3BdOiB7XG4gICAgICAgICAgLi4uY29sb3JVSVtwcm9wXSxcbiAgICAgICAgICBjdXN0b21QYWxldHRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiBvcGVuIGRyb3Bkb3duIGFuZCBwcm9wIGlzIGNvbG9yIHJhbmdlXG4gICAqIEF1dG9tYXRpY2FsbHkgc2V0IGNvbG9yUmFuZ2VDb25maWcncyBzdGVwIGFuZCByZXZlcnNlZFxuICAgKiBAcGFyYW0geyp9IG5ld0NvbmZpZ1xuICAgKiBAcGFyYW0geyp9IHByb3BcbiAgICovXG4gIHVwZGF0ZUNvbG9yVUlCeUNvbG9yUmFuZ2UobmV3Q29uZmlnLCBwcm9wKSB7XG4gICAgY29uc3Qge2NvbG9yVUksIHZpc0NvbmZpZ30gPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIHdoZW4gY3VzdG9tIHBhbGV0dGUgYWRkcy9yZW1vdmVzIHN0ZXAsIHRoZSBudW1iZXIgaW4gXCJTdGVwc1wiIGlucHV0IGNvbnRyb2xcbiAgICAvLyBzaG91bGQgYmUgdXBkYXRlZCBhcyB3ZWxsXG4gICAgY29uc3QgaXNDdXN0b20gPSBuZXdDb25maWcuY3VzdG9tUGFsZXR0ZT8uY2F0ZWdvcnkgPT09ICdDdXN0b20nO1xuICAgIGNvbnN0IGN1c3RvbVN0ZXBzQ2hhbmdlZCA9IGlzQ3VzdG9tXG4gICAgICA/IG5ld0NvbmZpZy5jdXN0b21QYWxldHRlLmNvbG9ycy5sZW5ndGggIT09IHZpc0NvbmZpZ1twcm9wXS5jb2xvcnMubGVuZ3RoXG4gICAgICA6IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDb25maWcuc2hvd0Ryb3Bkb3duICE9PSAnbnVtYmVyJyAmJiAhY3VzdG9tU3RlcHNDaGFuZ2VkKSByZXR1cm47XG5cbiAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtcbiAgICAgIGNvbG9yVUk6IHtcbiAgICAgICAgLi4uY29sb3JVSSxcbiAgICAgICAgW3Byb3BdOiB7XG4gICAgICAgICAgLi4uY29sb3JVSVtwcm9wXSxcbiAgICAgICAgICBjb2xvclJhbmdlQ29uZmlnOiB7XG4gICAgICAgICAgICAuLi5jb2xvclVJW3Byb3BdLmNvbG9yUmFuZ2VDb25maWcsXG4gICAgICAgICAgICBzdGVwczogY3VzdG9tU3RlcHNDaGFuZ2VkXG4gICAgICAgICAgICAgID8gY29sb3JVSVtwcm9wXS5jdXN0b21QYWxldHRlLmNvbG9ycy5sZW5ndGhcbiAgICAgICAgICAgICAgOiB2aXNDb25maWdbcHJvcF0uY29sb3JzLmxlbmd0aCxcbiAgICAgICAgICAgIHJldmVyc2VkOiBCb29sZWFuKHZpc0NvbmZpZ1twcm9wXS5yZXZlcnNlZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUNvbG9yUmFuZ2VCeUNvbG9yVUkobmV3Q29uZmlnLCBwcmV2aW91cywgcHJvcCkge1xuICAgIC8vIG9ubHkgdXBkYXRlIGNvbG9yUmFuZ2UgaWYgY2hhbmdlcyBpbiBVSSBpcyBtYWRlIHRvICdyZXZlcnNlZCcsICdzdGVwcycgb3Igc3RlcHNcbiAgICBjb25zdCBzaG91bGRVcGRhdGUgPVxuICAgICAgbmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcgJiZcbiAgICAgIFsncmV2ZXJzZWQnLCAnc3RlcHMnLCAnY29sb3JCbGluZFNhZmUnLCAndHlwZSddLnNvbWUoXG4gICAgICAgIGtleSA9PlxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZywga2V5KSAmJlxuICAgICAgICAgIG5ld0NvbmZpZy5jb2xvclJhbmdlQ29uZmlnW2tleV0gIT09XG4gICAgICAgICAgICAocHJldmlvdXNbcHJvcF0gfHwgREVGQVVMVF9DT0xPUl9VSSkuY29sb3JSYW5nZUNvbmZpZ1trZXldXG4gICAgICApO1xuICAgIGlmICghc2hvdWxkVXBkYXRlKSByZXR1cm47XG5cbiAgICBjb25zdCB7Y29sb3JVSSwgdmlzQ29uZmlnfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZm9yIGN1c3RvbSBwYWxldHRlLCBvbmUgY2FuIG9ubHkgJ3JldmVyc2UnIHRoZSBjb2xvcnMgaW4gY3VzdG9tIHBhbGV0dGUuXG4gICAgLy8gY2hhbmdpbmcgJ3N0ZXBzJywgJ2NvbG9yQmluZFNhZmUnLCAndHlwZScgc2hvdWxkIGZhbGwgYmFjayB0byBwcmVkZWZpbmVkIHBhbGV0dGUuXG4gICAgY29uc3QgaXNDdXN0b21Db2xvclJldmVyc2VkID1cbiAgICAgIHZpc0NvbmZpZy5jb2xvclJhbmdlLmNhdGVnb3J5ID09PSAnQ3VzdG9tJyAmJlxuICAgICAgbmV3Q29uZmlnLmNvbG9yUmFuZ2VDb25maWcgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdDb25maWcuY29sb3JSYW5nZUNvbmZpZywgJ3JldmVyc2VkJyk7XG5cbiAgICBjb25zdCB1cGRhdGUgPSBpc0N1c3RvbUNvbG9yUmV2ZXJzZWRcbiAgICAgID8gdXBkYXRlQ3VzdG9tQ29sb3JSYW5nZUJ5Q29sb3JVSSh2aXNDb25maWdbcHJvcF0sIGNvbG9yVUlbcHJvcF0uY29sb3JSYW5nZUNvbmZpZylcbiAgICAgIDogdXBkYXRlQ29sb3JSYW5nZUJ5TWF0Y2hpbmdQYWxldHRlKHZpc0NvbmZpZ1twcm9wXSwgY29sb3JVSVtwcm9wXS5jb2xvclJhbmdlQ29uZmlnKTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlTGF5ZXJWaXNDb25maWcoe1twcm9wXTogdXBkYXRlfSk7XG4gICAgfVxuICB9XG4gIGhhc0NvbHVtblZhbHVlKGNvbHVtbj86IExheWVyQ29sdW1uKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY29sdW1uICYmIGNvbHVtbi52YWx1ZSAmJiBjb2x1bW4uZmllbGRJZHggPiAtMSk7XG4gIH1cbiAgaGFzUmVxdWlyZWRDb2x1bW4oY29sdW1uPzogTGF5ZXJDb2x1bW4pIHtcbiAgICByZXR1cm4gQm9vbGVhbihjb2x1bW4gJiYgKGNvbHVtbi5vcHRpb25hbCB8fCB0aGlzLmhhc0NvbHVtblZhbHVlKGNvbHVtbikpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBsYXllciBoYXMgYWxsIGNvbHVtbnNcbiAgICogQHJldHVybnMgeWVzIG9yIG5vXG4gICAqL1xuICBoYXNBbGxDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHtjb2x1bW5zLCBjb2x1bW5Nb2RlfSA9IHRoaXMuY29uZmlnO1xuICAgIC8vIGlmIGxheWVyIGhhcyBkaWZmZXJlbnQgY29sdW1uIG1vZGUsIGNoZWNrIGlmIGhhdmUgYWxsIHJlcXVpcmVkIGNvbHVtbnMgb2YgY3VycmVudCBjb2x1bW4gTW9kZVxuICAgIGlmIChjb2x1bW5Nb2RlKSB7XG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1uTW9kZXMgPSAodGhpcy5zdXBwb3J0ZWRDb2x1bW5Nb2RlcyB8fCBbXSkuZmluZChcbiAgICAgICAgY29sTW9kZSA9PiBjb2xNb2RlLmtleSA9PT0gY29sdW1uTW9kZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICBjdXJyZW50Q29sdW1uTW9kZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIGN1cnJlbnRDb2x1bW5Nb2Rlcy5yZXF1aXJlZENvbHVtbnM/LmV2ZXJ5KGNvbEtleSA9PiB0aGlzLmhhc0NvbHVtblZhbHVlKGNvbHVtbnNbY29sS2V5XSkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIGNvbHVtbnMgJiZcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjb2x1bW5zKS5ldmVyeSgoY29sdW1uPzogTGF5ZXJDb2x1bW4pID0+IHRoaXMuaGFzUmVxdWlyZWRDb2x1bW4oY29sdW1uKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgbGF5ZXIgaGFzIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gbGF5ZXJEYXRhXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB5ZXMgb3Igbm9cbiAgICovXG4gIGhhc0xheWVyRGF0YShsYXllckRhdGE6IHtkYXRhOiB1bmtub3duW10gfCBhcnJvdy5UYWJsZX0pIHtcbiAgICBpZiAoIWxheWVyRGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgbGF5ZXJEYXRhLmRhdGEgJiZcbiAgICAgICAgKChsYXllckRhdGEuZGF0YSBhcyB1bmtub3duW10pLmxlbmd0aCB8fCAobGF5ZXJEYXRhLmRhdGEgYXMgYXJyb3cuVGFibGUpLm51bVJvd3MpXG4gICAgKTtcbiAgfVxuXG4gIGlzVmFsaWRUb1NhdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy50eXBlICYmIHRoaXMuaGFzQWxsQ29sdW1ucygpKTtcbiAgfVxuXG4gIHNob3VsZFJlbmRlckxheWVyKGRhdGEpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgQm9vbGVhbih0aGlzLnR5cGUpICYmXG4gICAgICB0aGlzLmhhc0FsbENvbHVtbnMoKSAmJlxuICAgICAgdGhpcy5oYXNMYXllckRhdGEoZGF0YSkgJiZcbiAgICAgIHR5cGVvZiB0aGlzLnJlbmRlckxheWVyID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfVxuXG4gIGdldENvbG9yU2NhbGUoXG4gICAgY29sb3JTY2FsZTogc3RyaW5nLFxuICAgIGNvbG9yRG9tYWluOiBWaXN1YWxDaGFubmVsRG9tYWluLFxuICAgIGNvbG9yUmFuZ2U6IENvbG9yUmFuZ2VcbiAgKTogR2V0VmlzQ2hhbm5lbFNjYWxlUmV0dXJuVHlwZSB7XG4gICAgaWYgKGNvbG9yU2NhbGUgPT09IFNDQUxFX1RZUEVTLmN1c3RvbU9yZGluYWwpIHtcbiAgICAgIHJldHVybiBnZXRDYXRlZ29yaWNhbENvbG9yU2NhbGUoY29sb3JEb21haW4sIGNvbG9yUmFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChoYXNDb2xvck1hcChjb2xvclJhbmdlKSAmJiBjb2xvclNjYWxlID09PSBTQ0FMRV9UWVBFUy5jdXN0b20pIHtcbiAgICAgIGNvbnN0IGNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBjb2xvclJhbmdlLmNvbG9yTWFwPy5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgY01hcC5zZXQoaywgdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gaGV4VG9SZ2IodikgOiB2KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSBjb2xvclNjYWxlID09PSBTQ0FMRV9UWVBFUy5jdXN0b20gPyBjb2xvclNjYWxlIDogU0NBTEVfVFlQRVMub3JkaW5hbDtcblxuICAgICAgY29uc3Qgc2NhbGUgPSBnZXRTY2FsZUZ1bmN0aW9uKHNjYWxlVHlwZSwgY01hcC52YWx1ZXMoKSwgY01hcC5rZXlzKCksIGZhbHNlKTtcbiAgICAgIHNjYWxlLnVua25vd24oY01hcC5nZXQoVU5LTk9XTl9DT0xPUl9LRVkpIHx8IE5PX1ZBTFVFX0NPTE9SKTtcblxuICAgICAgcmV0dXJuIHNjYWxlIGFzIEdldFZpc0NoYW5uZWxTY2FsZVJldHVyblR5cGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShjb2xvclNjYWxlLCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZS5jb2xvcnMubWFwKGhleFRvUmdiKSk7XG4gIH1cblxuICBhY2Nlc3NWU0ZpZWxkVmFsdWUoX2ZpZWxkLCBfaW5kZXhLZXkpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldEZpZWxkVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSB2aXN1YWwgY2hhbm5lbHMgdG8gZGVjay5nbCBhY2Nlc29yc1xuICAgKiBAcGFyYW0gcGFyYW0gUGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW0uZGF0YUFjY2Vzc29yIEFjY2VzcyBrZXBsZXIuZ2wgbGF5ZXIgZGF0YSBmcm9tIGRlY2suZ2wgbGF5ZXJcbiAgICogQHBhcmFtIHBhcmFtLmRhdGFDb250YWluZXIgRGF0YUNvbnRhaW5lciB0byB1c2UgdXNlIHdpdGggZGF0YUFjY2Vzc29yXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlQWNjZXNzb3JzIC0gZGVjay5nbCBsYXllciBhdHRyaWJ1dGUgYWNjZXNzb3JzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVBY2Nlc3NvcnMoe1xuICAgIGRhdGFBY2Nlc3NvciA9IGRlZmF1bHREYXRhQWNjZXNzb3IsXG4gICAgZGF0YUNvbnRhaW5lcixcbiAgICBpbmRleEtleVxuICB9OiB7XG4gICAgZGF0YUFjY2Vzc29yPzogdHlwZW9mIGRlZmF1bHREYXRhQWNjZXNzb3I7XG4gICAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lckludGVyZmFjZTtcbiAgICBpbmRleEtleT86IG51bWJlciB8IG51bGw7XG4gIH0pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVBY2Nlc3NvcnM6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnZpc3VhbENoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZCxcbiAgICAgICAgZml4ZWQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBhY2Nlc3NvcixcbiAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgbnVsbFZhbHVlLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlXG4gICAgICB9ID0gdGhpcy52aXN1YWxDaGFubmVsc1tjaGFubmVsXTtcblxuICAgICAgaWYgKGFjY2Vzc29yKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEdldFNjYWxlID0gdGhpcy5jb25maWdbZmllbGRdO1xuXG4gICAgICAgIGlmIChzaG91bGRHZXRTY2FsZSkge1xuICAgICAgICAgIGNvbnN0IGlzRml4ZWQgPSBmaXhlZCAmJiB0aGlzLmNvbmZpZy52aXNDb25maWdbZml4ZWRdO1xuXG4gICAgICAgICAgY29uc3Qgc2NhbGVGdW5jdGlvbiA9XG4gICAgICAgICAgICBjaGFubmVsU2NhbGVUeXBlID09PSBDSEFOTkVMX1NDQUxFUy5jb2xvclxuICAgICAgICAgICAgICA/IHRoaXMuZ2V0Q29sb3JTY2FsZShcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW3NjYWxlXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW2RvbWFpbl0sXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy52aXNDb25maWdbcmFuZ2VdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHRoaXMuZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbc2NhbGVdLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWdbZG9tYWluXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnZpc0NvbmZpZ1tyYW5nZV0sXG4gICAgICAgICAgICAgICAgICBpc0ZpeGVkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IGdldEZpZWxkVmFsdWUgPSB0aGlzLmFjY2Vzc1ZTRmllbGRWYWx1ZSh0aGlzLmNvbmZpZ1tmaWVsZF0sIGluZGV4S2V5KTtcblxuICAgICAgICAgIGlmIChzY2FsZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdID0gc2NhbGVGdW5jdGlvbi5ieVpvb21cbiAgICAgICAgICAgICAgPyBtZW1vaXplKHogPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVGdW5jID0gc2NhbGVGdW5jdGlvbih6KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZUZ1bmMsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YUFjY2Vzc29yKGRhdGFDb250YWluZXIpKGQpLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW2ZpZWxkXSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0RmllbGRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogZCA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFbmNvZGVkQ2hhbm5lbFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBzY2FsZUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkYXRhQWNjZXNzb3IoZGF0YUNvbnRhaW5lcikoZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnW2ZpZWxkXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBnZXRGaWVsZFZhbHVlXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBzZXQgZ2V0RmlsbENvbG9yQnlab29tIHRvIHRydWVcbiAgICAgICAgICAgIGlmIChzY2FsZUZ1bmN0aW9uLmJ5Wm9vbSkge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVBY2Nlc3NvcnNbYCR7YWNjZXNzb3J9Qnlab29tYF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2V0QXR0cmlidXRlVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVBY2Nlc3NvcnNbYWNjZXNzb3JdID0gZ2V0QXR0cmlidXRlVmFsdWUodGhpcy5jb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZUFjY2Vzc29yc1thY2Nlc3Nvcl0gPVxuICAgICAgICAgICAgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZSh0aGlzLmNvbmZpZykgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWF0dHJpYnV0ZUFjY2Vzc29yc1thY2Nlc3Nvcl0pIHtcbiAgICAgICAgICBDb25zb2xlLndhcm4oYEZhaWxlZCB0byBwcm92aWRlIGFjY2Vzc29yIGZ1bmN0aW9uIGZvciAke2FjY2Vzc29yIHx8IGNoYW5uZWx9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhdHRyaWJ1dGVBY2Nlc3NvcnM7XG4gIH1cblxuICBnZXRWaXNDaGFubmVsU2NhbGUoXG4gICAgc2NhbGU6IHN0cmluZyxcbiAgICBkb21haW46IFZpc3VhbENoYW5uZWxEb21haW4gfCBEb21haW5RdWFudGlsZXMsXG4gICAgcmFuZ2U6IGFueSxcbiAgICBmaXhlZD86IGJvb2xlYW5cbiAgKTogR2V0VmlzQ2hhbm5lbFNjYWxlUmV0dXJuVHlwZSB7XG4gICAgLy8gaWYgcXVhbnRpbGUgaXMgcHJvdmlkZWQgcGVyIHpvb21cbiAgICBpZiAoaXNEb21haW5RdWFudGlsZShkb21haW4pICYmIHNjYWxlID09PSBTQ0FMRV9UWVBFUy5xdWFudGlsZSkge1xuICAgICAgY29uc3QgelN0ZXBzID0gZG9tYWluLno7XG5cbiAgICAgIGNvbnN0IGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGVCeVpvb20oeikge1xuICAgICAgICBjb25zdCBzY2FsZURvbWFpbiA9IGdldERvbWFpblN0ZXBzYnlab29tKGRvbWFpbi5xdWFudGlsZXMsIHpTdGVwcywgeik7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSBnZXRUaHJlc2hvbGRzRnJvbVF1YW50aWxlcyhzY2FsZURvbWFpbiwgcmFuZ2UubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gZ2V0U2NhbGVGdW5jdGlvbigndGhyZXNob2xkJywgcmFuZ2UsIHRocmVzaG9sZHMsIGZhbHNlKTtcbiAgICAgIH07XG5cbiAgICAgIGdldFNjYWxlLmJ5Wm9vbSA9IHRydWU7XG4gICAgICByZXR1cm4gZ2V0U2NhbGU7XG4gICAgfSBlbHNlIGlmIChpc0RvbWFpblN0b3BzKGRvbWFpbikpIHtcbiAgICAgIC8vIGNvbG9yIGlzIGJhc2VkIG9uIHpvb21cbiAgICAgIGNvbnN0IHpTdGVwcyA9IGRvbWFpbi56O1xuICAgICAgLy8gZ2V0IHNjYWxlIGZ1bmN0aW9uIGJ5IHpcbiAgICAgIC8vIHtcbiAgICAgIC8vICB6OiBbeiwgeiwgel0sXG4gICAgICAvLyAgc3RvcHM6IFtbbWluLCBtYXhdLCBbbWluLCBtYXhdXSxcbiAgICAgIC8vICBpbnRlcnBvbGF0aW9uOiAnaW50ZXJwb2xhdGUnXG4gICAgICAvLyB9XG5cbiAgICAgIGNvbnN0IGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGVCeVpvb20oeikge1xuICAgICAgICBjb25zdCBzY2FsZURvbWFpbiA9IGdldERvbWFpblN0ZXBzYnlab29tKGRvbWFpbi5zdG9wcywgelN0ZXBzLCB6KTtcblxuICAgICAgICByZXR1cm4gZ2V0U2NhbGVGdW5jdGlvbihzY2FsZSwgcmFuZ2UsIHNjYWxlRG9tYWluLCBmaXhlZCk7XG4gICAgICB9O1xuXG4gICAgICBnZXRTY2FsZS5ieVpvb20gPSB0cnVlO1xuICAgICAgcmV0dXJuIGdldFNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBTQ0FMRV9GVU5DW2ZpeGVkID8gJ2xpbmVhcicgOiBzY2FsZV0oKVxuICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAucmFuZ2UoZml4ZWQgPyBkb21haW4gOiByYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgYm91bmRzIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgZ2V0UG9pbnRzQm91bmRzKFxuICAgIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gICAgZ2V0UG9zaXRpb246ICh4OiBhbnksIGRjOiBEYXRhQ29udGFpbmVySW50ZXJmYWNlKSA9PiBudW1iZXJbXSA9IGlkZW50aXR5XG4gICk6IG51bWJlcltdIHwgbnVsbCB7XG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHRocm91Z2ggdGhlIGVudGlyZSBkYXRhc2V0XG4gICAgLy8gZ2V0IGEgc2FtcGxlIG9mIGRhdGEgdG8gY2FsY3VsYXRlIGJvdW5kc1xuICAgIGNvbnN0IHNhbXBsZURhdGEgPVxuICAgICAgZGF0YUNvbnRhaW5lci5udW1Sb3dzKCkgPiBNQVhfU0FNUExFX1NJWkVcbiAgICAgICAgPyBnZXRTYW1wbGVDb250YWluZXJEYXRhKGRhdGFDb250YWluZXIsIE1BWF9TQU1QTEVfU0laRSlcbiAgICAgICAgOiBkYXRhQ29udGFpbmVyO1xuXG4gICAgY29uc3QgcG9pbnRzID0gZ2V0UG9zaXRpb24gPyBzYW1wbGVEYXRhLm1hcEluZGV4KGdldFBvc2l0aW9uKSA6IFtdO1xuXG4gICAgY29uc3QgbGF0Qm91bmRzID0gZ2V0TGF0TG5nQm91bmRzKHBvaW50cywgMSwgWy05MCwgOTBdKTtcbiAgICBjb25zdCBsbmdCb3VuZHMgPSBnZXRMYXRMbmdCb3VuZHMocG9pbnRzLCAwLCBbLTE4MCwgMTgwXSk7XG5cbiAgICBpZiAoIWxhdEJvdW5kcyB8fCAhbG5nQm91bmRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gW2xuZ0JvdW5kc1swXSwgbGF0Qm91bmRzWzBdLCBsbmdCb3VuZHNbMV0sIGxhdEJvdW5kc1sxXV07XG4gIH1cblxuICBnZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgY29uc3QgdHJpZ2dlckNoYW5nZWQgPSBkaWZmVXBkYXRlVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzLCB0aGlzLl9vbGREYXRhVXBkYXRlVHJpZ2dlcnMpO1xuICAgIHRoaXMuX29sZERhdGFVcGRhdGVUcmlnZ2VycyA9IGRhdGFVcGRhdGVUcmlnZ2VycztcblxuICAgIHJldHVybiB0cmlnZ2VyQ2hhbmdlZDtcbiAgfVxuXG4gIGdldEVuY29kZWRDaGFubmVsVmFsdWUoXG4gICAgc2NhbGU6ICh2YWx1ZSkgPT4gYW55LFxuICAgIGRhdGE6IGFueVtdLFxuICAgIGZpZWxkOiBWaXN1YWxDaGFubmVsRmllbGQsXG4gICAgbnVsbFZhbHVlID0gTk9fVkFMVUVfQ09MT1IsXG4gICAgZ2V0VmFsdWUgPSBkZWZhdWx0R2V0RmllbGRWYWx1ZVxuICApIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGZpZWxkLCBkYXRhKTtcblxuICAgIGlmICghbm90TnVsbG9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9IHZhbHVlLm1hcChzY2FsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gc2NhbGUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghbm90TnVsbG9yVW5kZWZpbmVkKGF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSBudWxsVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICB9XG5cbiAgdXBkYXRlTWV0YShtZXRhOiBMYXllclsnbWV0YSddKSB7XG4gICAgdGhpcy5tZXRhID0gey4uLnRoaXMubWV0YSwgLi4ubWV0YX07XG4gIH1cblxuICBnZXREYXRhVXBkYXRlVHJpZ2dlcnMoe2ZpbHRlcmVkSW5kZXgsIGlkLCBkYXRhQ29udGFpbmVyfTogS2VwbGVyVGFibGUpOiBhbnkge1xuICAgIGNvbnN0IHtjb2x1bW5zfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldERhdGE6IHtkYXRhc2V0SWQ6IGlkLCBkYXRhQ29udGFpbmVyLCBjb2x1bW5zLCBmaWx0ZXJlZEluZGV4fSxcbiAgICAgIGdldE1ldGE6IHtkYXRhc2V0SWQ6IGlkLCBkYXRhQ29udGFpbmVyLCBjb2x1bW5zfSxcbiAgICAgIC4uLih0aGlzLmNvbmZpZy50ZXh0TGFiZWwgfHwgW10pLnJlZHVjZShcbiAgICAgICAgKGFjY3UsIHRsLCBpKSA9PiAoe1xuICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgW2BnZXRMYWJlbENoYXJhY3RlclNldC0ke2l9YF06IHRsLmZpZWxkID8gdGwuZmllbGQubmFtZSA6IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZURhdGEoZGF0YXNldHM6IERhdGFzZXRzLCBvbGRMYXllckRhdGE6IGFueSkge1xuICAgIGlmICghdGhpcy5jb25maWcuZGF0YUlkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGxheWVyRGF0YXNldCA9IGRhdGFzZXRzW3RoaXMuY29uZmlnLmRhdGFJZF07XG4gICAgY29uc3Qge2RhdGFDb250YWluZXJ9ID0gbGF5ZXJEYXRhc2V0O1xuXG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoZGF0YUNvbnRhaW5lciwgbGF5ZXJEYXRhc2V0KTtcbiAgICBjb25zdCBkYXRhVXBkYXRlVHJpZ2dlcnMgPSB0aGlzLmdldERhdGFVcGRhdGVUcmlnZ2VycyhsYXllckRhdGFzZXQpO1xuICAgIGNvbnN0IHRyaWdnZXJDaGFuZ2VkID0gdGhpcy5nZXRDaGFuZ2VkVHJpZ2dlcnMoZGF0YVVwZGF0ZVRyaWdnZXJzKTtcblxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlZCAmJiAodHJpZ2dlckNoYW5nZWQuZ2V0TWV0YSB8fCB0cmlnZ2VyQ2hhbmdlZC5nZXREYXRhKSkge1xuICAgICAgdGhpcy51cGRhdGVMYXllck1ldGEobGF5ZXJEYXRhc2V0LCBnZXRQb3NpdGlvbik7XG5cbiAgICAgIC8vIHJlc2V0IGZpbHRlcmVkSXRlbUNvdW50XG4gICAgICB0aGlzLmZpbHRlcmVkSXRlbUNvdW50ID0ge307XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSBbXTtcblxuICAgIGlmICghKHRyaWdnZXJDaGFuZ2VkICYmIHRyaWdnZXJDaGFuZ2VkLmdldERhdGEpICYmIG9sZExheWVyRGF0YSAmJiBvbGRMYXllckRhdGEuZGF0YSkge1xuICAgICAgLy8gc2FtZSBkYXRhXG4gICAgICBkYXRhID0gb2xkTGF5ZXJEYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLmNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUobGF5ZXJEYXRhc2V0LCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtkYXRhLCB0cmlnZ2VyQ2hhbmdlZH07XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBvbmUgbGF5ZXIgZG9tYWluIHdoZW4gc3RhdGUuZGF0YSBjaGFuZ2VkXG4gICAqIGlmIHN0YXRlLmRhdGEgY2hhbmdlIGlzIGR1ZSBvdCB1cGRhdGUgZmlsdGVyLCBuZXdGaWxlciB3aWxsIGJlIHBhc3NlZFxuICAgKiBjYWxsZWQgYnkgdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhXG4gICAqIEBwYXJhbSBkYXRhc2V0c1xuICAgKiBAcGFyYW0gbmV3RmlsdGVyXG4gICAqIEByZXR1cm5zIGxheWVyXG4gICAqL1xuICB1cGRhdGVMYXllckRvbWFpbihkYXRhc2V0czogRGF0YXNldHMsIG5ld0ZpbHRlcj86IEZpbHRlcik6IExheWVyIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuZ2V0RGF0YXNldChkYXRhc2V0cyk7XG4gICAgaWYgKCF0YWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGNvbnN0IHtzY2FsZX0gPSBjaGFubmVsO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdGhpcy5jb25maWdbc2NhbGVdO1xuICAgICAgLy8gb3JkaW5hbCBkb21haW4gaXMgYmFzZWQgb24gZGF0YUNvbnRhaW5lciwgaWYgb25seSBmaWx0ZXIgY2hhbmdlZFxuICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUgb3JkaW5hbCBkb21haW5cbiAgICAgIGlmICghbmV3RmlsdGVyIHx8IHNjYWxlVHlwZSAhPT0gU0NBTEVfVFlQRVMub3JkaW5hbCkge1xuICAgICAgICBjb25zdCB7ZG9tYWlufSA9IGNoYW5uZWw7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW4gPSB0aGlzLmNhbGN1bGF0ZUxheWVyRG9tYWluKHRhYmxlLCBjaGFubmVsKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W2RvbWFpbl06IHVwZGF0ZWREb21haW59KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0RGF0YXNldChkYXRhc2V0cykge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhSWQgPyBkYXRhc2V0c1t0aGlzLmNvbmZpZy5kYXRhSWRdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB2aXN1YWwgY2hhbm5lbCBmaWVsZCBhbmQgc2NhbGVzIGJhc2VkIG9uIHN1cHBvcnRlZCBmaWVsZCAmIHNjYWxlIHR5cGVcbiAgICogQHBhcmFtIGNoYW5uZWxcbiAgICovXG4gIHZhbGlkYXRlVmlzdWFsQ2hhbm5lbChjaGFubmVsOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZhbGlkYXRlRmllbGRUeXBlKGNoYW5uZWwpO1xuICAgIHRoaXMudmFsaWRhdGVTY2FsZShjaGFubmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBmaWVsZCB0eXBlIGJhc2VkIG9uIGNoYW5uZWxTY2FsZVR5cGVcbiAgICovXG4gIHZhbGlkYXRlRmllbGRUeXBlKGNoYW5uZWw6IHN0cmluZykge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgY2hhbm5lbFNjYWxlVHlwZSwgc3VwcG9ydGVkRmllbGRUeXBlc30gPSB2aXN1YWxDaGFubmVsO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnW2ZpZWxkXSkge1xuICAgICAgLy8gaWYgZmllbGQgaXMgc2VsZWN0ZWQsIGNoZWNrIGlmIGZpZWxkIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAgICBjb25zdCBjaGFubmVsU3VwcG9ydGVkRmllbGRUeXBlcyA9XG4gICAgICAgIHN1cHBvcnRlZEZpZWxkVHlwZXMgfHwgQ0hBTk5FTF9TQ0FMRV9TVVBQT1JURURfRklFTERTW2NoYW5uZWxTY2FsZVR5cGVdO1xuXG4gICAgICBpZiAoIWNoYW5uZWxTdXBwb3J0ZWRGaWVsZFR5cGVzLmluY2x1ZGVzKHRoaXMuY29uZmlnW2ZpZWxkXS50eXBlKSkge1xuICAgICAgICAvLyBmaWVsZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQsIHNldCBpdCBiYWNrIHRvIG51bGxcbiAgICAgICAgLy8gc2V0IHNjYWxlIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtbZmllbGRdOiBudWxsfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHNjYWxlIHR5cGUgYmFzZWQgb24gYWdncmVnYXRpb25cbiAgICovXG4gIHZhbGlkYXRlU2NhbGUoY2hhbm5lbCkge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtzY2FsZX0gPSB2aXN1YWxDaGFubmVsO1xuICAgIGlmICghc2NhbGUpIHtcbiAgICAgIC8vIHZpc3VhbENoYW5uZWwgZG9lc24ndCBoYXZlIHNjYWxlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHRoaXMuZ2V0U2NhbGVPcHRpb25zKGNoYW5uZWwpO1xuICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgc2VsZWN0ZWQgc2NhbGUgaXNcbiAgICAvLyBzdXBwb3J0ZWQsIGlmIG5vdCwgY2hhbmdlIHRvIGRlZmF1bHRcbiAgICBpZiAoIXNjYWxlT3B0aW9ucy5pbmNsdWRlcyh0aGlzLmNvbmZpZ1tzY2FsZV0pKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyQ29uZmlnKHtbc2NhbGVdOiBzY2FsZU9wdGlvbnNbMF19KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNjYWxlIG9wdGlvbnMgYmFzZWQgb24gY3VycmVudCBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBnZXRTY2FsZU9wdGlvbnMoY2hhbm5lbDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHZpc3VhbENoYW5uZWwgPSB0aGlzLnZpc3VhbENoYW5uZWxzW2NoYW5uZWxdO1xuICAgIGNvbnN0IHtmaWVsZCwgc2NhbGUsIGNoYW5uZWxTY2FsZVR5cGV9ID0gdmlzdWFsQ2hhbm5lbDtcblxuICAgIHJldHVybiB0aGlzLmNvbmZpZ1tmaWVsZF1cbiAgICAgID8gRklFTERfT1BUU1t0aGlzLmNvbmZpZ1tmaWVsZF0udHlwZV0uc2NhbGVbY2hhbm5lbFNjYWxlVHlwZV1cbiAgICAgIDogW3RoaXMuZ2V0RGVmYXVsdExheWVyQ29uZmlnKHtkYXRhSWQ6ICcnfSlbc2NhbGVdXTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVyVmlzdWFsQ2hhbm5lbChkYXRhc2V0OiBLZXBsZXJUYWJsZSwgY2hhbm5lbDogc3RyaW5nKSB7XG4gICAgY29uc3QgdmlzdWFsQ2hhbm5lbCA9IHRoaXMudmlzdWFsQ2hhbm5lbHNbY2hhbm5lbF07XG4gICAgdGhpcy52YWxpZGF0ZVZpc3VhbENoYW5uZWwoY2hhbm5lbCk7XG4gICAgLy8gY2FsY3VsYXRlIGxheWVyIGNoYW5uZWwgZG9tYWluXG4gICAgY29uc3QgdXBkYXRlZERvbWFpbiA9IHRoaXMuY2FsY3VsYXRlTGF5ZXJEb21haW4oZGF0YXNldCwgdmlzdWFsQ2hhbm5lbCk7XG4gICAgdGhpcy51cGRhdGVMYXllckNvbmZpZyh7W3Zpc3VhbENoYW5uZWwuZG9tYWluXTogdXBkYXRlZERvbWFpbn0pO1xuICB9XG5cbiAgZ2V0VmlzdWFsQ2hhbm5lbFVwZGF0ZVRyaWdnZXJzKCk6IFVwZGF0ZVRyaWdnZXJzIHtcbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VyczogVXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMudmlzdWFsQ2hhbm5lbHMpLmZvckVhY2godmlzdWFsQ2hhbm5lbCA9PiB7XG4gICAgICAvLyBmaWVsZCByYW5nZSBzY2FsZSBkb21haW5cbiAgICAgIGNvbnN0IHthY2Nlc3NvciwgZmllbGQsIHNjYWxlLCBkb21haW4sIHJhbmdlLCBkZWZhdWx0VmFsdWUsIGZpeGVkfSA9IHZpc3VhbENoYW5uZWw7XG5cbiAgICAgIGlmIChhY2Nlc3Nvcikge1xuICAgICAgICB1cGRhdGVUcmlnZ2Vyc1thY2Nlc3Nvcl0gPSB7XG4gICAgICAgICAgW2ZpZWxkXTogdGhpcy5jb25maWdbZmllbGRdLFxuICAgICAgICAgIFtzY2FsZV06IHRoaXMuY29uZmlnW3NjYWxlXSxcbiAgICAgICAgICBbZG9tYWluXTogdGhpcy5jb25maWdbZG9tYWluXSxcbiAgICAgICAgICBbcmFuZ2VdOiB0aGlzLmNvbmZpZy52aXNDb25maWdbcmFuZ2VdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTpcbiAgICAgICAgICAgIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUodGhpcy5jb25maWcpIDogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIC4uLihmaXhlZCA/IHtbZml4ZWRdOiB0aGlzLmNvbmZpZy52aXNDb25maWdbZml4ZWRdfSA6IHt9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB1cGRhdGVUcmlnZ2VycztcbiAgfVxuXG4gIGNhbGN1bGF0ZUxheWVyRG9tYWluKGRhdGFzZXQsIHZpc3VhbENoYW5uZWwpIHtcbiAgICBjb25zdCB7c2NhbGV9ID0gdmlzdWFsQ2hhbm5lbDtcbiAgICBjb25zdCBzY2FsZVR5cGUgPSB0aGlzLmNvbmZpZ1tzY2FsZV07XG5cbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuY29uZmlnW3Zpc3VhbENoYW5uZWwuZmllbGRdO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIC8vIGlmIGNvbG9yRmllbGQgb3Igc2l6ZUZpZWxkIHdlcmUgc2V0IGJhY2sgdG8gbnVsbFxuICAgICAgcmV0dXJuIGRlZmF1bHREb21haW47XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXQuZ2V0Q29sdW1uTGF5ZXJEb21haW4oZmllbGQsIHNjYWxlVHlwZSkgfHwgZGVmYXVsdERvbWFpbjtcbiAgfVxuXG4gIGhhc0hvdmVyZWRPYmplY3Qob2JqZWN0SW5mbykge1xuICAgIHJldHVybiB0aGlzLmlzTGF5ZXJIb3ZlcmVkKG9iamVjdEluZm8pICYmIG9iamVjdEluZm8ub2JqZWN0ID8gb2JqZWN0SW5mby5vYmplY3QgOiBudWxsO1xuICB9XG5cbiAgaXNMYXllckhvdmVyZWQob2JqZWN0SW5mbyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvYmplY3RJbmZvPy5waWNrZWQgJiYgb2JqZWN0SW5mbz8ubGF5ZXI/LnByb3BzPy5pZCA9PT0gdGhpcy5pZDtcbiAgfVxuXG4gIGdldFJhZGl1c1NjYWxlQnlab29tKG1hcFN0YXRlOiBNYXBTdGF0ZSwgZml4ZWRSYWRpdXM/OiBib29sZWFuKSB7XG4gICAgY29uc3QgcmFkaXVzQ2hhbm5lbCA9IE9iamVjdC52YWx1ZXModGhpcy52aXN1YWxDaGFubmVscykuZmluZCh2YyA9PiB2Yy5wcm9wZXJ0eSA9PT0gJ3JhZGl1cycpO1xuXG4gICAgaWYgKCFyYWRpdXNDaGFubmVsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZCA9IHJhZGl1c0NoYW5uZWwuZmllbGQ7XG4gICAgY29uc3QgZml4ZWQgPSBmaXhlZFJhZGl1cyA9PT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzIDogZml4ZWRSYWRpdXM7XG4gICAgY29uc3Qge3JhZGl1c30gPSB0aGlzLmNvbmZpZy52aXNDb25maWc7XG5cbiAgICByZXR1cm4gZml4ZWQgPyAxIDogKHRoaXMuY29uZmlnW2ZpZWxkXSA/IDEgOiByYWRpdXMpICogdGhpcy5nZXRab29tRmFjdG9yKG1hcFN0YXRlKTtcbiAgfVxuXG4gIHNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gcHJvcHMuc29tZShwID0+ICF0aGlzLm5vbmVMYXllckRhdGFBZmZlY3RpbmdQcm9wcy5pbmNsdWRlcyhwKSk7XG4gIH1cblxuICBnZXRCcnVzaGluZ0V4dGVuc2lvblByb3BzKGludGVyYWN0aW9uQ29uZmlnLCBicnVzaGluZ1RhcmdldD8pIHtcbiAgICBjb25zdCB7YnJ1c2h9ID0gaW50ZXJhY3Rpb25Db25maWc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gYnJ1c2hpbmdcbiAgICAgIGF1dG9IaWdobGlnaHQ6ICFicnVzaC5lbmFibGVkLFxuICAgICAgYnJ1c2hpbmdSYWRpdXM6IGJydXNoLmNvbmZpZy5zaXplICogMTAwMCxcbiAgICAgIGJydXNoaW5nVGFyZ2V0OiBicnVzaGluZ1RhcmdldCB8fCAnc291cmNlJyxcbiAgICAgIGJydXNoaW5nRW5hYmxlZDogYnJ1c2guZW5hYmxlZFxuICAgIH07XG4gIH1cblxuICBnZXREZWZhdWx0RGVja0xheWVyUHJvcHMoe1xuICAgIGlkeCxcbiAgICBncHVGaWx0ZXIsXG4gICAgbWFwU3RhdGUsXG4gICAgbGF5ZXJDYWxsYmFja3MsXG4gICAgdmlzaWJsZVxuICB9OiB7XG4gICAgaWR4OiBudW1iZXI7XG4gICAgZ3B1RmlsdGVyOiBHcHVGaWx0ZXI7XG4gICAgbWFwU3RhdGU6IE1hcFN0YXRlO1xuICAgIGxheWVyQ2FsbGJhY2tzOiBhbnk7XG4gICAgdmlzaWJsZTogYm9vbGVhbjtcbiAgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGlkeCxcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCxcbiAgICAgIHBpY2thYmxlOiB0cnVlLFxuICAgICAgd3JhcExvbmdpdHVkZTogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IHtkZXB0aFRlc3Q6IEJvb2xlYW4obWFwU3RhdGUuZHJhZ1JvdGF0ZSB8fCB0aGlzLmNvbmZpZy52aXNDb25maWcuZW5hYmxlM2QpfSxcbiAgICAgIGhpZGRlbjogdGhpcy5jb25maWcuaGlkZGVuLFxuICAgICAgLy8gdmlzY29uZmlnXG4gICAgICBvcGFjaXR5OiB0aGlzLmNvbmZpZy52aXNDb25maWcub3BhY2l0eSxcbiAgICAgIGhpZ2hsaWdodENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgIC8vIGRhdGEgZmlsdGVyaW5nXG4gICAgICBleHRlbnNpb25zOiBbZGF0YUZpbHRlckV4dGVuc2lvbl0sXG4gICAgICBmaWx0ZXJSYW5nZTogZ3B1RmlsdGVyID8gZ3B1RmlsdGVyLmZpbHRlclJhbmdlIDogdW5kZWZpbmVkLFxuICAgICAgb25GaWx0ZXJlZEl0ZW1zQ2hhbmdlOiBncHVGaWx0ZXIgPyBsYXllckNhbGxiYWNrcz8ub25GaWx0ZXJlZEl0ZW1zQ2hhbmdlIDogdW5kZWZpbmVkLFxuXG4gICAgICAvLyBsYXllciBzaG91bGQgYmUgdmlzaWJsZSBhbmQgaWYgc3BsaXRNYXAsIHNob3duIGluIHRvIG9uZSBvZiBwYW5lbFxuICAgICAgdmlzaWJsZTogdGhpcy5jb25maWcuaXNWaXNpYmxlICYmIHZpc2libGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdEhvdmVyTGF5ZXJQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGAke3RoaXMuaWR9LWhvdmVyZWRgLFxuICAgICAgcGlja2FibGU6IGZhbHNlLFxuICAgICAgd3JhcExvbmdpdHVkZTogdHJ1ZSxcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVFxuICAgIH07XG4gIH1cblxuICByZW5kZXJUZXh0TGFiZWxMYXllcihcbiAgICB7XG4gICAgICBnZXRQb3NpdGlvbixcbiAgICAgIGdldEZpbHRlcmVkLFxuICAgICAgZ2V0UGl4ZWxPZmZzZXQsXG4gICAgICBiYWNrZ3JvdW5kUHJvcHMsXG4gICAgICB1cGRhdGVUcmlnZ2VycyxcbiAgICAgIHNoYXJlZFByb3BzXG4gICAgfToge1xuICAgICAgZ2V0UG9zaXRpb24/OiAoKGQ6IGFueSkgPT4gbnVtYmVyW10pIHwgYXJyb3cuVmVjdG9yO1xuICAgICAgZ2V0RmlsdGVyZWQ/OiAoZGF0YToge2luZGV4OiBudW1iZXJ9LCBvYmplY3RJbmZvOiB7aW5kZXg6IG51bWJlcn0pID0+IG51bWJlcjtcbiAgICAgIGdldFBpeGVsT2Zmc2V0OiAodGV4dExhYmVsOiBhbnkpID0+IG51bWJlcltdIHwgKChkOiBhbnkpID0+IG51bWJlcltdKTtcbiAgICAgIGJhY2tncm91bmRQcm9wcz86IHtiYWNrZ3JvdW5kOiBib29sZWFufTtcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IGFueTtcbiAgICAgIH07XG4gICAgICBzaGFyZWRQcm9wczogYW55O1xuICAgIH0sXG4gICAgcmVuZGVyT3B0c1xuICApIHtcbiAgICBjb25zdCB7ZGF0YSwgbWFwU3RhdGV9ID0gcmVuZGVyT3B0cztcbiAgICBjb25zdCB7dGV4dExhYmVsfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uc3QgVGV4dExheWVyQ2xhc3MgPSBkYXRhLmRhdGEgaW5zdGFuY2VvZiBhcnJvdy5UYWJsZSA/IEdlb0Fycm93VGV4dExheWVyIDogVGV4dExheWVyO1xuXG4gICAgcmV0dXJuIGRhdGEudGV4dExhYmVscy5yZWR1Y2UoKGFjY3UsIGQsIGkpID0+IHtcbiAgICAgIGlmIChkLmdldFRleHQpIHtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IHRleHRMYWJlbFtpXS5iYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRQcm9wcz8uYmFja2dyb3VuZDtcblxuICAgICAgICBhY2N1LnB1c2goXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIG5ldyBUZXh0TGF5ZXJDbGFzcyh7XG4gICAgICAgICAgICAuLi5zaGFyZWRQcm9wcyxcbiAgICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1sYWJlbC0ke3RleHRMYWJlbFtpXS5maWVsZD8ubmFtZX1gLFxuICAgICAgICAgICAgZGF0YTogZGF0YS5kYXRhLFxuICAgICAgICAgICAgdmlzaWJsZTogdGhpcy5jb25maWcuaXNWaXNpYmxlLFxuICAgICAgICAgICAgZ2V0VGV4dDogZC5nZXRUZXh0LFxuICAgICAgICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBnZXRGaWx0ZXJlZCxcbiAgICAgICAgICAgIGNoYXJhY3RlclNldDogZC5jaGFyYWN0ZXJTZXQsXG4gICAgICAgICAgICBnZXRQaXhlbE9mZnNldDogZ2V0UGl4ZWxPZmZzZXQodGV4dExhYmVsW2ldKSxcbiAgICAgICAgICAgIGdldFNpemU6IFBST0pFQ1RFRF9QSVhFTF9TSVpFX01VTFRJUExJRVIsXG4gICAgICAgICAgICBzaXplU2NhbGU6IHRleHRMYWJlbFtpXS5zaXplLFxuICAgICAgICAgICAgZ2V0VGV4dEFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lOiB0ZXh0TGFiZWxbaV0uYWxpZ25tZW50LFxuICAgICAgICAgICAgZ2V0Q29sb3I6IHRleHRMYWJlbFtpXS5jb2xvcixcbiAgICAgICAgICAgIG91dGxpbmVXaWR0aDogdGV4dExhYmVsW2ldLm91dGxpbmVXaWR0aCAqIFRFWFRfT1VUTElORV9NVUxUSVBMSUVSLFxuICAgICAgICAgICAgb3V0bGluZUNvbG9yOiB0ZXh0TGFiZWxbaV0ub3V0bGluZUNvbG9yLFxuICAgICAgICAgICAgYmFja2dyb3VuZCxcbiAgICAgICAgICAgIGdldEJhY2tncm91bmRDb2xvcjogdGV4dExhYmVsW2ldLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRTZXR0aW5nczoge1xuICAgICAgICAgICAgICBzZGY6IHRleHRMYWJlbFtpXS5vdXRsaW5lV2lkdGggPiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAvLyB0ZXh0IHdpbGwgYWx3YXlzIHNob3cgb24gdG9wIG9mIGFsbCBsYXllcnNcbiAgICAgICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RmlsdGVyVmFsdWU6IGRhdGEuZ2V0RmlsdGVyVmFsdWUsXG4gICAgICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgICAgICAuLi51cGRhdGVUcmlnZ2VycyxcbiAgICAgICAgICAgICAgZ2V0VGV4dDogdGV4dExhYmVsW2ldLmZpZWxkPy5uYW1lLFxuICAgICAgICAgICAgICBnZXRQaXhlbE9mZnNldDoge1xuICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVRyaWdnZXJzLmdldFJhZGl1cyxcbiAgICAgICAgICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgICAgICAgICBhbmNob3I6IHRleHRMYWJlbFtpXS5hbmNob3IsXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50OiB0ZXh0TGFiZWxbaV0uYWxpZ25tZW50XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldFRleHRBbmNob3I6IHRleHRMYWJlbFtpXS5hbmNob3IsXG4gICAgICAgICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lOiB0ZXh0TGFiZWxbaV0uYWxpZ25tZW50LFxuICAgICAgICAgICAgICBnZXRDb2xvcjogdGV4dExhYmVsW2ldLmNvbG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YkxheWVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgLi4uKGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bGw6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNhbGN1bGF0ZURhdGFBdHRyaWJ1dGUoa2VwbGVyVGFibGU6IEtlcGxlclRhYmxlLCBnZXRQb3NpdGlvbik6IGFueSB7XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgdXBkYXRlTGF5ZXJNZXRhKGRhdGFzZXQ6IEtlcGxlclRhYmxlLCBnZXRQb3NpdGlvbikge1xuICAgIC8vIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZ2V0UG9zaXRpb25BY2Nlc3NvcihcbiAgICBfZGF0YUNvbnRhaW5lcj86IERhdGFDb250YWluZXJJbnRlcmZhY2UsXG4gICAgLy8gVE9ETyByZWZhY3RvciBmb3IgdGhlIG5leHQgbWFqb3IgdmVyc2lvbiB0byBwYXNzIG9ubHkgZGF0YXNldFxuICAgIF9kYXRhc2V0PzogS2VwbGVyVGFibGVcbiAgKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkge1xuICAgIC8vIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgICByZXR1cm4gKCkgPT4gbnVsbDtcbiAgfVxuXG4gIGdldExlZ2VuZFZpc3VhbENoYW5uZWxzKCk6IHtba2V5OiBzdHJpbmddOiBWaXN1YWxDaGFubmVsfSB7XG4gICAgcmV0dXJuIHRoaXMudmlzdWFsQ2hhbm5lbHM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSxJQUFBQSxLQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxrQkFBQSxHQUFBRCxPQUFBO0FBQ0EsSUFBQUUsV0FBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsT0FBQSxHQUFBSCxPQUFBO0FBQ0EsSUFBQUksT0FBQSxHQUFBSixPQUFBO0FBQ0EsSUFBQUssVUFBQSxHQUFBQyxzQkFBQSxDQUFBTixPQUFBO0FBRUEsSUFBQU8sS0FBQSxHQUFBQyx1QkFBQSxDQUFBUixPQUFBO0FBQ0EsSUFBQVMsaUJBQUEsR0FBQUgsc0JBQUEsQ0FBQU4sT0FBQTtBQUNBLElBQUFVLFlBQUEsR0FBQVYsT0FBQTtBQUNBLElBQUFXLFdBQUEsR0FBQVgsT0FBQTtBQUVBLElBQUFZLFVBQUEsR0FBQVosT0FBQTtBQWtCQSxJQUFBYSxNQUFBLEdBQUFiLE9BQUE7QUFZQSxJQUFBYyxZQUFBLEdBQUFkLE9BQUE7QUFtQ0EsSUFBQWUsUUFBQSxHQUFBVCxzQkFBQSxDQUFBTixPQUFBO0FBQXFDLElBQUFnQixxQkFBQSxFQWhGckM7QUFDQTtBQUFBLFNBQUFDLHlCQUFBQyxDQUFBLDZCQUFBQyxPQUFBLG1CQUFBQyxDQUFBLE9BQUFELE9BQUEsSUFBQUUsQ0FBQSxPQUFBRixPQUFBLFlBQUFGLHdCQUFBLFlBQUFBLHlCQUFBQyxDQUFBLFdBQUFBLENBQUEsR0FBQUcsQ0FBQSxHQUFBRCxDQUFBLEtBQUFGLENBQUE7QUFBQSxTQUFBVix3QkFBQVUsQ0FBQSxF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