/// <reference types="deck.gl" />
import { DataFilterExtension } from '@deck.gl/extensions';
import React from 'react';
import * as arrow from 'apache-arrow';
import { FindDefaultLayerPropsReturnValue } from './layer-utils';
import { DataContainerInterface, DomainQuantiles } from '@kepler.gl/utils';
import { Datasets, GpuFilter, KeplerTable } from '@kepler.gl/table';
import { AggregatedBin, ColorRange, ColorUI, Field, Filter, GetVisChannelScaleReturnType, LayerVisConfigSettings, MapState, AnimationConfig, KeplerLayer, LayerBaseConfig, LayerColumns, LayerColumn, ColumnPairs, ColumnLabels, SupportedColumnMode, FieldPair, NestedPartial, RGBColor, ValueOf, VisualChannel, VisualChannels, VisualChannelDomain, VisualChannelField, VisualChannelScale } from '@kepler.gl/types';
export type { AggregatedBin, LayerBaseConfig, VisualChannel, VisualChannels, VisualChannelDomain, VisualChannelField, VisualChannelScale };
export declare type LayerBaseConfigPartial = {
    dataId: LayerBaseConfig['dataId'];
} & Partial<LayerBaseConfig>;
export declare type LayerColorConfig = {
    colorField: VisualChannelField;
    colorDomain: VisualChannelDomain;
    colorScale: VisualChannelScale;
};
export declare type LayerSizeConfig = {
    sizeDomain: VisualChannelDomain;
    sizeScale: VisualChannelScale;
    sizeField: VisualChannelField;
};
export declare type LayerHeightConfig = {
    heightField: VisualChannelField;
    heightDomain: VisualChannelDomain;
    heightScale: VisualChannelScale;
};
export declare type LayerStrokeColorConfig = {
    strokeColorField: VisualChannelField;
    strokeColorDomain: VisualChannelDomain;
    strokeColorScale: VisualChannelScale;
};
export declare type LayerCoverageConfig = {
    coverageField: VisualChannelField;
    coverageDomain: VisualChannelDomain;
    coverageScale: VisualChannelScale;
};
export declare type LayerRadiusConfig = {
    radiusField: VisualChannelField;
    radiusDomain: VisualChannelDomain;
    radiusScale: VisualChannelScale;
};
export declare type LayerWeightConfig = {
    weightField: VisualChannelField;
};
export declare type VisualChannelDescription = {
    label: string;
    measure: string | undefined;
};
declare type ColumnValidator = (column: LayerColumn, columns: LayerColumns, allFields: Field[]) => boolean;
export declare type UpdateTriggers = {
    [key: string]: UpdateTrigger;
};
export declare type UpdateTrigger = {
    [key: string]: any;
};
export declare type LayerBounds = [number, number, number, number];
/**
 * Approx. number of points to sample in a large data set
 */
export declare const LAYER_ID_LENGTH = 6;
declare const defaultDataAccessor: (dc: any) => (d: any) => any;
export declare const defaultGetFieldValue: (field: any, d: any) => any;
export declare const OVERLAY_TYPE_CONST: {
    deckgl: "deckgl";
    mapboxgl: "mapboxgl";
};
export declare const layerColors: RGBColor[];
export declare type LayerInfoModal = {
    id: string;
    template: React.FC<void>;
    modalProps: {
        title: string;
    };
};
export declare const colorMaker: Generator<RGBColor, any, unknown>;
export declare type BaseLayerConstructorProps = {
    id?: string;
} & LayerBaseConfigPartial;
declare class Layer implements KeplerLayer {
    id: string;
    meta: Record<string, any>;
    visConfigSettings: {
        [key: string]: ValueOf<LayerVisConfigSettings>;
    };
    config: LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig>;
    _oldDataUpdateTriggers: any;
    isValid: boolean;
    errorMessage: string | null;
    filteredItemCount: {
        [deckLayerId: string]: number;
    };
    constructor(props: BaseLayerConstructorProps);
    get layerIcon(): React.ElementType;
    get overlayType(): keyof typeof OVERLAY_TYPE_CONST;
    get type(): string | null;
    get name(): string | null;
    get isAggregated(): boolean;
    get requiredLayerColumns(): string[];
    get optionalColumns(): string[];
    get noneLayerDataAffectingProps(): string[];
    get visualChannels(): VisualChannels;
    get columnValidators(): {
        [key: string]: ColumnValidator;
    };
    get columnPairs(): ColumnPairs | null;
    /**
     * Column labels if its different than column key
     */
    get columnLabels(): ColumnLabels | null;
    get defaultPointColumnPairs(): ColumnPairs;
    get defaultLinkColumnPairs(): ColumnPairs;
    /**
     * Return a React component for to render layer instructions in a modal
     * @returns {object} - an object
     * @example
     *  return {
     *    id: 'iconInfo',
     *    template: IconInfoModal,
     *    modalProps: {
     *      title: 'How to draw icons'
     *   };
     * }
     */
    get layerInfoModal(): LayerInfoModal | Record<string, LayerInfoModal> | null;
    /**
     * Returns which column modes this layer supports
     */
    get supportedColumnModes(): SupportedColumnMode[] | null;
    get supportedDatasetTypes(): string[] | null;
    static findDefaultLayerProps(dataset: KeplerTable, foundLayers?: any[]): FindDefaultLayerPropsReturnValue;
    /**
     * Given a array of preset required column names
     * found field that has the same name to set as layer column
     *
     * @param {object} defaultFields
     * @param {object[]} allFields
     * @returns {object[] | null} all possible required layer column pairs
     */
    static findDefaultColumnField(defaultFields: any, allFields: any): any[] | null;
    static getAllPossibleColumnPairs(requiredColumns: any): any[];
    static hexToRgb(c: any): RGBColor;
    getDefaultLayerConfig(props: LayerBaseConfigPartial): LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig>;
    /**
     * Get the description of a visualChannel config
     * @param key
     * @returns
     */
    getVisualChannelDescription(key: string): VisualChannelDescription;
    /**
     * Assign a field to layer column, return column config
     */
    assignColumn(key: string, field: {
        name: string;
        fieldIdx: number;
    }): LayerColumns;
    /**
     * Assign a field pair to column config, return column config
     */
    assignColumnPairs(key: string, fieldPairs: FieldPair): LayerColumns;
    /**
     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
    getZoomFactor({ zoom, zoomOffset }: {
        zoom: any;
        zoomOffset?: number | undefined;
    }): number;
    /**
     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level
     * @param {object} mapState
     * @param {number} mapState.zoom - actual zoom
     * @param {number=} mapState.zoomOffset - zoomOffset when render in the plot container for export image
     * @returns {number}
     */
    getElevationZoomFactor({ zoom, zoomOffset }: {
        zoom: number;
        zoomOffset?: number;
    }): number;
    formatLayerData(datasets: Datasets, oldLayerData?: unknown, animationConfig?: AnimationConfig): {};
    renderLayer(...args: any[]): any[];
    getHoverData(object: any, dataContainer: DataContainerInterface, fields?: Field[], animationConfig?: AnimationConfig, hoverInfo?: {
        index: number;
    }): any;
    getFilteredItemCount(): number | null;
    /**
     * When change layer type, try to copy over layer configs as much as possible
     * @param configToCopy - config to copy over
     * @param visConfigSettings - visConfig settings of config to copy
     * @param datasets - current datasets.
     * @param defaultLayerProps - default layer creation configurations for current layer and datasets.
     */
    assignConfigToLayer(configToCopy: LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig>, visConfigSettings: {
        [key: string]: ValueOf<LayerVisConfigSettings>;
    }, datasets?: Datasets, defaultLayerProps?: FindDefaultLayerPropsReturnValue | null): void;
    copyLayerConfig(currentConfig: any, configToCopy: any, { shallowCopy, notToCopy }?: {
        shallowCopy?: string[];
        notToCopy?: string[];
    }): {
        columnMode?: string | undefined;
        columns?: LayerColumns | undefined;
    };
    registerVisConfig(layerVisConfigs: {
        [key: string]: keyof LayerVisConfigSettings | ValueOf<LayerVisConfigSettings>;
    }): void;
    getLayerColumns(propsColumns?: {}): {};
    updateLayerConfig<LayerConfig extends LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig> = LayerBaseConfig>(newConfig: Partial<LayerConfig>): Layer;
    updateLayerVisConfig(newVisConfig: any): this;
    updateLayerColorUI(prop: string, newConfig: NestedPartial<ColorUI>): Layer;
    updateCustomPalette(newConfig: any, previous: any, prop: any): void;
    /**
     * if open dropdown and prop is color range
     * Automatically set colorRangeConfig's step and reversed
     * @param {*} newConfig
     * @param {*} prop
     */
    updateColorUIByColorRange(newConfig: any, prop: any): void;
    updateColorRangeByColorUI(newConfig: any, previous: any, prop: any): void;
    hasColumnValue(column?: LayerColumn): boolean;
    hasRequiredColumn(column?: LayerColumn): boolean;
    /**
     * Check whether layer has all columns
     * @returns yes or no
     */
    hasAllColumns(): boolean;
    /**
     * Check whether layer has data
     *
     * @param {Array | Object} layerData
     * @returns {boolean} yes or no
     */
    hasLayerData(layerData: {
        data: unknown[] | arrow.Table;
    }): boolean;
    isValidToSave(): boolean;
    shouldRenderLayer(data: any): boolean;
    getColorScale(colorScale: string, colorDomain: VisualChannelDomain, colorRange: ColorRange): GetVisChannelScaleReturnType;
    accessVSFieldValue(_field: any, _indexKey: any): (field: any, d: any) => any;
    /**
     * Mapping from visual channels to deck.gl accesors
     * @param param Parameters
     * @param param.dataAccessor Access kepler.gl layer data from deck.gl layer
     * @param param.dataContainer DataContainer to use use with dataAccessor
     * @return {Object} attributeAccessors - deck.gl layer attribute accessors
     */
    getAttributeAccessors({ dataAccessor, dataContainer, indexKey }: {
        dataAccessor?: typeof defaultDataAccessor;
        dataContainer: DataContainerInterface;
        indexKey?: number | null;
    }): {
        [key: string]: any;
    };
    getVisChannelScale(scale: string, domain: VisualChannelDomain | DomainQuantiles, range: any, fixed?: boolean): GetVisChannelScaleReturnType;
    /**
     * Get longitude and latitude bounds of the data.
     */
    getPointsBounds(dataContainer: DataContainerInterface, getPosition?: (x: any, dc: DataContainerInterface) => number[]): number[] | null;
    getChangedTriggers(dataUpdateTriggers: any): false | {
        [key: string]: true;
    };
    getEncodedChannelValue(scale: (value: any) => any, data: any[], field: VisualChannelField, nullValue?: import("@kepler.gl/types").RGBAColor, getValue?: (field: any, d: any) => any): any;
    updateMeta(meta: Layer['meta']): void;
    getDataUpdateTriggers({ filteredIndex, id, dataContainer }: KeplerTable): any;
    updateData(datasets: Datasets, oldLayerData: any): {
        data?: undefined;
        triggerChanged?: undefined;
    } | {
        data: never[];
        triggerChanged: boolean | {
            [key: string]: true;
        };
    };
    /**
     * helper function to update one layer domain when state.data changed
     * if state.data change is due ot update filter, newFiler will be passed
     * called by updateAllLayerDomainData
     * @param datasets
     * @param newFilter
     * @returns layer
     */
    updateLayerDomain(datasets: Datasets, newFilter?: Filter): Layer;
    getDataset(datasets: any): any;
    /**
     * Validate visual channel field and scales based on supported field & scale type
     * @param channel
     */
    validateVisualChannel(channel: string): void;
    /**
     * Validate field type based on channelScaleType
     */
    validateFieldType(channel: string): void;
    /**
     * Validate scale type based on aggregation
     */
    validateScale(channel: any): void;
    /**
     * Get scale options based on current field
     * @param {string} channel
     * @returns {string[]}
     */
    getScaleOptions(channel: string): string[];
    updateLayerVisualChannel(dataset: KeplerTable, channel: string): void;
    getVisualChannelUpdateTriggers(): UpdateTriggers;
    calculateLayerDomain(dataset: any, visualChannel: any): any;
    hasHoveredObject(objectInfo: any): any;
    isLayerHovered(objectInfo: any): boolean;
    getRadiusScaleByZoom(mapState: MapState, fixedRadius?: boolean): number;
    shouldCalculateLayerData(props: string[]): boolean;
    getBrushingExtensionProps(interactionConfig: any, brushingTarget?: any): {
        autoHighlight: boolean;
        brushingRadius: number;
        brushingTarget: any;
        brushingEnabled: any;
    };
    getDefaultDeckLayerProps({ idx, gpuFilter, mapState, layerCallbacks, visible }: {
        idx: number;
        gpuFilter: GpuFilter;
        mapState: MapState;
        layerCallbacks: any;
        visible: boolean;
    }): {
        id: string;
        idx: number;
        coordinateSystem: number;
        pickable: boolean;
        wrapLongitude: boolean;
        parameters: {
            depthTest: boolean;
        };
        hidden: boolean;
        opacity: any;
        highlightColor: RGBColor | import("@kepler.gl/types").RGBAColor;
        extensions: DataFilterExtension[];
        filterRange: number[][] | undefined;
        onFilteredItemsChange: any;
        visible: boolean;
    };
    getDefaultHoverLayerProps(): {
        id: string;
        pickable: boolean;
        wrapLongitude: boolean;
        coordinateSystem: number;
    };
    renderTextLabelLayer({ getPosition, getFiltered, getPixelOffset, backgroundProps, updateTriggers, sharedProps }: {
        getPosition?: ((d: any) => number[]) | arrow.Vector;
        getFiltered?: (data: {
            index: number;
        }, objectInfo: {
            index: number;
        }) => number;
        getPixelOffset: (textLabel: any) => number[] | ((d: any) => number[]);
        backgroundProps?: {
            background: boolean;
        };
        updateTriggers: {
            [key: string]: any;
        };
        sharedProps: any;
    }, renderOpts: any): any;
    calculateDataAttribute(keplerTable: KeplerTable, getPosition: any): any;
    updateLayerMeta(dataset: KeplerTable, getPosition: any): void;
    getPositionAccessor(_dataContainer?: DataContainerInterface, _dataset?: KeplerTable): (...args: any[]) => any;
    getLegendVisualChannels(): {
        [key: string]: VisualChannel;
    };
}
export default Layer;
