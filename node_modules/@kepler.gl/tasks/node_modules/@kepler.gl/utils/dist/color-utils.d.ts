import { CategoricalPalette, ColorPalette } from '@kepler.gl/constants';
import { ColorMap, ColorRange, ColorRangeConfig, HexColor, RGBAColor, RGBColor } from '@kepler.gl/types';
/**
 * get r g b from hex code
 *
 * @param hex
 * @returns array of r g bs
 */
export declare function hexToRgb(hex: string): RGBColor;
export declare function isHexColor(hex: string): RegExpExecArray | null;
/**
 * get hex from r g b
 *
 * @param rgb
 * @returns hex string
 */
export declare function rgbToHex([r, g, b]: RGBColor | RGBAColor): HexColor;
/**
 * Whether color range has custom color map
 */
export declare function hasColorMap(colorRange: ColorRange): boolean;
/**
 * given a list of rgb arrays it will generate a linear gradient css rule
 * @param direction
 * @param colors
 * @return
 */
export declare function createLinearGradient(direction: string, colors: RGBColor[]): string;
/**
 * Convert color to RGB
 */
export declare function colorMaybeToRGB(color: unknown): RGBColor | null;
/**
 * Whether color is rgb
 * @returns
 */
export declare function isRgbColor(color: unknown): boolean;
/**
 * Take color values in 0-255 range and map to [0, 1]
 */
export declare function normalizeColor(color: number[]): number[];
/**
 * Convert color to Hex
 */
export declare function colorMaybeToHex(color: unknown): HexColor;
/**
 * Convert color to Hex
 */
export declare function interpolateHex(hex1: HexColor, hex2: HexColor): HexColor;
export declare function addNewQuantativeColorBreakAtIndex(colorMap: any, index: any, newColors: any): any;
/**
 * Add a new color to custom palette
 */
export declare function addCustomPaletteColor(customPalette: ColorRange, index: number): ColorRange;
/**
 * Sort custom palette
 */
export declare function sortCustomPaletteColor(customPalette: ColorRange, oldIndex: number, newIndex: number): ColorRange;
/**
 * remove a color in custom palette at index
 */
export declare function removeCustomPaletteColor(customPalette: ColorRange, index: number): ColorRange;
/**
 * Update a color in custom palette at index
 */
export declare function updateCustomPaletteColor(customPalette: ColorRange, index: number, newValue: HexColor): ColorRange;
/**
 * Get a reversed colorRange
 */
export declare function reverseColorRange(reversed: boolean, colorRange: ColorRange): ColorRange;
/**
 * Whether palette matches current ColorBlindSafe config
 */
export declare function paletteIsColorBlindSafe(palette: ColorPalette, colorBlindSafe: boolean): boolean;
/**
 * Whether palette matches current steps config
 */
export declare function isQuaPalette(palette: ColorPalette): palette is CategoricalPalette;
/**
 * Whether palette matches current steps config
 */
export declare function paletteIsSteps(palette: ColorPalette, steps: number): boolean;
/**
 * Whether palette matches current type config
 */
export declare function paletteIsType(palette: ColorPalette, type: string): boolean;
/**
 * Find best match palette based on config, update color range by it
 */
export declare function updateColorRangeByMatchingPalette(currentColorRange: ColorRange, config: ColorRangeConfig): ColorRange;
/**
 * Update custom palette when reverse the colors in custom palette, since changing 'steps',
 * 'colorBindSafe', 'type' should fall back to predefined palette.
 */
export declare function updateCustomColorRangeByColorUI(oldColorRange: ColorRange, colorConfig: ColorRangeConfig): ColorRange;
/**
 * Update color range after selecting a palette from color range selectoer
 * Copy over colorMap and colorLegends
 */
export declare function updateColorRangeBySelectedPalette(oldColorRange: any, colorPalette: any, colorConfig: any): any;
/**
 * convert saved colorRange to colorPalette objevt type/name/category/isColorBlind
 */
export declare function colorRangeBackwardCompatibility(colorRange: ColorRange): ColorRange;
/**
 * Initialize custom palette from current standard color range object
 */
export declare function initializeCustomPalette(colorRange: ColorRange, colorMap?: ColorMap): ColorRange;
