"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineBandsUint = exports.combineBandsInt = exports.combineBandsFloat = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2["default"])(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var imageBands = opts.imageBands;
  if (!imageBands || imageBands.length === 0) {
    return null;
  }
  var _imageBands = (0, _slicedToArray2["default"])(imageBands, 4),
    bitmapTextureR = _imageBands[0],
    bitmapTextureG = _imageBands[1],
    bitmapTextureB = _imageBands[2],
    bitmapTextureA = _imageBands[3];

  // return default values to prevent deck.gl validation warnings.
  // Note: all bands must be set for the shadow effect to work as expected.
  return {
    bitmapTextureR: bitmapTextureR || bitmapTextureR,
    bitmapTextureG: bitmapTextureG || bitmapTextureR,
    bitmapTextureB: bitmapTextureB || bitmapTextureR,
    bitmapTextureA: bitmapTextureA || bitmapTextureR
  };
}
var fs1 = "uniform sampler2D bitmapTextureR;\nuniform sampler2D bitmapTextureG;\nuniform sampler2D bitmapTextureB;\nuniform sampler2D bitmapTextureA;\n";
var fs2 = "precision mediump float;\nprecision mediump int;\nprecision mediump usampler2D;\n\n#ifdef SAMPLER_TYPE\n  uniform SAMPLER_TYPE bitmapTextureR;\n  uniform SAMPLER_TYPE bitmapTextureG;\n  uniform SAMPLER_TYPE bitmapTextureB;\n  uniform SAMPLER_TYPE bitmapTextureA;\n#else\n  uniform sampler2D bitmapTextureR;\n  uniform sampler2D bitmapTextureG;\n  uniform sampler2D bitmapTextureB;\n  uniform sampler2D bitmapTextureA;\n#endif\n";
var combineBands = {
  name: 'combine-bands',
  fs1: fs1,
  fs2: fs2,
  getUniforms: getUniforms,
  defines: {
    SAMPLER_TYPE: 'sampler2D'
  },
  inject: {
    'fs:DECKGL_CREATE_COLOR': "\n    float channel1 = float(texture2D(bitmapTextureR, coord).r);\n    float channel2 = float(texture2D(bitmapTextureG, coord).r);\n    float channel3 = float(texture2D(bitmapTextureB, coord).r);\n    float channel4 = float(texture2D(bitmapTextureA, coord).r);\n\n    image = vec4(channel1, channel2, channel3, channel4);\n    "
  }
};
var combineBandsFloat = exports.combineBandsFloat = _objectSpread(_objectSpread({}, combineBands), {}, {
  name: 'combine-bands-float'
});
var combineBandsUint = exports.combineBandsUint = _objectSpread(_objectSpread({}, combineBands), {}, {
  name: 'combine-bands-uint',
  defines: {
    SAMPLER_TYPE: 'usampler2D'
  }
});
var combineBandsInt = exports.combineBandsInt = _objectSpread(_objectSpread({}, combineBands), {}, {
  name: 'combine-bands-int',
  defines: {
    SAMPLER_TYPE: 'isampler2D'
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRVbmlmb3JtcyIsIm9wdHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpbWFnZUJhbmRzIiwiX2ltYWdlQmFuZHMiLCJfc2xpY2VkVG9BcnJheTIiLCJiaXRtYXBUZXh0dXJlUiIsImJpdG1hcFRleHR1cmVHIiwiYml0bWFwVGV4dHVyZUIiLCJiaXRtYXBUZXh0dXJlQSIsImZzMSIsImZzMiIsImNvbWJpbmVCYW5kcyIsIm5hbWUiLCJkZWZpbmVzIiwiU0FNUExFUl9UWVBFIiwiaW5qZWN0IiwiY29tYmluZUJhbmRzRmxvYXQiLCJleHBvcnRzIiwiX29iamVjdFNwcmVhZCIsImNvbWJpbmVCYW5kc1VpbnQiLCJjb21iaW5lQmFuZHNJbnQiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcmFzdGVyL3dlYmdsL3RleHR1cmUvY29tYmluZS1iYW5kcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge1RleHR1cmUyRH0gZnJvbSAnQGx1bWEuZ2wvd2ViZ2wnO1xuXG5pbXBvcnQge0dldFVuaWZvcm1zT3V0cHV0LCBTaGFkZXJNb2R1bGV9IGZyb20gJy4uL3R5cGVzJztcblxuZnVuY3Rpb24gZ2V0VW5pZm9ybXMob3B0czoge2ltYWdlQmFuZHM/OiBUZXh0dXJlMkRbXX0gPSB7fSk6IEdldFVuaWZvcm1zT3V0cHV0IHtcbiAgY29uc3Qge2ltYWdlQmFuZHN9ID0gb3B0cztcblxuICBpZiAoIWltYWdlQmFuZHMgfHwgaW1hZ2VCYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFtiaXRtYXBUZXh0dXJlUiwgYml0bWFwVGV4dHVyZUcsIGJpdG1hcFRleHR1cmVCLCBiaXRtYXBUZXh0dXJlQV0gPSBpbWFnZUJhbmRzO1xuXG4gIC8vIHJldHVybiBkZWZhdWx0IHZhbHVlcyB0byBwcmV2ZW50IGRlY2suZ2wgdmFsaWRhdGlvbiB3YXJuaW5ncy5cbiAgLy8gTm90ZTogYWxsIGJhbmRzIG11c3QgYmUgc2V0IGZvciB0aGUgc2hhZG93IGVmZmVjdCB0byB3b3JrIGFzIGV4cGVjdGVkLlxuICByZXR1cm4ge1xuICAgIGJpdG1hcFRleHR1cmVSOiBiaXRtYXBUZXh0dXJlUiB8fCBiaXRtYXBUZXh0dXJlUixcbiAgICBiaXRtYXBUZXh0dXJlRzogYml0bWFwVGV4dHVyZUcgfHwgYml0bWFwVGV4dHVyZVIsXG4gICAgYml0bWFwVGV4dHVyZUI6IGJpdG1hcFRleHR1cmVCIHx8IGJpdG1hcFRleHR1cmVSLFxuICAgIGJpdG1hcFRleHR1cmVBOiBiaXRtYXBUZXh0dXJlQSB8fCBiaXRtYXBUZXh0dXJlUlxuICB9O1xufVxuXG5jb25zdCBmczEgPSBgXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGJpdG1hcFRleHR1cmVSO1xudW5pZm9ybSBzYW1wbGVyMkQgYml0bWFwVGV4dHVyZUc7XG51bmlmb3JtIHNhbXBsZXIyRCBiaXRtYXBUZXh0dXJlQjtcbnVuaWZvcm0gc2FtcGxlcjJEIGJpdG1hcFRleHR1cmVBO1xuYDtcblxuY29uc3QgZnMyID0gYFxcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbnByZWNpc2lvbiBtZWRpdW1wIGludDtcbnByZWNpc2lvbiBtZWRpdW1wIHVzYW1wbGVyMkQ7XG5cbiNpZmRlZiBTQU1QTEVSX1RZUEVcbiAgdW5pZm9ybSBTQU1QTEVSX1RZUEUgYml0bWFwVGV4dHVyZVI7XG4gIHVuaWZvcm0gU0FNUExFUl9UWVBFIGJpdG1hcFRleHR1cmVHO1xuICB1bmlmb3JtIFNBTVBMRVJfVFlQRSBiaXRtYXBUZXh0dXJlQjtcbiAgdW5pZm9ybSBTQU1QTEVSX1RZUEUgYml0bWFwVGV4dHVyZUE7XG4jZWxzZVxuICB1bmlmb3JtIHNhbXBsZXIyRCBiaXRtYXBUZXh0dXJlUjtcbiAgdW5pZm9ybSBzYW1wbGVyMkQgYml0bWFwVGV4dHVyZUc7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIGJpdG1hcFRleHR1cmVCO1xuICB1bmlmb3JtIHNhbXBsZXIyRCBiaXRtYXBUZXh0dXJlQTtcbiNlbmRpZlxuYDtcblxuY29uc3QgY29tYmluZUJhbmRzOiBTaGFkZXJNb2R1bGUgPSB7XG4gIG5hbWU6ICdjb21iaW5lLWJhbmRzJyxcbiAgZnMxLFxuICBmczIsXG4gIGdldFVuaWZvcm1zLFxuICBkZWZpbmVzOiB7XG4gICAgU0FNUExFUl9UWVBFOiAnc2FtcGxlcjJEJ1xuICB9LFxuICBpbmplY3Q6IHtcbiAgICAnZnM6REVDS0dMX0NSRUFURV9DT0xPUic6IGBcbiAgICBmbG9hdCBjaGFubmVsMSA9IGZsb2F0KHRleHR1cmUyRChiaXRtYXBUZXh0dXJlUiwgY29vcmQpLnIpO1xuICAgIGZsb2F0IGNoYW5uZWwyID0gZmxvYXQodGV4dHVyZTJEKGJpdG1hcFRleHR1cmVHLCBjb29yZCkucik7XG4gICAgZmxvYXQgY2hhbm5lbDMgPSBmbG9hdCh0ZXh0dXJlMkQoYml0bWFwVGV4dHVyZUIsIGNvb3JkKS5yKTtcbiAgICBmbG9hdCBjaGFubmVsNCA9IGZsb2F0KHRleHR1cmUyRChiaXRtYXBUZXh0dXJlQSwgY29vcmQpLnIpO1xuXG4gICAgaW1hZ2UgPSB2ZWM0KGNoYW5uZWwxLCBjaGFubmVsMiwgY2hhbm5lbDMsIGNoYW5uZWw0KTtcbiAgICBgXG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjb21iaW5lQmFuZHNGbG9hdDogU2hhZGVyTW9kdWxlID0ge1xuICAuLi5jb21iaW5lQmFuZHMsXG4gIG5hbWU6ICdjb21iaW5lLWJhbmRzLWZsb2F0J1xufTtcbmV4cG9ydCBjb25zdCBjb21iaW5lQmFuZHNVaW50OiBTaGFkZXJNb2R1bGUgPSB7XG4gIC4uLmNvbWJpbmVCYW5kcyxcbiAgbmFtZTogJ2NvbWJpbmUtYmFuZHMtdWludCcsXG4gIGRlZmluZXM6IHtcbiAgICBTQU1QTEVSX1RZUEU6ICd1c2FtcGxlcjJEJ1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVCYW5kc0ludDogU2hhZGVyTW9kdWxlID0ge1xuICAuLi5jb21iaW5lQmFuZHMsXG4gIG5hbWU6ICdjb21iaW5lLWJhbmRzLWludCcsXG4gIGRlZmluZXM6IHtcbiAgICBTQU1QTEVSX1RZUEU6ICdpc2FtcGxlcjJEJ1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBTUEsU0FBU0EsV0FBV0EsQ0FBQSxFQUEyRDtFQUFBLElBQTFEQyxJQUFnQyxHQUFBQyxTQUFBLENBQUFDLE1BQUEsUUFBQUQsU0FBQSxRQUFBRSxTQUFBLEdBQUFGLFNBQUEsTUFBRyxDQUFDLENBQUM7RUFDeEQsSUFBT0csVUFBVSxHQUFJSixJQUFJLENBQWxCSSxVQUFVO0VBRWpCLElBQUksQ0FBQ0EsVUFBVSxJQUFJQSxVQUFVLENBQUNGLE1BQU0sS0FBSyxDQUFDLEVBQUU7SUFDMUMsT0FBTyxJQUFJO0VBQ2I7RUFFQSxJQUFBRyxXQUFBLE9BQUFDLGVBQUEsYUFBeUVGLFVBQVU7SUFBNUVHLGNBQWMsR0FBQUYsV0FBQTtJQUFFRyxjQUFjLEdBQUFILFdBQUE7SUFBRUksY0FBYyxHQUFBSixXQUFBO0lBQUVLLGNBQWMsR0FBQUwsV0FBQTs7RUFFckU7RUFDQTtFQUNBLE9BQU87SUFDTEUsY0FBYyxFQUFFQSxjQUFjLElBQUlBLGNBQWM7SUFDaERDLGNBQWMsRUFBRUEsY0FBYyxJQUFJRCxjQUFjO0lBQ2hERSxjQUFjLEVBQUVBLGNBQWMsSUFBSUYsY0FBYztJQUNoREcsY0FBYyxFQUFFQSxjQUFjLElBQUlIO0VBQ3BDLENBQUM7QUFDSDtBQUVBLElBQU1JLEdBQUcsaUpBS1I7QUFFRCxJQUFNQyxHQUFHLGdiQWdCUjtBQUVELElBQU1DLFlBQTBCLEdBQUc7RUFDakNDLElBQUksRUFBRSxlQUFlO0VBQ3JCSCxHQUFHLEVBQUhBLEdBQUc7RUFDSEMsR0FBRyxFQUFIQSxHQUFHO0VBQ0hiLFdBQVcsRUFBWEEsV0FBVztFQUNYZ0IsT0FBTyxFQUFFO0lBQ1BDLFlBQVksRUFBRTtFQUNoQixDQUFDO0VBQ0RDLE1BQU0sRUFBRTtJQUNOLHdCQUF3QjtFQVExQjtBQUNGLENBQUM7QUFFTSxJQUFNQyxpQkFBK0IsR0FBQUMsT0FBQSxDQUFBRCxpQkFBQSxHQUFBRSxhQUFBLENBQUFBLGFBQUEsS0FDdkNQLFlBQVk7RUFDZkMsSUFBSSxFQUFFO0FBQXFCLEVBQzVCO0FBQ00sSUFBTU8sZ0JBQThCLEdBQUFGLE9BQUEsQ0FBQUUsZ0JBQUEsR0FBQUQsYUFBQSxDQUFBQSxhQUFBLEtBQ3RDUCxZQUFZO0VBQ2ZDLElBQUksRUFBRSxvQkFBb0I7RUFDMUJDLE9BQU8sRUFBRTtJQUNQQyxZQUFZLEVBQUU7RUFDaEI7QUFBQyxFQUNGO0FBQ00sSUFBTU0sZUFBNkIsR0FBQUgsT0FBQSxDQUFBRyxlQUFBLEdBQUFGLGFBQUEsQ0FBQUEsYUFBQSxLQUNyQ1AsWUFBWTtFQUNmQyxJQUFJLEVBQUUsbUJBQW1CO0VBQ3pCQyxPQUFPLEVBQUU7SUFDUEMsWUFBWSxFQUFFO0VBQ2hCO0FBQUMsRUFDRiIsImlnbm9yZUxpc3QiOltdfQ==