"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sigmoidalContrast = void 0;
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project

// From mapbox/rio-color under the MIT License
//
// Sigmoidal contrast is a type of contrast control that
// adjusts the contrast without saturating highlights or shadows.
// It allows control over two factors:
// the contrast range from light to dark, and where the middle value
// of the mid-tones falls. The result is a non-linear and smooth
// contrast change.
// Parameters
// ----------
// arr : ndarray, float, 0 .. 1
//     Array of color values to adjust
// contrast : integer
//     Enhances the intensity differences between the lighter and darker
//     elements of the image. For example, 0 is none, 3 is typical and
//     20 is a lot.
// bias : float, between 0 and 1
//     Threshold level for the contrast function to center on
//     (typically centered at 0.5)
// Notes
// ----------
// Sigmoidal contrast is based on the sigmoidal transfer function:
// .. math:: g(u) = ( 1/(1 + e^{- \alpha * u + \beta)})
// This sigmoid function is scaled so that the output is bound by
// the interval [0, 1].
// .. math:: ( 1/(1 + e^(\beta * (\alpha - u))) - 1/(1 + e^(\beta * \alpha)))/
//     ( 1/(1 + e^(\beta*(\alpha - 1))) - 1/(1 + e^(\beta * \alpha)) )
// Where :math: `\alpha` is the threshold level, and :math: `\beta` the
// contrast factor to be applied.
// References
// ----------
// .. [CT] Hany Farid "Fundamentals of Image Processing"
//         http://www.cs.dartmouth.edu/farid/downloads/tutorials/fip.pdf
var fs = "#define epsilon 0.00000001\n\nuniform float sigmoidalContrast;\nuniform float sigmoidalBias;\n\n// NOTE: Input array must have float values between 0 and 1!\n// NOTE: bias must be a scalar float between 0 and 1!\nvec4 calculateSigmoidalContrast(vec4 arr, float contrast, float bias) {\n  // We use the names alpha and beta to match documentation.\n  float alpha = bias;\n  float beta = contrast;\n\n  // alpha must be >= 0\n  alpha = clamp(alpha, epsilon, alpha);\n\n  if (beta > 0.) {\n    vec4 numerator = 1. / (1. + exp(beta * (alpha - arr))) - 1. / (\n      1. + exp(beta * alpha)\n    );\n    float denominator = 1. / (1. + exp(beta * (alpha - 1.))) - 1. / (\n      1. + exp(beta * alpha)\n    );\n    arr = numerator / denominator;\n  } else if (beta < 0.) {\n    arr = (\n      (beta * alpha) - log(\n        (\n          1.0 / (\n            (arr / (1.0 + exp((beta * alpha) - beta))) -\n            (arr / (1.0 + exp(beta * alpha))) +\n            (1.0 / (1.0 + exp(beta * alpha)))\n          )\n        ) - 1.0)\n    ) / beta;\n  }\n\n  return arr;\n}\n";
function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var sigmoidalContrast = opts.sigmoidalContrast,
    sigmoidalBias = opts.sigmoidalBias;
  if (!(Number.isFinite(sigmoidalContrast) || Number.isFinite(sigmoidalBias))) {
    return null;
  }
  return {
    sigmoidalContrast: Number.isFinite(sigmoidalContrast) ? sigmoidalContrast : 0,
    sigmoidalBias: Number.isFinite(sigmoidalBias) ? sigmoidalBias : 0.5
  };
}
var sigmoidalContrast = exports.sigmoidalContrast = {
  name: 'sigmoidalContrast',
  fs: fs,
  getUniforms: getUniforms,
  inject: {
    'fs:DECKGL_MUTATE_COLOR': "\n    image = calculateSigmoidalContrast(image, sigmoidalContrast, sigmoidalBias);\n    "
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmcyIsImdldFVuaWZvcm1zIiwib3B0cyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInNpZ21vaWRhbENvbnRyYXN0Iiwic2lnbW9pZGFsQmlhcyIsIk51bWJlciIsImlzRmluaXRlIiwiZXhwb3J0cyIsIm5hbWUiLCJpbmplY3QiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcmFzdGVyL3dlYmdsL2NvbG9yL3NpZ21vaWRhbC1jb250cmFzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vLyBDb3B5cmlnaHQgY29udHJpYnV0b3JzIHRvIHRoZSBrZXBsZXIuZ2wgcHJvamVjdFxuXG5pbXBvcnQge0dldFVuaWZvcm1zT3V0cHV0LCBTaGFkZXJNb2R1bGV9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gRnJvbSBtYXBib3gvcmlvLWNvbG9yIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuLy9cbi8vIFNpZ21vaWRhbCBjb250cmFzdCBpcyBhIHR5cGUgb2YgY29udHJhc3QgY29udHJvbCB0aGF0XG4vLyBhZGp1c3RzIHRoZSBjb250cmFzdCB3aXRob3V0IHNhdHVyYXRpbmcgaGlnaGxpZ2h0cyBvciBzaGFkb3dzLlxuLy8gSXQgYWxsb3dzIGNvbnRyb2wgb3ZlciB0d28gZmFjdG9yczpcbi8vIHRoZSBjb250cmFzdCByYW5nZSBmcm9tIGxpZ2h0IHRvIGRhcmssIGFuZCB3aGVyZSB0aGUgbWlkZGxlIHZhbHVlXG4vLyBvZiB0aGUgbWlkLXRvbmVzIGZhbGxzLiBUaGUgcmVzdWx0IGlzIGEgbm9uLWxpbmVhciBhbmQgc21vb3RoXG4vLyBjb250cmFzdCBjaGFuZ2UuXG4vLyBQYXJhbWV0ZXJzXG4vLyAtLS0tLS0tLS0tXG4vLyBhcnIgOiBuZGFycmF5LCBmbG9hdCwgMCAuLiAxXG4vLyAgICAgQXJyYXkgb2YgY29sb3IgdmFsdWVzIHRvIGFkanVzdFxuLy8gY29udHJhc3QgOiBpbnRlZ2VyXG4vLyAgICAgRW5oYW5jZXMgdGhlIGludGVuc2l0eSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBsaWdodGVyIGFuZCBkYXJrZXJcbi8vICAgICBlbGVtZW50cyBvZiB0aGUgaW1hZ2UuIEZvciBleGFtcGxlLCAwIGlzIG5vbmUsIDMgaXMgdHlwaWNhbCBhbmRcbi8vICAgICAyMCBpcyBhIGxvdC5cbi8vIGJpYXMgOiBmbG9hdCwgYmV0d2VlbiAwIGFuZCAxXG4vLyAgICAgVGhyZXNob2xkIGxldmVsIGZvciB0aGUgY29udHJhc3QgZnVuY3Rpb24gdG8gY2VudGVyIG9uXG4vLyAgICAgKHR5cGljYWxseSBjZW50ZXJlZCBhdCAwLjUpXG4vLyBOb3Rlc1xuLy8gLS0tLS0tLS0tLVxuLy8gU2lnbW9pZGFsIGNvbnRyYXN0IGlzIGJhc2VkIG9uIHRoZSBzaWdtb2lkYWwgdHJhbnNmZXIgZnVuY3Rpb246XG4vLyAuLiBtYXRoOjogZyh1KSA9ICggMS8oMSArIGVeey0gXFxhbHBoYSAqIHUgKyBcXGJldGEpfSlcbi8vIFRoaXMgc2lnbW9pZCBmdW5jdGlvbiBpcyBzY2FsZWQgc28gdGhhdCB0aGUgb3V0cHV0IGlzIGJvdW5kIGJ5XG4vLyB0aGUgaW50ZXJ2YWwgWzAsIDFdLlxuLy8gLi4gbWF0aDo6ICggMS8oMSArIGVeKFxcYmV0YSAqIChcXGFscGhhIC0gdSkpKSAtIDEvKDEgKyBlXihcXGJldGEgKiBcXGFscGhhKSkpL1xuLy8gICAgICggMS8oMSArIGVeKFxcYmV0YSooXFxhbHBoYSAtIDEpKSkgLSAxLygxICsgZV4oXFxiZXRhICogXFxhbHBoYSkpIClcbi8vIFdoZXJlIDptYXRoOiBgXFxhbHBoYWAgaXMgdGhlIHRocmVzaG9sZCBsZXZlbCwgYW5kIDptYXRoOiBgXFxiZXRhYCB0aGVcbi8vIGNvbnRyYXN0IGZhY3RvciB0byBiZSBhcHBsaWVkLlxuLy8gUmVmZXJlbmNlc1xuLy8gLS0tLS0tLS0tLVxuLy8gLi4gW0NUXSBIYW55IEZhcmlkIFwiRnVuZGFtZW50YWxzIG9mIEltYWdlIFByb2Nlc3NpbmdcIlxuLy8gICAgICAgICBodHRwOi8vd3d3LmNzLmRhcnRtb3V0aC5lZHUvZmFyaWQvZG93bmxvYWRzL3R1dG9yaWFscy9maXAucGRmXG5jb25zdCBmcyA9IGBcXFxuI2RlZmluZSBlcHNpbG9uIDAuMDAwMDAwMDFcblxudW5pZm9ybSBmbG9hdCBzaWdtb2lkYWxDb250cmFzdDtcbnVuaWZvcm0gZmxvYXQgc2lnbW9pZGFsQmlhcztcblxuLy8gTk9URTogSW5wdXQgYXJyYXkgbXVzdCBoYXZlIGZsb2F0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEhXG4vLyBOT1RFOiBiaWFzIG11c3QgYmUgYSBzY2FsYXIgZmxvYXQgYmV0d2VlbiAwIGFuZCAxIVxudmVjNCBjYWxjdWxhdGVTaWdtb2lkYWxDb250cmFzdCh2ZWM0IGFyciwgZmxvYXQgY29udHJhc3QsIGZsb2F0IGJpYXMpIHtcbiAgLy8gV2UgdXNlIHRoZSBuYW1lcyBhbHBoYSBhbmQgYmV0YSB0byBtYXRjaCBkb2N1bWVudGF0aW9uLlxuICBmbG9hdCBhbHBoYSA9IGJpYXM7XG4gIGZsb2F0IGJldGEgPSBjb250cmFzdDtcblxuICAvLyBhbHBoYSBtdXN0IGJlID49IDBcbiAgYWxwaGEgPSBjbGFtcChhbHBoYSwgZXBzaWxvbiwgYWxwaGEpO1xuXG4gIGlmIChiZXRhID4gMC4pIHtcbiAgICB2ZWM0IG51bWVyYXRvciA9IDEuIC8gKDEuICsgZXhwKGJldGEgKiAoYWxwaGEgLSBhcnIpKSkgLSAxLiAvIChcbiAgICAgIDEuICsgZXhwKGJldGEgKiBhbHBoYSlcbiAgICApO1xuICAgIGZsb2F0IGRlbm9taW5hdG9yID0gMS4gLyAoMS4gKyBleHAoYmV0YSAqIChhbHBoYSAtIDEuKSkpIC0gMS4gLyAoXG4gICAgICAxLiArIGV4cChiZXRhICogYWxwaGEpXG4gICAgKTtcbiAgICBhcnIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgfSBlbHNlIGlmIChiZXRhIDwgMC4pIHtcbiAgICBhcnIgPSAoXG4gICAgICAoYmV0YSAqIGFscGhhKSAtIGxvZyhcbiAgICAgICAgKFxuICAgICAgICAgIDEuMCAvIChcbiAgICAgICAgICAgIChhcnIgLyAoMS4wICsgZXhwKChiZXRhICogYWxwaGEpIC0gYmV0YSkpKSAtXG4gICAgICAgICAgICAoYXJyIC8gKDEuMCArIGV4cChiZXRhICogYWxwaGEpKSkgK1xuICAgICAgICAgICAgKDEuMCAvICgxLjAgKyBleHAoYmV0YSAqIGFscGhhKSkpXG4gICAgICAgICAgKVxuICAgICAgICApIC0gMS4wKVxuICAgICkgLyBiZXRhO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cbmA7XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1zKFxuICBvcHRzOiB7c2lnbW9pZGFsQ29udHJhc3Q/OiBudW1iZXI7IHNpZ21vaWRhbEJpYXM/OiBudW1iZXJ9ID0ge31cbik6IEdldFVuaWZvcm1zT3V0cHV0IHtcbiAgY29uc3Qge3NpZ21vaWRhbENvbnRyYXN0LCBzaWdtb2lkYWxCaWFzfSA9IG9wdHM7XG5cbiAgaWYgKCEoTnVtYmVyLmlzRmluaXRlKHNpZ21vaWRhbENvbnRyYXN0KSB8fCBOdW1iZXIuaXNGaW5pdGUoc2lnbW9pZGFsQmlhcykpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNpZ21vaWRhbENvbnRyYXN0OiBOdW1iZXIuaXNGaW5pdGUoc2lnbW9pZGFsQ29udHJhc3QpID8gc2lnbW9pZGFsQ29udHJhc3QgOiAwLFxuICAgIHNpZ21vaWRhbEJpYXM6IE51bWJlci5pc0Zpbml0ZShzaWdtb2lkYWxCaWFzKSA/IHNpZ21vaWRhbEJpYXMgOiAwLjVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHNpZ21vaWRhbENvbnRyYXN0OiBTaGFkZXJNb2R1bGUgPSB7XG4gIG5hbWU6ICdzaWdtb2lkYWxDb250cmFzdCcsXG4gIGZzLFxuICBnZXRVbmlmb3JtcyxcbiAgaW5qZWN0OiB7XG4gICAgJ2ZzOkRFQ0tHTF9NVVRBVEVfQ09MT1InOiBgXG4gICAgaW1hZ2UgPSBjYWxjdWxhdGVTaWdtb2lkYWxDb250cmFzdChpbWFnZSwgc2lnbW9pZGFsQ29udHJhc3QsIHNpZ21vaWRhbEJpYXMpO1xuICAgIGBcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQSxFQUFFLDRpQ0F1Q1A7QUFFRCxTQUFTQyxXQUFXQSxDQUFBLEVBRUM7RUFBQSxJQURuQkMsSUFBMEQsR0FBQUMsU0FBQSxDQUFBQyxNQUFBLFFBQUFELFNBQUEsUUFBQUUsU0FBQSxHQUFBRixTQUFBLE1BQUcsQ0FBQyxDQUFDO0VBRS9ELElBQU9HLGlCQUFpQixHQUFtQkosSUFBSSxDQUF4Q0ksaUJBQWlCO0lBQUVDLGFBQWEsR0FBSUwsSUFBSSxDQUFyQkssYUFBYTtFQUV2QyxJQUFJLEVBQUVDLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDSCxpQkFBaUIsQ0FBQyxJQUFJRSxNQUFNLENBQUNDLFFBQVEsQ0FBQ0YsYUFBYSxDQUFDLENBQUMsRUFBRTtJQUMzRSxPQUFPLElBQUk7RUFDYjtFQUVBLE9BQU87SUFDTEQsaUJBQWlCLEVBQUVFLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDSCxpQkFBaUIsQ0FBQyxHQUFHQSxpQkFBaUIsR0FBRyxDQUFDO0lBQzdFQyxhQUFhLEVBQUVDLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDRixhQUFhLENBQUMsR0FBR0EsYUFBYSxHQUFHO0VBQ2xFLENBQUM7QUFDSDtBQUVPLElBQU1ELGlCQUErQixHQUFBSSxPQUFBLENBQUFKLGlCQUFBLEdBQUc7RUFDN0NLLElBQUksRUFBRSxtQkFBbUI7RUFDekJYLEVBQUUsRUFBRkEsRUFBRTtFQUNGQyxXQUFXLEVBQVhBLFdBQVc7RUFDWFcsTUFBTSxFQUFFO0lBQ04sd0JBQXdCO0VBRzFCO0FBQ0YsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==