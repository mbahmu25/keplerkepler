"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
// SPDX-License-Identifier: MIT
// Copyright contributors to the kepler.gl project
var _default = exports["default"] = "#define SHADER_NAME raster-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n\n  vec4 image;\n  DECKGL_CREATE_COLOR(image, vTexCoord);\n\n  DECKGL_MUTATE_COLOR(image, vTexCoord);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(image.rgb)), opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZGVmYXVsdCIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmFzdGVyL3Jhc3Rlci1sYXllci9yYXN0ZXItbGF5ZXItd2ViZ2wxLmZzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbi8vIENvcHlyaWdodCBjb250cmlidXRvcnMgdG8gdGhlIGtlcGxlci5nbCBwcm9qZWN0XG5cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSByYXN0ZXItbGF5ZXItZnJhZ21lbnQtc2hhZGVyXG5cbiNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuI2VuZGlmXG5cbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG52YXJ5aW5nIHZlYzIgdlRleFBvcztcblxudW5pZm9ybSBmbG9hdCBkZXNhdHVyYXRlO1xudW5pZm9ybSB2ZWM0IHRyYW5zcGFyZW50Q29sb3I7XG51bmlmb3JtIHZlYzMgdGludENvbG9yO1xudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuXG51bmlmb3JtIGZsb2F0IGNvb3JkaW5hdGVDb252ZXJzaW9uO1xudW5pZm9ybSB2ZWM0IGJvdW5kcztcblxuLyogcHJvamVjdGlvbiB1dGlscyAqL1xuY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNjtcbmNvbnN0IGZsb2F0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gUEkgLyAyLjA7XG5cbi8vIGZyb20gZGVncmVlcyB0byBXZWIgTWVyY2F0b3JcbnZlYzIgbG5nbGF0X3RvX21lcmNhdG9yKHZlYzIgbG5nbGF0KSB7XG4gIGZsb2F0IHggPSBsbmdsYXQueDtcbiAgZmxvYXQgeSA9IGNsYW1wKGxuZ2xhdC55LCAtODkuOSwgODkuOSk7XG4gIHJldHVybiB2ZWMyKFxuICAgIHJhZGlhbnMoeCkgKyBQSSxcbiAgICBQSSArIGxvZyh0YW4oUEkgKiAwLjI1ICsgcmFkaWFucyh5KSAqIDAuNSkpXG4gICkgKiBXT1JMRF9TQ0FMRTtcbn1cblxuLy8gZnJvbSBXZWIgTWVyY2F0b3IgdG8gZGVncmVlc1xudmVjMiBtZXJjYXRvcl90b19sbmdsYXQodmVjMiB4eSkge1xuICB4eSAvPSBXT1JMRF9TQ0FMRTtcbiAgcmV0dXJuIGRlZ3JlZXModmVjMihcbiAgICB4eS54IC0gUEksXG4gICAgYXRhbihleHAoeHkueSAtIFBJKSkgKiAyLjAgLSBQSSAqIDAuNVxuICApKTtcbn1cbi8qIEVuZCBwcm9qZWN0aW9uIHV0aWxzICovXG5cbi8vIGFwcGx5IGRlc2F0dXJhdGlvblxudmVjMyBjb2xvcl9kZXNhdHVyYXRlKHZlYzMgY29sb3IpIHtcbiAgZmxvYXQgbHVtaW5hbmNlID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgKiAwLjMzMzMzMzMzMztcbiAgcmV0dXJuIG1peChjb2xvciwgdmVjMyhsdW1pbmFuY2UpLCBkZXNhdHVyYXRlKTtcbn1cblxuLy8gYXBwbHkgdGludFxudmVjMyBjb2xvcl90aW50KHZlYzMgY29sb3IpIHtcbiAgcmV0dXJuIGNvbG9yICogdGludENvbG9yO1xufVxuXG4vLyBibGVuZCB3aXRoIGJhY2tncm91bmQgY29sb3JcbnZlYzQgYXBwbHlfb3BhY2l0eSh2ZWMzIGNvbG9yLCBmbG9hdCBhbHBoYSkge1xuICBpZiAodHJhbnNwYXJlbnRDb2xvci5hID09IDAuMCkge1xuICAgIHJldHVybiB2ZWM0KGNvbG9yLCBhbHBoYSk7XG4gIH1cbiAgZmxvYXQgYmxlbmRlZEFscGhhID0gYWxwaGEgKyB0cmFuc3BhcmVudENvbG9yLmEgKiAoMS4wIC0gYWxwaGEpO1xuICBmbG9hdCBoaWdoTGlnaHRSYXRpbyA9IGFscGhhIC8gYmxlbmRlZEFscGhhO1xuICB2ZWMzIGJsZW5kZWRSR0IgPSBtaXgodHJhbnNwYXJlbnRDb2xvci5yZ2IsIGNvbG9yLCBoaWdoTGlnaHRSYXRpbyk7XG4gIHJldHVybiB2ZWM0KGJsZW5kZWRSR0IsIGJsZW5kZWRBbHBoYSk7XG59XG5cbnZlYzIgZ2V0VVYodmVjMiBwb3MpIHtcbiAgcmV0dXJuIHZlYzIoXG4gICAgKHBvcy54IC0gYm91bmRzWzBdKSAvIChib3VuZHNbMl0gLSBib3VuZHNbMF0pLFxuICAgIChwb3MueSAtIGJvdW5kc1szXSkgLyAoYm91bmRzWzFdIC0gYm91bmRzWzNdKVxuICApO1xufVxuXG52b2lkIG1haW4odm9pZCkge1xuICB2ZWMyIHV2ID0gdlRleENvb3JkO1xuICBpZiAoY29vcmRpbmF0ZUNvbnZlcnNpb24gPCAtMC41KSB7XG4gICAgdmVjMiBsbmdsYXQgPSBtZXJjYXRvcl90b19sbmdsYXQodlRleFBvcyk7XG4gICAgdXYgPSBnZXRVVihsbmdsYXQpO1xuICB9IGVsc2UgaWYgKGNvb3JkaW5hdGVDb252ZXJzaW9uID4gMC41KSB7XG4gICAgdmVjMiBjb21tb25Qb3MgPSBsbmdsYXRfdG9fbWVyY2F0b3IodlRleFBvcyk7XG4gICAgdXYgPSBnZXRVVihjb21tb25Qb3MpO1xuICB9XG5cbiAgdmVjNCBpbWFnZTtcbiAgREVDS0dMX0NSRUFURV9DT0xPUihpbWFnZSwgdlRleENvb3JkKTtcblxuICBERUNLR0xfTVVUQVRFX0NPTE9SKGltYWdlLCB2VGV4Q29vcmQpO1xuXG4gIGdsX0ZyYWdDb2xvciA9IGFwcGx5X29wYWNpdHkoY29sb3JfdGludChjb2xvcl9kZXNhdHVyYXRlKGltYWdlLnJnYikpLCBvcGFjaXR5KTtcblxuICBnZW9tZXRyeS51diA9IHV2O1xuICBERUNLR0xfRklMVEVSX0NPTE9SKGdsX0ZyYWdDb2xvciwgZ2VvbWV0cnkpO1xufVxuYDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUFBLElBQUFBLFFBQUEsR0FBQUMsT0FBQSIsImlnbm9yZUxpc3QiOltdfQ==